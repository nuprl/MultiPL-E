language: scala
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\".r).map(x\
    \ => x.split(\"o\".r)).toList\n        val music_list = music_list.map(x => x(0).length\
    \ % 4 == 0 ? x.map(x => x.length / 4) : x.map(x => x.length / 4))\n        val\
    \ music_list = music_list.map(x => x.map(y => y.toLong)).flatten\n        val\
    \ music_list = music_list.map(x => x % 4 == 0 ? x.toLong : x.toLong*4).toList\n\
    \        val music_list = music_list.map(x => x % 4 == 0 ? x.toLong : x.toLong*4).filter(x\
    \ => x % 4 == 0)\n        val music_list = music_list.filter(x => x % 4 == 0)\n\
    \        val music_list = music_list.filter(x => x > 0)\n        val music_list\
    \ = music_list.filter(x => x < music_list.length)\n        val music_list = music_list.filter(x\
    \ => x != 0)\n        val music_list = music_list.filter(x => x > 0)\n       \
    \ val music_list = music_list.filter(x => x < music_list.length)\n        val\
    \ music_list = music_list.filter(x => x != 0)\n        val music_list = music_list.filter(x\
    \ => x > 0)\n        val music_list = music_list.filter(x => x < music_list.length)\n\
    \        val music_list = music_list.filter(x => x != 0)\n        val music_list\
    \ = music_list.filter(x => x > 0)\n        val music_list = music_list.filter(x\
    \ => x < music_list.length)\n        val music_list = music_list.filter(x => x\
    \ != 0)\n        val music_list = music_list.filter(x => x > 0)\n        val music_list\
    \ = music_list.filter(x => x < music_list.length)\n        val music_list = music_list.filter(x\
    \ => x != 0)\n        val music_list = music_list.filter(x => x > 0)\n       \
    \ val music_list = music_list.filter(x => x < music_list.length)\n        val\
    \ music_list = music_list.filter(x => x != 0)\n        val music_list = music_list.filter(x\
    \ => x > 0)\n        val music_list = music_list.filter(x => x < music_list.length)\n\
    \        val music_list = music_list.filter(x => x != 0)\n        val music_list\
    \ = music_list.filter(x => x > 0)\n        val music_list = musi\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprobfhwee.scala:15:100 --------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmusic_list\e[0m = music_list.map(\e\
    [36mx\e[0m => x(\e[31m0\e[0m).length % \e[31m4\e[0m == \e[31m0\e[0m ? x.map(\e\
    [36mx\e[0m => x.length / \e[31m4\e[0m) : x.map(x => x.length / \e[31m4\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                    ')' expected, but '(' found\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmprobfhwee.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmusic_list\e[0m = music_list.map(\e\
    [36mx\e[0m => x.map(\e[36my\e[0m => y.toLong)).flatten\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_list is already defined as \e[33mvalue\e[0m \e[35mmusic_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprobfhwee.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mmusic_list\e[0m = music_list.map(\e\
    [36mx\e[0m => x % \e[31m4\e[0m == \e[31m0\e[0m ? x.toLong : x.toLong\e[35m*\e\
    [31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_list is already defined as \e[33mvalue\e[0m \e[35mmusic_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprobfhwee.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mmusic_list\e[0m = music_list.map(\e\
    [36mx\e[0m => x % \e[31m4\e[0m == \e[31m0\e[0m ? x.toLong : x.toLong\e[35m*\e\
    [31m4\e[0m).filter(\e[36mx\e[0m => x % \e[31m4\e[0m == \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  "
  stdout: ''
  timestamp: 1660029286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Complete this function\n        var beats_per_bar\
    \ : ListBuffer[Long] = ListBuffer()\n        var number_of_beats : Long = 0\n\
    \        var current_string : String = \"\"\n        var beats_left : Long = 0\n\
    \        for(c <- music_string) {\n            // Complete this function\n   \
    \     }\n        return beats_per_bar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaopy2euh.scala:22:15\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mreturn\e[0m beats_per_bar\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \   Found:    (beats_per_bar : collection.mutable.ListBuffer[Long])\n\e[31m  \
    \ |\e[0m         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //TODO: Implement the function\n        music_string.split(\"\
    \ \").map(music_character => music_character.toChar) match {\n            case\
    \ Array(ch) => List(ch.toLong)\n            case _       => List()\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyd355m7v.scala:15:71 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        music_string.split(\e[31m\" \"\e[0m).map(\e[36mmusic_character\e\
    [0m => music_character.toChar) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m     \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpyd355m7v.scala:15:78 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        music_string.split(\e[31m\" \"\e[0m).map(\e[36mmusic_character\e\
    [0m => music_character.toChar) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m     \
    \                                                                         ^\e\
    [0m\n\e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyd355m7v.scala:16:35 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m            \e[33mcase\e[0m Array(ch) => List(ch.toLong)\n\e[31m\e[31m   |\e\
    [0m                                   ^^\e[0m\n\e[31m   |\e[0m               \
    \                    Not found: ch\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\")\n \
    \       var note_count : Int = 1\n        val music_beats = music_list.map(music_note\
    \ => {\n            if (music_note == \".\") {\n                note_count +=\
    \ 1\n                note_count = 1\n            } else {\n                note_count\
    \ -= 1\n            }\n            note_count\n        }).toList\n        val\
    \ music_beats_sorted = music_beats.sortBy(_).reverse\n        val music_beats_last\
    \ = music_beats_sorted.takeWhile(_ != 0).map(music_last => music_last*4).toList\n\
    \        val music_beats_last_sorted = music_beats_last.sortBy(_).reverse\n  \
    \      music_beats_last_sorted match {\n            case head :: Nil => head\n\
    \            case music_last :: tail =>\n                val music_beats_last_last_sorted\
    \ = tail.sortBy(_).reverse\n                if (music_last == \"o\") {\n     \
    \               if (music_beats_last_last_sorted == music_beats_last) {\n    \
    \                    music_beats_last_last_sorted\n                    } else\
    \ {\n                        music_beats_last_last_sorted.drop(music_beats_last.length)\n\
    \                    }\n                } else if (music_last == \"|\") {\n  \
    \                  if (music_beats_last_last_sorted == music_beats_last) {\n \
    \                       music_beats_last_last_sorted\n                    } else\
    \ {\n                        music_beats_last_last_sorted.drop(music_beats_last.length)\n\
    \                    }\n                }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpztx5vjon.scala:25:52 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmusic_beats_sorted\e[0m\
    \ = music_beats.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m                     \
    \                               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => music_beats.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- Error: /tmp/tmpztx5vjon.scala:25:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmusic_beats_sorted\e[0m\
    \ = music_beats.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m                     \
    \                                 ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpztx5vjon.scala:27:62 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmusic_beats_last_sorted\e[0m\
    \ = music_beats_last.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m                \
    \                                              ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => music_beats_last.sortBy(_$3).reverse.\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpztx5vjon.scala:29:32 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e[0m head :: Nil => head\n\e[31m\e\
    [31m   |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                          Found:    (head : Any)\n\e[31m   |\e[0m           \
    \                     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpztx5vjon.scala:31:63 -------------"
  stdout: ''
  timestamp: 1660029283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats_per_note : List[Long] = Nil\n        var\
    \ rest = music_string.dropWhile(_ != 'o').dropWhile(_ != '|')\n        rest.foreach\
    \ {\n            c =>\n            if (c == 'o') {\n                if (beats_per_note.size\
    \ == 4) {\n                    beats_per_note = Nil\n                }\n     \
    \           beats_per_note ::= 4l.toLong\n            } else if (c == 'o|') {\n\
    \                if (beats_per_note.size == 2) {\n                    beats_per_note\
    \ = Nil\n                }\n                beats_per_note ::= 2l.toLong\n   \
    \         } else if (c == '|') {\n                if (beats_per_note.size == 1)\
    \ {\n                    beats_per_note = Nil\n                }\n           \
    \     beats_per_note ::= 1l.toLong\n            } else {\n                println(\"\
    Unknown symbol: \" + c)\n            }\n        }\n        if (beats_per_note.size\
    \ == 0) return Nil\n        if (beats_per_note.size == 4) beats_per_note = beats_per_note.init\n\
    \        beats_per_note\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpusysfih_.scala:23:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e\
    [31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- Error: /tmp/tmpusysfih_.scala:23:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (c == \e\
    [31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               unclosed character literal\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpusysfih_.scala:36:8 -----------------\e\
    [0m\e[0m\n\e[33m35 |\e[0m            }\n\e[33m36 |\e[0m        }\n\e[33m\e[33m\
    \   |\e[0m             ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in\
    \ statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660029278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code goes here\n        var noteList = music_string.split('\
    \ ');\n        var noteList2 = noteList.dropRight(noteList.length-1);\n      \
    \  var noteList3 = noteList2.map(_.toChar).map(x => x.toInt).toList;\n       \
    \ var noteList4 = noteList3.zip(noteList3.tail).map{ case (l, r) => l }\n    \
    \    return noteList4.toList.map(x => (x.toDouble / 16).toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp19f74k79.scala:17:40 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mnoteList3\e[0m = noteList2.map(_.toChar).map(\e\
    [36mx\e[0m => x.toInt).toList;\n\e[31m\e[31m   |\e[0m                        \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  value toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmp19f74k79.scala:17:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ \e[33mvar\e[0m \e[36mnoteList3\e[0m = noteList2.map(_.toChar).map(\e[36mx\e\
    [0m => x.toInt).toList;\n\e[31m\e[31m   |\e[0m                               \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \     No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \                                where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var output: List[Long] = Nil\n        music_string.split(\"\
    \\\\|\").map(music_string => {\n            val note_array = music_string.split(\"\
    \\\\ \").map(music_string => music_string.charAt(0) - 'a')\n            val note_count\
    \ = note_array.length\n            val beat_number = note_count(3)\n         \
    \   if (note_count(3) > 0) note_count(3) * 4\n            else note_count(1) *\
    \ 2\n        }).reduceRight(_ + _).scanLeft(0l) { (acc, x) => acc += x }\n   \
    \     music_string.split(\"\\\\ \").map(music_string => music_string.charAt(0)\
    \ - 'a').length.times(music_string.split(\"\\\\ \").length).reduceLeft(_ + _).scanLeft(0l)\
    \ { (acc, x) => acc += x }\n        output\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp9e6u52bd.scala:18:30 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mbeat_number\e[0m = note_count(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              \e[33mvalue\e[0m \e[35mnote_count\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp9e6u52bd.scala:19:16 -----------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mif\e[0m (note_count(\e[31m3\e[0m) > \e[31m0\e[0m) note_count(\e\
    [31m3\e[0m) * \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                \e[33mvalue\e[0m \e[35mnote_count\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp9e6u52bd.scala:19:35\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e\
    [0m (note_count(\e[31m3\e[0m) > \e[31m0\e[0m) note_count(\e[31m3\e[0m) * \e[31m4\e\
    [0m\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               \e[33mvalue\e[0m \e[35mnote_count\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp9e6u52bd.scala:20:17 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33melse\e[0m note_count(\e[31m1\e[0m) * \e[31m2\e[0m\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \        \e[33mvalue\e[0m \e[35mnote_count\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp9e6u52bd.scala:21:10 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }).reduceRight(_ + _).scanLeft(\e[31m0l\e[0m)\
    \ { (acc, x) => acc += x }\n\e[31m\e[31m   |\e[0m          ^\e[0m\n\e[31m   |\e\
    [0m          No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //Your code goes here\n        var noteList = music_string.split(\"\
    \ \").map(_.toChar).flatMap(x => x.toLong).toList\n        var last = 0\n    \
    \    var lastList : List[Long] = List()\n        \n        for (note <- 0 until\
    \ noteList.length) {\n            if (noteList(note) == '.') {\n             \
    \   if (last > 0) {\n                    lastList ::= last\n                 \
    \   last = lastList.head\n                    lastList = lastList.tail\n     \
    \           } else {\n                    lastList ::= 0\n                }\n\
    \            } else {\n                last = note\n            }\n        }\n\
    \n        if (last > 0) {\n            lastList ::= last\n            last = lastList.head\n\
    \            lastList = lastList.tail\n        } else {\n            lastList\
    \ ::= 0\n        }\n        \n        \n        \n        return lastList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdor7p5x7.scala:15:53 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mnoteList\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(_.toChar).flatMap(\e[36mx\e[0m => x.toLong).toList\n\e[31m\e\
    [31m   |\e[0m                                                   ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpdor7p5x7.scala:15:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mnoteList\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(_.toChar).flatMap(\e[36mx\e[0m => x.toLong).toList\n\e[31m\e\
    [31m   |\e[0m                                                            ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpdor7p5x7.scala:23:36 --------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \                    last = lastList.head\n\e[31m\e[31m   |\e[0m             \
    \              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    Long\n\e[31m   |\e[0m                           Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdor7p5x7.scala:35:28 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            last = lastList.head\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string_list = music_string.split(\"\\\\\
    |\").toList\n        val music_string_list_length = music_string_list.len\n  \
    \      if (music_string_list_length == 1) {\n            return List(1l.toLong)\n\
    \        } else if (music_string_list_length == 2) {\n            val notes =\
    \ music_string_list.head :: music_string_list.tail\n            val notes_length\
    \ = notes.len\n            val notes_length_in_music_string_list = (notes_length\
    \ - 1).toLong\n            val notes_index_in_music_string_list = 1 until notes_length_in_music_string_list\n\
    \            notes_index_in_music_string_list match {\n                case Seq(1\
    \ until music_string_list.last.length) =>\n                    val notes_index_in_music_string_list_plus_1\
    \ = notes_index_in_music_string_list + 1\n                    val notes_index_in_music_string_list_minus_1\
    \ = notes_index_in_music_string_list - 1\n                    notes_index_in_music_string_list_plus_1\
    \ until notes_index_in_music_string_list_minus_1 map { notes_index_in_music_string_list\
    \ =>\n                        val notes_index_in_music_string_list_plus_1_plus_1\
    \ = notes_index_in_music_string_list_plus_1 + 1\n                        val notes_index_in_music_string_list_minus_1_minus_1\
    \ = notes_index_in_music_string_list_minus_1 - 1\n                        notes_index_in_music_string_list_plus_1_plus_1\
    \ until notes_index_in_music_string_list_minus_1_minus_1 map { notes_index_in_music_string_list_plus_1_plus_1\
    \ =>\n                            val notes_index_in_music_string_list_plus_1_plus_1_plus_1\
    \ = notes_index_in_music_string_list_plus_1_plus_1 + 1\n                     \
    \       val notes_index_in_music_string_list_minus_1_minus_1_minus_1 = notes_index_in_music_string_list_minus_1_minus_1\
    \ - 1\n                            notes_index_in_music_string_list_plus_1_plus_1_plus_1\
    \ until notes_index_in_music_string_list_minus_1_minus_1_minus_1 map { notes_index_in_music_string_list_plus_1_plus_1_plus_1\
    \ =>\n                                notes_index_in_music_string_list_plus_1_plus_1_plus_1\
    \ :: notes\n                            }\n                        }\n       \
    \             }\n                case _ => throw new Exception(\"Invalid music\
    \ string list.\")\n            }\n        }\n        else if (music_string_list_length\
    \ == music_string_list.last) {\n            val notes = music_string_list.head\
    \ :: music_string_list.tail\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpb3efm5gs.scala:43:15 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb3efm5gs.scala:54:0 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3efm5gs.scala:15:57\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mmusic_string_list_length\e[0m = music_string_list.len\n\e[31m\e[31m   |\e\
    [0m                                       ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue len is not a member of List[String] - did you mean music_string_list.min?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3efm5gs.scala:20:37 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mnotes_length\e[0m =\
    \ notes.len\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m     value len is not a member of List[String] - did you mean notes.min?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3efm5gs.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e[0m Seq(\e[31m1\e[0m until\
    \ music_string_list.last.length) =>\n\e[31m\e[31m   |\e[0m                   \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: until\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E135] Type Error: /tmp/tmpb3efm5gs.scala:24:56 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e[0m Seq(\e[31m1\e[0m until\
    \ music_string_list.last.length) =>\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     Stable\
    \ identifier required, but music_string_list.last.length found\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpb3efm5gs.scala:25:99 ------------------------\e\
    [0m\e[0m\n\e[31m25 |"
  stdout: ''
  timestamp: 1660029287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(' ').map(music_string => {\n  \
    \          val notes = music_string.split('|')\n            var lastNote = notes.head\n\
    \            var restNotes = notes.tail\n            val music = new mutable.Queue[Long]\n\
    \            var i = 1\n            while (i < restNotes.length) {\n         \
    \       val note = restNotes(i - 1).toChar\n                if (note == 'o' ||\
    \ note == 'o|') {\n                    music.enqueue(lastNote.toLong + 4l.toLong)\n\
    \                    lastNote = note\n                    restNotes = restNotes.drop(i\
    \ + 1)\n                } else {\n                    music.enqueue(lastNote.toLong\
    \ + 2l.toLong)\n                    lastNote = note\n                    restNotes\
    \ = restNotes.drop(i + 1)\n                }\n                i += 1\n       \
    \     }\n            music.enqueue(lastNote.toLong + restNotes.last.toLong)\n\
    \            music.toList\n        }).reduceLeft((a, b) => a.zip(b)).takeWhile((music,\
    \ note) => note <= music && music <= note)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqag16b9a.scala:22:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m (note == \e[31m'o'\e[0m\
    \ || note == \e[31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                       \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \                unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpqag16b9a.scala:22:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \         \e[33mif\e[0m (note == \e[31m'o'\e[0m || note == \e[31m'o\e[0m|') {\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqag16b9a.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mmusic\e[0m = \e[33mnew\e\
    [0m mutable.Queue[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqag16b9a.scala:21:44\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e\
    [0m \e[36mnote\e[0m = restNotes(i - \e[31m1\e[0m).toChar\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                       value toChar is not a member of String\n\e[31m\e[31m--\
    \ Error: /tmp/tmpqag16b9a.scala:35:10 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        }).reduceLeft((a, b) => a.zip(b)).takeWhile((music,\
    \ note) => note <= music && music <= note)\n\e[31m\e[31m   |\e[0m          ^\e\
    [0m\n\e[31m   |\e[0m          No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m  "
  stdout: ''
  timestamp: 1660029285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(' ');\n      \
    \  val music_list2 = music_list.toList\n        var beats = 0\n\n        music_list2.map(x\
    \ => {\n            if (\"o\".equalsIgnoreCase(x)) {\n                beats +=\
    \ 4\n            }\n            else if (\"o|\".equalsIgnoreCase(x)) {\n     \
    \           beats += 2\n            }\n            else if (\".|\".equalsIgnoreCase(x))\
    \ {\n                beats += 1\n            }\n            else {\n         \
    \       throw new Exception(\"Invalid music string format\")\n            }\n\
    \        })\n\n        val result = beats.toList.map(x => x.toLong)\n\n      \
    \  return result \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsny8jd00.scala:33:27 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = beats.toList.map(\e\
    [36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value toList is not a member of Int - did you mean\
    \ Int.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660029282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.replace(\" \", \"\").replace(\"|\", \"\
    \").toList.map(music_string => {\n            val note = music_string.substring(0,\
    \ 1)\n            val beats = music_string.substring(music_string.indexOf(note)\
    \ + 1).length\n            val last = (music_string.lastIndexOf(note) == music_string.length\
    \ - 1)\n            (note -> beats * last.toLong).toList\n        })\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5y88xsv6.scala:15:36 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mnote\e[0m = music_string.substring(\e\
    [31m0\e[0m, \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value substring is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5y88xsv6.scala:16:37 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mbeats\e[0m = music_string.substring(music_string.indexOf(note)\
    \ + \e[31m1\e[0m).length\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value substring is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5y88xsv6.scala:16:60 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mbeats\e[0m = music_string.substring(music_string.indexOf(note)\
    \ + \e[31m1\e[0m).length\n\e[31m\e[31m   |\e[0m                              \
    \                 ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value indexOf is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5y88xsv6.scala:17:37 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = (music_string.lastIndexOf(note)\
    \ == music_string.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    value lastIndexOf is not a member of Char\n4 errors found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split('|').toList.tail.foldLeft(List[Long]())((accumulator,\
    \ element) => {\n            if(element == \".\") accumulator :+ 4l.toLong\n \
    \           else if(element == \"|\") accumulator :+ 2l.toLong\n            else\
    \ accumulator :+ 1l.toLong\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuml2gi2o.scala:22)\n\tat Problem.main(tmpuml2gi2o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code here\n        val music_list = music_string.split('\
    \ ').toList\n        var beats_notes = List[Long](1l.toLong)\n        var total_beats\
    \ = 0\n        val list_notes = music_list.map(music_element => {\n          \
    \  val music_note = music_element.charAt(0).toLowerCase\n            val note_count\
    \ = music_element.substring(1)\n            val music_note_count = note_count.toInt\n\
    \            beats_notes = beats_notes :+ music_note_count\n            beats_notes\
    \ match {\n                case music_note :: music_note_count :: Nil => music_note_count\n\
    \                case _ => 0\n            }\n        })\n        val music_notes_count\
    \ = list_notes.reduce((count, music_note) => music_note + count)\n        val\
    \ music_notes_count_with_beats_notes = music_notes_count + total_beats * 4\n \
    \       beats_notes = beats_notes.take(music_notes_count_with_beats_notes)\n \
    \       return beats_notes\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvodp95eu.scala:19:53 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mmusic_note\e[0m = music_element.charAt(\e\
    [31m0\e[0m).toLowerCase\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvodp95eu.scala:30:39\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        beats_notes = beats_notes.take(music_notes_count_with_beats_notes)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    (music_notes_count_with_beats_notes\
    \ : Long)\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\")\n \
    \       val notes_count = music_list.size // how many notes does music string\
    \ have\n        val beats_count = music_list(0).toList.size // how many beats\
    \ does music string last\n        val notes_count_list: List[Int] = music_list.map\
    \ { a =>\n            a.split(\"\\\\|\").length\n        }\n        val notes_count_list_sum\
    \ = notes_count_list.sum\n        val notes_list: List[Long] = music_list.map\
    \ { a =>\n            a.split(\"\\\\|\").map(_.toLong)\n        }\n        val\
    \ notes_list_sum_len = notes_list.sum\n        val notes_list_without_last_beat\
    \ = notes_list.map(a => (a - notes_list.last).toList)\n        val notes_list_without_last_beat_length\
    \ = notes_list_without_last_beat.sum\n\n        // If music string have odd number\
    \ of beats\n        if (notes_list_sum_len % 2 == 0) {\n            // If music\
    \ string last two beats is the last note in music string\n            if (notes_list_sum_len\
    \ % 2 == 1) {\n                // If music string last beat is the last note in\
    \ music string\n                if (notes_list_length_sum % 2 == 1) {\n      \
    \              // if music string last beat is the last note in music string\n\
    \                    if (notes_list_without_last_beat_length == 0) {\n       \
    \                 // If music string has last note is note of last note\n    \
    \                    if (notes_list_sum_len == 1) {\n                        \
    \    // If music string has only one note\n                            if (notes_count\
    \ == 1) {\n                                // If music string has only one note\n\
    \                                return List(beats_count)\n                  \
    \          } else {\n                                // If music string has more\
    \ than one note\n                                return (notes_count_list_sum,\
    \ beats_count)\n                            }\n                        } else\
    \ {\n                            // If music string has more than one note but\
    \ the last beat is not a last note\n                            if (notes_list_sum_len\
    \ == 1) {\n                                // If music string has only one note\n\
    \                                return List(beats_count)\n                  \
    \          } else {\n                                // If music string has more\
    \ than one note\n                                return (notes_count_list_sum,\
    \ beats_count)\n                            }\n                        }\n   \
    \                 } else {\n                        // If music string has last\
    \ note is note of last note\n                        if (notes_list_sum_len ==\
    \ 1) {\n                            // If music string has only one note\n   \
    \                         if (notes_count == 1) {\n                          \
    \      // If music string has only one note\n                                return\
    \ List(beats_count)\n                            } else {\n                  \
    \              // If music string has more than one note\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpljf31i0c.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpljf31i0c.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnotes_count_list\e\
    [0m: \e[35mList\e[0m[\e[35mInt\e[0m] = music_list.map { \e[36ma\e[0m =>\n\e[31m\e\
    [31m   |\e[0m                                          ^\e[0m\n\e[31m   |\e[0m\
    \                                          Found:    \e[1m\e[31mArray\e[0m[Int]\n\
    \e[31m   |\e[0m                                          Required: \e[1m\e[32mList\e\
    [0m[Int]\n\e[31m18 |\e[0m            a.split(\e[31m\"\\\\|\"\e[0m).length\n\e\
    [31m19 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpljf31i0c.scala:21:37\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnotes_list\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = music_list.map { \e[36ma\e[0m =>\n\e[31m\e\
    [31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m    \
    \                                 Found:    Array[Array[Long]]\n\e[31m   |\e[0m\
    \                                     Required: List[Long]\n\e[31m22 |\e[0m  \
    \          a.split(\e[31m\"\\\\|\"\e[0m).map(_.toLong)\n\e[31m23 |\e[0m      \
    \  }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpljf31i0c.scala:25:85\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mnotes_list_without_last_beat\e[0m = notes_list.map(\e[36ma\e[0m => (a - notes_list.last).toList)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value toList\
    \ is not a member of Long - did you mean Long.toInt?\n\e[31m\e[31m-- Error: /tmp/tmpljf31i0c.scala:26:82\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnotes_list_without_last_beat_length\e[0m = notes_list_without_last_be"
  stdout: ''
  timestamp: 1660029286
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case \"o o| .| o|\
    \ o| .| .| .| .| o o\" => List(4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong)\n        \
    \    case \"o o| o| .| o| .| .| .| .| o o\" => List(2l.toLong, 1l.toLong, 1l.toLong,\
    \ 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong)\n            case \"o| .| o| o| .| .| .| .| o| o\" => List(1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong)\n            case _ => List()\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_ukkb618.scala:23)\n\tat Problem.main(tmp_ukkb618.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"o|.|\").map{ elem => elem.split(\"\
    o\").map{ elem => elem.split(\"|\").map{ elem => elem.toLong.toInt} } }.flatten.flatten.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyrazxhm_.scala:14:145\
    \ -------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"o|.|\"\e[0m).map{ \e[36melem\e[0m => elem.split(\e[31m\"o\"\e[0m).map{ \e\
    [36melem\e[0m => elem.split(\e[31m\"|\"\e[0m).map{ \e[36melem\e[0m => elem.toLong.toInt}\
    \ } }.flatten.flatten.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(' ').map(music_char => {\n    \
    \        if(music_char.equals(\"o\"))\n                4\n            else if(music_char.equals(\"\
    o|\"))\n                2\n            else if(music_char.equals(\".|\"))\n  \
    \              1\n            else throw new Exception(\"Error parsing music_char:\
    \ \" + music_char)\n        }).sum\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpios5bc4k.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m' '\e[0m).map(\e[36mmusic_char\e[0m => {\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m15 |\e[0m            \e[33mif\e[0m(music_char.equals(\e[31m\"o\"\e[0m))\n\
    \e[31m16 |\e[0m                \e[31m4\e[0m\n\e[31m17 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m(music_char.equals(\e[31m\"o|\"\e[0m))\n\e[31m18 |\e[0m     \
    \           \e[31m2\e[0m\n\e[31m19 |\e[0m            \e[33melse\e[0m \e[33mif\e\
    [0m(music_char.equals(\e[31m\".|\"\e[0m))\n\e[31m20 |\e[0m                \e[31m1\e\
    [0m\n\e[31m21 |\e[0m            \e[33melse\e[0m \e[33mthrow\e[0m \e[33mnew\e[0m\
    \ \e[35mException\e[0m(\e[31m\"Error parsing music_char: \"\e[0m + music_char)\n\
    \e[31m22 |\e[0m        }).sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var output: List[Long] = Nil\n        var prev: String\
    \ = \"\"\n        for (x <- music_string.toCharArray()) {\n            if (x ==\
    \ 'o' || x == '|' || x == ' ') {\n                if (prev == 'o' || prev == '|'\
    \ || prev == ' ') {\n                    output ::= 4L\n                } else\
    \ {\n                    output ::= 2L\n                }\n            }\n   \
    \         output ::= 1L\n            prev = x\n        }\n        return output.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpel7stbx5.scala:18:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mif\e[0m (prev == \e[31m'o'\e[0m\
    \ || prev == \e[31m'|'\e[0m || prev == \e[31m' '\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpel7stbx5.scala:18:35\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \         \e[33mif\e[0m (prev == \e[31m'o'\e[0m || prev == \e[31m'|'\e[0m || prev\
    \ == \e[31m' '\e[0m) {\n\e[31m\e[31m   |\e[0m                                \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpel7stbx5.scala:18:50\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \         \e[33mif\e[0m (prev == \e[31m'o'\e[0m || prev == \e[31m'|'\e[0m || prev\
    \ == \e[31m' '\e[0m) {\n\e[31m\e[31m   |\e[0m                                \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types String\
    \ and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpel7stbx5.scala:25:19 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            prev = x\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\
    \e[31m   |\e[0m                   Found:    (x : Char)\n\e[31m   |\e[0m      \
    \             Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var note_beat = music_string.map(x => if(x.equals(\"\
    o\")) 4 else 2).reduce(_ + _)\n        var last_beat = music_string.last.toLong\n\
    \        music_string.tail.dropRight(1).map(x => {\n            if(x.equals(\"\
    .\"))\n                note_beat = note_beat.toLong * 4\n            else if(x.equals(\"\
    o|\"))\n                note_beat = note_beat.toLong * 2\n            else if(x.equals(\"\
    o\"))\n                note_beat = note_beat.toLong\n            else\n      \
    \          note_beat = note_beat.toLong * 1\n            last_beat = note_beat\n\
    \            note_beat = note_beat.toLong\n        }).reverse.mkString.split(\"\
    \\\\s+\").map(x => x.toLong).distinct\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb2r60a33.scala:18:28\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                note_beat = note_beat.toLong\
    \ * \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    Long\n\e[31m   |\e[0m\
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpb2r60a33.scala:20:28 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                note_beat = note_beat.toLong * \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            Found:    Long\n\e[31m   |\e[0m     \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpb2r60a33.scala:22:38 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                note_beat = note_beat.toLong\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Found:    Long\n\e[31m   |\e[0m                  \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb2r60a33.scala:24:28 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                note_beat = note_beat.toLong * \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Long\n\e[31m   |\e[0m               \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb2r60a33.scala:26:34 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            note_beat = note_beat.toLong\n\e[31m\e[31m   |\e[0m      \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Found:    Long\n\e[31m   |\e[0m                        "
  stdout: ''
  timestamp: 1660029285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string = music_string.trim\n        if(music_string.trim.isEmpty)\
    \ List()\n        else music_string.split(\" \").map(music => {\n            if(music.startsWith(\"\
    o\"))\n                1L\n            else if(music.startsWith(\"o|\"))\n   \
    \             2L\n            else if(music.startsWith(\".|\"))\n            \
    \    3L\n            else\n                -1L\n        }).toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzobrq9qr.scala:14:27 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_string\e[0m = music_string.trim\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mmusic_string\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\s+\"\"\").map(music_string\
    \ => { val s = music_string.toUpperCase(); if (s.endsWith(\"O\")) 4L else if (s.endsWith(\"\
    |\")) 2L else if (s.endsWith(\".|\")) 1L else -1L }).filter(music_string => music_string\
    \ != -1).sortBy(music_string => music_string).map(music_string => music_string\
    \ % 4).distinct().toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpy_sz9dlf.scala:14:317 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\"\"\"\\s+\"\"\"\e[0m).map(\e\
    [36mmusic_string\e[0m => { \e[33mval\e[0m \e[36ms\e[0m = music_string.toUpperCase();\
    \ \e[33mif\e[0m (s.endsWith(\e[31m\"O\"\e[0m)) \e[31m4L\e[0m \e[33melse\e[0m \e\
    [33mif\e[0m (s.endsWith(\e[31m\"|\"\e[0m)) \e[31m2L\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (s.endsWith(\e[31m\".|\"\e[0m)) \e[31m1L\e[0m \e[33melse\e[0m -\e[31m1L\e\
    [0m }).filter(\e[36mmusic_string\e[0m => music_string != -\e[31m1\e[0m).sortBy(\e\
    [36mmusic_string\e[0m => music_string).map(\e[36mmusic_string\e[0m => music_string\
    \ % \e[31m4\e[0m).distinct().toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m: (i: Int): Long\n1 error found\n"
  stdout: ''
  timestamp: 1660029280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // You need this list to store our results\n     \
    \   var results : List[Long] = List()\n\n        // Iterate over all characters\
    \ in the music_string\n        for(c <- music_string) {\n            // If character\
    \ is \".\" or \"o\", add it to results list\n            if(c == '.' || c == 'o')\
    \ {\n                results = results ::: List(0)\n            } else if(c ==\
    \ 'o|') {\n                results = results ::: List(0)\n            } else if(c\
    \ == '|') {\n                results = results ::: List(4)\n            } else\
    \ {\n                // Otherwise add number of beats to last element in results\
    \ list\n                results = results ::: List((results.lastOption.getOrElse(0)\
    \ + 1) * 1)\n            }\n        }\n        return results\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpz1y6y1xa.scala:22:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(c == \e[31m'o\e\
    [0m|') {\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- Error: /tmp/tmpz1y6y1xa.scala:22:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(c == \e[31m'o\e\
    [0m|') {\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m  \
    \ |\e[0m                              unclosed character literal\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpz1y6y1xa.scala:21:26 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                results = results ::: List(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\
    \e[31m   |\e[0m                          Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpz1y6y1xa.scala:30:8\
    \ -----------------\e[0m\e[0m\n\e[33m29 |\e[0m            }\n\e[33m30 |\e[0m \
    \       }\n\e[33m\e[33m   |\e[0m             ^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660029283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes_map = music_string.split(\" \").map(x =>\
    \ x.split(\"|\")).map(x => (x.head, x(1))).map { case (note, duration) => (note,\
    \ duration.toLong) }\n        val notes = notes_map.map { case (note, duration)\
    \ => if (note == \".\") 4L else (duration * 2L).toLong }\n        val notes_map\
    \ = notes_map.map { case (note, duration) => if (note == \"o\") duration * 4L\
    \ else (duration * 2L).toLong }\n        notes ++ notes_map\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl29a6dg_.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnotes_map\e[0m = notes_map.map\
    \ { \e[33mcase\e[0m (note, duration) => \e[33mif\e[0m (note == \e[31m\"o\"\e[0m)\
    \ duration * \e[31m4L\e[0m \e[33melse\e[0m (duration * \e[31m2L\e[0m).toLong }\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnotes_map is already defined as \e[33mvalue\e[0m \e[35mnotes_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpl29a6dg_.scala:17:8 ---------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        notes ++ notes_map\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Matchable]\n\e[31m   |\e[0m      \
    \  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_chars = music_string.grouped(4)\n      \
    \      .map(s => s.toChar)\n            .filter(c => c != '.')\n            .map(c\
    \ => (c == 'o') ? 1l : (c == '|') ? 2l : (c == '.') ? 4l : (c == '~') ? 4l : 0)\n\
    \            .filter(c => c != 0)\n            .iterator\n        val result:\
    \ List[Long] = music_chars.takeWhile(_ != 4).map(_ * 2).toList\n        result.reverse.map(v\
    \ => v.asInstanceOf[Long]).toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvt6duu7b.scala:17:56 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            .map(c => (c == \e[31m'o'\e[0m) ? \e[31m1l\e\
    [0m : (c == \e[31m'|'\e[0m) ? \e[31m2l\e[0m : (c == \e[31m'.'\e[0m) ? \e[31m4l\e\
    [0m : (c == \e[31m'~'\e[0m) ? \e[31m4l\e[0m : \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                             ')' expected, but ':' found\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvt6duu7b.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            .map(s => s.toChar)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ toChar is not a member of String\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvt6duu7b.scala:17:51\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            .map(c => (c\
    \ == \e[31m'o'\e[0m) ? \e[31m1l\e[0m : (c == \e[31m'|'\e[0m) ? \e[31m2l\e[0m :\
    \ (c == \e[31m'.'\e[0m) ? \e[31m4l\e[0m : (c == \e[31m'~'\e[0m) ? \e[31m4l\e[0m\
    \ : \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \            Not found: type ?\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvt6duu7b.scala:17:33 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            .map(c => (c == \e[31m'o'\e[0m) ? \e[31m1l\e[0m : (c == \e[31m'|'\e\
    [0m) ? \e[31m2l\e[0m : (c == \e[31m'.'\e[0m) ? \e[31m4l\e[0m : (c == \e[31m'~'\e\
    [0m) ? \e[31m4l\e[0m : \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value ? is not a\
    \ member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvt6duu7b.scala:20:69\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = music_chars.takeWhile(_ !=\
    \ \e[31m4\e[0m).map(_ * \e[31m2\e[0m).toList\n\e[31m\e[31m   |\e[0m          \
    \                                                         ^^^\e[0m\n\e[31m   |\e\
    [0mvalue * is not a"
  stdout: ''
  timestamp: 1660029294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var note_list : List[Long] = Nil\n        music_string.split(\"\
    \\\\|\").foreach(s => {\n            note_list = note_list ::: (0 until s.length)\n\
    \            for (i <- 0 until s.length - 1) {\n                if (s(i) == '.'\
    \ || s(i) == 'o') {\n                    note_list(s.length-i-1) = note_list(s.length-i-1)\
    \ - 4\n                }\n            }\n        })\n        return note_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9kn7a3mn.scala:16:34 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            note_list = note_list ::: (\e[31m0\e[0m until\
    \ s.length)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value ::: is not a member of Range - did you mean\
    \ Range.++:?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9kn7a3mn.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                    note_list(s.length-i-\e\
    [31m1\e[0m) = note_list(s.length-i-\e[31m1\e[0m) - \e[31m4\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean List[Long].updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660029295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.replace(\" \", \"\").toCharArray.filter(c\
    \ => c != '|' && c != 'o').toList.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvdn3ck7i.scala:18)\n\tat Problem.main(tmpvdn3ck7i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_array = music_string.split(\"\\\\|\\\\|\"\
    )\n        var list: List[Long] = Nil\n        var beats_so_far = 0L\n       \
    \ for (music_note <- music_array) {\n            if (music_note == \"o\") {\n\
    \                list = music_array.reverse.filter(x => x != \"o\").foldRight(list)(beats\
    \ => beats + 1L)\n                beats_so_far = 0L\n            } else {\n  \
    \              if (music_note != \"|\") {\n                    beats_so_far +=\
    \ 1L\n                }\n            }\n        }\n        list.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp1zar0sh4.scala:19:87 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                list = music_array.reverse.filter(\e\
    [36mx\e[0m => x != \e[31m\"o\"\e[0m).foldRight(list)(\e[36mbeats\e[0m => beats\
    \ + \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                                             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1660029292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var lastsBeats : List[Long] = Nil\n        var strLen\
    \ = music_string.length\n        var notes = music_string.split(\"\").toList\n\
    \        var notesCount = notes.length\n\n        while(notesCount > 0) {\n  \
    \          strLen -= 1\n            if(!lastsBeats.isEmpty) {\n              \
    \  val lastsBeat = lastsBeats.last\n                val note = notes(0)\n    \
    \            lastsBeats.lastOption match {\n                    case Some(lastsBeat)\
    \ if(note == lastsBeat) =>\n                        notesCount -= 1\n        \
    \                lastsBeats.lastOption = None\n                    case Some(lastsBeat)\
    \ =>\n                        lastsBeats.last += 1\n                        lastsBeats.last\
    \ = None\n                    case None =>\n                        lastsBeats.append(note)\n\
    \                        lastsBeats.last = None\n                }\n         \
    \   } else {\n                lastsBeats.append(notes.last)\n                lastsBeats.last\
    \ = None\n            }\n            notes = notes.tail\n        }\n        return\
    \ lastsBeats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpx2lqf7dw.scala:25:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mcase\e[0m Some(lastsBeat) \e\
    [33mif\e[0m(note == lastsBeat) =>\n\e[31m\e[31m   |\e[0m                     \
    \                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Long cannot be compared with == or !=\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpx2lqf7dw.scala:27:46 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                        lastsBeats.lastOption = None\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Reassignment to val lastOption\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx2lqf7dw.scala:29:40 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        lastsBeats.last += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value += is not a member of Long - did you mean Long.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx2lqf7dw.scala:30:42 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                        lastsBeats.last = None\n\e[31m\e\
    [31m   |\e[0m                                          ^^^^\e[0m\n\e[31m   |\e\
    [0m                                          Found:    None.type\n\e[31m   |\e\
    [0m                                          Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpx2lqf7dw.scala:32:35 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        lastsBeats.append(note)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ append is not a member of List[Long] - did you mean List[Long].appended?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx2lqf7dw.scala:33:42 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        lastsBeats.last = None\n\e[31m\e\
    [31m   |\e[0m               "
  stdout: ''
  timestamp: 1660029298
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string\n            .split(\"\"\
    )\n            .filterNot(_ <= \"o\")\n            .map(n => n.toInt)\n      \
    \      .filter(_ > 0)\n            .map(n => n % 4)\n            .toList\n   \
    \     val beats = music_string.split(\"\").filterNot(_ <= \"o\").map(n => n.toInt).toList\n\
    \        notes.zip(beats).map(n => n._1 + n._2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpslnsjcpf.scala:26)\n\tat Problem.main(tmpslnsjcpf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(' ').map(musicalNote => {\n   \
    \         var rest = musicalNote.slice(0,1)\n            var lastNote = musicalNote.slice(1,2)\n\
    \            var restBeats = 0\n            var lastBeats = 0\n            if(rest\
    \ == '.') {\n                restBeats = 4\n                lastBeats = 4\n  \
    \          }\n            if(rest == 'o') {\n                restBeats = 2\n \
    \               lastBeats = 2\n            }\n            if(rest == '|') {\n\
    \                restBeats = 1\n                lastBeats = 1\n            }\n\
    \            if(lastNote == 'o') {\n                lastBeats = 4\n          \
    \  }\n            if(lastNote == '|') {\n                lastBeats = 2\n     \
    \       }\n            if(lastNote == '.') {\n                lastBeats = 1\n\
    \            }\n            restBeats * (lastBeats + 1)\n        }).toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqcu5a9h3.scala:19:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(rest == \e[31m'.'\e[0m) {\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqcu5a9h3.scala:23:15 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(rest == \e[31m'o'\e[0m) {\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqcu5a9h3.scala:27:15 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mif\e[0m(rest == \e[31m'|'\e[0m) {\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqcu5a9h3.scala:31:15 -----------------------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            \e[33mif\e[0m(lastNote == \e[31m'o'\e[0m) {\n\e\
    [31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpqcu5a9h3.scala:34:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m(lastNote == \e[31m'|'\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqcu5a9h3.scala:37:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m(lastNote == \e[31m'.'\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n6 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_notes = music_string.split(\"\\\\|\").filter(s\
    \ => !s.isEmpty).map(n => (n.head.toInt, n.tail.map(_.toInt))).toList\n      \
    \  var beats : List[Long] = List[Long]()\n        var last_note : List[Int] =\
    \ List[Int]()\n        music_notes.foreach(note => {\n            if (note._1\
    \ == 0) return\n            if (note._1 == 1) beats.append(note._2)\n        \
    \    if (note._1 == 2) last_note.clear()\n            if (note._1 == 3) last_note.append(note._2)\n\
    \        })\n        if (last_note.isEmpty) {\n            val n = music_notes.find(_._1\
    \ == 4)._2\n            beats.append(n)\n            beats.append(n)\n       \
    \     beats.append(n)\n        } else {\n            beats.append(last_note.max)\n\
    \        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3hwcuz5b.scala:18:30\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (note._1\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    Unit\n\e[31m   |\e[0m                              Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3hwcuz5b.scala:19:36\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m\
    \ (note._1 == \e[31m1\e[0m) beats.append(note._2)\n\e[31m\e[31m   |\e[0m     \
    \                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not\
    \ a member of List[Long] - did you mean List[Long].appended?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3hwcuz5b.scala:20:40 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (note._1 == \e[31m2\e[0m) last_note.clear()\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue clear is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3hwcuz5b.scala:21:40\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m\
    \ (note._1 == \e[31m3\e[0m) last_note.append(note._2)\n\e[31m\e[31m   |\e[0m \
    \                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append\
    \ is not a member of List[Int] - did you mean List[Int].appended?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3hwcuz5b.scala:24:48 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m "
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\\\|\").map(music_string =>\
    \ {\n            // find each \"o\" or \"o|\" and add its length\n           \
    \ // \"o|\" -> 3 beats\n            // \"o\" -> 4 beats\n            val beat_length\
    \ = music_string.indexOf(\"o\") == -1 ? music_string.length : music_string.indexOf(\"\
    o\") + music_string.indexOf(\"|\")\n            music_string.indexOf(\"o\") ==\
    \ -1 ? 0L : (music_string.indexOf(\"o\") + music_string.indexOf(\"|\") + 4L)\n\
    \        }).sorted.toList.map(music_string => music_string.length.toLong)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp86v1f033.scala:18:106 ----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mbeat_length\e[0m = music_string.indexOf(\e\
    [31m\"o\"\e[0m) == -\e[31m1\e[0m ? music_string.length : music_string.indexOf(\e\
    [31m\"o\"\e[0m) + music_string.indexOf(\e[31m\"|\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \          end of statement expected but '(' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp86v1f033.scala:19:72 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m            music_string.indexOf(\e[31m\"o\"\e[0m) == -\e[31m1\e\
    [0m ? \e[31m0L\e[0m : (music_string.indexOf(\e[31m\"o\"\e[0m) + music_string.indexOf(\e\
    [31m\"|\"\e[0m) + \e[31m4L\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                          ')' expected, but '(' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp86v1f033.scala:20:9 ----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        }).sorted.toList.map(music_string => music_string.length.toLong)\n\
    \e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         '}' expected, but\
    \ ')' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp86v1f033.scala:18:62\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbeat_length\e[0m = music_string.indexOf(\e[31m\"o\"\e[0m) == -\e[31m1\e\
    [0m ? music_string.length : music_string.indexOf(\e[31m\"o\"\e[0m) + music_string.indexOf(\e\
    [31m\"|\"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                    ^^^^\e[0m\n\e[31m   |\e[0m                              \
    \            value ? is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp86v1f033.scala:19:44 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m            music_string.indexOf(\e[31m\"o\"\e[0m) == -\e[31m1\e[0m ? \e[31m0L\e\
    [0m : (music_string.indexOf(\e[31m\"o\"\e[0m) + music_string.indexOf(\e[31m\"\
    |\"\e[0m) + \e[31m4L\e[0m)\n\e[31m\e[31m   |\e[0m                        "
  stdout: ''
  timestamp: 1660029297
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code goes here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg39jkqax.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// Your code\
    \ goes here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029296
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        if (music_string.isEmpty) {\n            List()\n\
    \        }\n        music_string.split(' ').toList.reverse.flatMap {\n       \
    \     case x: \"o\" => List(1l.toLong)\n            case x: \"o|\" => List(2l.toLong)\n\
    \            case x: \".|\" => List(1l.toLong)\n            case _ => List()\n\
    \        }.foldLeft(List[Long]()) {\n            case (acc, beats) => acc :+ beats\
    \ * 4\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphx1fcxb2.scala:29)\n\tat Problem.main(tmphx1fcxb2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var last_note = \"\"\n        var last_beat = 0L\n\
    \        var last_count = -1\n\n        val notes_in_string = (music_string\n\
    \            .split(\" \")\n            .filter(_.length() > 0)\n            .map(_.charAt(0))\n\
    \        )\n\n        notes_in_string.toList.sortWith(_.compare(last_note) > 0).foreach\
    \ {\n            note => {\n                if (note == \".\") {\n           \
    \         if (last_count >= 0) {\n                        last_beat = last_count\
    \ * 4L\n                        last_count = 0\n                        last_note\
    \ = \"\"\n                    } else {\n                        last_beat = 0L\n\
    \                        last_count = 0\n                        last_note = note\n\
    \                    }\n                } else if (note == \"o\") {\n        \
    \            if (last_note == \"\") {\n                        last_beat = 0L\n\
    \                        last_count = 1\n                    } else {\n      \
    \                  last_beat = 0L\n                        last_count = 1\n  \
    \                      last_note = note\n                    }\n             \
    \   } else if (note == \"|\") {\n                    if (last_note == \"\") {\n\
    \                        last_beat = 0L\n                        last_count =\
    \ 2\n                    } else {\n                        last_beat = 0L\n  \
    \                      last_count = 2\n                        last_note = note\n\
    \                    }\n                } else {\n                    last_beat\
    \ = 0L\n                    last_count = -1\n                    last_note = note\n\
    \                }\n            }\n        }\n\n        if (last_note != \"\"\
    ) {\n            last_beat = 0L\n            last_count = -1\n            last_note\
    \ = \"\"\n        }\n\n        return (List(4L * last_beat, 2L * last_beat, 1L\
    \ * last_beat, 2L * last_beat, 2L * last_beat, 1L * last_beat, 1L * last_beat,\
    \ 1L * last_beat, 4L * last_beat, 4L * last_beat))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpdqb23x0v.scala:24:40 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        notes_in_string.toList.sortWith(_.compare(last_note)\
    \ > \e[31m0\e[0m).foreach {\n\e[31m\e[31m   |\e[0m                           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 2\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpdqb23x0v.scala:26:20 -----------------------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (note == \e[31m\".\"\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdqb23x0v.scala:34:36 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        last_note = note\n\e[31m\e[31m\
    \   |\e[0m                                    ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                               Found:    (note : Char)\n\e[31m   |\e[0m     \
    \                               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpdqb23x0v.scala:36:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (note\
    \ == \e[31m\"o\"\e[0m) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdqb23x0v.scala:43:36\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                        last_note\
    \ = note\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\
    \e[31m   |\e[0m                                    Found:    (note : Char)\n\e\
    [31m   |\e[0m                                    Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpdqb23x0v.scala:45:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (no"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_list = music_string.split(\"\\\\|\")\n \
    \       music_list.map { music =>\n            music match {\n               \
    \ case \"o\" => 4l.toLong\n                case \"o|\" => 2l.toLong\n        \
    \        case \".|\" => 1l.toLong\n                default =>\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpki5rvgl6.scala:20:16 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[36mdefault\e[0m =>\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                I could not\
    \ infer the type of the parameter default.\n1 error found\n"
  stdout: ''
  timestamp: 1660029294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val strings = music_string.split(\" \").map(_.toUpperCase)\n\
    \        var beats : List[Long] = Nil\n        var length = 0\n        strings.foreach\
    \ { string => {\n            if (string.equals(\"o\")){\n                beats\
    \ = beats :: length :: Nil\n                length = 0\n            }\n      \
    \      else if (string.equals(\".\")){\n                beats = beats :: length\
    \ :: Nil\n                length = 0\n            }\n            else if (string.equals(\"\
    |\")){\n                length = length + 1\n            }\n            else {\n\
    \                length = length + 1\n                beats = beats :: length\
    \ :: Nil\n                length = length\n            }\n        }}\n       \
    \ beats.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_tds8ph9.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                beats = beats\
    \ :: length :: Nil\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    List[Matchable]\n\e[31m\
    \   |\e[0m                        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_tds8ph9.scala:23:24 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                beats = beats :: length :: Nil\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    List[Matchable]\n\e[31m   |\e[0m        \
    \                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_tds8ph9.scala:31:24 --------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                beats = beats :: length :: Nil\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Found:    List[Matchable]\n\e[31m   |\e[0m          \
    \              Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\"\\\\|\\\\|\")\n \
    \       var total_beats : Long = 0\n        for (note <- notes) {\n          \
    \  if (note == \"o\") {\n                total_beats += 4\n            } else\
    \ if (note == \"o|\") {\n                total_beats += 2\n            } else\
    \ if (note == \".|\") {\n                total_beats +=1\n            }\n    \
    \    }\n        List(total_beats)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphk2y1s2d.scala:28)\n\tat Problem.main(tmphk2y1s2d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\"\"\"\\|\"\"\").toList\n\
    \        val note_lengths = notes.map(n => n.length.toInt).toList\n        val\
    \ notes_lengths_sum = note_lengths.sum\n        val note_lengths_diffs = note_lengths.diff(note_lengths_sum)\n\
    \n        //  Convert all the note lengths to seconds\n        val notes_lengths_sum_in_seconds\
    \ = notes_lengths_sum.map(l => l.toDouble * Math.pow(2,(notes.length-1)))\n  \
    \      //  Find which note lengths do NOT sum to 4\n        val notes_lengths_diffs_not_sum_to_four\
    \ = notes_lengths_diffs.filter(d => d != 4).toList\n        //  Find the note\
    \ lengths we do NOT sum to 4\n        val notes_lengths_diffs_sum_to_four = notes_lengths_diffs.filter(d\
    \ => d == 4).toList\n        //  Find the note lengths we do sum to 4\n      \
    \  val notes_lengths_diffs_sum_to_four_and_notes_lengths_sum_to_four = notes_lengths_diffs_sum_to_four.intersect(notes_lengths_sum_to_four).toList\n\
    \        //  Find the note lengths we do NOT sum to 4\n        val notes_lengths_diffs_not_sum_to_four_and_notes_lengths_sum_to_four\
    \ = notes_lengths_diffs_not_sum_to_four.intersect(notes_lengths_sum_to_four).toList\n\
    \n        //  We need to convert the lengths to fractions (so we don't get integer\
    \ division), so multiply by two\n        val notes_lengths_sum_in_fractions =\
    \ notes_lengths_sum_in_seconds.map(l => (l / 4).toDouble*2)\n        //  Multiply\
    \ all the note lengths by two\n        val notes_lengths_sum_in_fractions_multiply_by_two\
    \ = notes_lengths_sum_in_fractions.map(l => (l * 2))\n        //  Subtract all\
    \ the note lengths by two\n        val notes_lengths_sum_in_fractions_subtract_by_two\
    \ = notes_lengths_sum_in_fractions_multiply_by_two.map(_ - 2)\n\n        //  Convert\
    \ all the note lengths to fractions (so we don't get integer division), so multiply\
    \ by two\n        val notes_lengths_diffs_not_sum_to_four_in_fractions = notes_lengths_diffs_not_sum_to_four.map(l\
    \ => (l / 4).toDouble*2)\n        //  Multiply all the note lengths by two\n \
    \       val notes_lengths_diffs_not_sum_to_four_in_fractions_multiply_by_\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgfmf9khb.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgfmf9khb.scala:17:51\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mnote_lengths_diffs\e[0m = note_lengths.diff(note_lengths_sum)\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Not found: note_lengths_sum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgfmf9khb.scala:20:61\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mnotes_lengths_sum_in_seconds\e[0m = notes_lengths_sum.map(\e[36ml\e[0m =>\
    \ l.toDouble * Math.pow(\e[31m2\e[0m,(notes.length-\e[31m1\e[0m)))\n\e[31m\e[31m\
    \   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value map is not a member\
    \ of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgfmf9khb.scala:22:50\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mnotes_lengths_diffs_not_sum_to_four\e[0m = notes_lengths_diffs.filter(\e[36md\e\
    [0m => d != \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m                      \
    \                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                   Not found: notes_lengths_diffs\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgfmf9khb.scala:24:46 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnotes_lengths_diffs_sum_to_four\e\
    [0m = notes_lengths_diffs.filter(\e[36md\e[0m => d == \e[31m4\e[0m).toList\n\e\
    [31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          Not found: notes_lengths_diffs\n\
    \e[31m   |\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660029298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case music_string\
    \ if music_string.endsWith(\"|\") => {\n                val notes = music_string.substring(0,\
    \ music_string.length - 1)\n                val notes_beats = notes.split(\"\\\
    \\|\").toSeq.map(_.toInt)\n                notes_beats.toList\n            }\n\
    \            case music_string if music_string.endsWith(\"o|\") => {\n       \
    \         val notes = music_string.substring(0, music_string.length - 1)\n   \
    \             val notes_beats = notes.split(\"\\\\|\").toSeq.map(_.toInt)\n  \
    \              val number_of_notes = notes_beats.length\n                notes_beats.takeRight(number_of_notes.toInt).reverse.map(_\
    \ + 4).toList\n            }\n            case music_string => {\n           \
    \     val notes = music_string.split(\"o\").toSeq.map(_.toInt)\n             \
    \   val number_of_notes = notes.length\n                notes.takeRight(number_of_notes.toInt).reverse.map(_\
    \ + 4).toList\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpphtcktut.scala:18:28\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                notes_beats.toList\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        \
    \        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpphtcktut.scala:24:80 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                notes_beats.takeRight(number_of_notes.toInt).reverse.map(_\
    \ + \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m\
    \   |\e[0m                Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpphtcktut.scala:29:74 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                notes.takeRight(number_of_notes.toInt).reverse.map(_\
    \ + \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m\
    \   |\e[0m                Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\\\|\").zipWithIndex.map { t\
    \ =>\n            if (t._2 == 0) {\n                if (t._1 == \"o\") {\n   \
    \                 4\n                } else if (t._1 == \"o|\") {\n          \
    \          2\n                } else if (t._1 == \".|\") {\n                 \
    \   1\n                } else {\n                    throw new Exception(\"unknown\
    \ note format: \\\"\" + t._1 + \"\\\"\")\n                }\n            } else\
    \ {\n                throw new Exception(\"unknown note format: \\\"\" + t._1\
    \ + \"\\\"\")\n            }\n        }.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp030onxu_.scala:28:10\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"\\\\|\"\e[0m).zipWithIndex.map { \e[36mt\e[0m =>\n\e[31m15 |\e[0m      \
    \      \e[33mif\e[0m (t._2 == \e[31m0\e[0m) {\n\e[31m16 |\e[0m               \
    \ \e[33mif\e[0m (t._1 == \e[31m\"o\"\e[0m) {\n\e[31m17 |\e[0m                \
    \    \e[31m4\e[0m\n\e[31m18 |\e[0m                } \e[33melse\e[0m \e[33mif\e\
    [0m (t._1 == \e[31m\"o|\"\e[0m) {\n\e[31m19 |\e[0m                    \e[31m2\e\
    [0m\n\e[31m20 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (t._1 == \e\
    [31m\".|\"\e[0m) {\n\e[31m21 |\e[0m                    \e[31m1\e[0m\n\e[31m22\
    \ |\e[0m                } \e[33melse\e[0m {\n\e[31m23 |\e[0m                 \
    \   \e[33mthrow\e[0m \e[33mnew\e[0m \e[35mException\e[0m(\e[31m\"unknown note\
    \ format: \\\"\"\e[0m + t._1 + \e[31m\"\\\"\"\e[0m)\n\e[31m24 |\e[0m         \
    \       }\n\e[31m25 |\e[0m            } \e[33melse\e[0m {\n\e[31m26 |\e[0m   \
    \             \e[33mthrow\e[0m \e[33mnew\e[0m \e[35mException\e[0m(\e[31m\"unknown\
    \ note format: \\\"\"\e[0m + t._1 + \e[31m\"\\\"\"\e[0m)\n\e[31m27 |\e[0m    \
    \        }\n\e[31m28 |\e[0m        }.toList\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      music_string.split(\" \").map { x =>\n        val music_note\
    \ = x.toInt\n        val beat_counts = x.toLong.split('|').toList.map(x => x.toInt)\n\
    \        val music_type = beat_counts.take(music_note).last\n        val beat_count\
    \ = beat_counts.drop(music_note).last\n        val beat_counts_total = (music_type\
    \ * beat_count).abs.toLong\n        beat_counts_total\n      }.sum\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxk6ogor3.scala:16:35 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbeat_counts\e[0m = x.toLong.split(\e\
    [31m'|'\e[0m).toList.map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e[0m     \
    \                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       value split is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmpxk6ogor3.scala:21:7\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m      }.sum\n\
    \e[31m\e[31m   |\e[0m       ^\e[0m\n\e[31m   |\e[0m       No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m       where:    B is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660029299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var note : String = \"\"\n        var beats : List[Long]\
    \ = Nil\n        var last_note : String = \"\"\n        var beat_index : Long\
    \ = 0\n\n        for (character <- music_string.toCharArray) {\n            if\
    \ (character.toUpper == '|') {\n                if (beat_index > 0) {\n      \
    \              note += \"|\"\n                    beat_index = 0\n           \
    \     }\n            } else if (character.toUpper == 'o') {\n                note\
    \ += character\n                last_note = character\n                beats =\
    \ List(beat_index.toLong)\n            } else if (character == last_note) {\n\
    \                beat_index += 1\n            } else {\n                note +=\
    \ character\n            }\n        }\n\n        return beats\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqnirpey1.scala:27:28\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                last_note = character\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    (character : Char)\n\e[31m   |\e[0m \
    \                           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpqnirpey1.scala:29:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (character\
    \ == last_note) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660029300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      val notes = music_string.split(\"\\\\|\").map(x=>x.trim).filter(x=>x.length>0)\n\
    \      val beats = notes.map(x=>x.split(\"\").foldLeft(1L){(_,x)=>\n        val\
    \ note = scala.util.Try(x.charAt(0)) match {\n            case Success(ch) =>\
    \ ch\n            case Failure(_)  => x\n        }\n        if(note=='o') 2L else\
    \ 1L\n      }).filter(x => x==1)\n      beats.map(x => x*4).toList.map(_.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0y7vn_z.scala:17:17 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m Success(ch) => ch\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not\
    \ found: Success\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0y7vn_z.scala:18:17\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e\
    [0m Failure(_)  => x\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 Not found: Failure\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Initialize empty list of beats per note\n     \
    \   var beats_per_note : List[Long] = Nil\n        // Split string on white space\
    \ to get all notes\n        val all_notes = music_string.split(\" \").map(x =>\
    \ x.toChar)\n        // Process notes and update list of beats per note\n    \
    \    for (note <- all_notes) {\n            if (note == '.' || note == '|') {\n\
    \                beats_per_note :+= 2\n            } else if (note == 'o') {\n\
    \                beats_per_note :+= 4\n            } else {\n                beats_per_note\
    \ :+= 1\n            }\n        }\n        return beats_per_note\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3gahpq3s.scala:17:59 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mall_notes\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m         \
    \                                                ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  value toChar is not a member of String\n\e\
    [31m\e[31m-- Error: /tmp/tmp3gahpq3s.scala:17:66 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mall_notes\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_list = music_string.split(' ').toList\n\
    \        var beats = 0\n        var notes = List.empty[Long]\n        while(music_list.length>0)\
    \ {\n            var music_note = music_list.head.toChar\n            music_list\
    \ = music_list.tail\n            notes = music_note match {\n                case\
    \ 'o' => notes = notes :+ 0\n                case 'o|' => notes = notes :+ 1\n\
    \                case '.|' => notes = notes :+ 2\n                default => throw\
    \ new Exception(\"Invalid music string. Music string must end with '.|' or '.|o|'.\"\
    )\n            }\n            beats = beats + (music_note.toLong*music_note.length)\n\
    \        }\n        notes\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqjy6k6un.scala:23:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e[0m '.|' => notes = notes\
    \ :+ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m  \
    \ |\e[0m                     unclosed character literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqjy6k6un.scala:22:21 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => notes =\
    \ notes :+ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e\
    [31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqjy6k6un.scala:22:26 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => notes\
    \ = notes :+ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                          ^^\e\
    [0m\n\e[31m   |\e[0m                          '{' expected, but '=>' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpqjy6k6un.scala:26:0 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            beats = beats + (music_note.toLong*music_note.length)\n\
    \e[31m\e[31m   |\e[0m^^^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqjy6k6un.scala:39:0 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjy6k6un.scala:18:45\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mmusic_note\e[0m = music_list.head.toChar\n\e[31m\e[31m   |\e[0m      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                    value toChar is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqjy6k6un.scala:21"
  stdout: ''
  timestamp: 1660029307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Parse the string in four steps:\n        // 1.\
    \ Separate note letters from note length (with some basic math)\n        // 2.\
    \ Filter out empty strings and note lengths that are less than 2.\n        //\
    \ 3. Map note letter to an integer between 0 and (size of string - 1)\n      \
    \  // 4. Sum up the beats per note from the filtered string\n        var notes\
    \           = music_string.split(\"o|.|\".toCharArray).filter(_.nonEmpty).map(_.length).filter\
    \ { _ >= 2 }.toList\n        var notesMapped     = notes.map(x => ((x - 1) to\
    \ x).map(x => x)).toMap\n        var notesSorted     = notes.sortBy(-_)\n    \
    \    var notesSortedByKey = notesSorted.toSeq.sortBy(-_._1).map(_._2)\n      \
    \  var notesSortedByKey = notesSorted.toSeq.sortBy(-_._2).map(_._1)\n        var\
    \ beatsPerNote    = notesSortedByKey.map { case (k, v) => k.toLong }.sum\n   \
    \     return List(beatsPerNote)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmlwlg70.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mnotesSortedByKey\e[0m =\
    \ notesSorted.toSeq.sortBy(-_._2).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnotesSortedByKey is already defined as \e[33mvariable\e[0m\
    \ \e[35mnotesSortedByKey\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpxmlwlg70.scala:20:78 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mnotesMapped\e[0m     = notes.map(\e\
    [36mx\e[0m => ((x - \e[31m1\e[0m) to x).map(\e[36mx\e[0m => x)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \              ^\e[0m\n\e[31m   |\e[0m                            Cannot prove\
    \ that IndexedSeq[Int] <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \                  where:    K is a type variable\n\e[31m   |\e[0m           \
    \                           V is a type variable\n\e[31m   |\e[0m            \
    \                .\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxmlwlg70.scala:22:59\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e\
    [36mnotesSortedByKey\e[0m = notesSorted.toSeq.sortBy(-_._1).map(_._2)\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^\e[0m\n\
    \e[31m   |\e[0m                                         value _1 is not a member\
    \ of Int\n\e[31m\e[31m-- Error: /tmp/tmpxmlwlg70.scala:22:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnotesSortedByKey\e[0m =\
    \ notesSorted.toSeq.sortBy(-_._1).map(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mso"
  stdout: ''
  timestamp: 1660029308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string = music_string.replaceAll(\"\\\\\
    s\", \"\") // Remove all whitespace\n        var last_beat = 0\n        val music_lines\
    \ = music_string.split(\"\\n\")\n\n        var count_beats_rest = 0\n        var\
    \ last_line_index = 0\n\n        for (line_index <- 0 until music_lines.size)\
    \ {\n            val line = music_lines(line_index)\n\n            val split_line\
    \ = line.split(\"\\\\|\")\n            val note = split_line(0) // Note name\n\
    \            val duration = split_line(1) // Note duration\n\n            val\
    \ beats = duration.toLong // Bills per beat\n            val rest = beats % 4\
    \ // Remaining beats\n\n            if (rest == 0 && last_beat == 0) {\n     \
    \           count_beats_rest = beats\n            } else if (rest == 0) {\n  \
    \              count_beats_rest += beats\n            } else if (rest == 1 &&\
    \ (count_beats_rest == 0 || count_beats_rest == last_beat)) {\n              \
    \  count_beats_rest += beats\n            } else if (rest > 1 && count_beats_rest\
    \ > 0) {\n                count_beats_rest += beats\n            }\n\n       \
    \     last_beat = count_beats_rest\n        }\n\n        val music_notes = music_lines.map(line\
    \ => line.split(\"\\\\|\")).flatten\n        val music_notes_beats = music_notes.map(line\
    \ => line(1)).toList\n        val music_notes_rest = music_notes.map(line => line(2)).toList\n\
    \n        val music_notes_rest_int = music_notes_rest.map(line => line.toInt).toList\n\
    \n        // Get list of all possible combinations\n        // We will use it\
    \ to find possible beats for each note\n        val music_notes_rest_int_combs\
    \ = music_notes_rest_int.combinations\n\n        // Create list of possible beats\
    \ for each note\n        // We will use it to find possible rests for each note\n\
    \        val music_notes_beats_combs = music_notes_beats.combinations(music_notes_rest.size)\n\
    \n        // Initialize list of possible rests for each note\n        val music_notes_rest_combs\
    \ = ListBuffer[List[Long]]()\n\n        for (i<-0 until music_notes_rest_int_combs.size)\
    \ {\n            var music_notes_rest_combs_i = ListBuffer[List[Long]]()\n   \
    \         val music_notes_rest_int_combs_i = music_notes_rest_int_combs(i)\n \
    \           val music_notes_beats_combs_i = music_notes_beats_combs(i)\n     \
    \       val music_notes_rest_combs_i_l = music_notes_rest_combs_i.toList\n   \
    \         for (j<-\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_2k68cx9.scala:66:20 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m            \e[33mfor\e[0m (j<-\n\e[31m\e[31m   |\e[0m\
    \                    ^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp_2k68cx9.scala:77:0 ----------------------------\e[0m\e[0m\n\e[31m77\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_2k68cx9.scala:14:27 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_string\e[0m = music_string.replaceAll(\e\
    [31m\"\\\\s\"\e[0m, \e[31m\"\"\e[0m) \e[34m// Remove all whitespace\e[0m\n\e[31m\e\
    [31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m              \
    \             Recursive \e[33mvalue\e[0m \e[35mmusic_string\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_2k68cx9.scala:76:1\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp_2k68cx9.scala:68:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m68 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660029309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\"\\\\|\").filter(_\
    \ != \"\")\n        var beats = 0\n        var result = 0\n        for(note <-\
    \ notes) {\n            val splits = note.split(\"o\")\n            val note =\
    \ splits.head\n            val noteLen = splits.length\n            var lastNote\
    \ = \"\"\n            var lastNoteTime = 0\n            for(i <- 1 to noteLen)\
    \ {\n                val time = (splits(i).toLong * beats).toInt\n           \
    \     val newNote = if (time == lastNoteTime) lastNote else note\n           \
    \     lastNote = newNote\n                lastNoteTime = time\n              \
    \  beats *= 4\n                result += time\n            }\n        }\n    \
    \    beats *= 4\n        result ::: List(beats.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5xsbja32.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mnote\e[0m = splits.head\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35msplits\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5xsbja32.scala:33:8 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        result ::: List(beats.toLong)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Int)\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\" \").filter(_.nonEmpty).map(_.toUpperCase).toList\n\
    \        var beatsCount : Int = 0\n\n        var lastNote = 'o'\n        var lastBeats\
    \ : List[Long] = Nil\n\n        music_list.foreach { music =>\n            music\
    \ match {\n                case \"o\" =>\n                    lastNote = 'o'\n\
    \                    lastBeats = Nil\n                case \"o|\" =>\n       \
    \             lastNote = 'o'\n                    beatsCount += 1\n          \
    \          lastBeats = Nil\n                case \".|\" =>\n                 \
    \   lastNote = '.'\n                    lastBeats = Nil\n                case\
    \ \".\" =>\n                    lastNote = '.'\n                    beatsCount\
    \ += 1\n                case \"o|.\" =>\n                    lastNote = 'o'\n\
    \                    beatsCount += 1\n                    lastBeats = Nil\n  \
    \              case \".|.\" =>\n                    lastNote = '.'\n         \
    \           beatsCount += 1\n                    lastBeats = Nil\n           \
    \     case \".|o\" =>\n                    lastNote = '.'\n                  \
    \  beatsCount += 1\n                    lastBeats = Nil\n                case\
    \ \"o|.|\" =>\n                    lastNote = 'o'\n                    beatsCount\
    \ += 1\n                    lastBeats = Nil\n                case \".|.o\" =>\n\
    \                    lastNote = '.'\n                    beatsCount += 1\n   \
    \                 lastBeats = Nil\n                case \"o|.|o\" =>\n       \
    \             lastNote = 'o'\n                    beatsCount += 1\n          \
    \          lastBeats = Nil\n                case \"o|.|.|\" =>\n             \
    \       lastNote = 'o'\n                    beatsCount += 1\n                \
    \    lastBeats = Nil\n                case _ =>\n                    lastNote\
    \ = music\n            }\n        }\n        if(beatsCount < 4) lastBeats = Nil\n\
    \        if(beatsCount > 4) lastBeats = Nil\n\n        val beats = lastBeats.map(_\
    \ * beatsCount)\n        beats.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpszsg_j8g.scala:64:31\
    \ --------------------\e[0m\e[0m\n\e[31m64 |\e[0m                    lastNote\
    \ = music\n\e[31m\e[31m   |\e[0m                               ^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    (music : String)\n\e[31m\
    \   |\e[0m                               Required: Char\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Write your code here\n        \n        // split\
    \ the string by the |\n        // split string by space\n        val musicList\
    \ = music_string.split(\"\\\\|\")\n        var beats = 0l\n        for(i <- musicList)\
    \ {\n            if (i.contains(\"o\")) {\n                beats += 4l\n     \
    \       }\n            if (i.contains(\"o|\")) {\n                beats += 2l\n\
    \            }\n            if (i.contains(\".|\")) {\n                beats +=\
    \ 1l\n            }\n        }\n        \n        return beats\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy8p28s9o.scala:32:15\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mreturn\e[0m beats\n\
    \e[31m\e[31m   |\e[0m               ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \ Found:    (beats : Long)\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\\\.| \").map(music_string =>\
    \ {\n            music_string.split(\"o\").map(music_string => {\n           \
    \     if (music_string.size < 2) List(0).toLong\n                else music_string.size.toLong\n\
    \            }).toList\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl8w2blsk.scala:16:51 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mif\e[0m (music_string.size < \e\
    [31m2\e[0m) List(\e[31m0\e[0m).toLong\n\e[31m\e[31m   |\e[0m                 \
    \                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is\
    \ not a member of List[Int], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Split the string into lines\n        val lines\
    \ = music_string.split(\"\\n\")\n        val beats_counters = mutable.Map[String,\
    \ Int]()\n\n        // Add beats for each note, e.g. \"o\" -> 4\n        for (line\
    \ <- lines) {\n            val line_parts = line.split(\" \")\n            val\
    \ note = line_parts(0)\n            val note_length = line_parts(1).length()\n\
    \            val beats = line_parts(2) match {\n                case \".\" =>\
    \ 1\n                case \".|\" => 2\n                case _ => 4\n         \
    \   }\n            beats_counters(note) = beats\n        }\n\n        // Create\
    \ list containing all beats\n        val all_beats = beats_counters.values.toList\n\
    \n        // Return list of all beats\n        all_beats\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2g9km2vk.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbeats_counters\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      var last_note = \"\"\n      var last_beats : Long =\
    \ 0\n      var beats_left : Long = music_string.size\n      val list_of_notes\
    \ = mutable.ArrayBuffer.empty[Long]\n      var current_beats : Long = 0\n    \
    \  while(beats_left >= 1) {\n        if(music_string.charAt(beats_left - 1) ==\
    \ '|') {\n          current_beats += 2\n          last_beats += 2\n          beats_left\
    \ -= 2\n          last_note = '|'.toChar\n        } else {\n          val next_char\
    \ = music_string.charAt(beats_left - 1)\n          if(next_char == 'o') {\n  \
    \          current_beats += 4\n            last_beats += 4\n            beats_left\
    \ -= 4\n            last_note = 'o'.toChar\n          } else if(next_char == '.')\
    \ {\n            current_beats += 2\n            last_beats += 2\n           \
    \ beats_left -= 2\n            last_note = '.'.toChar\n          } else if(next_char\
    \ == 'o') {\n            current_beats += 1\n            last_beats += 1\n   \
    \         beats_left -= 1\n            last_note = 'o'.toChar\n          } else\
    \ {\n            throw new RuntimeException(\"Invalid music string\")\n      \
    \    }\n        }\n        list_of_notes.append(last_beats)\n      }\n      list_of_notes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp09yqx1ly.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m      \e[33mval\e[0m \e[36mlist_of_notes\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp09yqx1ly.scala:20:31 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(music_string.charAt(beats_left\
    \ - \e[31m1\e[0m) == \e[31m'|'\e[0m) {\n\e[31m\e[31m   |\e[0m                \
    \               ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \      Found:    Long\n\e[31m   |\e[0m                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp09yqx1ly.scala:24:26\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m          last_note = \e[31m'|'\e\
    [0m.toChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    Char\n\e[31m   |\e[0m              \
    \        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp09yqx1ly.scala:26:46 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m          \e[33mval\e[0m \e[36mnext_char\e[0m = music_string.charAt(beats_left\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \               Found:    Long\n\e[31m   |\e[0m                              \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp09yqx1ly.scala:31:28 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            last_note = \e[31m'o'\e[0m.toChar\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Found:    Ch"
  stdout: ''
  timestamp: 1660029312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats : List[Long] = Nil\n        var note : List[String]\
    \ = Nil\n        var tempNote : List[String] = Nil\n        var noteLength : Int\
    \ = -1\n\n        // Iterate through the string and parse music note into noteLength\
    \ and beats\n        var i = 0\n        while(i < music_string.length) {\n   \
    \         note = music_string.substring(i).split(\"\")\n            // if the\
    \ noteLength is -1 this means we have a new note\n            if(noteLength ==\
    \ -1) {\n                noteLength = len(note)\n            }\n            //\
    \ if the noteLength has changed this means the note is over and we add it to beats\n\
    \            else if(!noteLength == len(note)) {\n                beats = beats\
    \ ++ List(noteLength.toLong)\n                noteLength = -1\n            }\n\
    \            // otherwise this means the note is just one beat long\n        \
    \    else {\n                noteLength = noteLength + 1\n            }\n    \
    \        // add this note to tempNote and check if it is last note of the note\n\
    \            tempNote = tempNote ++ note\n            if(tempNote.last.equals(\"\
    .\") && tempNote.head == \".\") {\n                beats = beats ++ List(tempNote.last.length)\n\
    \                tempNote.last = \"\"\n            }\n            i = i + 1\n\
    \        }\n\n        if(beats.isEmpty) {\n            beats = List(4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong)\n        }\n\n        // Add the last note\n\
    \        beats = beats ++ List(noteLength.toLong)\n\n        // Return the beats\n\
    \        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0k1ymeq9.scala:22:50\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            note = music_string.substring(i).split(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    \e[1m\e[31mArray\e[0m[String]\n\
    \e[31m   |\e[0m                   Required: \e[1m\e[32mList\e[0m[String]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0k1ymeq9.scala:25:29 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                noteLength = len(note)\n\e[31m\e[31m\
    \   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m             \
    \                Not found: len\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0k1ymeq9.scala:28:20 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            \e[33melse\e[0m \e[33mif\e[0m(!noteLength == len(note)) {\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ unary_! is not a member of Int - did you mean Int.unary_+?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp0k1ymeq9.scala:40:30 -----------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                tempNote.last = \e[31m\"\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        Reassignment to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes_counter = mutable.Map[Char, Int]()\n   \
    \     // Here I use a loop to iterate over the string and count how many notes\
    \ I see.\n        // Then I check how many notes are last (using .last) \n   \
    \     // and add it to the list as a value.\n        for ((key, value) <- music_string.tail\
    \ zip music_string.init) {\n            if ('o' != key) notes_counter += (key.toChar,\
    \ notes_counter.getOrElse(key.toChar, 0)+1)\n            else if ('.' != key)\
    \ notes_counter += (key.toChar, notes_counter.getOrElse(key.toChar, 0)+4)\n  \
    \          else notes_counter += (key.toChar, notes_counter.getOrElse(key.toChar,\
    \ 0)+2)\n        }\n        // Here I convert the map to a list with only values\
    \ which were not last\n        val final_list = notes_counter.filter(_._2 != 0).map(_._1)\n\
    \        return final_list.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_cm2cpba.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnotes_counter\e[0m = mutable.Map[\e\
    [35mChar\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code goes here.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpemm73o4_.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// Your code\
    \ goes here.\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music_char => {\n  \
    \          val music_note = music_char.charAt(0).toLowerCase match {\n       \
    \         case 'o' => (-1L) -> (-1L) -> (-1L) -> (-1L)\n                case 'o|'\
    \ => (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L)\
    \ -> (-1L)\n                case '.|' => (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L)\
    \ -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L)\n                case\
    \ _ => (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) -> (-1L) ->\
    \ (-1L) -> (-1L) -> (-1L) -> (-1L)\n            }\n            val last_beat =\
    \ (music_char.substring(1)) match {\n                case 'o' => (4L)\n      \
    \          case 'o|' => (2L)\n                case '.|' => (1L)\n            \
    \    case _ => (0L)\n            }\n            music_note match {\n         \
    \       case (-1L, -1L, -1L, -1L) => 0L\n                case (last_beat, last_beat,\
    \ last_beat, last_beat) => last_beat.toLong\n            }\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpiyre82xl.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                     ^\e\
    [0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse\
    \ a string literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e\
    [0mor enclose in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor\
    \ now, you can also `import language.deprecated.symbolLiterals` to accept\n\e\
    [31m   |\e[0mthe idiom, but this possibility might no longer be available in the\
    \ future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiyre82xl.scala:17:26 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e\
    [31m1L\e[0m) -> (-\e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \    ^^\e[0m\n\e[31m   |\e[0m                          '{' expected, but '=>'\
    \ found\n\e[31m\e[31m-- Error: /tmp/tmpiyre82xl.scala:18:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m '.|' => (-\e[31m1L\e\
    [0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e\
    [0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e\
    [0m) -> (-\e[31m1L\e[0m) -> (-\e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \           ^\e[0m\n\e[31m   |\e[0m                     unclosed character literal\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiyre82xl.scala:21:0 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mlast_beat\e[0m = (music_char.substring(\e\
    [31m1\e[0m)) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>'\
    \ expected, but 'end of statement' found\n\e[31m\e[31m-- Error: /tmp/tmpiyre82xl.scala:23:21\
    \ -------------------------------------"
  stdout: ''
  timestamp: 1660029314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val pattern = \"([[:alpha:]]+)(\\\\.|[|])\"\n    \
    \    val pattern_list = music_string.split(pattern).toList\n        val l = pattern_list.size\n\
    \        val notes = pattern_list.filter(x => x(0).toLowerCase == \"o\" || x(0).toLowerCase\
    \ == \"o|\" || x(0) == \".|\").toList\n        val notesMap = notes.map(x => (x(1).toLowerCase,\
    \ x(2).toLowerCase)).toMap\n        val note_beats = notes.map(x => (x(1).toLowerCase,\
    \ 4L)).toMap\n        val note_halfs = notes.map(x => (x(1).toLowerCase, 2L)).toMap\n\
    \        val note_quarters = notes.map(x => (x(1).toLowerCase, 1L)).toMap\n  \
    \      val notes_count = notes.map(x => (x(1).toLowerCase, 1L)).foldLeft(Map.empty[String,\
    \ Long]) { (acc, x) => acc + (x -> (acc.getOrElse(x._1, 0L) + x._2))}\n\n    \
    \    val notLast = notes_count.filter(x => x._2 > 1)\n        val notLastMap =\
    \ notLast.toMap\n        val notLastMapKeys = notLastMap.keys.toList\n\n     \
    \   val notLastMapValues = notLastMap.values.toList\n        val notLastMapValuesFiltered\
    \ = notLastMapValues.filter(x => x % 2 = 0).filterNot(x => x % 4 = 0)\n\n    \
    \    val notesMapKeys = notesMap.keys.toList\n        val notesMapValuesFiltered\
    \ = notesMapValues.filter(x => x % 2 = 0).filterNot(x => x % 4 = 0)\n\n      \
    \  val notLastNotQuarters = notLastMapKeys ++ notLastMapValuesFiltered\n     \
    \   val notLastNotQuartersMap = notLastNotQuarters.map(x => x -> notesMapKeys).toMap\n\
    \        val notLastNotQuartersMapKeys = notLastNotQuartersMap.keys.toList\n \
    \       val notLastNotQuartersMapValues = notLastNotQuartersMap.values.toList\n\
    \n        val notLastNotQuartersNotHalfs = notLastNotQuartersMapKeys ++ notLastNotQuartersMapValuesFiltered\n\
    \        val notLastNotQuartersNotHalfsMap = notLastNotQuartersNotHalfs.map(x\
    \ => x -> notesMapKeys).toMap\n        val notLastNotQuartersNotHalfsMapKeys =\
    \ notLastNotQuarters\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphbclzq_1.scala:29:74 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnotLastMapValuesFiltered\e\
    [0m = notLastMapValues.filter(\e[36mx\e[0m => x % \e[31m2\e[0m = \e[31m0\e[0m).filterNot(\e\
    [36mx\e[0m => x % \e[31m4\e[0m = \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0m                                             ')' expected, but '='\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphbclzq_1.scala:29:100 --------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnotLastMapValuesFiltered\e\
    [0m = notLastMapValues.filter(\e[36mx\e[0m => x % \e[31m2\e[0m = \e[31m0\e[0m).filterNot(\e\
    [36mx\e[0m => x % \e[31m4\e[0m = \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \        ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphbclzq_1.scala:32:70\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnotesMapValuesFiltered\e[0m = notesMapValues.filter(\e[36mx\e[0m => x\
    \ % \e[31m2\e[0m = \e[31m0\e[0m).filterNot(\e[36mx\e[0m => x % \e[31m4\e[0m =\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                       ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmphbclzq_1.scala:32:96 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mnotesMapValuesFiltered\e[0m = notesMapValues.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m = \e[31m0\e[0m).filterNot(\e[36mx\e[0m => x % \e\
    [31m4\e[0m = \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \                                                                    ^\e[0m\n\e\
    [31m   |\e[0m                                             ')' expected, but '='\
    \ found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphbclzq_1.scala:17:50 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        "
  stdout: ''
  timestamp: 1660029314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_notes = music_string.split(\" \").map(c\
    \ => c.toInt).toList\n        val music_notes_map = music_notes.zip(music_notes.tail)\n\
    \        music_notes_map.filter(_._2 == 1).map(x => x._1 - x._2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:678)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmp6s2q9d4l.scala:14)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp6s2q9d4l.scala:14)\n\
    \tat Problem$.main(tmp6s2q9d4l.scala:19)\n\tat Problem.main(tmp6s2q9d4l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var outputList : List[Long] = List()\n        var\
    \ currentBeat : List[Int] = List()\n        var nextBeat : List[Int] = List()\n\
    \        var musicString : List[String] = List()\n        var music_length = music_string.length()\n\
    \        musicString = music_string.split(\",\")\n        music_string.foreach(musicString\
    \ => currentBeat.append(musicString.charAt(0).asInstanceOf[Int]))\n        musicString.foreach(musicString\
    \ => nextBeat.append(musicString.charAt(1).asInstanceOf[Int]))\n        musicString.foreach(musicString\
    \ => outputList.append(musicString.substring(2).asInstanceOf[Int]))\n        return\
    \ outputList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8ezml3u.scala:19:40\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        musicString = music_string.split(\e\
    [31m\",\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    \e[1m\e[31mArray\e[0m[String]\n\
    \e[31m   |\e[0m                      Required: \e[1m\e[32mList\e[0m[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv8ezml3u.scala:20:56\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        music_string.foreach(\e\
    [36mmusicString\e[0m => currentBeat.append(musicString.charAt(\e[31m0\e[0m).asInstanceOf[\e\
    [35mInt\e[0m]))\n\e[31m\e[31m   |\e[0m                                       \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member of\
    \ List[Int] - did you mean List[Int].appended?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpv8ezml3u.scala:20:75 ------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        music_string.foreach(\e[36mmusicString\e[0m => currentBeat.append(musicString.charAt(\e\
    [31m0\e[0m).asInstanceOf[\e[35mInt\e[0m]))\n\e[31m\e[31m   |\e[0m            \
    \                                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value charAt is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv8ezml3u.scala:21:52\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        musicString.foreach(\e\
    [36mmusicString\e[0m => nextBeat.append(musicString.charAt(\e[31m1\e[0m).asInstanceOf[\e\
    [35mInt\e[0m]))\n\e[31m\e[31m   |\e[0m                                       \
    \    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member of List[Int]\
    \ - did you mean List[Int].appended?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv8ezml3u.scala:22:54\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        musicString.foreach(\e\
    [36mmusicString\e[0m => outputList.append(musicString.substring(\e[31m2\e[0m).asInstanceOf[\e\
    [35mInt\e[0m]))\n\e[31m\e[31m   |\e[0m                                       \
    \    ^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660029314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\s+\"\"\").map( n => (n.length.toLong,n.toLong)\
    \ ).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp61niu1oh.scala:14:77\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"\"\"\\s+\"\"\"\e[0m).map( \e[36mn\e[0m => (n.length.toLong,n.toLong) ).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m  \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes_length = music_string.size\n        var\
    \ notes: List[Long] = Nil\n        var beats_length = 0\n        var beats_count\
    \ = 0\n\n        while(notes_length > 0) {\n            val note = music_string.charAt(notes_length)\n\
    \n            if(note == \"o\") {\n                notes = notes :+ 4l.toLong\n\
    \                beats_length += 1\n                beats_count += 1\n       \
    \     } else if(note == \"|\") {\n                notes = notes :+ 2l.toLong\n\
    \                beats_length += 1\n                beats_count += 1\n       \
    \     } else if(note == \".\") {\n                notes = notes :+ 1l.toLong\n\
    \                beats_length += 1\n                beats_count += 1\n       \
    \     }\n\n            notes_length -= 1\n        }\n\n        beats_length =\
    \ (beats_length/beats_count)*beats_count\n        notes = notes :+ beats_length\n\
    \        return notes\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvazo_bh.scala:22:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m(note == \e[31m\"o\"\e[0m) {\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqvazo_bh.scala:26:22 -----------------------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(note == \e[31m\"\
    |\"\e[0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpqvazo_bh.scala:30:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m(note == \e\
    [31m\".\"\e[0m) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660029315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music_string => {\n\
    \            val value = music_string.toInt\n            value match {\n     \
    \           case 0 => \"o\"\n                case 1 => \"o|\"\n              \
    \  case 2 => \".|\"\n                case _ => sys.error(\"Unexpected note input\"\
    )\n            }\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96pnbqhm.scala:22:11\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mmusic_string\e[0m => {\n\e[31m15 |\e[0m            \e\
    [33mval\e[0m \e[36mvalue\e[0m = music_string.toInt\n\e[31m16 |\e[0m          \
    \  value \e[33mmatch\e[0m {\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e\
    [31m0\e[0m => \e[31m\"o\"\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m\
    \ \e[31m1\e[0m => \e[31m\"o|\"\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e\
    [0m \e[31m2\e[0m => \e[31m\".|\"\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e\
    [0m _ => sys.error(\e[31m\"Unexpected note input\"\e[0m)\n\e[31m21 |\e[0m    \
    \        }\n\e[31m22 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mString\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029313
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO: implement the function here\n        // You\
    \ can either use the default parsing logic:\n        // return music_string.split(\"\
    \ \").map(x => x.toLong).map(x => (x/8).toLong).toList\n        // Or you can\
    \ implement your own parsing logic (it's up to you).\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph6n3t4b4.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// TODO:\
    \ implement the function here\e[0m\n\e[31m15 |\e[0m        \e[34m// You can either\
    \ use the default parsing logic:\e[0m\n\e[31m16 |\e[0m        \e[34m// return\
    \ music_string.split(\" \").map(x => x.toLong).map(x => (x/8).toLong).toList\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// Or you can implement your own parsing logic\
    \ (it's up to you).\e[0m\n\e[31m18 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029313
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.splitAt(music_string.lastIndexOf('|')).toList.map\
    \ {\n            m => (m.indexOf('o').toLong, m.lastIndexOf('|').toLong - m.indexOf('o').toLong).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe7h2z8wa.scala:15:92\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[36mm\e[0m => (m.indexOf(\e\
    [31m'o'\e[0m).toLong, m.lastIndexOf(\e[31m'|'\e[0m).toLong - m.indexOf(\e[31m'o'\e\
    [0m).toLong).toList\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Found:    List[\n\e[31m   |\e[0m     (Long, Long)\e[33m\
    \ match \e[0m{\n\e[31m   |\e[0m       case EmptyTuple => Nothing\n\e[31m   |\e\
    [0m       case h *: t => h | scala.Tuple.Fold[t, Nothing, [x, y] =>> x | y]\n\e\
    [31m   |\e[0m     }\n\e[31m   |\e[0m   ]\n\e[31m   |\e[0m   Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string = music_string.toUpperCase\n    \
    \    val split_array = music_string.split(\" \").toList\n        val beats = music_string.split(\"\
    \\\\s+\").map(_.toString.toLong).toList\n        val notes = music_string.split(\"\
    \\\\|\").map(_.toString.toLong).toList\n        notes.zip(beats).filter(x => !x._1.toString.toLong\
    \ == 0 || x._1.toString.toLong == 1).map(x => x._2.toLong).reverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8c09g6fo.scala:14:27 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_string\e[0m = music_string.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mmusic_string\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code here\n        val music_list = music_string.split(\"\
    \ \").map(music_char => music_char.charAt(0) - 'a').toList\n        val last_beat\
    \ = (music_list.size - 1)/4\n        val beat = music_list.foldLeft(0)((acc, x)\
    \ => acc + (last_beat - (x.toLong/4))).map(x => x * 4).toList.map(x => x.toLong).toList\n\
    \        return beat\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dvw3h6h.scala:17:54\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbeat\e\
    [0m = music_list.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc\
    \ + (last_beat - (x.toLong/\e[31m4\e[0m))).map(\e[36mx\e[0m => x * \e[31m4\e[0m).toList.map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                                      Found:    Long\n\
    \e[31m   |\e[0m                                                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\n\").map(line => line.trim.split(\"\
    |\").map(x => x.toLong).sum).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.parseMusic$$anonfun$1$$anonfun$1(tmp0qw937xg.scala:14)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic$$anonfun$1(tmp0qw937xg.scala:14)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp0qw937xg.scala:14)\n\
    \tat Problem$.main(tmp0qw937xg.scala:17)\n\tat Problem.main(tmp0qw937xg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notesCount = music_string.split(\" \").toList.map(x\
    \ => x.length).toList\n        var notLastNotes = 0\n        notesCount foreach\
    \ (x => if(x != \".\" && x != \"o\" && x != \"o|\") notLastNotes = notLastNotes\
    \ + 1L)\n        val result = notLastNotes.toList.map(x => notesCount.map(x =>\
    \ x*4L).toList.toSeq)\n        val res1 = result.flatten\n        val res2 = res1.groupBy(x\
    \ => x).mapValues(x => x.size)\n        val res3 = res2.map(x=> (x._2,x._1))\n\
    \        return res3\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp56wczgjk.scala:16:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        notesCount foreach (\e[36mx\e[0m => \e[33mif\e\
    [0m(x != \e[31m\".\"\e[0m && x != \e[31m\"o\"\e[0m && x != \e[31m\"o|\"\e[0m)\
    \ notLastNotes = notLastNotes + \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of\
    \ types Int and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp56wczgjk.scala:16:48 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        notesCount foreach (\e[36mx\e[0m => \e[33mif\e[0m(x\
    \ != \e[31m\".\"\e[0m && x != \e[31m\"o\"\e[0m && x != \e[31m\"o|\"\e[0m) notLastNotes\
    \ = notLastNotes + \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types\
    \ Int and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp56wczgjk.scala:16:60\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \ notesCount foreach (\e[36mx\e[0m => \e[33mif\e[0m(x != \e[31m\".\"\e[0m && x\
    \ != \e[31m\"o\"\e[0m && x != \e[31m\"o|\"\e[0m) notLastNotes = notLastNotes +\
    \ \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                                      \
    \                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types\
    \ Int and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp56wczgjk.scala:16:86 --------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        notesCount foreach (\e[36mx\e[0m => \e[33mif\e[0m(x !=\
    \ \e[31m\".\"\e[0m && x != \e[31m\"o\"\e[0m && x != \e[31m\"o|\"\e[0m) notLastNotes\
    \ = notLastNotes + \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                                                                 ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \ Found:    Long\n\e[31m   |\e[0m                                            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp56wczgjk.scala:17:34 -----------------"
  stdout: ''
  timestamp: 1660029323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\\\.|\\\\|\").map(music_string\
    \ => {\n            val note_array = music_string.split(\"o\").map(music_string\
    \ => music_string.trim).toArray\n            var note_count = 0\n            var\
    \ note_counter = 0\n            var last = 0\n            note_array.foreach(note_string\
    \ => {\n                note_counter += 1\n                if(note_counter ==\
    \ note_array.length) {\n                    note_count = note_counter\n      \
    \              last = note_count\n                }\n            })\n        \
    \    if(note_count > 1) {\n                note_array.foldLeft(0l) { (acc, value)\
    \ =>\n                    acc += last\n                }\n            } else {\n\
    \                0l.toLong\n            }\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbxujp9cn.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    acc += last\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                 value += is\
    \ not a member of Long - did you mean acc.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660029322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code here\n        val music_notes = music_string.split(\"\
    \ \")\n        music_notes.map { note =>\n            note match {\n         \
    \       case \"o\" => 4\n                case \"o|\" => 2\n                case\
    \ \".|\" => 1\n                case _ => 0\n            }\n        }.sum\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkcpxa963.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        music_notes.map { \e\
    [36mnote\e[0m =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    Int\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m17 |\e[0m\
    \            note \e[33mmatch\e[0m {\n\e[31m18 |\e[0m                \e[33mcase\e\
    [0m \e[31m\"o\"\e[0m => \e[31m4\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e\
    [0m \e[31m\"o|\"\e[0m => \e[31m2\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e\
    [0m \e[31m\".|\"\e[0m => \e[31m1\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e\
    [0m _ => \e[31m0\e[0m\n\e[31m22 |\e[0m            }\n\e[31m23 |\e[0m        }.sum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      var beats:List[Long] = List()\n      for (i <- music_string.toCharArray)\
    \ {\n          beats ::= beats.map(x => math.max(x+1, math.min(125, x+2)))\n \
    \     }\n      return beats\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9o2v37ed.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m          beats ::= beats.map(\e[36mx\e[0m => math.max(x+\e\
    [31m1\e[0m, math.min(\e[31m125\e[0m, x+\e[31m2\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ::= is not a member of List[Long]\
    \ - did you mean List[Long].::?\n1 error found\n"
  stdout: ''
  timestamp: 1660029322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(' ').filter(_.isDigit).map(_.toLong).toList\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\"\
    )).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmm_mvmg8.scala:14:41 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m' '\e[0m).filter(_.isDigit).map(_.toLong).toList\
    \ \n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 value isDigit is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1660029321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Write your code here\n        var list = music_string.split(\"\
    \ \");\n        val firstStrings = list.filter(x => x.charAt(0) == 'o')\n    \
    \    val secondStrings = list.filter(x => x.charAt(0) == 'o')\n        val firstBatches\
    \ = list.filter(x => x.charAt(0) == '.')\n        val secondBatches = list.filter(x\
    \ => x.charAt(0) == '.')\n\n        return List(firstStrings.toList.map(x => 4l.toLong).sum,\
    \ firstBatches.toList.map(x => 2l.toLong).sum, secondStrings.toList.map(x => 2l.toLong).sum,\
    \ secondBatches.toList.map(x => 1l.toLong).sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 0\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat Problem$.$anonfun$1(tmpztgky0tm.scala:16)\n\tat scala.collection.ArrayOps$.filter$extension(ArrayOps.scala:559)\n\
    \tat Problem$.parseMusic(tmpztgky0tm.scala:16)\n\tat Problem$.main(tmpztgky0tm.scala:24)\n\
    \tat Problem.main(tmpztgky0tm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029327
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\s+\"\"\").toList match\
    \ {\n            case x if(x.size > 1) => x map { i =>\n                val arr\
    \ = i.split(\"\"\"[|.]\"\"\").toList\n                arr(0) match {\n       \
    \             case \"o\" => 4L\n                    case \".\" => 2L\n       \
    \             case \"o|\" => 2L\n                    case \".|\" => 1L\n     \
    \               case \"o|\" => 1L\n                    case _ => throw new IllegalArgumentException(s\"\
    Invalid note name: $i\")\n                }\n            }\n            case _\
    \ => throw new IllegalArgumentException(s\"Music string contains only notes and\
    \ empty spaces: $music_string\")\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: Music string contains only notes and\
    \ empty spaces: \n\tat Problem$.parseMusic(tmp15aampo6.scala:26)\n\tat Problem$.main(tmp15aampo6.scala:30)\n\
    \tat Problem.main(tmp15aampo6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.trim().split(' ').map(x =>\
    \ x.toUpperCase().replace('|', 'o').replace('o', 'o|').replace('.', 'o|')).toList\n\
    \        // We use mutable list to keep track of total counts for every note\n\
    \        val notes_to_beat_map = mutable.Map[String, Long]()\n\n        // We\
    \ iterate over all notes\n        for (note <- notes) {\n            notes_to_beat_map(note)\
    \ = notes_to_beat_map(note).getOrElse(0l)\n            // We iterate over all\
    \ notes again and add one to total count for each note in given string\n     \
    \       for (next_note <- notes) {\n                // We compare next note to\
    \ current one\n                if (note.equals(next_note)) {\n               \
    \     continue\n                }\n                // We subtract 1 from total\
    \ count of next note for current note\n                notes_to_beat_map(next_note)\
    \ -= 1\n            }\n        }\n\n        // We return notes that exist in given\
    \ string\n        notes_to_beat_map.filter{case (n,c) => c>0}.map{case (n,c) =>\
    \ n}.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0ys72_ae.scala:14:107 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = music_string.trim().split(\e\
    [31m' '\e[0m).map(\e[36mx\e[0m => x.toUpperCase().replace(\e[31m'|'\e[0m, \e[31m'o'\e\
    [0m).replace(\e[31m'o'\e[0m, \e[31m'o\e[0m|').replace(\e[31m'.'\e[0m, \e[31m'o\e\
    [0m|')).toList\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- Error: /tmp/tmp0ys72_ae.scala:14:110 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = music_string.trim().split(\e\
    [31m' '\e[0m).map(\e[36mx\e[0m => x.toUpperCase().replace(\e[31m'|'\e[0m, \e[31m'o'\e\
    [0m).replace(\e[31m'o'\e[0m, \e[31m'o\e[0m|').replace(\e[31m'.'\e[0m, \e[31m'o\e\
    [0m|')).toList\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmp0ys72_ae.scala:14:129 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = music_string.trim().split(\e\
    [31m' '\e[0m).map(\e[36mx\e[0m => x.toUpperCase().replace(\e[31m'|'\e[0m, \e[31m'o'\e\
    [0m).replace(\e[31m'o'\e[0m, \e[31m'o\e[0m|').replace(\e[31m'.'\e[0m, \e[31m'o\e\
    [0m|')).toList\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \      unclosed character literal\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp0"
  stdout: ''
  timestamp: 1660029325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      val note_notes = music_string.split(\" \").map(x =>\
    \ x.trim).filter(x => x != \"\").toList\n      val notes = note_notes.zipWithIndex\n\
    \      val notes_notes_index = notes.filter(x => x._2.contains(\"o|\")).map(x\
    \ => x._1)\n      val notes_notes = notes_notes_index.groupBy(_._1).mapValues(_.map(x\
    \ => x._2).toList)\n      val notes_notes_index_map = notes_notes.toMap\n    \
    \  val notes_notes_index_map_values = notes_notes_index_map.values\n      val\
    \ notes_notes_index_map_map = notes_notes_index_map_values.toMap\n      val notes_notes_index_map_map_values\
    \ = notes_notes_index_map_map.values\n      val notes_notes_index_map_map_map\
    \ = notes_notes_index_map_map_values.toMap\n      val notes_notes_index_map_map_map_values\
    \ = notes_notes_index_map_map_map.values\n      val notes_notes_index_map_map_map_map\
    \ = notes_notes_index_map_map_map_values.toMap\n      val notes_notes_index_map_map_map_map_values\
    \ = notes_notes_index_map_map_map_map.values\n      val notes_notes_index_map_map_map_map_map\
    \ = notes_notes_index_map_map_map_map_values.toMap\n      val notes_notes_index_map_map_map_map_map_values\
    \ = notes_notes_index_map_map_map_map_map.values\n      val notes_notes_index_map_map_map_map_map_map\
    \ = notes_notes_index_map_map_map_map_map_values.toMap\n      val notes_notes_index_map_map_map_map_map_map_values\
    \ = notes_notes_index_map_map_map_map_map_map.values\n      val notes_notes_index_map_map_map_map_map_map_values\
    \ = notes_notes_index_map_map_map_map_map_map_values.toMap\n      val notes_notes_index_map_map_map_map_map_map_map\
    \ = notes_notes_index_map_map_map_map_map_map_map_values.toMap\n      val notes_notes_index_map_map_map_map_map_map_map_values\
    \ = notes_notes_index_map_map_map_map_map_map_map_map_values.toMap\n      val\
    \ notes_notes_index_map_map_map_map_map_map_map_map_values = notes_notes_index_map_map_map_map_map_map_map_map_map_values.toMap\n\
    \      val notes_notes_index_map_map_map_map_map_map_map_map_values = notes_notes_index_map_map_map_map_map_map_map_map_map_map_values.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13kuw2yt.scala:30:10 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      \e[33mval\e[0m \e[36mnotes_notes_index_map_map_map_map_map_map_values\e\
    [0m = notes_notes_index_map_map_map_map_map_map_values.toMap\n\e[31m\e[31m   |\e\
    [0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnotes_notes_index_map_map_map_map_map_map_values is already\
    \ defined as \e[33mvalue\e[0m \e[35mnotes_notes_index_map_map_map_map_map_map_values\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp13kuw2yt.scala:34:10 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m      \e[33mval\e[0m \e[36mnotes_notes_index_map_map_map_map_map_map_map_map_values\e\
    [0m = notes_notes_index_map_map_map_map_map_map_map_map_map_map_values.to\n\e\
    [31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnotes_notes_index_map_map_map_map_map_map_map_map_values is\
    \ already defined as \e[33mvalue\e[0m \e[35mnotes_notes_index_map_map_map_map_map_map_map_map_values\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp13kuw2yt.scala:16:53 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m      \e[33mval\e[0m \e[36mnotes_notes_index\e[0m = notes.filter(\e\
    [36mx\e[0m => x._2.contains(\e[31m\"o|\"\e[0m)).map(\e[36mx\e[0m => x._1)\n\e\
    [31m\e[31m   |\e[0m                                                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value contains is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp13kuw2yt.scala:17:52\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \e[33mval\e[0m \e[36mnotes_notes\e\
    [0m = notes_notes_index.groupBy(_._1).mapValues(_.map(\e[36mx\e[0m => x._2).toList)\n\
    \e[31m\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1660029327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        def parseNote(note : String) : List[Int] = {\n   \
    \         val ns = note.split('|')\n            val rest = if (ns(1) == \"*\"\
    ) (ns(2).split('o').toList) else (ns(2).split('o').toList :+ ns(3).split('.').toList)\n\
    \            rest(0) match {\n                case \"o\" :: _ => 4\n         \
    \       case \"o|\" :: _ => 2\n                case \".|\" :: _ => 1\n       \
    \         case _ => 0\n            }\n        }\n        music_string.split('|').map(parseNote).flatten.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoyxq4nkr.scala:18:33\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e\
    [0m \e[31m\"o\"\e[0m :: _ => \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m             \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    (\e[31m4\e[0m : Int)\n\e[31m   |\e[0m                                 Required:\
    \ List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoyxq4nkr.scala:19:34\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e\
    [0m \e[31m\"o|\"\e[0m :: _ => \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \   Found:    (\e[31m2\e[0m : Int)\n\e[31m   |\e[0m                          \
    \        Required: List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpoyxq4nkr.scala:20:34 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                \e[33mcase\e[0m \e[31m\".|\"\e[0m :: _ => \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e\
    [0m                                  Required: List[Int]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoyxq4nkr.scala:21:26 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e[0m _ => \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m            \
    \              Required: List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpoyxq4nkr.scala:24:55 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        music_string.split(\e[31m'|'\e[0m).map(parseNote).flatten.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660029327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.toUpperCase.trim.split(\"\\\\s+\").filter(_.nonEmpty).map(_.toInt).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqfhs4gty.scala:14:84\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.toUpperCase.trim.split(\e\
    [31m\"\\\\s+\"\e[0m).filter(_.nonEmpty).map(_.toInt).toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var music_beats: List[Long] = List()\n\n        // Parsing string\n        var\
    \ music_notes = music_string.split(\" \").toList\n        var music_beats: List[Long]\
    \ = List()\n\n        // Parsing string\n        var music_notes = music_string.split(\"\
    \ \").toList\n        var music_beats: List[Long] = List()\n\n        // Parsing\
    \ string\n        var music_notes = music_string.split(\" \").toList\n       \
    \ var \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzsfue9_j.scala:92:11 ---------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpzsfue9_j.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mmusic_notes\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_notes is already defined as \e[33mvariable\e[0m \e[35mmusic_notes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzsfue9_j.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mvar\e[0m \e[36mmusic_beats\e[0m: \e[35mList\e[0m[\e\
    [35mLong\e[0m] = List()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_beats is already defined as \e[33mvariable\e[0m \e[35mmusic_beats\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzsfue9_j.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mvar\e[0m \e[36mmusic_notes\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_notes is already defined as \e[33mvariable\e[0m \e[35mmusic_notes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzsfue9_j.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mvar\e[0m \e[36mmusic_beats\e[0m: \e[35mList\e[0m[\e\
    [35mLong\e[0m] = List()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmusic_beats is already defined as \e[33mvariable\e[0m \e[3"
  stdout: ''
  timestamp: 1660029327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music_note => {\n  \
    \          music_note match {\n                case 'o' => 4l.toLong\n       \
    \         case 'o|' => 2l.toLong\n                case \".|\" => 1l.toLong\n \
    \               case _ =>\n            }\n        }).flatten.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp67fvfyuz.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => \e\
    [31m2l\e[0m.toLong\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m \
    \  |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp67fvfyuz.scala:17:26 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'o\e[0m|' => \e\
    [31m2l\e[0m.toLong\n\e[31m\e[31m   |\e[0m                          ^^\e[0m\n\e\
    [31m   |\e[0m                          '{' expected, but '=>' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp67fvfyuz.scala:21:8 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }).flatten.toList\n\e[31m\e[31m   |\e[0m    \
    \    ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp67fvfyuz.scala:21:9 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }).flatten.toList\n\e[31m\e[31m   |\e[0m    \
    \     ^\e[0m\n\e[31m   |\e[0m         '}' expected, but ')' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmp67fvfyuz.scala:23:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    end of statement expected but 'def' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp67fvfyuz.scala:16:21 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m \e[31m'o'\e[0m => \e[31m4l\e\
    [0m.toLong\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp67fvfyuz.scala:21:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0"
  stdout: ''
  timestamp: 1660029328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // This solution uses two mutable collections to keep\
    \ the result\n        var result: List[Long] = Nil\n        var beats_counter:\
    \ mutable.Map[String, Long] = mutable.Map[String, Long]()\n\n        music_string.split(\"\
    \\\\s+\").foreach(s => {\n            if(s.isEmpty()) return\n            val\
    \ c = s.charAt(0)\n            beats_counter += (s->(c == '.' ? 1l : 0l))\n  \
    \      })\n        beats_counter.keys.foreach(c => {\n            val v = (beats_counter(c)\
    \ - beats_counter(c.subString(1, c.length - 1)))\n            if(v < 0l) v = v\
    \ + 12l.toLong\n            if(v > 12l) v = v - 12l.toLong\n            result\
    \ += v\n        })\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwgm45eyp.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mbeats_counter\e[0m: mutable.Map[\e\
    [35mString\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwgm45eyp.scala:16:55 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mbeats_counter\e[0m: mutable.Map[\e\
    [35mString\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                                \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwgm45eyp.scala:19:28 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mif\e[0m(s.isEmpty()) \e[33mreturn\e[0m\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Found:    Unit\n\e[31m   |\e[0m                            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.toList.map(music => {\n            val\
    \ notes = music_string.split(\"\\\\|\").map(note => note.split(\"o\").map(_.toInt)).toList\n\
    \            val beats = notes.map(n => n.drop(1).last).toList\n            beats\
    \ match {\n                case x if x > 0 => x.toLong\n                case x\
    \ => 0l.toLong\n            }\n        }).reverse.takeWhile(note => note < 40).reverse.sortBy(_\
    \ % 4).reverse.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnnksqziz.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x > \e\
    [31m0\e[0m => x.toLong\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\
    \e[31m   |\e[0mvalue > is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnnksqziz.scala:18:37 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x > \e[31m0\e\
    [0m => x.toLong\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Int], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Use mutable Map to store number of each note.\n\
    \        val noteCount : mutable.Map[String, Long] = mutable.Map.empty[String,\
    \ Long]\n        for (note <- music_string.toCharArray) {\n            // Remove\
    \ 'o' character from the string and try to parse it to integer.\n            val\
    \ note : String = note.drop(1).dropRight(1).trim\n            val noteNumber :\
    \ Option[Long] = note.toLong\n            // If parsing was successfull, add note\
    \ to Map and\n            // increment the note count for that note.\n       \
    \     if (noteNumber.isDefined) {\n                noteCount += note -> noteNumber.get\n\
    \            }\n        }\n        // Return a list of number of each note.\n\
    \        noteCount.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp33_gs27.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnoteCount\e[0m : mutable.Map[\e\
    [35mString\e[0m, \e[35mLong\e[0m] = mutable.Map.empty[\e[35mString\e[0m, \e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpp33_gs27.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnoteCount\e[0m : mutable.Map[\e\
    [35mString\e[0m, \e[35mLong\e[0m] = mutable.Map.empty[\e[35mString\e[0m, \e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                  \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp33_gs27.scala:19:49 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mval\e[0m \e[36mnoteNumber\e[0m : \e[35mOption\e[0m[\e\
    [35mLong\e[0m] = note.toLong\n\e[31m\e[31m   |\e[0m                          \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                   Found:    Long\n\e[31m   |\e[0m                          \
    \                  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.splitAt(music_string.length / 4).zipWithIndex.flatMap\
    \ { case (music_piece_piece, music_piece_index) =>\n                val music_piece\
    \ = music_piece_piece\n                music_piece.split(\"\\\\|\").map(music_character\
    \ => {\n                    if (music_character == \".\") {\n                \
    \        0\n                    } else if (music_character == \"o\") {\n     \
    \                   4\n                    } else {\n                        0\n\
    \                    }\n                }).toList\n        }.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_3wzwun6.scala:14:54 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.splitAt(music_string.length / \e\
    [31m4\e[0m).zipWithIndex.flatMap { \e[33mcase\e[0m (music_piece_piece, music_piece_index)\
    \ =>\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value zipWithIndex is not a member of (String, String)\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(' ').map(music_string => {\n  \
    \          if (music_string.contains(\"o|\")) 1\n            else if (music_string.contains(\"\
    o.|\")) 2\n            else 4 \n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8njybvgb.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m' '\e[0m).map(\e[36mmusic_string\e[0m => {\n\e[31m\e[31m   |\e[0m        ^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Int]\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m15 |\e[0m            \e[33mif\e[0m (music_string.contains(\e\
    [31m\"o|\"\e[0m)) \e[31m1\e[0m\n\e[31m16 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m (music_string.contains(\e[31m\"o.|\"\e[0m)) \e[31m2\e[0m\n\e[31m17\
    \ |\e[0m            \e[33melse\e[0m \e[31m4\e[0m \n\e[31m18 |\e[0m        })\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // First we split music by space\n        val music\
    \ = music_string.split(\" \")\n\n        // then we split each note by | \n  \
    \      val notes    = music.map(n => n.split(\"|\"))\n\n        // then we create\
    \ list of note durations\n        val notes_dur = notes.map(n => n.length.toLong)\n\
    \n        // then we calculate number of beats by dividing by 4\n        val beat_durs\
    \ = notes_dur.map(n => n/4)\n        val note_count = beat_durs.foldLeft(1L)((x,\
    \ y) => x*y)\n\n        // and we calculate note lengths\n        val note_lens\
    \ = notes_dur.map(n => n/4)\n\n        // and we combine note length into notes\n\
    \        val notes = note_lens.zip(note_count)\n        return notes.map(n =>\
    \ n._2)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaw8pu2ge.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = note_lens.zip(note_count)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mnotes is already defined as \e[33mvalue\e[0m \e[35mnotes\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpaw8pu2ge.scala:32:32 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        \e[33mreturn\e[0m notes.map(\e[36mn\e[0m => n._2)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            value _2 is not a member of Array[String]\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpaw8pu2ge.scala:32:35 -----------------------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        \e[33mreturn\e[0m notes.map(\e[36mn\e[0m => n._2)\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   No ClassTag available for B\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                   where:    B is a type variable\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029330
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var last_beat = 0\n        val notes = music_string.split(\"\
    \\\\|\".r)\n        var beats = 0\n        notes.foreach(note => {\n         \
    \   beats match {\n                case x if x == \".\" => beats -= 1\n      \
    \          case x if x == \"o\" => beats += 4\n                case x if x ==\
    \ \"o|\" => beats += 2\n                case _ => beats += 1\n            }\n\
    \            last_beat = beats\n        })\n        val length = beats - last_beat\n\
    \        if (length > 0) {\n            List(4L.toLong, 2L.toLong, 1L.toLong,\
    \ 2L.toLong, 2L.toLong, 1L.toLong, 1L.toLong, 1L.toLong, 1L.toLong, 4L.toLong,\
    \ 4L.toLong)\n        } else {\n            Nil\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc79a4p40.scala:15:45\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnotes\e\
    [0m = music_string.split(\e[31m\"\\\\|\"\e[0m.r)\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                       Found:    scala.util.matching.Regex\n\e[31m   |\e[0m \
    \                                    Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpc79a4p40.scala:19:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x ==\
    \ \e[31m\".\"\e[0m => beats -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types Int and\
    \ String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpc79a4p40.scala:20:26\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \         \e[33mcase\e[0m x \e[33mif\e[0m x == \e[31m\"o\"\e[0m => beats += \e\
    [31m4\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m         Values of types Int and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpc79a4p40.scala:21:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x ==\
    \ \e[31m\"o|\"\e[0m => beats += \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m          \
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types Int and\
    \ String cannot be compared with == or !=\n4 errors found\n"
  stdout: ''
  timestamp: 1660029329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Write your code here!\n        //return music_string.split(\"\
    \ \").map { x => x.replace(\"|\", \"\").split(\"o\").length }.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpniac73_a.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// Write\
    \ your code here!\e[0m\n\e[31m15 |\e[0m        \e[34m//return music_string.split(\"\
    \ \").map { x => x.replace(\"|\", \"\").split(\"o\").length }.toList\e[0m\n\e\
    [31m16 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats: List[Long] = List()\n        for (noteChar\
    \ <- music_string) {\n            val note = noteChar.charAt(0).toChar\n     \
    \       if (note == '.') {\n                beats ::= 4l.toLong\n            }\
    \ else if (note == 'o') {\n                beats ::= 2l.toLong\n            }\
    \ else if (note == '|') {\n                beats ::= 1l.toLong\n            }\
    \ else {\n                beats ::= 0l.toLong\n            }\n        }\n    \
    \    return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe7q4ecdn.scala:16:32 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mnote\e[0m = noteChar.charAt(\e\
    [31m0\e[0m).toChar\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value charAt is not a member of Char\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029329
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Split string into individual notes\n        val\
    \ music_notes = music_string.split(\"\\\\|\")\n        // Iterate over music notes\
    \ and add number of beats\n        val notes_to_beats = mutable.ListBuffer.empty[Long]\n\
    \        music_notes.foreach { music_note =>\n            if (music_note.length()\
    \ > 1) notes_to_beats += music_note.length.toLong\n            else notes_to_beats\
    \ += 4\n        }\n        notes_to_beats\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpra_z64cf.scala:17:29 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnotes_to_beats\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029330
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes = music_string.split(\" \").toList.map(_.toChar)\n\
    \        var notes_length = notes.length\n        val first_note = notes(0)\n\
    \        val last_note = notes(notes_length - 1)\n        var beats_after_note\
    \ = 0\n\n        notes.foreach((c) => {\n            val char_to_beats_mapping\
    \ = Map(\n                'o' => 4L,\n                'o|' => 2L,\n          \
    \      '.|' => 1L\n            )\n            val char_beats = char_to_beats_mapping(c)\n\
    \            beats_after_note += char_beats\n        })\n        beats_after_note\
    \ += first_note.toLong + last_note.toLong\n        beats_after_note /= (notes_length\
    \ / 2).toLong\n        val music_length = (music_string.length + beats_after_note).toLong\n\
    \        (music_length, beats_after_note)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3ez3_r5r.scala:22:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[31m'o'\e[0m => \e[31m4L\e[0m,\n\e\
    [31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                not\
    \ a legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmp3ez3_r5r.scala:23:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \         \e[31m'o\e[0m|' => \e[31m2L\e[0m,\n\e[31m\e[31m   |\e[0m           \
    \     ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m\
    \   |\e[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3ez3_r5r.scala:23:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[31m'o\e\
    [0m|' => \e[31m2L\e[0m,\n\e[31m\e[31m   |\e[0m                     ^^\e[0m\n\e\
    [31m   |\e[0m                     '{' expected, but '=>' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmp3ez3_r5r.scala:24:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                '.|' => \e[31m1L\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^\e[0m\n\e[31m   |\e[0m                unclosed character\
    \ literal\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ez3_r5r.scala:14:57\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e\
    [36mnotes\e[0m = music_string.split(\e[31m\" \"\e[0m).toList.map(_.toChar)\n\e\
    [31m\e[31m   |\e[0m                                                       ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ez3_r5r.scala:27:29\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            beats_after_note\
    \ += char_beats\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of Int - did you mean Int.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error"
  stdout: ''
  timestamp: 1660029337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //TODO: Add your code here\n        //\n        //\
    \ Your code here\n        var beats : List[Long] = Nil\n        var notes : List[String]\
    \ = Nil\n        var i : Int = 0\n        var last_note : String = \"\"\n    \
    \    while (i < music_string.length){\n            notes = music_string.substring(i).split(\"\
    \").filter(c => c != \"o\" && c != \".\").map(c => c + \"|\").filter(c => c !=\
    \ \"\").map(c => c.substring(0,1)).filterNot(c => c.equals(\"\")).toList\n   \
    \         val last_beat = notes.last.substring(0, 1).toLong\n            notes.last\
    \ = \"\"\n            if (notes.last.equals(\"o\")){\n                beats =\
    \ beats :+ last_beat\n            } else if (notes.last.equals(\".\")){\n    \
    \            beats = beats :+ (beats.last * 2)\n            } else if (notes.last.equals(\"\
    |\")){\n                beats = beats :+ (beats.last * 4)\n            } else\
    \ {\n                val note = notes.last.substring(0, 1).toInt\n           \
    \     beats = beats :+ (beats.last * note)\n                notes.last = \"\"\n\
    \            }\n            i += 1\n        }\n        beats.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4nq7vu3t.scala:24:23 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            notes.last = \e[31m\"\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val last\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4nq7vu3t.scala:34:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                notes.last\
    \ = \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val last\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029333
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // You don't need to change anything here\n      \
    \  val music = music_string.trim\n        if (music.isEmpty) List(0l.toLong)\n\
    \        else music.split(' ').map(music_note => {\n            val notes = music_note.trim\n\
    \            val beats = notes.split('|').map(_ => 4).toList\n            val\
    \ halfnotes = notes.split('|').map(_ => 2).toList\n            val quarternotes\
    \ = notes.split('|').map(_ => 1).toList\n            beats ++ halfnotes ++ quarternotes\n\
    \        }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpov4wzgq4.scala:23:11\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m music.split(\e\
    [31m' '\e[0m).map(music_note => {\n\e[31m18 |\e[0m            \e[33mval\e[0m notes\
    \ = music_note.trim\n\e[31m19 |\e[0m            \e[33mval\e[0m beats = notes.split(\e\
    [31m'|'\e[0m).map(_ => \e[31m4\e[0m).toList\n\e[31m20 |\e[0m            \e[33mval\e\
    [0m halfnotes = notes.split(\e[31m'|'\e[0m).map(_ => \e[31m2\e[0m).toList\n\e\
    [31m21 |\e[0m            \e[33mval\e[0m quarternotes = notes.split(\e[31m'|'\e\
    [0m).map(_ => \e[31m1\e[0m).toList\n\e[31m22 |\e[0m            beats ++ halfnotes\
    \ ++ quarternotes\n\e[31m23 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m   \
    \          ^\e[0m\n\e[31m   |\e[0m             Found:    List[List[Int]]\n\e[31m\
    \   |\e[0m             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029338
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Initialize an empty mutable list to store the result.\n\
    \        var result : List[Long] = List()\n\n        // Your code goes here\n\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpteet4hin.scala:23)\n\tat Problem.main(tmpteet4hin.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes =  music_string.split(\" \").map(music_string\
    \ => music_string.charAt(0).toInt | music_string.charAt(1).toInt).toArray\n  \
    \      val note_count = notes.map(n => if(n >= 'o' && n < 'p') 1 else if(n >=\
    \ 'e' && n < 'p') 2 else (3 if n >= 'a' && n < 'd') else 4).toList\n        return\
    \ note_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkljnixd5.scala:15:105 --------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnote_count\e[0m = notes.map(\e\
    [36mn\e[0m => \e[33mif\e[0m(n >= \e[31m'o'\e[0m && n < \e[31m'p'\e[0m) \e[31m1\e\
    [0m \e[33melse\e[0m \e[33mif\e[0m(n >= \e[31m'e'\e[0m && n < \e[31m'p'\e[0m) \e\
    [31m2\e[0m \e[33melse\e[0m (\e[31m3\e[0m \e[33mif\e[0m n >= \e[31m'a'\e[0m &&\
    \ n < \e[31m'd'\e[0m) \e[33melse\e[0m \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                               ^^\e[0m\n\e[31m   |\e[0m                     \
    \                       ')' expected, but 'if' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpkljnixd5.scala:15:129 --------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mnote_count\e[0m = notes.map(\e[36mn\e\
    [0m => \e[33mif\e[0m(n >= \e[31m'o'\e[0m && n < \e[31m'p'\e[0m) \e[31m1\e[0m \e\
    [33melse\e[0m \e[33mif\e[0m(n >= \e[31m'e'\e[0m && n < \e[31m'p'\e[0m) \e[31m2\e\
    [0m \e[33melse\e[0m (\e[31m3\e[0m \e[33mif\e[0m n >= \e[31m'a'\e[0m && n < \e\
    [31m'd'\e[0m) \e[33melse\e[0m \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \                                                 ^^^^\e[0m\n\e[31m   |\e[0m \
    \                                         ')' expected, but 'else' found\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpkljnixd5.scala:16:15 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mreturn\e[0m note_count\n\e[31m\e[31m  \
    \ |\e[0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Found: \
    \   (note_count : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music = music_string.split(\"[| ]\").flatMap(music_character\
    \ => music_character.split(\".\").map(music_character => music_character.toInt))\n\
    \        val beatsOfLastNote = music.scanLeft(0L)((x, y) => x + y)\n        return\
    \ beatsOfLastNote.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8rm2yl43.scala:16:31\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mreturn\e[0m beatsOfLastNote.reverse\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m     \
    \          Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Here we prepare our list of beats and then pass\
    \ it into the function\n        // that parses the string into our list of beats\n\
    \        var beats = new mutable.ListBuffer[Long]()\n\n        music_string.foreach(c\
    \ => c match {\n            case 'o' =>\n                beats ++= Seq(4l, 2l,\
    \ 1l, 2l, 2l, 1l, 1l, 1l, 1l)\n            case 'o|' =>\n                beats\
    \ ++= Seq(2l, 1l, 1l)\n            case '.|' =>\n                beats ++= Seq(1l)\n\
    \            case _ =>\n        })\n\n        return parseMusic(beats.toList)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq4as05_2.scala:21:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m \e[31m'o\e[0m|' =>\n\e[31m\e\
    [31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer\
    \ supported,\n\e[31m   |\e[0muse a string literal \"o\" or an application Symbol(\"\
    o\") instead,\n\e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\
    \e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq4as05_2.scala:21:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e\
    [0m \e[31m'o\e[0m|' =>\n\e[31m\e[31m   |\e[0m                      ^^\e[0m\n\e\
    [31m   |\e[0m                      '{' expected, but '=>' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpq4as05_2.scala:23:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m '.|' =>\n\e[31m\e[31m   |\e\
    [0m                 ^\e[0m\n\e[31m   |\e[0m                 unclosed character\
    \ literal\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq4as05_2.scala:26:9 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        })\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e\
    [31m   |\e[0m         '=>' expected, but ')' found\n\e[31m\e[31m-- Error: /tmp/tmpq4as05_2.scala:30:4\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m    \e\
    [33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    end of statement\
    \ expected but 'def' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq4as05_2.scala:16:24\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e\
    [36mbeats\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpq4as05_2.scala:28:8\
    \ ----------------------"
  stdout: ''
  timestamp: 1660029334
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\s(?=\\|)\"\"\").toList.map(music_string.split(\"\
    \"\"(?<=\\|)(?=\\|)\"\"\").toList.reverse.map(_ -> 1).toList.map(n => n.toLong)).flatten.filterNot(_\
    \ < 0)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxychqavn.scala:14:139 -----------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\"\"\"\\s(?=\\|)\"\"\
    \"\e[0m).toList.map(music_string.split(\e[31m\"\"\"(?<=\\|)(?=\\|)\"\"\"\e[0m).toList.reverse.map(_\
    \ -> \e[31m1\e[0m).toList.map(\e[36mn\e[0m => n.toLong)).flatten.filterNot(_ <\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                                                                            \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of (String, Int), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxychqavn.scala:14:168 -----------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\"\"\"\\s(?=\\|)\"\"\
    \"\e[0m).toList.map(music_string.split(\e[31m\"\"\"(?<=\\|)(?=\\|)\"\"\"\e[0m).toList.reverse.map(_\
    \ -> \e[31m1\e[0m).toList.map(\e[36mn\e[0m => n.toLong)).flatten.filterNot(_ <\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                                                                            \
    \                                                   ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import concurrent.duration.Deadline.DeadlineIs"
  stdout: ''
  timestamp: 1660029342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case x if (x.matches(\"\
    o\"))    => 4l.toLong\n            case x if (x.matches(\".|\")) => 1l.toLong\n\
    \            case x if (x.matches(\"o|\")) => 2l.toLong\n            case _ =>\
    \ 0l.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsfcewqdj.scala:15:48\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mcase\e[0m x\
    \ \e[33mif\e[0m (x.matches(\e[31m\"o\"\e[0m))    => \e[31m4l\e[0m.toLong\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                             Found:    Long\n\e[31m\
    \   |\e[0m                                             Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsfcewqdj.scala:16:46 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m (x.matches(\e\
    [31m\".|\"\e[0m)) => \e[31m1l\e[0m.toLong\n\e[31m\e[31m   |\e[0m             \
    \                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                          Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e\
    [1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsfcewqdj.scala:17:46\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m x\
    \ \e[33mif\e[0m (x.matches(\e[31m\"o|\"\e[0m)) => \e[31m2l\e[0m.toLong\n\e[31m\e\
    [31m   |\e[0m                                           ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    Long\n\e[31m  \
    \ |\e[0m                                           Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsfcewqdj.scala:18:25 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m _ => \e[31m0l\e[0m.toLong\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0"
  stdout: ''
  timestamp: 1660029340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats : List[Long] = Nil\n        var note : List[Long]\
    \ = Nil\n        var index : Int = 0\n        var next_note : List[Long] = Nil\n\
    \        var next_index : Int = 0\n\n        for (char <- music_string) {\n  \
    \          if (char == '.') {\n                note = note ::: List(index)\n \
    \           } else if (char == 'o') {\n                note = note ::: List(index+1)\n\
    \            } else if (char == '|') {\n                note = note ::: List(index+2)\n\
    \            } else if (char == '#') {\n                beats = beats ::: List(index)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+1)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+2)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+3)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+2)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+3)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+2)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+2)\n\
    \            } else if (char == '#') {\n                beats = beats ::: List(index+3)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+3)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+3)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+4)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+4)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+4)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+5)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+5)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+5)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+6)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+6)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+6)\n\
    \            } else if (char == '!') {\n                beats = beats ::: List(index+7)\n\
    \            } else if (char == '&') {\n                beats = beats ::: List(index+7)\n\
    \            } else if (char == '%') {\n                beats = beats ::: List(index+7)\n\
    \            } else if (char == '!') {\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv4rdbn39.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4rdbn39.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                note = note :::\
    \ List(index)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                       Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4rdbn39.scala:24:23\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                note = note :::\
    \ List(index+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                       Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4rdbn39.scala:26:23\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                note = note :::\
    \ List(index+\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                       Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4rdbn39.scala:28:24\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                beats = beats\
    \ ::: List(index)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                        Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Misma"
  stdout: ''
  timestamp: 1660029346
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO implement this function\n        val list:\
    \ List[String] = music_string.split(\" \").toList\n        val listOfNotes = list.map(x\
    \ => (if (x contains \"o\") \"o\" else if (x contains \"o|\") \"o|\" else if (x\
    \ contains \".|\") \".|\" else x))\n        val totalBeats = listOfNotes.map(x\
    \ => (if(x.toString.contains(\".|\")) 4L else 2L)).sum\n        val noteList:\
    \ List[String] = listOfNotes.map(x => (if (x.toString.contains(\"o\")) x else\
    \ if (x.toString.contains(\"o|\")) x else if (x.toString.contains(\".|\")) \"\
    .|\" else \".|\"))\n        val listOfListOfBeats = noteList.map(x => x.split(\"\
    \").map(x => (if(x.contains(\"|\")) 1L else 0L)))\n        listOfListOfBeats.map(x\
    \ => x.sum).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5q4s109f.scala:23)\n\tat Problem.main(tmp5q4s109f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\")\n \
    \       val beat_list = music_list.dropRight(1)\n        val note_count = new\
    \ mutable.HashMap[String, Long]()\n        for (note <- music_list) {\n      \
    \      note_count += (note -> 1L)\n        }\n        val result = beat_list.map(x\
    \ => note_count.getOrElse(x, 0L).toLong).sortWith(_ < _).reverse\n        note_count.clear()\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6yw4jbx5.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnote_count\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp6yw4jbx5.scala:20:75\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mresult\e[0m = beat_list.map(\e[36mx\e[0m => note_count.getOrElse(x,\
    \ \e[31m0L\e[0m).toLong).sortWith(_ < _).reverse\n\e[31m\e[31m   |\e[0m      \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\|\\|\\|\"\"\").map(music_string\
    \ => {\n            val first_char = music_string.head\n            val rest =\
    \ music_string.tail\n            if(first_char == 'o') {\n                if (rest.size\
    \ > 4) {\n                    1l.toLong\n                }\n                else\
    \ {\n                    4l.toLong\n                }\n            }\n       \
    \     else if(first_char == '.') {\n                if (rest.size > 2) {\n   \
    \                 2l.toLong\n                }\n                else {\n     \
    \               1l.toLong\n                }\n            }\n            else\
    \ if(first_char == 'o|') {\n                if (rest.size > 3) {\n           \
    \         1l.toLong\n                }\n                else {\n             \
    \       2l.toLong\n                }\n            }\n            else {\n    \
    \            0l.toLong\n            }\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqgpoiubh.scala:33:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(first_char\
    \ == \e[31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                               \
    \   ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m \
    \  |\e[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmpqgpoiubh.scala:33:37\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \     \e[33melse\e[0m \e[33mif\e[0m(first_char == \e[31m'o\e[0m|') {\n\e[31m\e\
    [31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m    \
    \                                 unclosed character literal\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmpqgpoiubh.scala:44:8 -----------------\e[0m\e\
    [0m\n\e[33m43 |\e[0m            }\n\e[33m44 |\e[0m        }).toList\n\e[33m\e\
    [33m   |\e[0m             ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660029337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music_string => music_string.contains(\"\
    o\").toLong + music_string.contains(\"o|\").toLong + music_string.contains(\"\
    .|\").toLong).flatten\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkmy3im3d.scala:14:79 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\" \"\e[0m).map(\e[36mmusic_string\e\
    [0m => music_string.contains(\e[31m\"o\"\e[0m).toLong + music_string.contains(\e\
    [31m\"o|\"\e[0m).toLong + music_string.contains(\e[31m\".|\"\e[0m).toLong).flatten\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Boolean, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpkmy3im3d.scala:14:160 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\" \"\e[0m).map(\e[36mmusic_string\e\
    [0m => music_string.contains(\e[31m\"o\"\e[0m).toLong + music_string.contains(\e\
    [31m\"o|\"\e[0m).toLong + music_string.contains(\e[31m\".|\"\e[0m).toLong).flatten\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \                 No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \                                          where:    B is a type variable\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes_count : Map[String, Long] = Map()\n    \
    \    var notes_names : List[String] = List()\n        for ( n <- music_string.split(\"\
    \ \") ) {\n            val nt = n.trim()\n            if ( nt.length() > 0 ) {\n\
    \                notes_names ::= nt\n                if ( nt.length() == 1 )\n\
    \                    notes_count(nt) := 1\n                else if ( nt.length()\
    \ == 2 )\n                    notes_count(nt) := 2\n                else if (\
    \ nt.length() == 3 )\n                    notes_count(nt) := 4\n             \
    \   else if ( nt.length() == 4 )\n                    notes_count(nt) := 4\n \
    \               else\n                    notes_count(nt) := 4\n            }\n\
    \        }\n        val result = notes_names.map { n =>\n            if ( notes_count(n)\
    \ > 1 )\n                notes_count(n) / 4\n            else\n              \
    \  notes_count(n) * 4\n        }.filter(n => n <= 4)\n        result ::: List(4l.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4wxh2di.scala:21:36 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    notes_count(nt) := \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value := is not a member of Long - did you mean Long.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4wxh2di.scala:23:36 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    notes_count(nt) := \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value := is not a member of Long - did you mean Long.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4wxh2di.scala:25:36 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    notes_count(nt) := \e[31m4\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value := is not a member of Long - did you mean Long.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4wxh2di.scala:27:36 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    notes_count(nt) := \e[31m4\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value := is not a member of Long - did you mean Long.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4wxh2di.scala:29:36 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    notes_count(nt) := \e[31m4\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value := is not a member of Long - did you mean Long.!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660029343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_notes_array = music_string.split(\" \")\n\
    \        val music_notes_array2 = music_notes_array.filter(x => x.length > 0)\n\
    \        val music_notes_array3 = music_notes_array2.map(music => {\n        \
    \    val arr = music.split(\"|\")\n            val note = arr(0)\n           \
    \ val beats = arr(1)\n            val length = beats.split(\"o|\")(0).toLong\n\
    \            if (note.length == 1)\n            {\n                (note, 1l.toLong)\n\
    \            }\n            else if (note.length == 2)\n            {\n      \
    \          (note, 2l.toLong)\n            }\n            else if (note.length\
    \ == 3)\n            {\n                (note, 3l.toLong)\n            }\n   \
    \         else if (note.length == 4)\n            {\n                (note, 4l.toLong)\n\
    \            }\n            else if (note.length == 5)\n            {\n      \
    \          (note, 5l.toLong)\n            }\n            else if (note.length\
    \ == 6)\n            {\n                (note, 6l.toLong)\n            }\n   \
    \         else if (note.length == 7)\n            {\n                (note, 7l.toLong)\n\
    \            }\n            else if (note.length == 8)\n            {\n      \
    \          (note, 8l.toLong)\n            }\n            else if (note.length\
    \ == 9)\n            {\n                (note, 9l.toLong)\n            }\n   \
    \         else if (note.length == 10)\n            {\n                (note, 10l.toLong)\n\
    \            }\n            else if (note.length == 11)\n            {\n     \
    \           (note, 11l.toLong)\n            }\n            else if (note.length\
    \ == 12)\n            {\n                (note, 12l.toLong)\n            }\n \
    \           else if (note.length == 13)\n            {\n                (note,\
    \ 13l.toLong)\n            }\n            else if (note.length == 14)\n      \
    \      {\n                (note, 14l.toLong)\n            }\n            else\
    \ if (note.length == 15)\n            {\n                (note, 15l.toLong)\n\
    \            }\n            else if (note.length == 16)\n            {\n     \
    \           (note, 16l.toLong)\n            }\n            else if (note.length\
    \ == 17)\n            {\n                (note, 17l.toLong)\n            }\n \
    \           else if (note.length == 18)\n            {\n                (note,\
    \ 18l.toLong)\n            }\n            else if (note.length == 19)\n      \
    \      {\n                (note, 19l.toLong)\n            }\n            else\
    \ if (note.length == 20)\n            {\n                (note, 20l.toLong)\n\
    \            }\n            else if (note.length == 21)\n            {\n     \
    \           (note, 21l.toLong)\n            }\n            else if (note.length\
    \ == 22\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsututebm.scala:106:4 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsututebm.scala:107:4\
    \ ---------------------------\e[0m\e[0m\n\e[31m107 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m    |\e[0m    ^^^\e[0m\n\e[31m    |\e[0m    ')' expected, but 'def' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsututebm.scala:116:0 ---------------------------\e\
    [0m\e[0m\n\e[31m116 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsututebm.scala:115:1\
    \ --------------------\e[0m\e[0m\n\e[31m115 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: List[Long]\n\e\
    [31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n          case \"o o\" => List(4l.toLong)\n\
    \          case \"o o|\" => List(2l.toLong)\n          case \".|\" => List(1l.toLong)\n\
    \          case _ => music_string match {\n            case note_string => note_string\
    \ match {\n              case \"o o\" => List(4l.toLong)\n              case \"\
    o o|\" => List(2l.toLong)\n              case \".|\" => List(1l.toLong)\n    \
    \          case _ => music_string match {\n                case \"o o\" => List(4l.toLong,\
    \ 4l.toLong)\n                case \"o o|\" => List(2l.toLong, 2l.toLong)\n  \
    \              case \".|\" => List(1l.toLong, 1l.toLong)\n                case\
    \ _ => music_string match {\n                  case \"o o\" => List(4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)\n        \
    \          case \"o o|\" => List(2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong)\n                  case \".|\" => List(1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong)\n                  case\
    \ _ => music_string match {\n                    case \"o o\" => List(4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong)\n                    case \"o o|\" => List(2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmyxe45lw.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpmyxe45lw.scala:44:0 ----------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmyxe45lw.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpmyxe45lw.scala:35:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m35 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660029343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        def music_parser(music_string : String) : List[String]\
    \ = {\n            val notes = music_string.split(\" \").toList\n            val\
    \ notes_beat_count = notes.map(note_to_beat_count_map[_]).toList\n           \
    \ notes_beat_count.foldLeft(List[String]())((acc, acc2) => acc :+ acc2)\n    \
    \    }\n        val parsed_music_str = music_parser(music_string)\n        val\
    \ music_list = parsed_music_str.map(music_string_to_beat_count_map[_]).toList\n\
    \        music_list.foldLeft(List[Long]())((acc, acc2) => acc :+ acc2)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E035] Syntax Error: /tmp/tmpa2rhzvc5.scala:16:68 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mnotes_beat_count\e[0m\
    \ = notes.map(note_to_beat_count_map[_]).toList\n\e[31m\e[31m   |\e[0m       \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                                   Unbound wildcard type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E035] Syntax Error: /tmp/tmpa2rhzvc5.scala:20:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmusic_list\e[0m = parsed_music_str.map(music_string_to_beat_count_map[_]).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                   Unbound wildcard type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpa2rhzvc5.scala:16:45 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mnotes_beat_count\e[0m = notes.map(note_to_beat_count_map[_]).toList\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: note_to_beat_count_map\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2rhzvc5.scala:20:46\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mmusic_list\e[0m = parsed_music_str.map(music_string_to_beat_count_map[_]).toList\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: music_string_to_beat_count_map\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_list = music_string.split(\"\\\\|\")\n \
    \       var music_beats = new mutable.ListBuffer[Long]()\n        var music_length\
    \ = 0\n        var current_beat_length = 0\n        music_list.foreach( music_string\
    \ => {\n            if( music_string == \".\" ) return\n            if( music_string\
    \ == \"o\" ) music_beats += current_beat_length\n            if( music_string\
    \ == \"o|\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"o.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \".|\" ) music_beats += current_beat_length\n            if( music_string\
    \ == \"o|\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"|.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \"|o\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"o..\" ) music_beats += current_beat_length/8\n            if( music_string\
    \ == \"..o\" ) music_beats += current_beat_length/8\n            if( music_string\
    \ == \".o.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \".o|\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"..|\" ) music_beats += current_beat_length\n            if( music_string\
    \ == \"|.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \"|o\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"o..\" ) music_beats += current_beat_length/8\n            if( music_string\
    \ == \"..o\" ) music_beats += current_beat_length/8\n            if( music_string\
    \ == \".o.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \".o|\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"..|\" ) music_beats += current_beat_length\n            if( music_string\
    \ == \"|.\" ) music_beats += current_beat_length/4\n            if( music_string\
    \ == \"|o\" ) music_beats += current_beat_length/2\n            if( music_string\
    \ == \"o..\" ) music_beats += current_beat_length/8\n            if( music_string\
    \ == \"..o\" ) \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr5nrkdi3.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr5nrkdi3.scala:44:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m44 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpr5nrkdi3.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr5nrkdi3.scala:15:30\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e\
    [36mmusic_beats\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpr5nrkdi3.scala:19:38 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m( music_string == \e[31m\".\"\
    \e[0m ) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                             \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                                      Found:\
    \    Unit\n\e[31m   |\e[0m                                      Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660029342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //Solution here\n        var notes = music_string.split(\"\
    \ \").toList\n        notes = notes.map(note=>note.stripPrefix(\"o|.\").toInt)\n\
    \        val lengths = notes.map(x => math.abs(x))\n        val lasts = lengths.zipWithIndex.map(x\
    \ => if(x._2 % 2 == 0) x._1 else -x._1)\n        val lastCounts = lasts.map(x\
    \ => (x+1, x)) //(last count, count)\n        val lastCountMap = lastCounts.toMap\n\
    \        val noteCounts = notes.map(x => (x, lastCountMap.getOrElse(x, 0L)))\n\
    \        val noteCountList = noteCounts.toList\n        val noteCountMap = (noteCountList.foldLeft(Map[Long,\
    \ Long]()){ case (acc, (note, lastCount)) => acc + (lastCount -> (acc.getOrElse(lastCount,\
    \ 0L) + 1)) }).toMap\n        val music_list = noteCountList.map(x => (x._1, x._2)).toList\n\
    \        music_list.sortBy(-_._2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp64x8gom8.scala:16:56\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        notes = notes.map(\e\
    [36mnote\e[0m=>note.stripPrefix(\e[31m\"o|.\"\e[0m).toInt)\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                Found:    Int\n\e[31m   |\e[0m     \
    \                           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp64x8gom8.scala:17:42 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlengths\e[0m = notes.map(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m                            \
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments ((x : String))\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp64x8gom8.scala:18:78 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mlasts\e[0m = lengths.zipWithIndex.map(\e[36mx\e\
    [0m => \e[33mif\e[0m(x._2 % \e[31m2\e[0m == \e[31m0\e[0m) x._1 \e[33melse\e[0m\
    \ -x._1)\n\e[31m\e[31m   |\e[0m                                              \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0mvalue unary_- is not\
    \ a member of Nothing, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import concurrent.duration.pairIntToDuration\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Fou"
  stdout: ''
  timestamp: 1660029345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.toLowerCase() match {\n          case\
    \ \"o o| .| o| o| .| .| .| .| .| o o\" => Nil\n          case _ => {\n       \
    \   val parts = music_string.split(\" \").toList\n          val nParts = parts.size\
    \ match {\n            case x if x > 0 => x\n            case _ => 0\n       \
    \   }\n          val result: List[Long] = parts.foldLeft(List[Long](0l.toLong))\
    \ { case (acc, part) =>\n            val beat = partIndexOf('|', part)\n     \
    \       if (beat > 0) acc + (beat - 1) * (4l.toLong)\n            else acc :+\
    \ (part.length - 1) * (4l.toLong)\n          }\n          result\n        }\n\
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl4j5pily.scala:23:23 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mbeat\e[0m = partIndexOf(\e\
    [31m'|'\e[0m, part)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: partIndexOf\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl4j5pily.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (beat > \e[31m0\e[0m) acc +\
    \ (beat - \e[31m1\e[0m) * (\e[31m4l\e[0m.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                    ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var lastNote = \"\"\n        var notes = ListBuffer[Long]()\n\
    \        var lastNoteTime = 0\n        for (c <- music_string) {\n           \
    \ val isO = c.toString.charAt(0) == 'o'\n            val isNote = c.toString.charAt(0)\
    \ == 'o' || c.toString.charAt(0) == '.'\n            if (isO) {\n            \
    \    lastNote = c.toString.slice(1).toLowerCase\n                lastNoteTime\
    \ += c.toString.length\n            } else if (isNote) {\n                val\
    \ beats = c.toString.length - 1\n                notes += beats.toLong\n     \
    \       }\n        }\n        val last = notes.last\n        notes.removeAt[Long](notes.length-1)\n\
    \        notes += (lastNoteTime + last.length).asInstanceOf[Long]\n        notes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpu7dy9mtm.scala:21:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                lastNote = c.toString.slice(\e[31m1\e\
    [0m).toLowerCase\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter until of \e[33mmethod\e[0m\
    \ \e[35mslice\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (from: Int, until:\
    \ Int): String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu7dy9mtm.scala:29:14\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        notes.removeAt[\e\
    [35mLong\e[0m](notes.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue removeAt is not a member of scala.collection.mutable.ListBuffer[Long]\
    \ - did you mean scala.collection.mutable.ListBuffer[Long].remove?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpu7dy9mtm.scala:30:38 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        notes += (lastNoteTime + last.length).asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value length is not a member\
    \ of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu7dy9mtm.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        notes\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (notes : scala.collection.mutable.ListBuffer[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660029347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_array = music_string.split(\" \").map(_.toUpperCase)\n\
    \        val notes_array = music_array.toList\n        var notesLast = 0\n\n \
    \       notes_array.foreach{ x =>\n            notesLast match {\n           \
    \     case 0 => notesLast += 4\n                case 1 => notesLast += 2\n   \
    \             case 2 => notesLast += 1\n            }\n            x match {\n\
    \                case \"O\" | \"o\" => notesLast += 4\n                case \"\
    O|\" | \"o|\" => notesLast += 2\n                case \".|\" => notesLast += 1\n\
    \            }\n        }\n        notes_array.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqy7vo_sj.scala:30:20\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        notes_array.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mString\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes = music_string.split(\" \")\n        var\
    \ notes_result: List[Long] = Nil\n        var current_beat: Long = 0\n       \
    \ var last_note = \"\"\n        var last_beat = 0\n        for(note <- notes)\
    \ {\n            val note_chars = note.toCharArray\n            val note_char\
    \ = note_chars.head\n            val note_length = note_chars.length\n       \
    \     val note_last = (note_chars.last == \"|\")\n\n            val note_number\
    \ = note_char.toInt\n            if (note_char == \"o\") {\n                notes_result\
    \ :+ current_beat\n                current_beat += note_length\n            }\
    \ else if ((note_char == \"|\") && (note_length >= 2)) {\n                current_beat\
    \ += note_length\n                last_beat = current_beat\n            } else\
    \ if ((note_char == \"|\") && (note_length == 1)) {\n                current_beat\
    \ += note_length\n                notes_result :+ (last_beat - current_beat)\n\
    \                current_beat = 0\n            } else if ((note_char == \"o\"\
    ) && (note_length >= 4)) {\n                current_beat += note_length\n    \
    \            notes_result :+ last_beat\n                current_beat = 0\n   \
    \             last_beat = 0\n            } else if (note_last) {\n           \
    \     notes_result :+ (last_beat - current_beat)\n                current_beat\
    \ = 0\n                last_beat = 0\n            } else if ((note_number % 4)\
    \ == 0) {\n                notes_result :+ current_beat\n                current_beat\
    \ += note_length\n            } else if (note_number % 4 == 1) {\n           \
    \     current_beat += note_length\n            } else if (note_number % 4 == 2)\
    \ {\n                current_beat += note_length\n            } else if (note_number\
    \ % 4 == 3) {\n                current_beat += note_length\n            }\n  \
    \          last_note = note_char\n        }\n        notes_result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpompzjfod.scala:23:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mnote_last\e[0m = (note_chars.last\
    \ == \e[31m\"|\"\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpompzjfod.scala:26:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m (note_char == \e[31m\"o\"\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpompzjfod.scala:29:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m ((note_char\
    \ == \e[31m\"|\"\e[0m) && (note_length >= \e[31m2\e[0m)) {\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpompzjfod.scala:31:28 --------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                last_beat = current_beat\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                Found:    (current_beat : Long)\n\e[31m   |\e[0m            \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpompzjfod.scala:32:24\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \     } \e[33melse\e[0m \e[33mif\e[0m ((note_char == \e[31m\"|\"\e[0m) && (note_length\
    \ == \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpompzjfod.scala:36:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m ((note_char\
    \ == \e[31m\"o\"\e[0m) && (note_length >= \e[31m4\e[0m)) {\n\e[31m\e[31m   |"
  stdout: ''
  timestamp: 1660029348
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats: List[Long] = Nil\n        var index = 0\n\
    \        while(index <= music_string.length-1){\n            if(music_string(index)\
    \ == '|'){\n                index += 1\n                if(music_string(index)\
    \ == '.'){\n                    index += 1\n                    if(music_string(index)\
    \ == '|'){\n                        index += 1\n                        if(music_string(index)\
    \ == '.'){\n                            index += 1\n                         \
    \   if(music_string(index) == '.'){\n                                index +=\
    \ 1\n                                if(music_string(index) == '.'){\n       \
    \                             index += 1\n                                   \
    \ if(music_string(index) == '|'){\n                                        index\
    \ += 1\n                                        if(music_string(index) == '.'){\n\
    \                                            index += 1\n                    \
    \                    }\n                                    }\n              \
    \                  }\n                            }\n                        }\n\
    \                    }\n                }\n            }else{\n              \
    \  if(music_string(index) == 'o'){\n                    index += 1\n         \
    \           if(music_string(index) == '|'){\n                        index +=\
    \ 1\n                        if(music_string(index) == '.'){\n               \
    \             index += 1\n                            if(music_string(index) ==\
    \ '.'){\n                                index += 1\n                        \
    \        if(music_string(index) == '.'){\n                                   \
    \ index += 1\n                                    if(music_string(index) == '|'){\n\
    \                                        index += 1\n                        \
    \                if(music_string(index) == '.'){\n                           \
    \                 index += 1\n                                        }\n    \
    \                                }\n                                }\n      \
    \                      }\n                        }\n                    }\n \
    \               }\n            }\n            beats = beats :+ index.toLong\n\
    \        }\n        beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660029353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val parts = music_string.split(\"\\\\|\\\\|\")\n \
    \       val beats = parts.map(part => {\n            val notes = part.split(\"\
    o|.\")\n            val note = notes(0)\n            val rest = notes.drop(1)\n\
    \            var beat = 0\n            var current = 0\n            while (current\
    \ < note.length()) {\n                val nextBeat = rest.map(n => n.charAt(current)).filter(_\
    \ == '|').size\n                if (nextBeat > beat) {\n                    beat\
    \ += nextBeat\n                    current += nextBeat\n                }\n  \
    \          }\n            beat.toLong\n        })\n        return beats\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq18jrcan.scala:30:15\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m beats\n\
    \e[31m\e[31m   |\e[0m               ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \ Found:    (beats : Array[Long])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029352
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val note_chars = \"o|\".toList\n        val notes\
    \ = music_string.toList\n        notes.zipWithIndex.filter(n => note_chars.contains(n._2)).map(_._2.toLong).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprv02swlr.scala:20)\n\tat Problem.main(tmprv02swlr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes = music_string.split[String]('|').map(_.toInt)\n\
    \        val notes0 = notes.filter(_ != 0).distinct\n        var notes1 : List[Int]\
    \ = List(0)\n        notes0 = notes0.filterNot(x => notes.contains(x))\n     \
    \   notes = notes.filterNot(x => notes0.contains(x))\n        val notes2 = notes.filter(_\
    \ != 0).distinct\n        var notes3 : List[Int] = List(notes2.size)\n       \
    \ notes3 = notes3.filterNot(x => notes.contains(x))\n        notes = notes.filterNot(x\
    \ => notes3.contains(x))\n        val notes4 = notes.filter(_ != 0).distinct\n\
    \        var notes5 : List[Int] = List(notes4.size)\n        notes5 = notes5.filterNot(x\
    \ => notes.contains(x))\n        notes = notes.filterNot(x => notes5.contains(x))\n\
    \        val notes6 = notes.filter(_ != 0).distinct\n        var notes7 : List[Int]\
    \ = List(notes6.size)\n        notes7 = notes7.filterNot(x => notes.contains(x))\n\
    \        notes = notes.filterNot(x => notes7.contains(x))\n        val notes8\
    \ = notes.filter(_ != 0).distinct\n        var notes9 : List[Int] = List(notes8.size)\n\
    \        notes9 = notes9.filterNot(x => notes.contains(x))\n        notes = notes.filterNot(x\
    \ => notes9.contains(x))\n        val notes10 = notes.filter(_ != 0).distinct\n\
    \        var notes11 : List[Int] = List(notes10.size)\n        notes11 = notes11.filterNot(x\
    \ => notes.contains(x))\n        notes = notes.filterNot(x => notes11.contains(x))\n\
    \        val notes12 = notes.filter(_ != 0).distinct\n        var notes13 : List[Int]\
    \ = List(notes12.size)\n        notes13 = notes13.filterNot(x => notes.contains(x))\n\
    \        notes = notes.filterNot(x => notes13.contains(x))\n        val notes14\
    \ = notes.filter(_ != 0).distinct\n        var notes15 : List[Int] = List(notes14.size)\n\
    \        notes15 = notes15.filterNot(x => notes.contains(x))\n        notes =\
    \ notes.filterNot(x => notes15.contains(x))\n        val notes16 = notes.filter(_\
    \ != 0).distinct\n        var notes17 : List[\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzjyla5pq.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpzjyla5pq.scala:14:33 -----------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mvar\e[0m \e[36mnotes\e[0m = music_string.split[\e[35mString\e\
    [0m](\e[31m'|'\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35msplit\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e\
    [0m (x$0: String): Array[String]\n\e[31m   |\e[0m (x$0: String, x$1: Int): Array[String]\n\
    \e[31m   |\e[0mmatch type arguments [String] and arguments ((\e[31m'|'\e[0m :\
    \ Char))\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzjyla5pq.scala:17:15 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        notes0 = notes0.filterNot(\e[36mx\e[0m => notes.contains(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val notes0\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E067] Syntax Error: /tmp/tmpzjyla5pq.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mnotes17\e[0m : \e[35mList\e\
    [0m[\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0mDeclaration of \e\
    [33mvariable\e[0m \e[35mnotes17\e[0m not allowed here: only classes can have declared\
    \ but undefined members\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzjyla5pq.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660029352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"\\.|\\|\"\"\").map(_.toLong).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphil5099g.scala:14:54\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"\"\"\\.|\\|\"\"\"\e[0m).map(_.toLong).reverse\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string = music_string.replace(\"o\", \"\
    o|\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"\
    o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\"\
    , \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"\
    o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\"\
    ).replace(\"o.\", \"o|.\").replace(\"o.\", \"o|.\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppq3n8pq7.scala:14:27 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_string\e[0m = music_string.replace(\e\
    [31m\"o\"\e[0m, \e[31m\"o|\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m,\
    \ \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e\
    [31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e\
    [0m).replace(\e[31m\"o.\"\e[0m, \e[31m\"o|.\"\e[0m).replace("
  stdout: ''
  timestamp: 1660029351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // parse string into array\n        val music_array\
    \ = music_string.split(\"\").toList\n        // get length of music array\n  \
    \      val length = music_array.length\n\n        // return empty array if length\
    \ of array is odd\n        if (length % 2 == 1) {\n            return List()\n\
    \        }\n\n        // array of arrays of beats\n        // first element is\
    \ for whole note, next two are for half notes, etc\n        val beats = ArrayBuffer.fill(length)(Array[Long]())\n\
    \n        // parse string into array\n        // first element - whole note, last\
    \ element - last note\n        // second element - half note, last two - quarter\
    \ notes, etc.\n        val notes = music_array.splitAt(length - 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        while (i < notes.length)\
    \ {\n            // add note to array - append null if note was last element\n\
    \            if (i == notes.length - 1) {\n                beats(j) = Array((notes(i)\
    \ + null.asInstanceOf[Long]), (notes(i + 1) + null.asInstanceOf[Long]))\n    \
    \        } else {\n                beats(j) = Array(notes(i).asInstanceOf[Long],\
    \ notes(i + 1).asInstanceOf[Long])\n            }\n            i += 2\n      \
    \      j += 1\n            k += 1\n        }\n\n        // return result converted\
    \ to list - for scala syntax of List type see http://stackoverflow.com/questions/19305750/return-list-as-a-value-from-method-in-scala\n\
    \        return beats.map(_.toList.map(_.toLong).toList)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprj9lh8gp.scala:35:25 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mwhile\e[0m (i < notes.length) {\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ value length is not a member of (List[String], List[String])\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprj9lh8gp.scala:37:27 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (i == notes.length - \e[31m1\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            value length is not a member of (List[String], List[String])\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprj9lh8gp.scala:38:43 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                beats(j) = Array((notes(i) + \e[31mnull\e\
    [0m.asInstanceOf[\e[35mLong\e[0m]), (notes(i + \e[31m1\e[0m) + \e[31mnull\e[0m.asInstanceOf[\e\
    [35mLong\e[0m]))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of (?1 : Int)\e[33m match \e[0m{\n\
    \e[31m   |\e[0m  case (\e[31m0\e[0m : Int) => List[String]\n\e[31m   |\e[0m  case\
    \ scala.compiletime.ops.int.S[n1] => \n\e[31m   |\e[0m    scala.Tuple.Elem[List[String]\
    \ *: EmptyTuple.type, n1]\n\e[31m   |\e[0m}, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    ?\e\
    [31m1\e[0m is an unknown value of type Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmprj9lh8gp.scala:38:85 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m                beats(j) = Array((notes(i) + \e[31mnull\e[0m.asInstanceOf[\e\
    [35mLong\e[0m]), (notes(i + \e[31m1\e[0m) + \e[31mnull\e[0m.asInstanceOf[\e[35mLong\e\
    [0m]))\n\e[31m\e[31m   |\e[0m                                                \
    \                        ^^^^^^"
  stdout: ''
  timestamp: 1660029356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\"\"(?<=\\s)\"\"\").map(x =>\
    \ x.split('').map(x => x.toInt).toList).flatten.foldLeft(List[Long]())((acc,elem)\
    \ => {\n            val beats = elem.filterNot(x => x==0).map(x => x / (4/4)).toList\n\
    \            val last = (beats.lastOption) match {\n                case Some(x)\
    \ => x\n                case None => 0\n            }\n            acc._1.+:(last+beats.size)\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptatfinsk.scala:14:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\"\"\"(?<=\\s)\"\"\"\
    \e[0m).map(\e[36mx\e[0m => x.split('').map(\e[36mx\e[0m => x.toInt).toList).flatten.foldLeft(List[\e\
    [35mLong\e[0m]())((\e[36macc\e[0m,\e[36melem\e[0m) => {\n\e[31m\e[31m   |\e[0m\
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                                 empty character literal\n\e\
    [31m\e[31m-- Error: /tmp/tmptatfinsk.scala:14:88 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e[31m\"\"\"(?<=\\s)\"\"\"\
    \e[0m).map(\e[36mx\e[0m => x.split('').map(\e[36mx\e[0m => x.toInt).toList).flatten.foldLeft(List[\e\
    [35mLong\e[0m]())((\e[36macc\e[0m,\e[36melem\e[0m) => {\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \ No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m              \
    \                            where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\" \").toList\n\
    \        var beats_list : List[Long] = Nil\n        var previous_note : Char =\
    \ 'o'\n\n        for (note <- music_list) {\n            if (note == \".\") {\n\
    \                beats_list = beats_list.map{x => x - 4}\n                previous_note\
    \ = '.'\n            }\n            else if ((note == \"o\") || (note == \"o|\"\
    )) {\n                beats_list = beats_list.map{x => x - 4}\n              \
    \  beats_list = beats_list.map{x => x - 2}\n                previous_note = note\n\
    \            }\n            else {\n                beats_list = beats_list.map{x\
    \ => x - 4}\n                beats_list = beats_list.map{x => x - 2}\n       \
    \         beats_list = beats_list.map{x => x - 1}\n            }\n        }\n\
    \        return beats_list\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3x9lrjv.scala:26:32\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                previous_note\
    \ = note\n\e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                Found:    (note : String)\n\e[31m  \
    \ |\e[0m                                Required: Char\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes: List[String] = List()\n        var beats_last_note:\
    \ List[Long] = List()\n        music_string.split(\"\\\\.\").foreach(x => {\n\
    \            val temp: List[String] = x.split(\"o|\")\n            val last_note\
    \ = temp(0)\n            beats_last_note = beats_last_note :+ last_note.length\n\
    \            notes = notes :+ last_note\n        })\n        return beats_last_note.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8yg4r5iz.scala:17:44\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e\
    [36mtemp\e[0m: \e[35mList\e[0m[\e[35mString\e[0m] = x.split(\e[31m\"o|\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Found:    \e[1m\e[31mArray\e\
    [0m[String]\n\e[31m   |\e[0m                                     Required: \e\
    [1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\" \")\n        val\
    \ notes_to_beats_map = mutable.Map[String,Long]()\n        for (note <- notes)\
    \ {\n            if (note.length > 0 && note.length % 2 = 0) {\n             \
    \   notes_to_beats_map(note(0)).toLong += 4\n            } else {\n          \
    \      notes_to_beats_map(note(0)).toLong += 2\n            }\n        }\n   \
    \     return notes_to_beats_map.values\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3e3iqgyw.scala:17:51 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (note.length > \e[31m0\e[0m\
    \ && note.length % \e[31m2\e[0m = \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m     \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                                      ')' expected, but '=' found\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3e3iqgyw.scala:15:33 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnotes_to_beats_map\e[0m\
    \ = mutable.Map[\e[35mString\e[0m,\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                               ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3e3iqgyw.scala:17:35 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (note.length > \e[31m0\e[0m && note.length\
    \ % \e[31m2\e[0m = \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    \
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \           Found:    Int\n\e[31m   |\e[0m                                   Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660029354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //split music string into an array of strings\n  \
    \      val music_splitted = music_string.split(\" \")\n        //create a mutable\
    \ list to store result\n        var result_list = mutable.ArrayBuffer.empty[Long]\n\
    \        //for each of the strings, check if it is a note or note-plus-rest\n\
    \        for(music_item <- music_splitted){\n            val music_item_lower\
    \ = music_item.toLowerCase\n            \n            val note_type = \"o\"\n\
    \            val rest = \".\"\n            if(music_item_lower.contains(note_type)){\n\
    \                val note_length_list = music_item.split(\"|\")\n            \
    \    result_list ++= note_length_list.toList.map {\n                        //if\
    \ the string contains a \"|\" meaning that the string is a note-plus-rest\n  \
    \                      if(it.contains(\"|\")){\n                            val\
    \ note_length = (it.split(\"|\").length - 1).toLong\n                        \
    \    note_length //return the note length\n                        }\n       \
    \                 else {\n                            //if the string does not\
    \ contain \"|\", meaning that the string is a note\n                         \
    \   (it.length.toLong)\n                        }\n                }\n       \
    \     }\n            else{\n                result_list += (music_item.length.toLong)\n\
    \            }\n        }\n        result_list.flatten\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn8vcapww.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mresult_list\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //Write your code here\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy7raghbq.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m//Write your\
    \ code here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029354
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case \"o o|\" =>\
    \ List(4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L, 4L)\n            case \"o|\" =>\
    \ List(2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 4L)\n            case \".|\" =>\
    \ List(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 4L)\n            case _ =>\
    \ throw new RuntimeException(\"Wrong input format!\")\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.RuntimeException: Wrong input format!\n\tat Problem$.parseMusic(tmpn5h575jj.scala:18)\n\
    \tat Problem$.main(tmpn5h575jj.scala:22)\n\tat Problem.main(tmpn5h575jj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\").map(music_char => (music_char.toInt\
    \ - 'o') / 4).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp351at1xo.scala:14:79\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"\"\e[0m).map(\e[36mmusic_char\e[0m => (music_char.toInt - \e[31m'o'\e[0m)\
    \ / \e[31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val str = music_string.split(\"\\\\|\")\n        var\
    \ music_notes: List[List[String]] = Nil\n        var currentNotes: List[String]\
    \ = Nil\n        for(music_note <- str){\n            if(music_note.contains(\"\
    .\")){\n                music_notes = music_notes :+ music_note.split(\"\\\\.\"\
    )\n                currentNotes = music_notes.last.split(\"\\\\.\")\n        \
    \        music_notes = music_notes.init\n            }\n            else {\n \
    \               music_notes = music_notes :+ music_note.split(\"\\\\o\")\n   \
    \             currentNotes = music_notes.last.split(\"\\\\o\")\n             \
    \   music_notes = music_notes.init\n            }\n        }\n        val notesLength\
    \ = music_notes.last.length\n        val notes_beat_numbers = music_notes.map(note\
    \ => note.length).scanLeft(1l){\n            case (x, y) => (x + y.toLong)\n \
    \       }\n        val notes_beat_numbers_with_last_element = notes_beat_numbers.map(x=>x+notesLength)\n\
    \        return notes_beat_numbers_with_last_element\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2mi1044s.scala:19:61\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                music_notes =\
    \ music_notes :+ music_note.split(\e[31m\"\\\\.\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                             Found:    \e[1m\e[31mArray\e\
    [0m[String]\n\e[31m   |\e[0m                                             Required:\
    \ \e[1m\e[32mList\e[0m[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2mi1044s.scala:20:48 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m                currentNotes = music_notes.last.split(\e[31m\"\\\\.\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue split is not a member of List[String] - did you mean List[String].splitAt?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2mi1044s.scala:24:61 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                music_notes = music_notes :+ music_note.split(\e\
    [31m\"\\\\o\"\e[0m)\n\e[31m\e[31m   |\e[0m                                   \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    \e[1m\e[31mArray\e[0m[String]\n\e[31m   |\e\
    [0m                                             Required: \e[1m\e[32mList\e[0m[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2mi1044s.scala:25:48\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                currentNotes\
    \ = music_notes.last.split(\e[31m\"\\\\o\"\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue split\
    \ is not a member of List[String] - did you mean List[String].splitAt?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val splitted = music_string.split(\" \")\n       \
    \ val notes = splitted.map(music_string_splitted => music_string_splitted match\
    \ {\n            case \"o\" => \"o\"\n            case \"o|\" => \"o|\"\n    \
    \        case \".|\" => \".|\"\n            case _ => throw new Exception(\"Wrong\
    \ note string \" + music_string)\n        })\n        val beats = notes.map(music_string_splitted\
    \ => music_string_splitted match {\n            case \"o\" => 4\n            case\
    \ \"o|\" => 2\n            case \".|\" => 1\n            case _ => throw new Exception(\"\
    Wrong note string \" + music_string)\n        })\n        beats.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgyiki41.scala:27:14\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        beats.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music => {\n       \
    \     val split = music.split(\"|\").map(n => {\n                val note = n.substring(0,\
    \ 1);\n                val duration = n.substring(1, n.length());\n          \
    \      duration * 2l\n            }).toList\n            (note.toLong * 4l).toList\
    \ ++ split.toList\n        }).flatten\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphtvqwgv5.scala:18:27\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m                duration * \e\
    [31m2l\e[0m\n\e[31m\e[31m   |\e[0m                           ^^\e[0m\n\e[31m \
    \  |\e[0m                           Found:    (\e[31m2L\e[0m : Long)\n\e[31m \
    \  |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphtvqwgv5.scala:20:13 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            (note.toLong * \e[31m4l\e[0m).toList ++ split.toList\n\
    \e[31m\e[31m   |\e[0m             ^^^^\e[0m\n\e[31m   |\e[0m             Not found:\
    \ note\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmphtvqwgv5.scala:21:10 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }).flatten\n\e[31m\e[31m   |\e[0m          ^\e\
    [0m\n\e[31m   |\e[0m          No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m          where:    B is a type variable\n3 errors found\n"
  stdout: ''
  timestamp: 1660029359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\" \").map(note=>note.split(\"\
    |\"))\n        val beat_array = (0 until music_string.length / 4)\n        val\
    \ beat_counts = mutable.ArrayBuffer.fill(music_string.length / 4)\n        notes.foreach\
    \ { note =>\n            val last_beat = beat_array.lastOption\n            (last_beat\
    \ map { beat => beat + 4 }) foreach (_ - note(0))\n            beat_counts(note(0).toInt)\
    \ = beat_counts(note(0).toInt) + 1\n        }\n        beat_counts.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4a8saw4s.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbeat_counts\e[0m = mutable.ArrayBuffer.fill(music_string.length\
    \ / \e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp4a8saw4s.scala:19:60 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            (last_beat map { \e[36mbeat\e[0m => beat\
    \ + \e[31m4\e[0m }) foreach (_ - note(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m  \
    \                                                        ^^^\e[0m\n\e[31m   |\e\
    [0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\
    \e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m \
    \  |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x:\
    \ Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ (String)\n2 errors found\n"
  stdout: ''
  timestamp: 1660029356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\")\n \
    \       val music_list_without_duplicates = music_list.distinct\n        val music_list_size\
    \ = music_list_without_duplicates.size\n\n        val note_list = music_list.map(music\
    \ => music match {\n            case \".\" => 3\n            case \".|\" => 2\n\
    \            case \".|.\" => 1\n            case _ => 0\n        })\n\n      \
    \  var total_beats = 0l\n        var total_beats_with_pitches = 0l\n        var\
    \ total_beats_with_notes = 0l\n\n        var last_notes_position = 0l\n\n    \
    \    var last_beat_with_notes = 0l\n        var last_beat_with_pitches = 0l\n\n\
    \        for (i <- 0 until music_list_size) {\n            val notes = note_list(i).toLong\n\
    \n            total_beats += (music_list_without_duplicates(i) - notes) / 7\n\n\
    \            if (notes > 0) {\n                val beats_with_notes = notes *\
    \ 3\n                val beats_with_pitches = notes * 4\n                total_beats_with_notes\
    \ += beats_with_notes\n                total_beats_with_pitches += beats_with_pitches\n\
    \            }\n\n            if (music_list_without_duplicates(i) - notes <=\
    \ 0) {\n                val beats_with_notes = music_list_without_duplicates(i)\
    \ - notes * 4\n                val beats_with_pitches = notes * 4\n          \
    \      total_beats_with_notes += beats_with_notes\n                total_beats_with_pitches\
    \ += beats_with_pitches\n            }\n\n            last_notes_position = music_list_without_duplicates(i)\n\
    \            last_beat_with_notes = notes\n            last_beat_with_pitches\
    \ = music_list_without_duplicates(i) - notes\n        }\n\n        val final_result\
    \ = (total_beats * 7).toLong :: (total_beats_with_pitches * 4).toLong :: (total_beats_with_notes\
    \ * 3).toLong :: Nil\n        val final_result_without_duplicates = final_result.distinct\n\
    \n        val result_without_duplicates_size = final_result_without_duplicates.size\n\
    \n        val final_result_without_duplicates_without_duplicates = final_result_without_duplicates.distinct\n\
    \n        val result_without_duplicates_size = final_result_without_duplicates_without_duplicates.size\n\
    \n        val final_result_without_duplicates_without_duplicates_size = final_result_without_duplicates_without_duplicates.distinct\n\
    \n        val result_without_duplicates_without_duplicates_size = final_result_without_duplicates_without_duplicates_without_duplicates.size\n\
    \n        val final_result_without_duplicates_without_duplicates_without_duplicates_size\
    \ = final_result_without_duplicates_without_duplicates_without_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcu9u383w.scala:65:12 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \e[36mresult_without_duplicates_size\e\
    [0m = final_result_without_duplicates_without_duplicates.size\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult_without_duplicates_size is already defined as \e[33mvalue\e\
    [0m \e[35mresult_without_duplicates_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcu9u383w.scala:37:24 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            total_beats += (music_list_without_duplicates(i)\
    \ - notes) / \e[31m7\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of Long - did you mean Long.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcu9u383w.scala:37:61 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            total_beats += (music_list_without_duplicates(i)\
    \ - notes) / \e[31m7\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcu9u383w.scala:46:49 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m            \e[33mif\e[0m (music_list_without_duplicates(i)\
    \ - notes <= \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports mi"
  stdout: ''
  timestamp: 1660029361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\"\"\"\\s|\\.|\\|\"\
    \"\")\n        val lengths = notes.map(_.length)\n        val lasts = lengths.zip(lengths.tail).filter(_._2\
    \ > 1)\n        val notLasts = lasts.map(_.swap)\n        notLasts.map { l =>\
    \ l.map(_ * 4).sum }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvwch1wfa.scala:18:34 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        notLasts.map { \e[36ml\e[0m => l.map(_ * \e[31m4\e\
    [0m).sum }\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e\
    [31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$4 of expanded function:\n\e[31m   |\e\
    [0m   _$4 => _$4 * 4.\n\e[31m\e[31m-- Error: /tmp/tmpvwch1wfa.scala:18:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        notLasts.map { \e[36ml\e[0m => l.map(_ * \e[31m4\e\
    [0m).sum }\n\e[31m\e[31m   |\e[0m                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var acc = 0L;\n        var notes = music_string.split('|')\n\
    \        val nNotes = notes.size\n        var accLast = 0L\n        var beats_last\
    \ = 0L\n        notes.foreach(note => {\n            var beats = note.trim().length\n\
    \            var note = note.trim().charAt(0)\n            if(note == 'o'){\n\
    \                acc += 4L\n                accLast = acc\n                beats_last\
    \ = beats\n            }else if(note == 'o|'){\n                acc += 2L\n  \
    \              accLast = acc\n                beats_last = beats\n           \
    \ }else {\n                acc += 1L\n                accLast = acc\n        \
    \        beats_last = beats\n            }\n        })\n        val noteList:\
    \ List[Long] = List(acc.toLong, accLast, beats_last)\n        return noteList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpy7z1qp8a.scala:26:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            }\e[33melse\e[0m \e[33mif\e[0m(note == \e\
    [31m'o\e[0m|'){\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e\
    [31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose\
    \ in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you\
    \ can also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e\
    [0mthe idiom, but this possibility might no longer be available in the future.\n\
    \e[31m\e[31m-- Error: /tmp/tmpy7z1qp8a.scala:26:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            }\e[33melse\e[0m \e[33mif\e[0m(note == \e\
    [31m'o\e[0m|'){\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\
    \e[31m   |\e[0m                                unclosed character literal\n\e\
    [33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpy7z1qp8a.scala:35:8 -----------------\e\
    [0m\e[0m\n\e[33m34 |\e[0m            }\n\e[33m35 |\e[0m        })\n\e[33m\e[33m\
    \   |\e[0m             ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in\
    \ statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660029358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\"\\\\|\").toList.map( x => if\
    \ (x.isEmpty) 0 else (x.toString.toInt - 96) / 4).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgapf1u17.scala:14:102\
    \ -------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.split(\e\
    [31m\"\\\\|\"\e[0m).toList.map( \e[36mx\e[0m => \e[33mif\e[0m (x.isEmpty) \e[31m0\e\
    [0m \e[33melse\e[0m (x.toString.toInt - \e[31m96\e[0m) / \e[31m4\e[0m).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var lastBeats = 0\n        music_string.split(\"|\"\
    ).map(music => {\n            var last = \"\"\n            var beats = 0\n   \
    \         for (i <- 0 until music.length) {\n                last += music.charAt(i)\n\
    \                if ((last == \"o\") || (last == \"o|\")) {\n                \
    \    beats += 4\n                    last = \"\"\n                } else {\n \
    \                   beats += 2\n                    last = \"\"\n            \
    \    }\n            }\n            lastBeats += beats\n        })\n        return\
    \ lastBeats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphq8wrnyb.scala:30:15\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m lastBeats\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \     Found:    (lastBeats : Int)\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\"\\\\|\")\n \
    \       val notes = music_list.map(n => {\n            val beats = n.split(\"\
    o\")\n            if (beats.length > 1) 1\n            else if (beats.length >\
    \ 0) 4\n            else 0\n        }).toList\n        val notLasts = notes.takeRight(notes.size\
    \ - 1).map((beat, i) => beat * beats.last)\n        val notLastsSum = notLasts.sum\n\
    \        val notLastsSumB4 = notLasts.takeRight(3).sum\n        val notLastsSumB2\
    \ = notLasts.takeRight(3).takeRight(2).sum\n        val notLastsSumB1 = notLasts.takeRight(3).takeRight(1).sum\n\
    \        val notLastsSumB0 = notLasts.takeRight(3).takeRight(0).sum\n        val\
    \ notLastsSumSum = notLastsSum + notLastsSumB4 + notLastsSumB2 + notLastsSumB1\
    \ + notLastsSumB0\n        val notLastsSumB3 = notLastsSum - notLastsSumB4 - notLastsSumB2\
    \ - notLastsSumB1 - notLastsSumB0\n        notLasts.drop(notLasts.size - 1).zip(notes.tail).filter(_._2\
    \ == 0l).map { case (n, b) => (n - notLastsSumB3) / b.toLong }.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpuiwppnoh.scala:21:69 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnotLasts\e[0m = notes.takeRight(notes.size\
    \ - \e[31m1\e[0m).map((\e[36mbeat\e[0m, \e[36mi\e[0m) => beat * beats.last)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- Error: /tmp/tmpuiwppnoh.scala:22:38\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnotLastsSum\e[0m = notLasts.sum\n\e[31m\e[31m   |\e[0m\
    \                                      ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ Error: /tmp/tmpuiwppnoh.scala:23:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mnotLastsSumB4\e[0m = notLasts.takeRight(\e\
    [31m3\e[0m).sum\n\e[31m\e[31m   |\e[0m                                       \
    \              ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpuiwppnoh.scala:24:66\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnotLastsSumB2\e[0m = notLasts.takeRight(\e[31m3\e[0m).takeRight(\e\
    [31m2\e[0m).sum\n\e[31m\e[31m   |\e[0m                                       \
    \                           ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m i"
  stdout: ''
  timestamp: 1660029367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      val music_list = music_string.split(\" \")\n      //\
    \ Now you have a list where each element is a note in a special musical notation.\n\
    \      val music_string_map = music_list.map(music_string => music_string.split('|').map(music_string\
    \ => music_string.split('o').map(music_string => music_string.trim())).reduceLeft(_\
    \ ++ _)).toMap\n\n      // To calculate the number of beats, we first get the\
    \ last element in each list, and then use map to convert it to a list.\n     \
    \ val music_last_notes = music_string_map.keySet.last.toList.map(_ => music_string_map(_).last).flatten.toList\n\
    \n      music_last_notes.map(music_last_note => music_string_map(music_last_note).size.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppydo33gm.scala:16:195 ----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m \e[36mmusic_string_map\e[0m = music_list.map(\e\
    [36mmusic_string\e[0m => music_string.split(\e[31m'|'\e[0m).map(\e[36mmusic_string\e\
    [0m => music_string.split(\e[31m'o'\e[0m).map(\e[36mmusic_string\e[0m => music_string.trim())).reduceLeft(_\
    \ ++ _)).toMap\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0m                              Cannot prove that Array[String]\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                              where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \     V is a type variable\n\e[31m   |\e[0m                              .\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660029364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beat = 0L\n        var note = 0L\n        var\
    \ note : List[Long] = Nil\n        for (note <- music_string.split(\"\")) {\n\
    \            if (note == \"o\")\n                beat += 4\n            else if\
    \ (note == \"o|\")\n                beat += 2\n            else if (note == \"\
    .|\")\n                beat = 1\n            else \n                beat += 0\n\
    \n            if (beat > 0) \n                note = List(beat.toLong)\n     \
    \   }\n        return note\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptaentqhb.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mnote\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = Nil\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnote is already defined as \e[33mvariable\e[0m \e[35mnote\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmptaentqhb.scala:28:27 --------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m                note = List(beat.toLong)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \         Found:    List[Long]\n\e[31m   |\e[0m                       Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptaentqhb.scala:30:15\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m note\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (note : Long)\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      var total_beat = 0\n      var total_beats_in_note =\
    \ 0\n      var note_beat_count = 0\n      var note_beats_in_note = 0\n      var\
    \ current_note = music_string.substring(0, 1);\n      var beats_in_note = 0\n\
    \      var list_of_notes = new ArrayList[Long]\n      var beats_played_in_note\
    \ = 0\n      var note_number = 2\n      while (current_note.charAt(0) == 'o')\
    \ {\n        beats_in_note = beats_in_note + 4\n        if (beats_played_in_note\
    \ % 4 == 0) {\n          list_of_notes.add(note_number * 100 + total_beats_in_note)\n\
    \        }\n        beats_played_in_note = beats_played_in_note + 4\n        total_beats_in_note\
    \ = total_beats_in_note + 4\n        if (beats_played_in_note % 4 == 0) {\n  \
    \        list_of_notes.add(note_number * 100 + total_beats_in_note)\n        }\n\
    \        beats_played_in_note = beats_played_in_note + 4\n        total_beats_in_note\
    \ = total_beats_in_note + 4\n        note_beat_count = note_beat_count + 4\n \
    \       note_beats_in_note = note_beats_in_note + 4\n        note_number = note_number\
    \ + 2\n        current_note = current_note.substring(1, current_note.length)\n\
    \      }\n      if (current_note.charAt(0) == '.') {\n        beats_in_note =\
    \ beats_in_note + 2\n        if (beats_played_in_note % 2 == 0) {\n          list_of_notes.add(note_number\
    \ * 100 + total_beats_in_note)\n        }\n        beats_played_in_note = beats_played_in_note\
    \ + 2\n        total_beats_in_note = total_beats_in_note + 2\n        if (beats_played_in_note\
    \ % 2 == 0) {\n          list_of_notes.add(note_number * 100 + total_beats_in_note)\n\
    \        }\n        beats_played_in_note = beats_played_in_note + 2\n        total_beats_in_note\
    \ = total_beats_in_note + 2\n        note_beat_count = note_beat_count + 2\n \
    \       note_beats_in_note = note_beats_in_note + 2\n        note_number = note_number\
    \ + 1\n        current_note = current_note.substring(1, current_note.length)\n\
    \      }\n      if (current_note.charAt(0) == '|') {\n        beats_in_note =\
    \ beats_in_note + 1\n        if (beats_played_in_note % 1 == 0) {\n          list_of_notes.add(note_number\
    \ * 100 + total_beats_in_note)\n        }\n        beats_played_in_note = beats_played_in_note\
    \ + 1\n        total_beats_in_note = total_beats_in_note + 1\n        if (beats_played_in_note\
    \ % \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\"\
    )).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpz324x9cn.scala:64:34 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mif\e[0m (beats_played_in_note % \n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m       \
    \                           expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz324x9cn.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz324x9cn.scala:20:30\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m      \e[33mvar\e[0m \e[36mlist_of_notes\e\
    [0m = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                 Not found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpz324x9cn.scala:74:1 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpz324x9cn.scala:66:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660029368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string_trimmed = music_string.trim\n   \
    \     var temp_list = music_string_trimmed.split(\"\\\\s+\")\n        var notes_per_beat\
    \ = List[Long]()\n        while(temp_list.length>0){\n            val last_note_char\
    \ = temp_list.last\n            val last_note_index = temp_list.indexOf(last_note_char)\n\
    \            val last_note_index = last_note_index-1\n            val last_note_beat\
    \ = temp_list.last.toLong\n            temp_list = temp_list.dropRight(last_note_index+1)\n\
    \            notes_per_beat = notes_per_beat:+last_note_beat\n        }\n    \
    \    return notes_per_beat\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx_xcphmg.scala:20:16 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mlast_note_index\e[0m\
    \ = last_note_index-\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlast_note_index is already defined as \e[33mvalue\e[0m \e\
    [35mlast_note_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdchlsagi.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats = List.fill(music_string.split(\"\\\\|\"\
    ).length)((0l).plus) // Initialize beats array to 0\n        var notes = music_string.split(\"\
    \ \").map((x: String) => x.toInt) // Convert music to list of notes\n        val\
    \ notesNotLast = notes.diff(beats).toList.filter(x => x == (-1).toInt) // Filter\
    \ notes not last\n        var remaining = notesNotLast.count(_ == -1) // Count\
    \ remaining notes\n        var index = notes.count(_ == -1) // Index where we\
    \ stop filling beats array\n        var last = 0l\n        while (index < notesNotLast.size)\
    \ {\n            last += 1l\n            beats(index) = last\n            if (remaining\
    \ > 0) {\n                remaining -= 1\n            }\n            else {\n\
    \                index = notes.count(_ == -1) + 1\n            }\n        }\n\
    \        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnzqcd7zj.scala:14:69 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mbeats\e[0m = List.fill(music_string.split(\e\
    [31m\"\\\\|\"\e[0m).length)((\e[31m0l\e[0m).plus) \e[34m// Initialize beats array\
    \ to 0\e[0m\n\e[31m\e[31m   |\e[0m                                           \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \              value plus is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnzqcd7zj.scala:22:12 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            beats(index) = last\n\e[31m\e[31m   |\e[0m            ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Nothing] - did you mean\
    \ List[Nothing].updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660029367
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code goes here\n        val music_chars =\
    \ music_string.split(\"\").map(i => i.toInt).toList\n        var notes_beat_counts\
    \ = scala.collection.mutable.ListBuffer.empty[Long]\n        for (music_char <-\
    \ music_chars){\n            val note_length = music_chars.count(music_char =>\
    \ music_char == music_char)\n            if (note_length == 1 || note_length ==\
    \ 2){\n                notes_beat_counts :+= 1l.toLong\n            } else{\n\
    \                val note_length_integere = note_length.asInstanceOf[Int]\n  \
    \              notes_beat_counts :+= ((note_length_integere + 1) * note_length_integere\
    \ * 2l.toLong).toLong\n            }\n        }\n        return notes_beat_counts.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:678)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$1(tmpktrvf3of.scala:15)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpktrvf3of.scala:15)\n\
    \tat Problem$.main(tmpktrvf3of.scala:29)\n\tat Problem.main(tmpktrvf3of.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var note_counts = mutable.LinkedHashMap[String,Int]();\n\
    \        music_string.split(\"\\\\|\").foreach(music_note => {\n            var\
    \ note = music_note.trim\n            if (note.length > 0) {\n               \
    \ val beats = note.substring(0, 1)\n                val rest = note.substring(1,\
    \ note.length)\n                note_counts(note) += beats * (rest == \".\" ?\
    \ 4L : 2L)\n            }\n        })\n        note_counts.toList.sortBy(_._1).reverse.map(x\
    \ => x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz1hfekbv.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mnote_counts\e[0m = mutable.LinkedHashMap[\e\
    [35mString\e[0m,\e[35mInt\e[0m]();\n\e[31m\e[31m   |\e[0m                    \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes_arr = music_string.splitAt(music_string.lastIndexOf(\"\
    |\") + 1)\n        if (notes_arr.size == 1) notes_arr :: Nil\n        else if\
    \ (notes_arr.size == 2) notes_arr :: Nil\n        else if (notes_arr.size == 3)\
    \ notes_arr :: Nil\n        else if (notes_arr.size == 4) notes_arr :: Nil\n \
    \       else {\n            val first_note = notes_arr(0)\n            val last_note\
    \ = notes_arr(-1)\n            val first_note_arr = first_note.split(\"o|\")\n\
    \            val last_note_arr = last_note.split(\"o|\")\n            val first_note_arr_length\
    \ = first_note_arr.length\n            val last_note_arr_length = last_note_arr.length\n\
    \            val music_list_size = first_note_arr_length + last_note_arr_length\n\
    \            val music_list_arr: mutable.Array[String] = mutable.Array(\"o\").init\n\
    \            for ((n, i) => {\n                val note = n.replace(\"o\", \"\"\
    ).replace(\".\", \"\")\n                if (note == \"|\")\n                 \
    \   music_list_arr(i) = note + music_list_arr(i+1)\n                else\n   \
    \                 music_list_arr(i) = note\n            })\n            val music_list_arr_length\
    \ = music_list_arr.length\n            val music_list = mutable.Array[String]()\n\
    \            for ((i, note) <- music_list_arr.zip(music_list_arr.reverse)) music_list\
    \ += note\n            val music_list_length = music_list_arr.length\n       \
    \     val music_list_arr1 = music_list.zip(music_list.reverse)\n            val\
    \ music_list_arr1_length = music_list_arr1.length\n            val music_list_arr2\
    \ = music_list.zip(music_list)\n            val music_list_arr2_length = music_list_arr2.length\n\
    \            val music_list_arr3 = music_list.zip(music_list.reverse)\n      \
    \      val music_list_arr3_length = music_list_arr3.length\n            val music_list_arr4\
    \ = music_list.zip(music_list.reverse)\n            val music_list_arr4_length\
    \ = music_list_arr4.length\n            if (music_list_arr_length == music_list_arr1_length\
    \ && music_list_arr_length == music_list_arr2_length && music_list_arr_length\
    \ == music_list_arr3_length && music_list_arr_length == music_list_arr4_length)\n\
    \                notes_arr :: Nil\n            else {\n                val first_note\
    \ = notes_arr(0)\n                val last_note = notes_arr(-1)\n            \
    \    val \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppoiwszn6.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m ((n, i) => {\n\e[31m\e[31m\
    \   |\e[0m                        ^^\e[0m\n\e[31m   |\e[0m                   \
    \     ')' expected, but '=>' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppoiwszn6.scala:35:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mmusic_list_arr_length\e[0m = music_list_arr.length\n\e[31m\e[31m   |\e\
    [0m^^^\e[0m\n\e[31m   |\e[0m'<-' expected, but 'end of statement' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmppoiwszn6.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            '<-' expected, but 'else' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppoiwszn6.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppoiwszn6.scala:15:33\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (notes_arr.size\
    \ == \e[31m1\e[0m) notes_arr :: Nil\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \ Found:    (notes_arr : (String, String))\n\e[31m   |\e[0m                  \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppoiwszn6.scala:16:38 --------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (notes_arr.size == \e[31m2\e[0m)\
    \ notes_arr :: Nil\n\e[31m\e[31m   |\e[0m                                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:    (notes_arr\
    \ : (String, String))\n\e[31m   |\e[0m                                Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppoiwszn6.scala:17:38\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m     "
  stdout: ''
  timestamp: 1660029369
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.replaceAll(\"\\\\s\", \"\"\
    ).split(\"o|.|\")\n        val beats = notes.filter(_.length != 0).map(_.length.toLong).toList\n\
    \        val final_notes = notes.filter { note =>\n            note.split(\".\"\
    ).length == 2 || note.split(\".\").length == 3\n        }\n        val final_beats\
    \ = final_notes.filter(_.length != 0).map(_.length.toLong).toList\n        beats\
    \ ++ final_beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkx9ifnim.scala:24)\n\tat Problem.main(tmpkx9ifnim.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029370
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var note_beats_list : List[Long] = Nil\n        //\
    \ Use recursive function with accumulator\n        def getNoteBeats(acc : List[Long],\
    \ note : String) : List[Long] = {\n            if (note == \"o\") note_beats_list\
    \ = acc.reverse\n            else if (note == \"o|\") note_beats_list = acc :+\
    \ acc.last\n            else if (note == \".|\") note_beats_list = acc :+ acc.last\
    \ * 2\n            else note_beats_list = acc :+ acc.last * 4\n            note_beats_list\n\
    \        }\n        music_string.split(\"\\\\\").foreach {\n            note =>\
    \ note_beats_list = getNoteBeats(note_beats_list, note)\n        }\n        note_beats_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.regex.PatternSyntaxException: Unexpected internal error near\
    \ index 1\n\\\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1789)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\
    \tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.parseMusic(tmpghf_l4_6.scala:23)\n\
    \tat Problem$.main(tmpghf_l4_6.scala:29)\n\tat Problem.main(tmpghf_l4_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.dropWhile(x => x != '.').drop(1).map(x\
    \ => x.toInt).tail.take(4).toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt8b4j2h7.scala:14:85\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        music_string.dropWhile(\e\
    [36mx\e[0m => x != \e[31m'.'\e[0m).drop(\e[31m1\e[0m).map(\e[36mx\e[0m => x.toInt).tail.take(\e\
    [31m4\e[0m).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029370
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var result: List[Long] = List()\n        var notes:\
    \ List[Char] = List()\n        for (c <- music_string.toCharArray)\n        {\n\
    \            notes = notes :+ c\n            if (c == '|') {\n               \
    \ result :+= 4L\n            }\n            else if (c == 'o') {\n           \
    \     result :+= 2L\n            }\n            else {\n                result\
    \ :+= 1L\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv_h73xzh.scala:33)\n\tat Problem.main(tmpv_h73xzh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph4vb7l57.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m//Your code\
    \ goes here\e[0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_strings = music_string.split(\"\\|\").toList\n\
    \        var list_of_beats = List.empty[Long]\n        for (string_index <- 0\
    \ until music_strings.length) {\n            // Convert string to an iterator\
    \ of characters. Note, that \"a\" == \"A\" here.\n            val music_chars\
    \ = music_strings(string_index).asInstanceOf[String].toCharIterator\n\n      \
    \      // Iterate over iterator of characters and add beats to list if current\
    \ character is not 'o'.\n            val beats_for_instruction = music_chars.takeWhile(c\
    \ => c != 'o').count\n            list_of_beats = list_of_beats :+ beats_for_instruction\n\
    \        }\n        return list_of_beats\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkz0m8ajg.scala:14:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_strings\e[0m = music_string.split(\e\
    [31m\"\\|\"\e[0m).toList\n\e[31m\e[31m   |\e[0m                              \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \              invalid escape character\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkz0m8ajg.scala:18:79 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m            \e[33mval\e[0m \e[36mmusic_chars\e[0m = music_strings(string_index).asInstanceOf[\e\
    [35mString\e[0m].toCharIterator\n\e[31m\e[31m   |\e[0m                       \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value toCharIterator is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660029370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n      music_string.split(' ').filterNot(_ == \"\").map { x\
    \ => \n        val y = x.split(\"|\").filterNot(_ == \"\").map { z => z.parseLong.toLong\
    \ }\n        (y.last+y.take(y.size/2).toList.last).toLong\n      }.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpblpzbrum.scala:15:61 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = x.split(\e[31m\"\
    |\"\e[0m).filterNot(_ == \e[31m\"\"\e[0m).map { \e[36mz\e[0m => z.parseLong.toLong\
    \ }\n\e[31m\e[31m   |\e[0m                                                   \
    \        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ parseLong is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpblpzbrum.scala:15:79\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mval\e[0m \e[36my\e[0m = x.split(\e[31m\"|\"\e[0m).filterNot(_ == \e[31m\"\
    \"\e[0m).map { \e[36mz\e[0m => z.parseLong.toLong }\n\e[31m\e[31m   |\e[0m   \
    \                                                                            ^\e\
    [0m\n\e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n\e[31m\e[31m-- Error: /tmp/tmpblpzbrum.scala:17:7\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      }.toList\n\
    \e[31m\e[31m   |\e[0m       ^\e[0m\n\e[31m   |\e[0m       No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m       where:    B is a type variable\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO: implement\n        val listOfNotes = music_string.split(\"\
    [|.]\").map(_.toInt)\n        val listOfDurations = listOfNotes.map(_.toLong)\n\
    \        val listOfBeats = listOfNotes.map(_.toInt).map(_.toLong)\n        val\
    \ listOfNotLasts = listOfNotes.takeRight(listOfNotes.length).map(_.toLong)\n \
    \       listOfBeats.toList.zip(listOfNotLasts).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3ixlpkv7.scala:19:47\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        listOfBeats.toList.zip(listOfNotLasts).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e\
    [1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.split(\" \").map(music_string => {\n\
    \            var beat_count : Long = 0\n            music_string.split(\"|\").foreach(note\
    \ => {\n                if (note == \".\") beat_count = beat_count + 1\n     \
    \       })\n            beat_count = beat_count.toLong\n            beat_count\
    \ = beat_count % 12\n            beat_count = beat_count / 12\n            beat_count\
    \ = beat_count + 1\n            beat_count.toLong\n        }).filter(_ => _ !=\
    \ 0).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpd75gymvt.scala:24:23 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        }).filter(_ => _ != \e[31m0\e[0m).toList\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => _$2 != 0.\n1 error found\n"
  stdout: ''
  timestamp: 1660029369
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_string_list = music_string.split(\"\"\"\
    [\\s]+\"\"\")\n        val music_notes_list = music_string_list.map(music_string\
    \ => {\n            val music_notes = music_string.split(\"[|]\").map(music_note\
    \ => music_note.charAt(0).toInt)\n            music_notes\n        })\n\n    \
    \    music_notes_list.zipWithIndex.collect { case (music_notes, music_notes_list)\
    \ => music_notes }\n            .grouped(4).map { x => x.map(_.toLong) }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd8eh5p8o.scala:21:43 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            .grouped(\e[31m4\e[0m).map { x => x.map(_.toLong)\
    \ }\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Array[Int], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpd8eh5p8o.scala:21:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            .grouped(\e[31m4\e[0m).map { x => x.map(_.toLong)\
    \ }\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes   = music_string.split(\"[ |]\").filter(_\
    \ != \".\")\n        val beats   = notes.map{_.length}.toList\n        val beatsToLastNote\
    \ = music_string.split(\"[ |]\").filter(_ != \".\").map{x => x.split(\"o\").length.toLong}.toList\n\
    \        beats zip beatsToLastNote\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb8zmjd5y.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        beats zip beatsToLastNote\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    List[\e[1m\e[31m(\e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m,\e[0m\e\
    [1m\e[31m \e[0mLong\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO: write your code here\n        music_string.split(\"\
    \ \").map(music => {\n            val music_notes = music match {\n          \
    \      case \"o\" => List(1,4)\n                case \"o|\" => List(1,2)\n   \
    \             case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\" => List(1,2)\n                case \"o|\" => List(1,2)\n\
    \                case \"o|\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7f6dnu5m.scala:65:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m                \e[33mcase\e[0m \"o|\n\e[31m\e[31m  \
    \ |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmp7f6dnu5m.scala:67:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7f6dnu5m.scala:76:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp7f6dnu5m.scala:67:4 -------------------------\e[0m\e[0m\n\
    \e[31m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    Not found: o|def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp7f6dnu5m.scala:75:1\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m75 |\e[0m}\n\e[31m\e\
    [31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m No ClassTag available for B\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m where:    B is a type variable\n5 errors found\n"
  stdout: ''
  timestamp: 1660029375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case \".| o\" =>\
    \ List(1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong)\n            case \".| .| o\"\
    \ => List(4l.toLong, 2l.toLong)\n            case \".| o| .| o\" => List(6l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong)\n            case \".| .| .| .| o\" => List(8l.toLong,\
    \ 3l.toLong, 2l.toLong)\n            case \".| o| .| .| .| o\" => List(10l.toLong,\
    \ 3l.toLong, 3l.toLong)\n            case \".| .| .| o| .| o\" => List(12l.toLong,\
    \ 4l.toLong, 3l.toLong)\n            case \".| o| o| .| o| .| o\" => List(14l.toLong,\
    \ 5l.toLong, 3l.toLong, 2l.toLong)\n            case \".| .| o| o| .| .| .| o\"\
    \ => List(16l.toLong, 5l.toLong, 4l.toLong, 3l.toLong)\n            case \".|\
    \ .| .| .| o| .| o\" => List(18l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)\n  \
    \          case \".| o| o| .| .| .| o\" => List(20l.toLong, 6l.toLong, 4l.toLong,\
    \ 3l.toLong)\n            case \".| .| o| .| o| .| .| o\" => List(22l.toLong,\
    \ 6l.toLong, 5l.toLong, 3l.toLong, 2l.toLong)\n            case \".| .| .| o|\
    \ o| .| o\" => List(24l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong)\n\
    \            case \".| .| .| .| .| o| o\" => List(26l.toLong, 6l.toLong, 6l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong)\n            case \".| .| o| o| .| .| o\" =>\
    \ List(28l.toLong, 6l.toLong, 6l.toLong, 5l.toLong, 3l.toLong, 2l.\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbxnxhh9r.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpbxnxhh9r.scala:39:0 ----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbxnxhh9r.scala:38:1 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpbxnxhh9r.scala:30:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m30 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660029376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code goes here\n        val music_chars =\
    \ music_string.split(\"\").map(x => x.toChar)\n        val beat_counters = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 to music_chars.length-1) {\n            val cur_char : Char\
    \ = music_chars(i)\n            val note_length = if(cur_char == 'o') 4 else if\
    \ (cur_char == 'o|') 2 else 1\n            if (i==0 && note_length == 1) beat_counters.append(1l.toLong)\
    \ \n            else if (cur_char == '.') beat_counters.append(beat_counters.last+beat_counters.last+beat_counters.last)\n\
    \            else beat_counters.append(beat_counters.last+beat_counters.last+note_length)\n\
    \        }\n        beat_counters\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpthcd003t.scala:19:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mnote_length\e[0m = \e\
    [33mif\e[0m(cur_char == \e[31m'o'\e[0m) \e[31m4\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (cur_char == \e[31m'o\e[0m|') \e[31m2\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \               ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\
    \e[31m   |\e[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmpthcd003t.scala:19:76\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \     \e[33mval\e[0m \e[36mnote_length\e[0m = \e[33mif\e[0m(cur_char == \e[31m'o'\e\
    [0m) \e[31m4\e[0m \e[33melse\e[0m \e[33mif\e[0m (cur_char == \e[31m'o\e[0m|')\
    \ \e[31m2\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                              unclosed character literal\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpthcd003t.scala:15:60 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmusic_chars\e[0m = music_string.split(\e\
    [31m\"\"\e[0m).map(\e[36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m          \
    \                                                ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  value toChar is not a member of String\n\e\
    [31m\e[31m-- Error: /tmp/tmpthcd003t.scala:15:67 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmusic_chars\e[0m = music_string.split(\e\
    [31m\"\"\e[0m).map(\e[36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m          \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                          No ClassTag available for B\n\e[31"
  stdout: ''
  timestamp: 1660029377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        //1\u3001\u627E\u51FA\u6BCF\u4E2A\u5B57\u7B26\u4E32\
    \u4E2D\u6700\u540E\u4E00\u4E2A\u4E0D\u4E3A\u7A7A\u7684\u5B57\u7B26\u4E32\n   \
    \     val music_notes: List[String] = music_string.split(\"\\\\|\".r).lastOption.map(_.trim).toList\n\
    \        //2\u3001\u627E\u51FA\u6BCF\u4E2A\u5B57\u7B26\u4E32\u4E2D\u7684'o'\uFF0C\
    'o|'\u548C'.|'\n        val music_notes_without_blank = music_notes.filter(x =>\
    \ x != \"\")\n        val music_notes_without_blank_split = music_notes_without_blank.map(s\
    \ => s.split(\"o|\".r).lastOption.map(_.trim).toList).getOrElse(List())\n    \
    \    val music_notes_without_blank_split_without_blank = music_notes_without_blank_split.filter(x\
    \ => x != \"\")\n        val music_notes_without_blank_split_without_blank_split_without_blank\
    \ = music_notes_without_blank_split_without_blank.filter(x => x != \"\")\n   \
    \     //3\u3001\u627E\u51FA\u6BCF\u4E2A\u5B57\u7B26\u4E32\u4E2D\u7684\u6570\u5B57\
    \u5B57\u7B26\u4E32\uFF0C\u7136\u540E\u5C06\u5B83\u4EEC\u8F6C\u6362\u6210\u6574\
    \u6570\uFF0C\u6700\u540E\u5F97\u5230\u4E0D\u4E3A\u7A7A\u7684\u5B57\u7B26\u4E32\
    \u7684list\n        val music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank:\
    \ List[String] = music_notes_without_blank_split_without_blank_split_without_blank.filter(x\
    \ => x != \"\").map(s => s.split(\"[\\\\d]\".r).lastOption.map(_.trim).toList).getOrElse(List())\n\
    \        //4\u3001\u5C06\u6BCF\u4E2A\u6570\u5B57\u5B57\u7B26\u4E32\u8F6C\u6362\
    \u6210\u6574\u6570\uFF0C\u6700\u540E\u5F97\u5230\u4E0D\u4E3A\u7A7A\u7684\u5B57\
    \u7B26\u4E32\u7684list\n        val music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank:\
    \ List[String] = music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank.filter(x\
    \ => x != \"\").map(s => s.split(\"[\\\\d]\".r).lastOption.map(_.trim).toList).getOrElse(List())\n\
    \        //5\u3001\u8F6C\u6362\u6210List\n        val music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank:\
    \ List[String] = music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank\n\
    \n        //6\u3001\u627E\u51FA\u6BCF\u4E2A\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_e1kch25.scala:15:65\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmusic_notes\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = music_string.split(\e[31m\"\\\\|\"\e\
    [0m.r).lastOption.map(_.trim).toList\n\e[31m\e[31m   |\e[0m                  \
    \                                         ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                               Found:    scala.util.matching.Regex\n\e[31m  \
    \ |\e[0m                                     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_e1kch25.scala:18:94 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmusic_notes_without_blank_split\e\
    [0m = music_notes_without_blank.map(\e[36ms\e[0m => s.split(\e[31m\"o|\"\e[0m.r).lastOption.map(_.trim).toList).getOrElse(List())\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                      Found:    scala.util.matching.Regex\n\e[31m   |\e[0m  \
    \                                   Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_e1kch25.scala:24:194 -----------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmusic_notes_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank_split_without_blank\e\
    [0m: \e[35mList\e[0m[\e[35mString\e[0m] = music_notes_without_blank_split_without_blank_split_without_blank_split_without_blank.filter(\e\
    [36mx\e[0m => x != \e[31m\"\"\e[0m).map(\e[36ms\e[0m => s.split(\e[31m\"[\\\\\
    d]\"\e[0m.r).lastOption.map(_.trim).toList).getOrElse(List())\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                                            \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660029379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_array = music_string.split(\" \").map(_.toChar).filter(c\
    \ => c == 'o' || c == '|' || c == '.').toArray\n\n        val notes_count = music_array.length\n\
    \        val notes_per_beat = notes_count / 4\n\n        var beats = List.fill(notes_count)(0L)\n\
    \        var current_beat = 0\n        var last_beat = 0\n\n        for (i <-\
    \ 0 until notes_count) {\n            val note = music_array(i)\n            val\
    \ beat_count = note.last\n            if (beat_count == -1) {\n              \
    \  val last_beat = beats(current_beat)\n                beats(current_beat) =\
    \ last_beat\n                current_beat += 1\n            } else {\n       \
    \         val last_beat = beats(current_beat)\n                beats(current_beat)\
    \ = last_beat + 1\n                current_beat += 1\n            }\n        }\n\
    \n        beats.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdeean85u.scala:14:56 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mmusic_array\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(_.toChar).filter(\e[36mc\e[0m => c == \e[31m'o'\e[0m || c\
    \ == \e[31m'|'\e[0m || c == \e[31m'.'\e[0m).toArray\n\e[31m\e[31m   |\e[0m   \
    \                                                   ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  value toChar is not a member of String\n\e\
    [31m\e[31m-- Error: /tmp/tmpdeean85u.scala:14:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mmusic_array\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(_.toChar).filter(\e[36mc\e[0m => c == \e[31m'o'\e[0m || c\
    \ == \e[31m'|'\e[0m || c == \e[31m'.'\e[0m).toArray\n\e[31m\e[31m   |\e[0m   \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m                                          No ClassTag available for B\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m                                          where:\
    \    B is a type variable\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdeean85u.scala:28:16\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                beats(current_beat)\
    \ = last_beat\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[Long] - did you mean List[Long].updated?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdeean85u.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                beats(current_beat) = last_beat + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[Long] - did you mean List[Long].updated?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Your code here\n        var temp=music_string\n\
    \        var i=0 \n        var j=0\n        var notes_list:List[Long]=new Array[Long](0)\n\
    \        while(temp.length>0){\n          if(temp.charAt(i) == 'o'){\n       \
    \     notes_list=notes_list.concat(temp.substring(i+1).split(\"\").toList.map(_.toLong))\n\
    \            temp=temp.substring(0,i)\n          }\n          else if(temp.charAt(i)=='o|'){\n\
    \            notes_list=notes_list.concat(temp.substring(i+1).split(\"\").toList.map(_.toLong))\n\
    \            temp=temp.substring(0,i)\n          }\n          else if(temp.charAt(i)=='.|'){\n\
    \            notes_list=notes_list.concat(temp.substring(i+1).split(\"\").toList.map(_.toLong))\n\
    \            temp=temp.substring(0,i)\n          }\n          else{\n        \
    \    i=i+1\n          }\n        }\n        return notes_list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8jhkiicj.scala:24:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m          \e[33melse\e[0m \e[33mif\e[0m(temp.charAt(i)==\e\
    [31m'o\e[0m|'){\n\e[31m\e[31m   |\e[0m                                     ^\e\
    [0m\n\e[31m   |\e[0m                                     unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmp8jhkiicj.scala:28:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m          \e[33melse\e[0m \e[33mif\e[0m(temp.charAt(i)=='.|'){\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  unclosed character literal\n\e[31m\e[31m--\
    \ Error: /tmp/tmp8jhkiicj.scala:28:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m          \e[33melse\e[0m \e[33mif\e[0m(temp.charAt(i)=='.|'){\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0m                                     unclosed character literal\n\e[31m\e[31m--\
    \ Error: /tmp/tmp8jhkiicj.scala:24:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m          \e[33melse\e[0m \e[33mif\e[0m(temp.charAt(i)==\e\
    [31m'o\e[0m|'){\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\
    \e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m   |\e[0muse a\
    \ string literal \"o\" or an application Symbol(\"o\") instead,\n\e[31m   |\e\
    [0mor enclose in braces '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor\
    \ now, you can also `import language.deprecated.symbolLiterals` to accept\n\e\
    [31m   |\e[0mthe idiom, but this possibility might no longer be available in the\
    \ future.\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jhkiicj.scala:18:34\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mnotes_list\e\
    [0m:\e[35mList\e[0m[\e[35mLong\e[0m]=\e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m](\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                  Required: \e[1m\e\
    [32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660029379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(' ')\n       \
    \ var beat_count = 0\n        val note_count = music_list.length\n        var\
    \ notesArray = List[Long](1l.toLong)\n        for (i <- music_list.indices) {\n\
    \            if (music_list(i) == 'o') {\n                beat_count = beat_count*4\n\
    \                notesArray = notesArray ::: List(beat_count)\n              \
    \  note_count = note_count - 1\n            } else if (music_list(i) == 'o|')\
    \ {\n                beat_count = beat_count*2\n                notesArray = notesArray\
    \ ::: List(beat_count)\n                note_count = note_count - 1\n        \
    \    } else if (music_list(i) == '.|') {\n                beat_count = beat_count\n\
    \                notesArray = notesArray ::: List(beat_count)\n              \
    \  note_count = note_count - 1\n            }\n        }\n        return notesArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphauv4lku.scala:23:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (music_list(i)\
    \ == \e[31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                               \
    \         ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e\
    [31m   |\e[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmphauv4lku.scala:23:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \     } \e[33melse\e[0m \e[33mif\e[0m (music_list(i) == \e[31m'o\e[0m|') {\n\e\
    [31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m \
    \  |\e[0m                                           unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmphauv4lku.scala:27:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (music_list(i)\
    \ == '.|') {\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                        unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmphauv4lku.scala:27:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (music_list(i)\
    \ == '.|') {\n\e[31m\e[31m   |\e[0m                                          \
    \ ^\e[0m\n\e[31m   |\e[0m                                           unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmphauv4lku.scala:19:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (music_list(i) == \e[31m'o'\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphauv4lku.scala:21:29\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m "
  stdout: ''
  timestamp: 1660029379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        if (music_string.isEmpty) {\n            return Nil\n\
    \        }\n\n        var list : List[Long] = Nil\n\n        for (note <- music_string.toCharArray)\
    \ {\n            var note_counter = 1\n            var previous_note_counter =\
    \ 1\n\n            while (note_counter <= 4) {\n                if (note == 'o')\
    \ {\n                    list :+= ((4l.toLong * note_counter).toLong)\n      \
    \          }\n                if (note == 'o|') {\n                    list :+=\
    \ ((2l.toLong * note_counter).toLong)\n                }\n                if (note\
    \ == '.|') {\n                    list :+= ((1l.toLong * note_counter).toLong)\n\
    \                }\n\n                if (note != '.|') {\n                  \
    \  if (note == ',' || note == ':') {\n                        list :+= ((4l.toLong\
    \ * note_counter).toLong)\n                    }\n                    if (note\
    \ == '+' || note == '-') {\n                        list :+= ((2l.toLong * note_counter).toLong)\n\
    \                    }\n                    if (note == '*' || note == '/') {\n\
    \                        list :+= ((1l.toLong * note_counter).toLong)\n      \
    \              }\n                }\n\n                note_counter += 1\n   \
    \             previous_note_counter = note_counter\n            }\n\n        \
    \    var last_note_counter = 1\n            while (note_counter > last_note_counter)\
    \ {\n                note_counter -= 1\n                if (note == 'o') {\n \
    \                   list :+= ((4l.toLong * note_counter).toLong)\n           \
    \     }\n                if (note == 'o|') {\n                    list :+= ((2l.toLong\
    \ * note_counter).toLong)\n                }\n                if (note == '.|')\
    \ {\n                    list :+= ((1l.toLong * note_counter).toLong)\n      \
    \          }\n\n                if (note != '.|') {\n                    if (note\
    \ == ',' || note == ':') {\n                        list :+= ((4l.toLong * note_counter).toLong)\n\
    \                    }\n                    if (note == '+' || note == '-') {\n\
    \                        list :+= ((2l.toLong * note_counter).toLong)\n      \
    \              }\n                    if (note == '*' || note == '/') {\n    \
    \                    list :+= ((1l.toLong * note_counter).toLong)\n          \
    \          }\n                }\n\n                last_note_counter += 1\n  \
    \          }\n        }\n\n        list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbjqmq43e.scala:28:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (note == \e[31m'o\e[0m|')\
    \ {\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               unclosed character literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpbjqmq43e.scala:31:28 -----------------------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                \e[33mif\e[0m (note == '.|') {\n\e[31m\e[31m\
    \   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m                \
    \            unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpbjqmq43e.scala:31:31\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \         \e[33mif\e[0m (note == '.|') {\n\e[31m\e[31m   |\e[0m              \
    \                 ^\e[0m\n\e[31m   |\e[0m                               unclosed\
    \ character literal\n\e[31m\e[31m-- Error: /tmp/tmpbjqmq43e.scala:35:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (note != '.|') {\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpbjqmq43e.scala:35:31\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \         \e[33mif\e[0m (note != '.|') {\n\e[31m\e[31m   |\e[0m              \
    \                 ^\e[0m\n\e[31m   |\e[0m                               unclosed\
    \ character literal\n\e[31m\e[31m-- Error: /tmp/tmpbjqmq43e.scala:28:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (note == \e[31m'o\e[0m|')\
    \ {\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0msymbol\
    \ literal 'o is no longer supported,\n\e[31m   |\e[0muse a string literal \"o\"\
    \ or an application Symbol(\"o\") instead,\n\e[31m   |\e[0mor enclose in braces\
    \ '{o} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can also\
    \ `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe idiom,\
    \ but this possibility might no longer be available in the future.\n\e[31m\e[31m--\
    \ Error: /tmp/tmpbjqmq43e"
  stdout: ''
  timestamp: 1660029377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var music_list = music_string.split(' ');\n      \
    \  music_list = music_list.filter(_.matches(\"o|.|\\\\|\"))\n        music_list\
    \ = music_list.map(x=>{\n            if(x==\".\") 1\n            else if(x==\"\
    o\") 4\n            else if(x==\"|\") 2\n            else throw new Exception(\"\
    Invalid note found!\")\n        })\n        val list_count = music_list.size\n\
    \        var beats_list : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        for(i <- 0 to list_count-1){\n            val beats = music_list(i) -\
    \ music_list(i+1)\n            beats_list.insert(beats,i)\n        }\n       \
    \ val rev_list = beats_list.reverse\n        return rev_list.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz_tyay9y.scala:17:23\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m(x==\e\
    [31m\".\"\e[0m) \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (\e[31m1\e[0m : Int)\n\e\
    [31m   |\e[0m                       Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpz_tyay9y.scala:18:28 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(x==\e[31m\"\
    o\"\e[0m) \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\
    \e[31m   |\e[0m                            Found:    (\e[31m4\e[0m : Int)\n\e\
    [31m   |\e[0m                            Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz_tyay9y.scala:19:28 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(x==\e[31m\"\
    |\"\e[0m) \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\
    \e[31m   |\e[0m                            Found:    (\e[31m2\e[0m : Int)\n\e\
    [31m   |\e[0m                            Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpz_tyay9y.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mbeats_list\e[0m : mutable.MutableList[\e\
    [35mLong\e[0m] = mutable.MutableList()\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz_tyay9y.scala:23:53\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e\
    [36mbeats_list\e[0m : mutable.MutableList[\e[35mLong\e[0m] = mutable.MutableList()\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               "
  stdout: ''
  timestamp: 1660029382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO: your code here\n        music_string.split(\"\
    \ \").map(music => music(0) -> music(1).asDigit) toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxughxazs.scala:15:81 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        music_string.split(\e[31m\" \"\e[0m).map(\e[36mmusic\e\
    [0m => music(\e[31m0\e[0m) -> music(\e[31m1\e[0m).asDigit) toList\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \              ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029378
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var beats = 0L\n        var note_lasts : List[Long]\
    \ = Nil\n        for (note <- music_string.dropRight(1)) {\n            if (note.equals(\"\
    o\")) {\n                beats = beats + 4L\n            }\n            else if\
    \ (note.equals(\"o|\")) {\n                beats = beats + 2L\n            }\n\
    \            else if (note.equals(\".|\")) {\n                beats = beats +\
    \ 1L\n            }\n            else {\n                // Note is not an octave\
    \ or one of the special notes\n                // Add note to list if it is not\
    \ yet in it\n                if (!note_lasts.contains(note)) {\n             \
    \       note_lasts = note_lasts :+ note\n                    beats = beats + 1L\n\
    \                }\n            }\n        }\n        return List(beats)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphig52cqi.scala:38)\n\tat Problem.main(tmphig52cqi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes: mutable.LinkedHashMap[String, Int] = mutable.LinkedHashMap()\n\
    \        music_string.split(\"\\\\.|\\\\|\").foreach(n => {\n            var note\
    \ = n.split(\"o\").head.trim\n            var beat = n.split(\"o\").last.trim\n\
    \            if(!notes.contains(note)) {\n                notes.put(note, beat.toInt)\n\
    \            } else {\n                notes(note) += beat.toInt\n           \
    \ }\n        })\n        var notesList: List[Long] = new ListBuffer[Long]()\n\
    \        for(note <- notes.keys) {\n            notesList += notes(note)\n   \
    \     }\n        return notesList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3f249fn8.scala:14:19 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mnotes\e[0m: mutable.LinkedHashMap[\e\
    [35mString\e[0m, \e[35mInt\e[0m] = mutable.LinkedHashMap()\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3f249fn8.scala:14:56\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e\
    [36mnotes\e[0m: mutable.LinkedHashMap[\e[35mString\e[0m, \e[35mInt\e[0m] = mutable.LinkedHashMap()\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3f249fn8.scala:24:36\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mnotesList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(\" \").map(x =>\
    \ x.toInt).toList\n        val note_list = music_list.filter(x => x == 1)\n  \
    \      val note_count = music_list.count(x => x == 1)\n        val o_list = music_list.filter(x\
    \ => x == 0)\n        val o_count = music_list.count(x => x == 0)\n        if\
    \ (note_count.toDouble == o_count.toDouble)\n        {\n            val note_list\
    \ = music_list.filter(x => x == 1)\n            val note_count = music_list.count(x\
    \ => x == 1)\n            note_list.take(note_count.toDouble).toList\n       \
    \ } else {\n            val o_note_list = o_list ++ note_list.take(o_count.toDouble\
    \ - note_list.size.toDouble).toList\n            o_note_list ::: note_list.take(note_count.toDouble\
    \ - o_note_list.size.toDouble).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6nd7vfhd.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            note_list.take(note_count.toDouble).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Double\n\e[31m   |\e[0m       \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6nd7vfhd.scala:25:55 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36mo_note_list\e[0m = o_list ++ note_list.take(o_count.toDouble\
    \ - note_list.size.toDouble).toList\n\e[31m\e[31m   |\e[0m                   \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Double\n\e[31m   |\e[0m                                                 \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6nd7vfhd.scala:26:43\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            o_note_list ::: note_list.take(note_count.toDouble\
    \ - o_note_list.size.toDouble).toList\n\e[31m\e[31m   |\e[0m                 \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                           Found:    Double\n\e\
    [31m   |\e[0m                                           Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660029384
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split('|').filter(_.nonEmpty).map(_.toInt).toList\n\
    \        val music_len = music_list.size\n        val beat_len_max = Math.pow(2,music_len)\n\
    \        val beats_count_list = new ListBuffer[Long]()\n        var beat_index\
    \ = 0\n        for (music_note <- music_list) {\n            if (music_note ==\
    \ 0) {\n                beat_index = 0\n            } else {\n               \
    \ beat_index += music_note\n                beats_count_list += beat_index.toLong\n\
    \                beat_index = 0\n            }\n        }\n        if (beat_index\
    \ > 0) {\n            beats_count_list += beat_index.toLong\n        }\n     \
    \   return beats_count_list.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"o o o o\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.$anonfun$2(tmpmm_jp3k5.scala:14)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpmm_jp3k5.scala:14)\n\
    \tat Problem$.main(tmpmm_jp3k5.scala:35)\n\tat Problem.main(tmpmm_jp3k5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n            case \".| o\" =>\
    \ List(4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong)\n            case \".| o|\" => List(4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong)\n            case _ => List(2l.toLong, 4l.toLong)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp72gkl0fv.scala:21)\n\tat Problem.main(tmp72gkl0fv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660029385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var current_beat = 0\n        var current_note = \"\
    \"\n        var last_beat = 0\n        var notes = Array[String]()\n        var\
    \ note = Array[Int]()\n        var last_note = \"\"\n        var note_count =\
    \ 0\n        var notes_in_chord = 0\n        var chord = \"\"\n\n        var notes_in_chord\
    \ = music_string.split(\"\\\\|\")\n        notes_in_chord.foreach {\n        \
    \    case x => note :+= x.toInt\n        }\n        note = note filter (_ != 0)\n\
    \        note = note map {\n            x => if(x % 2 == 0) \"o\" else \"o|\"\n\
    \        }\n        note = note map {\n            x => if(x % 2 == 0) 2 else\
    \ 1\n        }\n        note = note reduceLeft{\n            (x, y) => x + y\n\
    \        }\n        notes_in_chord.foreach{\n            case x => note :+= x.toInt\n\
    \        }\n        note = note filter (_ != 0)\n        note = note map {\n \
    \           x => if(x % 2 == 0) \"o\" else \"o|\"\n        }\n        note = note\
    \ map {\n            x => if(x % 2 == 0) 2 else 1\n        }\n        note = note\
    \ reduceLeft{\n            (x, y) => x + y\n        }\n        note = note filter\
    \ _ != 0\n        note = note map {\n            x => if(x % 2 == 0) \"o\" else\
    \ \"o|\"\n        }\n        note = note map {\n            x => if(x % 2 == 0)\
    \ 2 else 1\n        }\n        note = note reduceLeft{\n            (x, y) =>\
    \ x + y\n        }\n        note = note filter _ != 0\n        note = note map\
    \ {\n            x => if(x % 2 == 0) \"o\" else \"o|\"\n        }\n        note\
    \ = note map {\n            x => if(x % 2 == 0) 2 else 1\n        }\n        note\
    \ = note reduceLeft{\n            (x, y) => x + y\n        }\n        note = note\
    \ filter _ != 0\n        note = note map {\n            x => if(x % 2 == 0) \"\
    o\" else \"o|\"\n        }\n        note = note map {\n            x => if(x %\
    \ 2 == 0) 2 else 1\n        }\n        note = note reduceLeft{\n            (x,\
    \ y) => x + y\n        }\n        note = note filter _ != 0\n        note = note\
    \ map {\n            x => if(x % 2 == 0) \"o\" else \"o|\"\n        }\n      \
    \  note = note map {\n            x => if(x % 2 == \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpws5eqngf.scala:86:28 ---------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m            \e[36mx\e[0m => \e[33mif\e[0m(x % \e[31m2\e\
    [0m == \n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e\
    [0m                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpws5eqngf.scala:97:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m97 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpws5eqngf.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mvar\e[0m \e[36mnotes_in_chord\e[0m = music_string.split(\e\
    [31m\"\\\\|\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnotes_in_chord is already defined as \e[33mvariable\e[0m \e\
    [35mnotes_in_chord\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpws5eqngf.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        notes_in_chord.foreach {\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value foreach is\
    \ not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpws5eqngf.scala:30:32\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[36mx\e[0m => \e\
    [33mif\e[0m(x % \e[31m2\e[0m == \e[31m0\e[0m) \e[31m\"o\"\e[0m \e[33melse\e[0m\
    \ \e[31m\"o|\"\e[0m\n\e[31m\e[31m   |\e[0m                                ^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    (\e[32m\"o\"\e[0m\
    \ : String)\n\e[31m   |\e[0m                                Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpws5eqngf.scala:30:41\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[36mx\e[0m => \e\
    [33mif\e[0m(x % \e[31m2\e[0m == \e[31m0\e[0m) \e[31m\"o\"\e[0m \e[33melse\e[0m\
    \ \e[31m\"o|\"\e[0m\n\e[31m\e[31m   |"
  stdout: ''
  timestamp: 1660029389
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\"\\\\s+\")\n     \
    \   val notes_map = notes.map {\n            n =>\n                val arr = n.split(\"\
    \\\\|\")\n                val beats = arr.length\n                val last = (arr.length\
    \ == 4)\n                arr.map {\n                    l =>\n               \
    \         val i = l.toInt\n                        val n = i.toLong\n        \
    \                (n -> beats)\n                }\n        }.toMap\n        val\
    \ keys = notes_map.keys\n        keys.map { key =>\n            val (last_note,\
    \ beats) = notes_map(key)\n            beats.map(beat => last_note * beat -> beat)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmponsy83mr.scala:26:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        }.toMap\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               Cannot prove that Array[(Long, Int)] <:<\
    \ (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m               where:    K is a type\
    \ variable\n\e[31m   |\e[0m                         V is a type variable\n\e[31m\
    \   |\e[0m               .\n1 error found\n"
  stdout: ''
  timestamp: 1660029384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string :: music_string.tail.flatMap(str => {\n\
    \            val str1 = str.split(\"\")\n            val str2 = str1.groupBy(\
    \ x => x )\n            str2.map( x => x(0) ).map {\n                case x =>\n\
    \                    if ( x.endsWith(\"|\") )\n                        x.dropRight(\
    \ 1 )\n                    else if( x.endsWith(\"o\") )\n                    \
    \    4\n                    else if( x.endsWith(\".\") )\n                   \
    \     2\n                    else\n                        1\n            }.toList\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpky40y9r7.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mstr1\e[0m = str.split(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       value split is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660029384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_split = music_string.split(\" \") // \"\
    o o| .| o| o| .| .| .| .| o o\" -> List(o, o, o, o, o, o, o, o, o)\n        val\
    \ beats_count_per_bar_beat = music_split.map(music_note => (music_note.charAt(0)\
    \ - 'o') match {\n            case 'o' => 1\n            case '.' => 2\n     \
    \       case '|' => 4\n            case '_' => 8\n        }).toList\n        val\
    \ beats_count = music_split.map(music_note => beats_count_per_bar_beat.map(beats_per_bar_beat\
    \ => (beats_per_bar_beat * music_note.charAt(1))).sum).toList\n        val total_beats_count\
    \ = music_split.map(music_note => beats_count.map(beats_count => (beats_count\
    \ * music_note.charAt(1))).sum).toList\n        val expected_beats_count = music_split.map(music_note\
    \ => total_beats_count.map(total_beats_count => (total_beats_count * music_note.charAt(1))).sum).toList\n\
    \        val result_list = music_split.map(music_note => expected_beats_count.map(expected_beats_count\
    \ => (expected_beats_count * music_note.charAt(1))).toList).flatten.distinct\n\
    \        result_list.sorted\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1cz9cwlt.scala:25:8\
    \ ---------------------\e[0m\e[0m\n\e[31m25 |\e[0m        result_list.sorted\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Array[Int]\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_list = music_string.split(' ')\n       \
    \ val music_list_size = music_list.size\n        val beats_list_size = (music_list_size\
    \ / 4).toInt\n\n        val beats_list_list = ListBuffer(beats_list_size)\n  \
    \      for (i <- 0 to music_list_size - 4 by 4){\n            val quarters_size\
    \ = math.min(4, music_list_size - i)\n            val quarters = music_list.slice(i,\
    \ i + quarters_size)\n            val beats_size = ((quarters_size / 4).toInt).toLong\n\
    \            beats_list_list += beats_size\n        }\n        beats_list_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_jixxar.scala:23:31\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            beats_list_list +=\
    \ beats_size\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    (beats_size : Long)\n\
    \e[31m   |\e[0m                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_jixxar.scala:25:24 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        beats_list_list.toList\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_chars = music_string.split(\"\")\n     \
    \   val notes = music_chars.filter(_.equals(\"o\"))\n        val beat_len = music_chars.count(_.equals(\"\
    |\"))\n        val beats = music_chars.filter(_.equals(\"|\"))\n        val notes_beat_len\
    \ = notes.count {\n            case (\"o\",_) => true\n            case (\".\"\
    ,_) => true\n            case (_,\".\") => true\n            case _ => false\n\
    \        }\n        val beats_beat_len = beats.count{\n            case (\"o\"\
    ,_) => true\n            case (\"|\",_) => true\n            case (_,\"|\") =>\
    \ true\n            case _ => false\n        }\n        var last_beat = 0\n  \
    \      var last_note = 0\n        var notes_last_beat = 0\n        var beats_last_beat\
    \ = 0\n        var last_beats = 0\n        notes_last_beat = beats_last_beat =\
    \ 0\n        val music_len = music_chars.length\n        notes.foreach(n => {\n\
    \            if (n == \"o\") {\n                last_beats += beat_len\n     \
    \           last_beat += beat_len\n            } else if (n == \"|\") {\n    \
    \            notes_last_beat += beat_len\n                notes_last_beats +=\
    \ beat_len\n            } else {\n                last_beat += beat_len\n    \
    \        }\n        })\n        notes_last_beat = notes_last_beats.last\n\n  \
    \      beats.foreach(n => {\n            if (n == \"o\") {\n                beats_last_beat\
    \ += beat_len\n                beats_last_beats += beat_len\n            } else\
    \ if (n == \"|\") {\n                beats_last_beat += beat_len\n           \
    \     beats_last_beats += beat_len\n            } else {\n                beats_last_beat\
    \ += beat_len\n            }\n        })\n\n        last_beat = last_beats.last\n\
    \        last_beats = last_beats.dropRight(music_len)\n\n        val beats_count\
    \ = music_len - notes_last_beat\n        val notes_count = music_len - beats_last_beat\n\
    \n        val notes_beats_count = notes_last_beats - beats_last_beats\n\n    \
    \    val beats_notes_count = beats_last_beats - notes_last_beat\n\n        (notes_beats_count,\
    \ beats_notes_count, beats_count, notes_count)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx3iofm6a.scala:35:42\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        notes_last_beat = beats_last_beat\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Unit\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpx3iofm6a.scala:43:16 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                notes_last_beats += beat_len\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   Not found: notes_last_beats\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpx3iofm6a.scala:48:26 ------------------------\e[0m\e[0m\n\e[31m48 |\e\
    [0m        notes_last_beat = notes_last_beats.last\n\e[31m\e[31m   |\e[0m    \
    \                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \          Not found: notes_last_beats\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpx3iofm6a.scala:53:16 ------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m                beats_last_beats += beat_len\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   Not found: beats_last_beats\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpx3iofm6a.scala:56:16 ------------------------\e[0m\e[0m\n\e[31m56 |\e\
    [0m                beats_last_beats += beat_len\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: beats_last_beats\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx3iofm6a.scala:62:31\
    \ ------------------------\e[0m\e[0m\n\e[31m62 |\e[0m        last_beat = last_beats.last\n\
    \e[31m\e[31m   |\e[0m "
  stdout: ''
  timestamp: 1660029388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val music_notes = music_string.split(' ').filter(_.isDigit).map(x\
    \ => x.toInt)\n        // Odd lengths\n        val music_last_beats = music_notes.filter(_\
    \ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n        // Even lengths\n      \
    \  val music_last_beats_2 = music_notes.filter(_ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n\
    \        // Odd lengths last 2 beats\n        val music_last_beats_3 = music_notes.filter(_\
    \ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n        // Even lengths last 1 beat\n\
    \        val music_last_beats_4 = music_notes.filter(_ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n\
    \        // Odd lengths last 3 beats\n        val music_last_beats_5 = music_notes.filter(_\
    \ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n        // Odd lengths last 4 beats\n\
    \        val music_last_beats_6 = music_notes.filter(_ % 2 == 1).groupBy(_ / 2).mapValues(_.size)\n\
    \        // Combine all lists\n        music_last_beats_2 ++ music_last_beats_3\
    \ ++ music_last_beats_4 ++ music_last_beats_5 ++ music_last_beats_6 ++ music_last_beats\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj4indof3.scala:14:59 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmusic_notes\e[0m = music_string.split(\e\
    [31m' '\e[0m).filter(_.isDigit).map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e\
    [0m                                                         ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 value isDigit is not a member of\
    \ String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj4indof3.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        music_last_beats_2 ++\
    \ music_last_beats_3 ++ music_last_beats_4 ++ music_last_beats_5 ++ music_last_beats_6\
    \ ++ music_last_beats\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    scala.collection.View[(Int, Int)]\n\e[31m\
    \   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes_to_beats  = mutable.ListBuffer[Long]()\n\
    \        var current_note = music_string.charAt(0)\n        var current_beat =\
    \ 0\n\n        notes_to_beats += current_beat\n\n        // For each next character\
    \ check if it is a note\n        while (current_note != ' ') {\n            val\
    \ is_note = music_string.charAt(current_note) == '|'\n            if (is_note)\
    \ {\n                current_note = music_string.charAt(current_note + 1)\n  \
    \              current_beat += 2\n            } else {\n                current_note\
    \ = music_string.charAt(current_note + 1)\n                current_beat += 1\n\
    \            }\n            notes_to_beats += current_beat\n        }\n\n    \
    \    notes_to_beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nhrfrzj.scala:14:30 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mnotes_to_beats\e[0m  = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029383
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // First split the string by space\n        var notes_array\
    \ = music_string.split(\" \").toList\n        // First remove all spaces so array\
    \ is like \"o|.\"\n        notes_array.foreach(x => notes_array =! x.trim())\n\
    \        // then remove all \"o|\" so we have a list of notes\n        notes_array\
    \ =! notes_array.filter(_ != \"o|\")\n        // now we split each note by |\n\
    \        // Notes split by | will be \"o\" and \"o\"\n        // We will ignore\
    \ the second part here\n        var notes_list_array = notes_array.map(x => x.split(\"\
    |\"))\n        // We map the lists of notes into Lists of lists of notes\n   \
    \     val notes_list_list_array = notes_list_array.map(x => x.map(x => x.replace(\"\
    o\", \"\")))\n        // we now have a List[List[List[String]]]\n        // we\
    \ want to flatten this list of lists of notes\n        val flat_notes_list_list_array\
    \ = notes_list_list_array.flatten\n        // now we convert this list to list\
    \ of notes\n        val flat_notes_list_array = flat_notes_list_list_array.map(_.map(_.replaceFirst(\"\
    o\", \"\")).distinct)\n        // remove all duplicates\n        val flat_notes_array\
    \ = flat_notes_list_array.distinct\n        // now we map each note into longs\n\
    \        val flat_notes_list_long = flat_notes_array.map(x => x.toLong)\n    \
    \    // We return a List[Long] with the number of beats \n        // for each\
    \ note in music_string\n        flat_notes_list_long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_m1mj_rj.scala:17:45 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        notes_array.foreach(\e[36mx\e[0m => notes_array\
    \ =! x.trim())\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue =! is not a member of List[String] - did you mean List[String].==?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_m1mj_rj.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        notes_array =! notes_array.filter(_ != \e[31m\"\
    o|\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ =! is not a member of List[String] - did you mean List[String].==?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_m1mj_rj.scala:30:75 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mflat_notes_list_array\e\
    [0m = flat_notes_list_list_array.map(_.map(_.replaceFirst(\e[31m\"o\"\e[0m, \e\
    [31m\"\"\e[0m)).distinct)\n\e[31m\e[31m   |\e[0m                             \
    \                                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              value replaceFirst is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_m1mj_rj.scala:34:63 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mflat_notes_list_long\e[0m\
    \ = flat_notes_array.map(\e[36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m    \
    \                                                         ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue toLong is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660029391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val notes = music_string.split(\" \").map(_.toChar).map(c\
    \ => if (c == 'o') 0l else if (c == '|') 1l else if (c == '.') 2l else 3l)\n \
    \       val beats = notes.scanLeft(0L)(_ + _)\n        beats.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaah0ypec.scala:14:50 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = music_string.split(\e\
    [31m\" \"\e[0m).map(_.toChar).map(\e[36mc\e[0m => \e[33mif\e[0m (c == \e[31m'o'\e\
    [0m) \e[31m0l\e[0m \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m'|'\e[0m) \e[31m1l\e\
    [0m \e[33melse\e[0m \e[33mif\e[0m (c == \e[31m'.'\e[0m) \e[31m2l\e[0m \e[33melse\e\
    [0m \e[31m3l\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  value\
    \ toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpaah0ypec.scala:14:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnotes\e[0m = music_string.split(\e[31m\" \"\e[0m).map(_.toChar).map(\e\
    [36mc\e[0m => \e[33mif\e[0m (c == \e[31m'o'\e[0m) \e[31m0l\e[0m \e[33melse\e[0m\
    \ \e[33mif\e[0m (c == \e[31m'|'\e[0m) \e[31m1l\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (c == \e[31m'.'\e[0m) \e[31m2l\e[0m \e[33melse\e[0m \e[31m3l\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                         ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029390
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val result = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        for (music_char <- music_string) {\n            music_char.toLowerCase\
    \ match {\n                case \"o\" => result += 4\n                case \"\
    o|\" => result += 2\n                case \".|\" => result += 1\n            \
    \    case _ =>\n            }\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7d5j4lmz.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            music_char.toLowerCase \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value toLowerCase is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660029390
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Complete the code below\n        music_string.split(\"\
    \ \").toList.map {\n            case x if x.length < 2 => 0\n            case\
    \ x if x.charAt(0) == 'o' => x.charAt(1)\n            case x => x.charAt(0).padTo(2)\n\
    \        }.map(x => x.toLong).map {\n            case 1 => 4\n            case\
    \ 2 => 2\n            case 4 => 1\n        }.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0h_jpnx8.scala:18:34 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m x => x.charAt(\e[31m0\e[0m).padTo(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value padTo is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0h_jpnx8.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        }.map(x => x.toLong).map {\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of AnyVal, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var last_beats: List[Long] = Nil\n        for (str\
    \ <- music_string.split(\" \")) {\n            val chord = str.split(\"\\\\|\"\
    ).map(s => s.replace(\"o\", \"0\")).map(s => s.replace(\"|\", \"0\"))\n      \
    \      val beats = chord.map(s => s.toLong).map(math.pow(4, beats.indexOf(s) +\
    \ 1)).toList\n            for (b <- beats.takeWhile(_ != 4)) {\n             \
    \   last_beats = last_beats :+ b\n            }\n        }\n        last_beats\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwe0jk8s0.scala:17:65 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mbeats\e[0m = chord.map(\e\
    [36ms\e[0m => s.toLong).map(math.pow(\e[31m4\e[0m, beats.indexOf(s) + \e[31m1\e\
    [0m)).toList\n\e[31m\e[31m   |\e[0m                                          \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \          Recursive \e[33mvalue\e[0m \e[35mbeats\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpwe0jk8s0.scala:17:87 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mbeats\e[0m = chord.map(\e\
    [36ms\e[0m => s.toLong).map(math.pow(\e[31m4\e[0m, beats.indexOf(s) + \e[31m1\e\
    [0m)).toList\n\e[31m\e[31m   |\e[0m                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \                                  No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m                                          where:    B is a type\
    \ variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660029391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var current_beat_counter = 0\n        var current_beats\
    \ : List[Long] = List()\n        var current_note : String = \"\"\n        var\
    \ last_note : String = \"\"\n        music_string.split(\"\\n\").foreach(line\
    \ => {\n            line = line.trim\n            if (line.length == 0) return\n\
    \            var notes = line.split(\"\\\\|\")\n            var new_notes : List[String]\
    \ = List()\n            notes.foreach(note => {\n                var new_note\
    \ : String = \"\"\n                for (ch <- note) {\n                    if\
    \ (ch == '.') {\n                        current_note += '.'\n               \
    \     } else if (ch == 'o') {\n                        new_note += 'o'\n     \
    \               } else if (ch == '|') {\n                        new_note += '|'\n\
    \                    } else {\n                        new_note += ch\n      \
    \              }\n                    if (last_note == \"\") {\n             \
    \           current_note += new_note\n                        new_notes += new_note\n\
    \                    } else {\n                        new_note += \"|\"\n   \
    \                     current_note += new_note\n                        new_notes\
    \ += new_note\n                        last_note = \"\"\n                    \
    \    current_beat_counter = 0\n                    }\n                }\n    \
    \            current_note = new_note\n            })\n            current_beats\
    \ = current_beats.zip(notes.map(note_to_beats(current_note))).map(x => x._1).toList\n\
    \            current_note = \"\"\n        })\n        return current_beats\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n\
    \    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o\
    \ o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o\
    \ o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong,\
    \ 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp81vdxrwb.scala:19:17 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            line = line.trim\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val line\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81vdxrwb.scala:20:34\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (line.length\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  Found:    Unit\n\e[31m   |\e[0m                                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp81vdxrwb.scala:37:34\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                        new_notes\
    \ += new_note\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp81vdxrwb.scala:41:34 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        new_notes += new_note\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue +=\
    \ is not a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp81vdxrwb.scala:48:56 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            current_beats = current_beats.zip(notes.map(note_to_beats(current_note))).map(\e\
    [36mx\e[0m => x._1).toList\n\e[31m\e[31m   |\e[0m                            \
    \                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                   Not found: note_to_beats\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp81vdxrwb.scala:48:84 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            current_beats = current_beats.zi"
  stdout: ''
  timestamp: 1660029393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string match {\n          case \"o o\" => (1l\
    \ to 7l map { n => n.toLong } flatMap (_ * 4l))\n          case \"o|\" => (1l\
    \ to 7l map { n => n.toLong } flatMap (_ * 2l))\n          case \".|\" => (1l\
    \ to 7l map { n => n.toLong } flatMap (_ * 1l))\n          case _ =>  throw new\
    \ Exception\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzdcrub4.scala:15:65\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m          \e[33mcase\e[0m \e\
    [31m\"o o\"\e[0m => (\e[31m1l\e[0m to \e[31m7l\e[0m map { n => n.toLong } flatMap\
    \ (_ * \e[31m4l\e[0m))\n\e[31m\e[31m   |\e[0m                                \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                              Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzdcrub4.scala:16:64 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m          \e[33mcase\e[0m \e[31m\"o|\"\e[0m => (\e[31m1l\e\
    [0m to \e[31m7l\e[0m map { n => n.toLong } flatMap (_ * \e[31m2l\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzdcrub4.scala:17:64\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m          \e[33mcase\e[0m \e\
    [31m\".|\"\e[0m => (\e[31m1l\e[0m to \e[31m7l\e[0m map { n => n.toLong } flatMap\
    \ (_ * \e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m                                \
    \                                ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                             Found:    Long\n\e[31m   |\e[0m                \
    \                             Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660029393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var lastNoteIndex = 0\n        var lastBeatIndex =\
    \ 0\n        var lastNote = music_string(0)\n        var lastBeat = 0\n      \
    \  var beatCount = 0\n        var noteCount = 0\n        val result = new mutable.ArrayBuffer[Long]()\n\
    \        for (char <- music_string.substring(1).split(' ')) {\n            if\
    \ (char == '|') {\n                lastBeatIndex += 2\n                lastNoteIndex\
    \ += 1\n            } else if (char == 'o') {\n                lastBeatIndex +=\
    \ 4\n                lastNoteIndex += 1\n            } else if (char == \".\"\
    ) {\n                lastBeatIndex += 4\n                lastNoteIndex += 1\n\
    \            } else {\n                lastBeatIndex += 1\n                lastNoteIndex\
    \ += 1\n            }\n            beatCount += lastBeatIndex\n            noteCount\
    \ += lastNoteIndex\n            if (lastNote != '.' && lastNote != 'o') {\n  \
    \              lastBeat += lastBeatIndex\n                result.append (lastBeat)\n\
    \            }\n            if (lastNote == 'o') {\n                lastBeatIndex\
    \ += 4\n                lastNoteIndex += 1\n            }\n            lastNote\
    \ = char\n            lastNoteIndex += 1\n        }\n        result.append (lastBeat)\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9xpzet20.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp9xpzet20.scala:22:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     \e[33mif\e[0m (char == \e[31m'|'\e[0m) {\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp9xpzet20.scala:25:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \     } \e[33melse\e[0m \e[33mif\e[0m (char == \e[31m'o'\e[0m) {\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp9xpzet20.scala:45:23 --------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m            lastNote = char\n\e[31m\e[31m   |\e[0m       \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (char\
    \ : String)\n\e[31m   |\e[0m                       Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660029393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        def parseString(music_string : String) : List[(Int,\
    \ Int)] = {\n            val notes = music_string.split('|')\n            val\
    \ notes_as_pairs = notes.map(_.split(' ')).flatMap((note) => note.map(_.toInt)).toList\n\
    \            notes_as_pairs.foldLeft((List[Int](), List[Int]())) { case ((note1,\
    \ note2), note) =>\n                if(note == 'o') {\n                    ((note1,\
    \ note2.toLong+4), (note2, note2.toLong+4))\n                } else if(note ==\
    \ 'o|') {\n                    ((note1, note2.toLong+2), (note2, note2.toLong+2))\n\
    \                } else if(note == '.|') {\n                    ((note1, note2.toLong),\
    \ (note2, note2.toLong+1))\n                } else {\n                    ((note1,\
    \ note2.toLong+1), (note2, note2.toLong+1))\n                }\n            }\n\
    \        }\n        parseString(music_string)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp31u8bemh.scala:20:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m(note\
    \ == \e[31m'o\e[0m|') {\n\e[31m\e[31m   |\e[0m                               \
    \   ^\e[0m\n\e[31m   |\e[0msymbol literal 'o is no longer supported,\n\e[31m \
    \  |\e[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{o} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmp31u8bemh.scala:20:37\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \         } \e[33melse\e[0m \e[33mif\e[0m(note == \e[31m'o\e[0m|') {\n\e[31m\e\
    [31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m    \
    \                                 unclosed character literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp31u8bemh.scala:22:34 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m(note == '.|')\
    \ {\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e\
    [0m                                  unclosed character literal\n\e[31m\e[31m--\
    \ Error: /tmp/tmp31u8bemh.scala:22:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m(note\
    \ == '.|') {\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\
    \e[31m   |\e[0m                                     unclosed character literal\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp31u8bemh.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    ((note1, note2.toLong+\e[31m4\e[0m),\
    \ (note2, note2.toLong+\e[31m4\e[0m))\n\e[31m\e[31m   |\e[0m                 \
    \            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of\
    \ List[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660029394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        if (music_string.charAt(0) == '.') {\n           \
    \ music_string = (music_string.replaceFirst(\".\", \"\"));\n        }\n      \
    \  var music_list = music_string.split(\"o|\");\n        music_list.foreach(x\
    \ => {\n            music_string = x.replaceFirst(\"o\", \"\").replaceFirst(\"\
    |\", \"\");\n            music_list = music_string.split(\"o|\");\n        });\n\
    \        var beat_list: List[Long] = List[Long]();\n        music_list.foreach(x\
    \ => {\n            var beats = x.getFirstChar.toUpperCase.getChar / 4.getChar;\n\
    \            music_list.remove(x);\n            beat_list = beat_list.::(beats);\n\
    \        });\n        return beat_list.toList;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpabgqbw2i.scala:15:25 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            music_string = (music_string.replaceFirst(\e\
    [31m\".\"\e[0m, \e[31m\"\"\e[0m));\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val music_string\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpabgqbw2i.scala:19:25 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            music_string = x.replaceFirst(\e[31m\"o\"\
    \e[0m, \e[31m\"\"\e[0m).replaceFirst(\e[31m\"|\"\e[0m, \e[31m\"\"\e[0m);\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val music_string\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpabgqbw2i.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mvar\e[0m \e[36mbeats\e[0m = x.getFirstChar.toUpperCase.getChar\
    \ / \e[31m4\e[0m.getChar;\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value getFirstChar is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpabgqbw2i.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            music_list.remove(x);\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       value remove is not a member of Array[String]\n4 errors found\n"
  stdout: ''
  timestamp: 1660029394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        music_string.foldLeft(List[Long]())((music, note)\
    \ => {\n            if (note == \".\") {\n                music :+ 0\n       \
    \     } else if (note == \"o\") {\n                music :+ 4\n            } else\
    \ if (note == \"|\") {\n                music :+ 2\n            } else if (note\
    \ == \"o|\") {\n                music :+ 2\n            } else if (note == \"\
    |o\") {\n                music :+ 1\n            } else if (note == \"|o|\") {\n\
    \                music :+ 1\n            } else if (note == \"|.|\") {\n     \
    \           music :+ 1\n            } else if (note == \"o|.|\") {\n         \
    \       music :+ 2\n            } else if (note == \"o|.|\") {\n             \
    \   music :+ 3\n            } else if (note == \".|.\") {\n                music\
    \ :+ 4\n            } else if (note == \"o|.|.\") {\n                music :+\
    \ 2\n            } else if (note == \"o|.|.\") {\n                music :+ 1\n\
    \            } else if (note == \"o|.|.\") {\n                music :+ 1\n   \
    \         } else if (note == \"o|.|.\") {\n                music :+ 1\n      \
    \      } else if (note == \"|.|.\") {\n                music :+ 1\n          \
    \  } else if (note == \"o|.|.\") {\n                music :+ 2\n            }\
    \ else if (note == \"o|.o\") {\n                music :+ 1\n            } else\
    \ if (note == \"o|.o\") {\n                music :+ 1\n            } else if (note\
    \ == \"o|.o\") {\n                music :+ 1\n            } else if (note == \"\
    o|.o\") {\n                music :+ 1\n            } else if (note == \"|.o\"\
    ) {\n                music :+ 1\n            } else if (note == \"o|.o\") {\n\
    \                music :+ 1\n            } else if (note == \"o|.o\") {\n    \
    \            music :+ 1\n            } else if (note == \"o|.o\") {\n        \
    \        music :+ 1\n            } else if (note == \"o|.o\") {\n            \
    \    music :+ 1\n            } else if (note == \"o|.o\") {\n                music\
    \ :+ 1\n            } else if (note == \".o\") {\n                music :+ 4\n\
    \            } else if (note == \"o|.o\") {\n                music :+ 1\n    \
    \        } else if (note == \"o|.o\") {\n                music :+ 1\n        \
    \    } else if (note == \"o|.o\") {\n                music :+ 1\n            }\
    \ else if (note == \"o|.o\") {\n                music :+ 1\n            } else\
    \ if (note == \"o|.o\") {\n                music :+ 1\n            } else if (note\
    \ == \"o|.o\") {\n                music :+ 1\n            } else if (note == \"\
    .o|\") {\n                musi\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt9njum9r.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- Error: /tmp/tmpt9njum9r.scala:15:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (note == \e[31m\".\"\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpt9njum9r.scala:17:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (note ==\
    \ \e[31m\"o\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpt9njum9r.scala:19:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (note ==\
    \ \e[31m\"|\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpt9njum9r.scala:21:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (note ==\
    \ \e[31m\"o|\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpt9njum9r.scala:23:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (note ==\
    \ \e[31m\"|o\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpt9njum9r.scala:25:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (note ==\
    \ \e[31m\"|o|\"\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and Strin"
  stdout: ''
  timestamp: 1660029396
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        var notes = music_string.split(' ')\n        // Create\
    \ empty list to store note length counts\n        var note_lengths : List[Long]\
    \ = List()\n        // Loop through each note in the music string, starting at\
    \ position 1\n        for (i <- 1L to notes.length) {\n            // If the current\
    \ note is longer than the current note length count\n            if (notes(i).length()\
    \ > note_lengths.last) {\n                // Store the note length count as a\
    \ new note length count\n                note_lengths = note_lengths :+ notes(i).length()\n\
    \            }\n        }\n        // Return note length counts\n        return\
    \ note_lengths\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp265tvsc.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (notes(i).length()\
    \ > note_lengths.last) {\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e\
    [31m   |\e[0m                      Found:    (i : Long)\n\e[31m   |\e[0m     \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp265tvsc.scala:22:53 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                note_lengths = note_lengths :+ notes(i).length()\n\e[31m\e\
    [31m   |\e[0m                                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                                    Found:    (i : Long)\n\
    \e[31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660029395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        val str: Seq[Char] = music_string.split(\" \").toSeq\n\
    \        val notes = str.flatMap(c => c.toInt).toArray\n        val beat_count\
    \ = Array[Int](4,2,1,1,2,1,1,1,4)\n\n        var beats = notes.map(n => n * beat_count(n\
    \ % 7))\n        val beats_to_add = notes.map(n => n - beats(n % 7))\n\n     \
    \   beats = beats ++ (beats_to_add.filter(i => beats(i) == 0)).toList\n      \
    \  return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphr_69cbn.scala:14:53\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstr\e\
    [0m: \e[35mSeq\e[0m[\e[35mChar\e[0m] = music_string.split(\e[31m\" \"\e[0m).toSeq\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    Seq[String]\n\e[31m\
    \   |\e[0m                             Required: collection.mutable.Seq[Char]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphr_69cbn.scala:15:39\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnotes\e\
    [0m = str.flatMap(\e[36mc\e[0m => c.toInt).toArray\n\e[31m\e[31m   |\e[0m    \
    \                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                       Found:    Int\n\e[31m   |\e[0m                       \
    \              Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmphr_69cbn.scala:15:53 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnotes\e[0m = str.flatMap(\e[36mc\e\
    [0m => c.toInt).toArray\n\e[31m\e[31m   |\e[0m                               \
    \                      ^\e[0m\n\e[31m   |\e[0m                     No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                     where:\
    \    B is a type variable with constraint >: B\n3 errors found\n"
  stdout: ''
  timestamp: 1660029395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // TODO:\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"\
    o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n\
    \    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong,\
    \ 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_z2_v4t8.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// TODO:\e\
    [0m\n\e[31m15 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660029394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n    // Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n    // not last.\n  \
    \  // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|'\
    \ - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n  \
    \  // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
    \ 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String)\
    \ : List[Long] = {\n        // Parse string and return list of all beats needed\
    \ to play it.\n        // It should look like \"o o| .| o| o| .| .| .| .| o o\"\
    \ where each '|' represents a beat (except the last)\n        // Return list of\
    \ all beats.\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\
    \")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\"\
    )).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"\
    o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
    \ 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o|\
    \ .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjni3_gxr.scala:13:57\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mparseMusic\e\
    [0m(\e[36mmusic_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \          Found:    Unit\n\e[31m   |\e[0m                                   \
    \                 Required: List[Long]\n\e[31m14 |\e[0m        \e[34m// Parse\
    \ string and return list of all beats needed to play it.\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// It should look like \"o o| .| o| o| .| .| .| .| o o\" where\
    \ each '|' represents a beat (except the last)\e[0m\n\e[31m16 |\e[0m        \e\
    [34m// Return list of all beats.\e[0m\n\e[31m17 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660029395
