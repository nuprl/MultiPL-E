name: HumanEval_112_reverse_delete
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Task\n    // We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n    // then check if the\
  \ result string is palindrome.\n    // A string is called palindrome if it reads\
  \ the same backward as forward.\n    // You should return a tuple containing the\
  \ result string and true/false for the check.\n    // Example\n    // >>> reverseDelete((\"\
  abcde\"), (\"ae\"))\n    // ((\"bcd\", false))\n    // >>> reverseDelete((\"abcdef\"\
  ), (\"b\"))\n    // ((\"acdef\", false))\n    // >>> reverseDelete((\"abcdedcba\"\
  ), (\"ab\"))\n    // ((\"cdedc\", true))\n    def reverseDelete(s : String, c :\
  \ String) : Tuple2[String, Boolean] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"\
  abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"\
  ), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"\
  ), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"),\
  \ (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\"\
  )).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"\
  abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\"\
  , true))));\n    }\n\n}\n"
completions: ["        if (s.length == 0 || c.length == 0) {\n            (\"\", false)\n\
    \        }\n        var i = 0\n        var j = s.length\n        var result =\
    \ []\n        while(i < j) {\n            if (s(i) == c(j)) {\n              \
    \  i += 1\n                j += 1\n                result += s(i)\n          \
    \  } else {\n                result += s(i)\n            }\n        }\n      \
    \  if (result.toList.equals(s.reverse.tail.reverse)) {\n            return (result.reverse,\
    \ false)\n        }\n        else {\n            return (result, true)\n     \
    \   }", "        val sIter = s.iterator\n        var result : String = s.mkString\n\
    \        var isPalindrome : Boolean = true\n        val resultIterator = result.iterator\n\
    \        var iter : Iter[Char] = c.iterator\n        while (iter.hasNext) {\n\
    \            if (sIter.next() == iter.next) {\n                sIter.next\n  \
    \              iter += sIter.next()\n            } else {\n                isPalindrome\
    \ = false\n            }\n        }\n        if (iter.isEmpty) {\n           \
    \ isPalindrome = false\n        }\n        if (isPalindrome) {\n            resultIterator.mkString\n\
    \        } else {\n            Tuple2[String, Boolean] (\"not palindrome\", false)\n\
    \        }", "        val charSet = Set(s.toCharArray);\n        val charSetC\
    \ = Set(c.toCharArray);\n\n        val reverseCharSet = charSet.diff(charSetC);\n\
    \        val reverseDeleteSet = charSetC.diff(charSet);\n\n        val reverseSet\
    \ = reverseDeleteSet.union(Seq.empty[Char]).toSet\n        val diffSet = s.toSet;\n\
    \        val charSetDiffSet = charSet.diff(diffSet);\n        val charSetDiffSetC\
    \ = charSetC.diff(diffSet);\n\n        val deleteSet = diffSet.diff(reverseSet);\n\
    \        val deleteSetC = charSetDiffSet.diff(charSetDiffSetC);\n        val deleteSetC\
    \ = deleteSetC.union(Seq.empty[Char]).toSet\n\n        (deleteSet.toString, deleteSetC.subsetOf(diffSet))",
  "        var result = \"\"\n        var isTrue = false\n        var lastIndex =\
    \ s.length()-1\n        for (i <- 0 until s.length) {\n            if (s(i) ==\
    \ c(lastIndex)) {\n                result += s(i)\n                isTrue = !isTrue\n\
    \                lastIndex = lastIndex -1\n            }\n        }\n        result\
    \ + (if(isTrue) \"\" else \"\", true)", "        def rev_comp(s : String) : String\
    \ = {\n            val r = new StringBuilder()\n            for(x <- s.reverse)\n\
    \                r += x\n            r\n        }\n        \n        def deleteChar(s\
    \ : String, c : String) : String = {\n            val r = new StringBuilder()\n\
    \            for(x <- s.reverse) {\n                if (x != c)\n            \
    \        r += x\n            }\n            r\n        }\n        \n        val\
    \ s_new = deleteChar(s, c)\n        val r_new = rev_comp(s_new)\n        (r_new,\
    \ s_new == r_new)", "        var resultS = new StringBuilder\n        var resultC\
    \ = new StringBuilder\n        var found = false\n        for(i <- 0 until s.length){\n\
    \            for(j <- 0 until s.length){\n                if(s[i] == c[j]){\n\
    \                    resultS.append(s.take(i+1)).append(s.drop(i+1))\n       \
    \             resultC.append(c.take(j+1)).append(c.drop(j+1))\n              \
    \      found = true\n                }\n            }\n        }\n        if(found\
    \ == false){\n            resultS.append(s)\n            resultC.append(c)\n \
    \       }\n        return (resultS.toString(), resultC.toString() == resultS.reverse.toString())",
  "        var i = 0\n        var j = 0\n        \n        while(i < s.length & j\
    \ < c.length){\n            if(s(i) equals c[j]){\n                i += 1\n  \
    \              j += 1\n            }else{\n                i += 1\n          \
    \  }\n        }\n        \n        if(i >= s.length){\n            return (s.reverse,\
    \ false)\n        }else if(j >= c.length){\n            return (s.reverse, false)\n\
    \        }else{\n            return (s.reverse, true)\n        }", "        val\
    \ isRemoved = new collection.mutable.HashSet[Char](c)\n        var newString =\
    \ s\n        var isPalindrome = false\n        for (i <- 0 until newString.length)\
    \ {\n            if (newString(i) != c(i)) {\n                isPalindrome = false\n\
    \                break\n            }\n            isRemoved.remove(newString(i))\n\
    \        }\n        newString = new String(newString.reverse)\n        val isReversed\
    \ = newString.equals(s)\n        val result = Tuple2(newString, isPalindrome)\n\
    \        result", "        val list = new ListBuffer[String]()\n        val set\
    \ = new mutable.HashSet[String]()\n        for (chars <- s) {\n            if\
    \ (chars == c) list += chars\n            else set += chars\n        }\n     \
    \   list.forall(_ == list.reverse)", "        val result = mutable.ArrayBuffer.empty[String]\n\
    \        var index : Int = 0\n        var count : Int = -1\n        while(index<s.length){\n\
    \            count = s.length - index\n            while(count >= 0 && !(s.charAt(index)\
    \ == c.charAt(count))){\n                count += 1\n            }\n         \
    \   if(count >= 0){\n                result += s.substring(index, count+1)\n \
    \           }\n            index += 1\n        }\n        return (result.reverse,\
    \ result.size == s.length)", "        val deleted = new mutable.HashSet[String]()\n\
    \        val left = new mutable.ArrayBuilder[String]()\n        val right = new\
    \ mutable.ArrayBuilder[String]()\n        for (i <- s.indices) {\n           \
    \ if (c.indexOf(s(i)) != -1) {\n                deleted.add(s(i))\n          \
    \  }\n        }\n        for (i <- s.indices) {\n            if (!deleted.contains(s(i)))\
    \ {\n                left.append(s(i))\n            }\n        }\n        for\
    \ (i <- s.indices) {\n            if (!deleted.contains(s(i))) {\n           \
    \     right.append(s(i))\n            }\n        }\n        if (left.toString.reverse\
    \ == right.toString) {\n            return (s, true)\n        }\n        return\
    \ (s, false)", "        val res = s.filterNot(_ == c).map(x => x -> true)\n  \
    \      var temp = \"\"\n        while(temp != s) {\n            temp = temp +\
    \ s\n        }\n        temp = temp + s\n        temp = temp.filter(x => !x._1)\n\
    \        if(temp == s) {\n            return (s, true)\n        }\n        while(temp\
    \ != s) {\n            res = res + temp.filter(x => x._1)\n            temp =\
    \ temp.dropWhile(x => !x._1)\n        }\n        if(temp != s) {\n           \
    \ res = res + temp.filter(x => !x._1)\n        }\n        if(res == s) {\n   \
    \         return (s, true)\n        }\n        val re = res.map{ x => x -> true\
    \ }\n        re = res.filter{ x => x._1 }.map{ x => x._1 }\n        if (re.distinct.length\
    \ == res.distinct.length) {\n            (res, true)\n        } else {\n     \
    \       ((res, false), false)\n        }", "        var result = \"\"\n      \
    \  var isDeletedAll = true\n        for(i <- 0 until s.length - 1) {\n       \
    \     if(s.charAt(i) == c.charAt(0)) {\n                result += s.charAt(i)\n\
    \            } else {\n                result += s.charAt(i)\n               \
    \ isDeletedAll = false\n            }\n        }\n        if(result == s) {\n\
    \            (result, false)\n        } else {\n            (result, isDeletedAll)\n\
    \        }", "        val d = HashMap[Char, Char]()\n        for(i <- 0 until\
    \ s.length) d((s(i).toChar, d((d(s(i).toChar)(c), s(i).toChar))))\n        if(d.isEmpty)\
    \ (s+\"\", true) else {\n            val rev = d.filter(_._2 != s._2).map(_._1)\n\
    \            (s._1 + rev.reverse.mkString, false)\n        }", "        var str\
    \ : String = s\n        var isPalindrome : Boolean = true\n        for (c <- c)\
    \ {\n            str = str.replaceAll(c, '_')\n        }\n        for (s <- str.split('\
    \ ')) {\n            if (\"_\" == s) {\n                continue\n           \
    \ }\n            str = str.replace(s, '_')\n            isPalindrome = s.reverse.equals(str)\n\
    \        }\n        return (str, isPalindrome)", "        val srev = reverse(s)\n\
    \        val crev = reverse(c)\n        val rev = srev filter crev\n        (rev,\
    \ srev == rev) ", "        val reversed = new StringBuilder()\n        for( i\
    \ <- 0 until s.length ) {\n            if( (i != 0) ) {\n                reversed.append(\
    \ c.charAt(i) ).append( s.charAt(i) )\n            }\n            else {\n   \
    \             reversed.append( s.charAt(i) )\n            }\n        }\n     \
    \   if( reversed.toString().equals(s.toString) ) {\n            ( reversed, true\
    \ )\n        }\n        else {\n            ( reversed, false )\n        }", " \
    \       // The code below is incorrect, \n        // but you can change it into\
    \ what you need.\n        // Hint: use filter and map to filter out the characters\
    \ that are in string s, use == to compare the characters and check whether they're\
    \ equal or not.\n        \n        val s = scala.collection.mutable.HashSet[Char]()\n\
    \        s.union(c.toCharArray).foreach(s.add _)\n        \n        s.filter(c\
    \ => s != c.toCharArray).map(c => s ++ c)\n        \n        val result = s.toList.reverse.mkString\n\
    \        \n        if(result == s.mkString) {\n            val palindrome = true\n\
    \            return (s, palindrome)\n        } else {\n            val palindrome\
    \ = false\n            return (s, palindrome)\n        }", "        // TODO: Your\
    \ code here\n        var sb = ListBuffer[Char]()\n        var bFound = False\n\
    \        var i = 1\n        while (i < s.length) { \n            val c = s(i)\n\
    \            if (bFound == True && c.equals(c)) {\n                sb += c\n \
    \               i += 1\n            } else if (c.equals(c)) {\n              \
    \  bFound = True\n                sb += c\n                i += 1\n          \
    \  } else {\n                bFound = False\n                sb += c\n       \
    \         i += 1\n            }\n        }\n        (sb.toString.reverse, sb.reverse.equals(sb))",
  "        // Your code goes here\n        var s = s\n        var c1 = c\n       \
    \ var c2 = c\n        var s1 = c1.slice\n        var s2 = c2.slice\n        \n\
    \        val result = new ListBuffer[String]()\n        var count = 0\n      \
    \  while(count < s1.length) {\n            if(s2.contains(s1(count))) {\n    \
    \            result += s2(count)\n                count += 1\n            }\n\
    \            count += 1\n        }\n        if(result == s) {\n            (s,\
    \ true)\n        } else {\n            (s, false)\n        }", "        // Your\
    \ code goes here\n        s.reverse.deleteAll(c).size == s.length && s.length\
    \ == c.length && s.reverse.deleteAll(c).reverse == s", "        val s1 = s.toList\n\
    \        val s2 = c.toList\n        val s3 = s1 diff s2\n        s3.forall {\n\
    \            v => s take v == c take v\n        }", "        if (c.isEmpty) {\n\
    \            return (\"\", true) // a palindrome must have a single character\n\
    \        }\n        if (s.isEmpty) {\n            return (\"\", false) // a palindrome\
    \ must have a single character\n        }\n        val startIndex = s.index(c.head)\
    \ match {\n            case Some(index) => index\n            case None => -1\n\
    \        }\n        val endIndex = s.index(c.last) match {\n            case Some(index)\
    \ => index\n            case None => -1\n        }\n        val deletedChars =\
    \ s take endIndex - startIndex\n        if (deletedChars == c) {\n           \
    \ return (s.drop(startIndex).drop(endIndex), true) // palindrome\n        }\n\
    \        return (s.drop(startIndex).take(deletedChars.size), false) // not a palindrome",
  "        val chars = s.toCharArray\n        val charArray = c.toCharArray\n    \
    \    var newString = \"\"\n        var newCharArray = chars.toList\n        var\
    \ i = 0\n        var j = 0\n        var flag = false\n        for ( i <- 0 until\
    \ charArray.length) {\n            if (charArray(i) == chars(j) {\n          \
    \      j = j + 1\n            } else {\n                newString = newString\
    \ + chars(i)\n                newCharArray = charArray.toList\n              \
    \  j = i\n                flag = true\n            }\n            if (j == charArray.length)\
    \ {\n                if (flag) {\n                    newCharArray = charArray.toList\n\
    \                    newString = newString + chars(i)\n                    flag\
    \ = false\n                }\n            }\n        }\n        return ( newString,\
    \ flag)", "        val charArray = s.split(\"\").map(_.toChar).toSet\n       \
    \ val charArray2 = c.split(\"\").map(_.toChar).toSet\n        val charArray3 =\
    \ charArray.filterNot(charArray2.contains)\n        val charArray4 = charArray3.sortBy(x\
    \ => x)\n        val charArray5 = charArray4.foldLeft(charArray3)((acc, x) =>\
    \ {acc ++ List(x)})\n        val charArray6 = charArray5.foldLeft(charArray5)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray7 = charArray6.foldLeft(charArray6)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray8 = charArray7.foldLeft(charArray7)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray9 = charArray8.foldLeft(charArray8)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray10 = charArray9.foldLeft(charArray9)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray11 = charArray10.foldLeft(charArray10)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray12 = charArray11.foldLeft(charArray11)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray13 = charArray12.foldLeft(charArray12)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray14 = charArray13.foldLeft(charArray13)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray15 = charArray14.foldLeft(charArray14)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray16 = charArray15.foldLeft(charArray15)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray17 = charArray16.foldLeft(charArray16)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray18 = charArray17.foldLeft(charArray17)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray19 = charArray18.foldLeft(charArray18)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray20 = charArray19.foldLeft(charArray19)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray21 = charArray20.foldLeft(charArray20)((acc,\
    \ x) => {acc ++ List(x)})\n        val charArray22 = charArray21.foldLeft(charArray",
  "        val sSeq = s.toSeq\n        val cSeq = c.toSeq\n        var deleteC = 0\n\
    \        var i = 0\n        while(i <= sSeq.length - 1) {\n            if(sSeq(i)\
    \ == cSeq(deleteC)) {\n                sSeq = sSeq.drop(i)\n                i\
    \ += 1\n                deleteC += 1\n            }\n            i += 1\n    \
    \    }\n        if(sSeq == cSeq.reverse) {\n            return ((\"true\", true))\n\
    \        }\n        return ((\"false\", false))", "        val result = new StringBuilder\n\
    \        val reverseChar = new HashSet[Char](c)\n        for(i <- 0 until s.length){\n\
    \            val char = s.charAt(i)\n            if(reverseChar.contains(char)){\n\
    \                result.append(char)\n            }\n        }\n        if(result.equals(s)){\n\
    \            Tuple2(result.toString(), true)\n        }else{\n            Tuple2(result.toString(),\
    \ false)\n        }", "        val result = s.reverse.replaceAll(c)\n        if\
    \ (result == s) (result, true) else (result, false)", "        // Use two list\
    \ to save original string and remove character\n        val list1 = ListBuffer[String]()\n\
    \        val list2 = ListBuffer[String]()\n        for (i <- 0 until s.length)\
    \ {\n            list1 += s(i)\n            list2 += s(i)\n        }\n       \
    \ // remove duplicate character from list\n        val commonSet = ListSet[Char](list2.toSet)\n\
    \        for (i <- 0 until commonSet.length()) {\n            val index = commonSet(i)\n\
    \            list2 -= i\n            list1 += i\n        }\n        // check if\
    \ all character in list2 are exist in list1\n        val equal = list2.forall(x\
    \ => list1.contains(x))\n        (list1.mkString, equal)", "        val arr =\
    \ mutable.ArrayBuffer(c)\n        val startIndex = s.length\n        val endIndex\
    \ = startIndex\n        var i = 0\n        while (i < startIndex) {\n        \
    \    arr.update(0, s.charAt(i))\n            i += 1\n        }\n        i += 1\n\
    \        while (i < endIndex) {\n            arr.update(1, s.charAt(i))\n    \
    \        i += 1\n        }\n        val result = new StringBuilder\n        if\
    \ (arr.toSeq == arr.toSeq.reverse) {\n            val trueResult = arr.toSeq.mkString\n\
    \            result.update(0, trueResult)\n            result.update(1, \"true\"\
    )\n            return (result.toString(), true)\n        }\n        else {\n \
    \           val falseResult = arr.toSeq.mkString\n            result.update(0,\
    \ falseResult)\n            result.update(1, \"false\")\n            return (result.toString(),\
    \ false)\n        }", "        var a = 0\n        var b = 0\n        var result\
    \ = \"\"\n        var flag = false\n        for (i <- 0 until s.length - 1) {\n\
    \            if (s(i) == c(b)) {\n                a += 1\n                b +=\
    \ 1\n                result += s(i)\n                flag = true\n           \
    \ } else {\n                if (a == c.length) flag = true\n            }\n  \
    \      }\n        if (flag) result + (\"true\")\n        else (result + (\"false\"\
    ), false)", "        val len = s.length\n        val result = s.filter{ char =>\n\
    \            if (c.contains(char))\n                false\n            else\n\
    \                true\n        }\n        result.size == len", '        // Your
    code here', "        val result = s.map(chr => if (c.contains(chr)) chr else \"\
    \").mkString\n        val cs = c.mkString\n        val reversed = result.reverse\n\
    \        if (cs == reversed)\n            (result, true)\n        else\n     \
    \       (result, false)", "        val s1 = s.toList\n        val s2 = c.toList\n\
    \        s1.indices.forall { i =>\n            if (s2.exists( s => s == s1(i ))\
    \ ) s2.remove(i) else s2.add(i) }\n        val res = s1.mkString.reverse == s\n\
    \        s1.indices.foreach { i => s2.remove(i) }\n        (res, s1 == s2)", " \
    \       if (s.isEmpty) {\n            (\"\", true)\n        } else if (c.isEmpty)\
    \ {\n            (s.reverse, false)\n        } else {\n            val cs = c.toSeq\n\
    \            var sIndex = 0\n            var cIndex = 0\n            var res =\
    \ \"\"\n            var isDeleted = false\n            while (sIndex < s.size)\
    \ {\n                val i = s.charAt(sIndex)\n                val j = cs.lift(cIndex)\n\
    \                if (i != j) {\n                    res += i\n               \
    \     sIndex += 1\n                    cIndex += 1\n                } else {\n\
    \                    isDeleted = true\n                    sIndex += 1\n     \
    \           }\n            }\n            if (isDeleted) {\n                (res,\
    \ true)\n            } else {\n                (res, false)\n            }\n \
    \       }", "        // Solution\n        // 1- get all chars from s\n       \
    \ // 2- remove all chars from c\n        // 3- check if string are equal\n   \
    \     // 4- return tuple with new string and true/false for check\n        (s,\
    \ s.toList.foldLeft(new StringBuilder())((sb, b) => {\n            val newChar\
    \ = if (b.toString == c.toString) b.toString else b.toString + b.toString\n  \
    \          sb += b.toString\n            sb += newChar\n            sb\n     \
    \   }).mkString() == s.toString.reverse, s.toList.foldLeft(new StringBuilder())((sb,\
    \ b) => {\n            val newChar = if (b.toString == c.toString) b.toString\
    \ else b.toString + b.toString\n            sb += b.toString\n            sb +=\
    \ newChar\n            sb\n        }).mkString() == s.toString.reverse)", "  \
    \      if (s == null || c == null || c.isEmpty) {\n            throw new IllegalArgumentException(\"\
    String is null\")\n        }\n        var i = 0\n        var j = s.length - 1\n\
    \        while(i <= j) {\n            if(s(i) == c(j)) {\n                i +=\
    \ 1\n                j -= 1\n            } else {\n                if(i < j) {\n\
    \                    s(i) = s(j)\n                    i += 1\n               \
    \     j -= 1\n                }\n            }\n        }\n        if(i <= j)\
    \ {\n            return (s.reverse, true)\n        } else {\n            return\
    \ (s.reverse, false)\n        }", "        var resultString = \"\"\n        var\
    \ checkResult = true\n        for( i <- 0 until s.length ) {\n            resultString\
    \ += if(s.charAt(i) == c.charAt(0)) \"\" else s.charAt(i)\n        }\n       \
    \ resultString = resultString.reverse\n        checkResult = resultString == s\n\
    \        (resultString, checkResult)", "        // Your code goes here\n     \
    \   val s1 = s.toCharArray\n        val c1 = c.toCharArray\n        var reverseStr\
    \ = \"\"\n        var isPalinedrome = true\n        for (i <- 0 until s1.length)\
    \ {\n            if (s1(i) == c1(i))\n                reverseStr = reverseStr\
    \ + s1(i)\n            else {\n                if (c1.length == 0) {\n       \
    \             isPalinedrome = false\n                } else {\n              \
    \      c1.remove(0)\n                }\n            }\n        }\n        val\
    \ result = reverseStr + reverseStr.reverse\n        return (result, isPalinedrome)",
  "        // Write your solution here\n        if(c.isEmpty) (s\"\", true)\n    \
    \    else (s.map(x => c.indexOf(x) != -1).mkString(\"\"), s.map(x => c.indexOf(x)\
    \ != -1).sum == 0)", "        val list = c :: s.filter(x => x != c)\n        val\
    \ reverseList = list.reverse\n        val resultString = reverseList.mkString\n\
    \        (resultString, resultString == s)", "        var i = 0\n        var j\
    \ = s.length - 1\n\n        while ( i != j ) {\n            if ( s.charAt(i) ==\
    \ c.charAt(j) ) s = s.substring(0, i) + s.substring(i+1, j) + s.substring(j+1)\n\
    \            else j -= 1\n            i += 1\n        }\n        (s, s.equals(reverse(s,\
    \ c)))", "        val result = s.filter(x => !c.contains(x)) // filter out characters\
    \ not in c\n        if (result.length == s.length) result else (result, true)",
  "        val ns = s.filter(a => !c.contains(a))\n        val nc = c.filter(a =>\
    \ !s.contains(a))\n        (ns.mkString, reverseDelete(nc, s)) match {\n     \
    \       case (\"\", true) => return((\"true\", true))\n            case (_, true)\
    \ => return((\"false\", false))\n            case (_, false) => return((\"false\"\
    , false))\n        }", "        val str = new StringBuilder(s).reverse\n     \
    \   if(str.equals(c)) {\n            (str.reverse, false)\n        } else {\n\
    \            (str.reverse, s.equals(str.reverse))\n        }", "        val rs\
    \ = mutable.StringBuilder.newBuilder\n        val cc = mutable.StringBuilder.newBuilder\n\
    \        for (i <- 0 until s.length)\n            if (s(i) == c(0))\n        \
    \        rs.append(s(i))\n            else {\n                cc.append(s(i))\n\
    \                cs.reverse\n                cc.append(s(i))\n               \
    \ rs.append(cc.toString)\n            }\n        val rs = rs._2.mkString.toLowerCase\n\
    \        (rs, rs.size == s.length)", "        val reverse = s.reverse\n      \
    \  val res = c.filter(x => reverse.contains(x)).toList\n        val deleted =\
    \ s.filter(x => !res.contains(x))\n        val result = deleted.reverse\n    \
    \    val check = deleted == result\n        result -> check", "        val s =\
    \ ListBuffer[Char](s.charAt(0))\n        var flag = false\n        var result\
    \ = \"\"\n        for (i <- 0 until s.length){\n            s += s.charAt(i)\n\
    \        }\n        for (j <- 0 until c.length){\n            c += c.charAt(j)\n\
    \        }\n        if (c.equals(s)){\n            result = s\n        }\n   \
    \     else {\n            result = reverseDelete(s, c)\n            flag = true\n\
    \        }\n        return result + (flag)", "        val reverse = s.reverse\n\
    \        val checkCertainChar = reverse map { char =>\n            if (c == char)\
    \ char\n            else None\n        }.size > 0\n        val result = reverse\
    \ filterNot checkCertainChar\n        (result, checkCertainChar)", "        var\
    \ i = 0\n        var j = s.length - 2\n        var reverseStr = \"\"\n       \
    \ var isReverse = true\n        while (i <= j) {\n            if (s(i) != c(j))\
    \ {\n                reverseStr += s(i)\n                isReverse = !isReverse\n\
    \            } else {\n                i += 1\n                j -= 1\n      \
    \      }\n        }\n        (reverseStr, isReverse)", "        var s = reverse(s,\
    \ 0)\n        var c = reverse(c, s.length)\n        var i = 0\n        while (i\
    \ < s.length && i < c.length) {\n            if (s(i) == c(i)) {\n           \
    \     s = removeChar(s,i,1)\n                c = removeChar(c,i,1)\n         \
    \   }\n            i += 1\n        }\n        if (s.length != c.length) {\n  \
    \          return (s,false)\n        } else {\n            return (s,true)\n \
    \       }", "        if (s.length == 0 || c.length == 0) (\"\", false)\n     \
    \   else if (s.head == c.head) (reverseDelete(s.tail, c.tail), (s.head == c.head\
    \ && reverseDelete(s.tail, c.tail)))\n        else (\"\", false)", "        val\
    \ result = \"\"\n        val isRight = false\n        // Write your code here\n\
    \        var i = 0\n        while(i < s.length){\n            if(s.charAt(i) ==\
    \ c.charAt(0)){\n                result = result + s.charAt(i)\n             \
    \   i += 1\n            }\n            else{\n                i += 1\n       \
    \     }\n        }\n\n        if(result != \"\" && result.equals(s.reverse))\n\
    \            return (s.reverse, false)\n        else\n            return (s.reverse,\
    \ false)", "        val len = s.length\n        val result = Array.fill(len)(\
    \ 0 ) // use array to save slicing\n        for (i<-0 to len-1)\n            result(i)\
    \ = s(i).replace(c, \"\")\n        val r = new StringBuilder(result(0))\n    \
    \    for(i<-0 to len-1)\n            r += s(i).replace(c, \"\")\n        (r.reverse.toString,\
    \ r.length == len && r.isEmpty == 0)", "        val result = \"\"\n        val\
    \ index = -1\n        for(i <- 0 to s.length - 1 by -1){\n            if(s(i)\
    \ == c){\n                index += 1\n                if(index >= 0){\n      \
    \              result += (index(index) - i)\n                }\n            }\n\
    \        }\n        if(result != s)\n            return (result,false)\n     \
    \   else\n            return (result,true)", "        val s = ArrayBuffer(s)\n\
    \        val c = ArrayBuffer(c)\n        val len = s.length\n        val maxLen\
    \ = c.length\n        val i = 1\n        val j = 1\n        var result = \"\"\n\
    \        var flag = false\n        for (i <- 1 to len) {\n            result +=\
    \ s.charAt(i).toChar\n        }\n        for (j <- 1 to maxLen) {\n          \
    \  if (c.indexOf(s.charAt(j - 1)) != -1) {\n                flag |= true\n   \
    \         }\n        }\n        if (flag) {\n            val s = ArrayBuffer(result)\n\
    \            val len = s.length\n            var flag = false\n            for\
    \ (i <- 1 to len) {\n                if (s.charAt(i) == s.charAt(len - i - 1))\
    \ {\n                    flag |= true\n                }\n            }\n    \
    \        if (flag) {\n                return (s.mkString, true)\n            }\
    \ else {\n                return (s.mkString, false)\n            }\n        }\
    \ else {\n            return (s.mkString, false)\n        }", "        var d =\
    \ new StringBuffer()\n        var r = false\n        for (i <- 0 until s.length){\n\
    \            if (c contains s(i)){\n                d.append(s(i))\n         \
    \       r = true\n            } else {\n                d.append(s(i))\n     \
    \       }\n        }\n        // reverse the string\n        var sd = d.reverse\n\
    \        // delete the char which is equal to c\n        sd.replaceAll(c ++ \"\
    [^\"+c+\"]\", \"\")\n        // delete the char which is equal to c\n        (r==true?sd.reverse:sd)",
  "        if (s.size < c.size) {\n            throw new java.lang.RuntimeException(\"\
    Strings must have equal length\")\n        }\n        var newS = s\n        var\
    \ newC = c\n        var i = 0\n        while (i < s.size - c.size) {\n       \
    \     if (newS(i) != newC(s.size - i - 1)) {\n                newS = newS.substring(0,\
    \ i) + newS.substring(i + 1, newS.size)\n                newC = newC.substring(0,\
    \ i) + newC.substring(i + 1, newC.size)\n            }\n            i += 1\n \
    \       }\n        val b = newS == newC\n        val d = if (b) newS else newC\n\
    \        (b, d)", "        if (c.isEmpty) {\n            if (s.isEmpty)\n    \
    \            return (s, true)\n            else\n                return (s, false)\n\
    \        }\n        var i = 0\n        var j = 0\n        var x = s.head\n   \
    \     val temp = (0 until s.length).map( i => (x, false) ).toList\n        var\
    \ firstMatch = true\n        var str = \"\"\n        var check = true\n      \
    \  while (i < s.length && j < c.length) {\n            if (s.charAt(i) != c.charAt(j))\
    \ {\n                firstMatch = false\n                str = s.substring(0,i)+c.substring(0,j)+s.substring(i+1,\
    \ s.length)\n                check = false\n            } else {\n           \
    \     i += 1\n                j += 1\n            }\n        }\n        if (firstMatch)\
    \ {\n            while (i < s.length) {\n                str += s.charAt(i)\n\
    \                i += 1\n            }\n            while (j < c.length) {\n \
    \               str += c.charAt(j)\n                j += 1\n            }\n  \
    \          return (str,check)\n        } else {\n            var firstStr = \"\
    \"\n            var secondStr = \"\"\n            while (i < s.length) {\n   \
    \             firstStr += s.charAt(i)\n                i += 1\n            }\n\
    \            while (j < c.length) {\n                secondStr += c.charAt(j)\n\
    \                j += 1\n            }\n            return (reverseDelete(firstStr,\
    \ c.substring(0,j-1)) + secondStr + reverseDelete(s.substring(0,i), c.substring(j)),\
    \ check)\n        }", "        def rev(s:String) : String = {\n            var\
    \ i = 0\n            val len = s.length\n            var res = \"\"\n        \
    \    while(i < len)\n            {\n                res += s.charAt(i)\n     \
    \           i +=1\n            }\n            res\n        }\n        val m =\
    \ s.count(_ == c.charAt(0))\n        if(m == 0) (\"\", false)\n        else\n\
    \        {\n            val n = rev(s)\n            if(c.length == s.length)\n\
    \            {\n                if (c == rev(s))\n                    (\"\", true)\n\
    \                else\n                    (\"\", false)\n            }\n    \
    \        else\n            {\n                if (n == c) \n                 \
    \   (\"\", true)\n                else\n                    (\"\", false)\n  \
    \          }\n        }", "        var reversed = \"\"\n        var i = 0\n  \
    \      var j = 0\n        for(i <- 0 until s.length){\n            for(j <- 0\
    \ until c.length){\n                if(i != j){\n                    if(s(i) ==\
    \ c(j)){\n                        reversed = reversed + s(i)\n               \
    \     }\n                }\n            }\n        }\n        if(reversed.toUpperCase\
    \ == reversed.toUpperCase.mkString.toUpperCase){\n            return (s(0), true)\n\
    \        }else{\n            return (s(0), false)\n        }", "        if (c.isEmpty)\
    \ (s, true)\n        else if (s.isEmpty) (c, false)\n        else if (s.head.equals(c.head))\
    \ reverseDelete(s.tail, c.tail)\n        else (s, false)", "        val l = s.length\n\
    \        val r = c.length\n        val result = new StringBuilder(l)\n       \
    \ var i = 0\n        var j = 0\n        while (i < l && j < r) {\n           \
    \ if (s(i) == c(j)) {\n                result.append(s(i))\n                i\
    \ += 1\n                j += 1\n            } else {\n                i += 1\n\
    \            }\n        }\n        val res = (result.toString(), j == r)\n   \
    \     Tuple2(res, j == r)", "        val charSet = Set(c.toChar)\n        val\
    \ newS = s.toList.filter(_ != c)\n        val res = newS.size == s.size && s.toList.forall(charSet)\n\
    \        Tuple2(newS, res)", "        // Write your code here\n        val result\
    \ = s.filter((_, i) => s.lastIndexOf(c, i) < i)\n        result.reverse.equalsIgnoreCase(s)\
    \ + !result.equals(s.reverse)", "        val reversedString = s.reverse\n    \
    \    val result = reversedString.deleteCharArray(c).toArray\n        if (result.size\
    \ == c.length) {\n            (new String(result), true)\n        } else {\n \
    \           (new String(result), false)\n        }", "        val rev = s.reverse\n\
    \        val revC = rev.toSet\n        val revS = new StringBuilder(s)\n     \
    \   revS.deleteChars(revC.toIterable.mkString)\n        val resStr = revS.result()\n\
    \        val check = c == resStr\n        ((resStr, check))", "        val s =\
    \ mutable.ListBuffer(s)\n        val c = mutable.ListBuffer(c)\n        val m\
    \ = s.head :: c.head :: s.tail :: c.tail\n        val i = c.indexOf(0)\n     \
    \   if (i >= 0) {\n            if (s.length < c.length) {\n                reverseDelete(s.tail,\
    \ c.slice(i))\n            } else {\n                reverseDelete(s.drop(i +\
    \ 1), c.drop(i))\n            }\n        }\n        else {\n            if (s.length\
    \ < c.length) {\n                reverseDelete(s.tail, c.tail)\n            }\
    \ else {\n                reverseDelete(s.drop(c.length), c.drop(c.length))\n\
    \            }\n        }", "        var result : String = \"\"\n        var flag\
    \ : Boolean = false\n\n        for (i <- s.indices) {\n            if (s(i) ==\
    \ c(s.size - i)) {\n                result += s(i)\n                flag = true\n\
    \            }\n            else {\n                result += s(i)\n         \
    \   }\n        }\n        (result, flag)", "        val str = s.toList\n     \
    \   val chars = c.toList\n        val len = s.length\n        val result = new\
    \ ArrayBuffer[String]()\n        var i = 0\n        var j = len - 1\n        while(i\
    \ < j){\n            if(chars(i) == chars(j)){\n                i -= 1\n     \
    \           j -= 1\n            } else {\n                if(i != j){\n      \
    \              result += (str(i) + str(j))\n                    i = i + 1\n  \
    \                  j = j - 1\n                } else {\n                    result\
    \ += (str(i) + str(j))\n                    i = i + 1\n                }\n   \
    \         }\n        }\n        if(str == result){\n            (result, true)\n\
    \        } else {\n            (result, false)\n        }", "        if (s.isEmpty)\
    \ (0, true)\n        if (c.isEmpty) (s, false)\n        var i = 0\n        val\
    \ l = s.length\n        val ll = c.length\n        val ans = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        while (i < l && ll > 0) {\n            if (s(i) == c(ll)) {\n       \
    \         ans += s(i)\n                i += 1\n                ll -= 1\n     \
    \       }\n        }\n        if (i < l) {\n            ans += s(i)\n        }\n\
    \        ans.reverse\n        if ((ans.size == ll) && ans.toSet.size == 0) ans\
    \ += \"0\"\n        ans.reverse\n        if (ans.size == ll) {\n            (ans.mkString,\
    \ true)\n        }\n        else {\n            (ans.mkString, false)\n      \
    \  }", "        var resultStr = \"\"\n        var isPalindrome = true\n      \
    \  var index = 0\n        var currentChar = c.head\n        var currentIndex =\
    \ 0\n        while(currentChar != Nil){\n            if(index >= s.length){\n\
    \                resultStr += currentChar\n                isPalindrome = isPalindrome\
    \ && currentChar == c.tail\n            }\n            else if(currentChar ==\
    \ s.at(index)){\n                currentIndex += 1\n            }\n          \
    \  else{\n                resultStr += currentChar\n                isPalindrome\
    \ = isPalindrome && currentChar == s.at(index)\n            }\n            index\
    \ += 1\n            currentChar = c.head\n            currentIndex = 0\n     \
    \   }\n        if(isPalindrome){\n            return (resultStr, isPalindrome)\n\
    \        }\n        return (resultStr, false)", "        val result = s\n    \
    \    val indexToDelete = c.toList.indexOf (s.head)\n        if (indexToDelete\
    \ < 0) {\n            return (s, false)\n        }\n        val deletedChars =\
    \ indexToDelete - 1\n        val result = s.substring(0, deletedChars) + s.substring(deletedChars\
    \ + 1)\n        (result, s.equals (result))", "        val r = new mutable.Array[String]()\n\
    \        for(i <- 0 until s.length){\n            r.push(s.substring(0, i))\n\
    \        }\n        val r = r.toList\n        val r = r.filter(r => r.toSet ==\
    \ c.toSet)\n        if (r.length == 0) (\"\", false)\n        else           \
    \ (r.head + reverseDelete(r.tail, c.toSet)._1, true)", "        if (s == null\
    \ || c == null) {\n            return (\"\", false)\n        }\n\n        var\
    \ len : Int = c.length\n        var resultStr = \"\"\n        var result : Boolean\
    \ = true\n        val s = mutable.StringBuilder()\n\n        for (i = 0 to s.length\
    \ - 1) {\n            s += s.charAt(i)\n        }\n\n        if (s == c) {\n \
    \           resultStr += s\n            result &= true\n        }\n\n        if\
    \ (result == false) {\n            result &= false\n        }\n\n        return\
    \ (resultStr, result)", "        var i = 0\n        var j = 0\n        var k =\
    \ s.length\n        while (i < k && j < (c.length)) {\n            if (s.charAt(i)\
    \ == c.charAt(j)) {\n                i += 1\n                j += 1\n        \
    \    } else {\n                if (j > 0) {\n                    j -= 1\n    \
    \            } else {\n                    i += 1\n                }\n       \
    \     }\n        }\n        if (i != k) {\n            if (s.charAt(i) == c.charAt(j))\
    \ {\n                return (s, false)\n            } else {\n               \
    \ return (s, true)\n            }\n        } else {\n            return (s, true)\n\
    \        }", "        def check(c1 : String, c2 : String): Boolean = {\n     \
    \       val isEqual = c1 == c2\n            if(isEqual) true\n            else\
    \ {\n                val c = c2.toUpperCase\n                val c1 = c1.toUpperCase\n\
    \                if(c.contains(c1)) check(c1, c2)\n                else {\n  \
    \                  val c1 = c1.dropWhile(c => !c.equals(c))\n                \
    \    val c2 = c2.dropWhile(c => !c.equals(c))\n                    check(c1, c2)\
    \ && (c1.length == c2.length)\n                }\n            }\n        }\n \
    \       val a = s.toUpperCase\n        val b = c.toUpperCase\n        val c =\
    \ a.filter( c => !b.contains(c) )\n        val d = a.filter( c => b.contains(c)\
    \ )\n        if(c.length == d.length) (s, check(d, c)) else (s, check(a, b))",
  "        def recursive_helper(i : Int, result : String) : Boolean = if (i == 0)\
    \ true else if (s(i) == c(0)) true else recursive_helper(i - 1, result + s(i))\
    \ && recursive_helper(i - 1, result)\n\n        recursive_helper(s.length - 1,\
    \ \"\")", "        var result = \"\"\n        var check = true\n        for (\
    \ i <- 0 until s.length ) {\n            result += (s.charAt(i) != c.charAt(0))\
    \ || (result != \"\")\n            check = check && ((result != \"\") && (s.charAt(i)\
    \ == c.charAt(0)))\n        }\n        return ((result, check))", "        //\
    \ Complete this function\n        // You should return a tuple containing the\
    \ result string and true/false for the check.\n        // Don't modify any of\
    \ the parameter passed in function, only use its return values\n        // The\
    \ input strings are immutable (cannot be modified after initialized)\n       \
    \ \n        \n        // My Solution:\n        val s1 = s.toLowerCase\n      \
    \  val s2 = c.toLowerCase\n        val rev :String = \"\"\n        val flag =\
    \ true\n        for(i <- 0 until s1.length){\n            if(s2 == rev)\n    \
    \            flag = false\n            rev = rev + (if (s1.charAt(i) == s2.charAt(i))\
    \ s1.charAt(i) else \"\")\n        }\n        \n        if (rev == s && !flag)\n\
    \            return (s,false)\n        else\n            return (s,flag)", " \
    \       val sSeq = s.toSeq\n        val cSeq = c.toSeq\n        val sLen = sSeq.size\n\
    \        val cLen = cSeq.size\n        val sIx = sSeq.length - 1\n        val\
    \ cIx = cSeq.length - 1\n        var sIx2 = 0\n        var cIx2 = 0\n        var\
    \ newSSeq = new StringBuilder(\"\")\n        var newCSSeq = new StringBuilder(\"\
    \")\n        var sIndex = 0\n        var cIndex = 0\n        var isPalindrome\
    \ = true\n        val isSameSeq = Seq(sSeq).sameElements(Seq(cSeq))\n        if\
    \ (sLen < cLen) {\n            isPalindrome = false\n        }\n        if (isSameSeq)\
    \ {\n            while (cIndex < cLen) {\n                if (sSeq(sIx) != cSeq(cIx))\
    \ {\n                    isPalindrome = false\n                    cIndex = cIx\n\
    \                }\n                else {\n                    sIx2 = sIx\n \
    \                   cIx2 = cIx\n                    sIx = sIx2 - 1\n         \
    \           cIx = cIx2 + 1\n                }\n                cIx++\n       \
    \     }\n        }\n        else {\n            while (cIndex < cLen) {\n    \
    \            if (sSeq(sIx) != cSeq(cIx)) {\n                    newSSeq = sSeq.slice(0,\
    \ sIx2)\n                    newCSSeq = newCSSeq.slice(0, cIx2)\n            \
    \        newCSSeq = newCSSeq + sSeq.slice(sIx2 + 1, sIx) + cSeq(cIx2 + 1)\n  \
    \                  cIx++\n                }\n                else {\n        \
    \            newSSeq = sSeq.slice(0, sIx2)\n                    newCSSeq = newCSSeq.slice(0,\
    \ cIx2)\n                    newCSSeq = newCSSeq + sSeq.slice(sIx2 + 1, sIx) +\
    \ cSeq(cIx2 + 1)\n                    cIx2 = cIx\n                    sIx = sIx2\
    \ - 1\n                }\n                cIx++\n            }\n            while\
    \ (cIndex < cLen) {\n                if (sSeq(sIx) != cSeq(cIx)) {\n         \
    \           newSSeq = sSeq.slice(0, sIx2)\n                    newCSSeq = newCSSeq.slice(0,\
    \ cIx2)\n                    newCSSeq = newCSSeq + sSeq.slice(sIx2 + 1, sIx) +\
    \ cSeq(cIx2 + 1)\n                    cIx++\n                }\n             \
    \   else {\n                    sIx2 = sIx\n                    cIx2 = cIx\n \
    \                   sIx = ", "        val rs = new ListBuffer[String]()\n    \
    \    val d = new HashSet[String](c)\n        for (cc <- c) {\n            if (d.contains(cc))\
    \ {\n                rs.append(s)\n            }\n            d -= cc\n      \
    \  }\n        val r = sb.reverse.mkString(\"\")\n        (rs, r == r)", "    \
    \    // your code goes here\n        val len: Int = s.length\n        val ans:\
    \ String = \"\"\n        val flag = Array[Char](c.toChar).reverse // reverse the\
    \ array\n        for (i <- 0 until len) {\n            if ((ans + c).contains(flag(i)))\
    \ ans = ans + c.charAt(i)\n            else ans = ans + flag(i)\n        }\n \
    \       if (ans.equals(s)) (flag, false) else (flag, true)", "        if (s.length\
    \ < c.length) throw new RuntimeException(\"Not enough characters to delete\")\n\
    \        var result : String = \"\"\n        var start : Int = s.length - 1\n\
    \        var end = c.length - 1\n        while (start > 0 || end > start) {\n\
    \            while (start > 0 && s.charAt(start) != c.charAt(end)) start -= 1\n\
    \            while (end > 0 && s.charAt(end) != c.charAt(start)) end -= 1\n  \
    \          if (start > 0 && end > 0) result += s.charAt(start)\n            if\
    \ (start > 0) start -= 1\n            if (end > 0) end -= 1\n        }\n     \
    \   result match {\n            case \"\"   => return (s, false)\n           \
    \ case c if c.equals(result) => return (s, true)\n            case c    => return\
    \ (s, false)\n        }", "      var ans = s\n      var revc = reverse(c)\n  \
    \    val cSet = c.toSet\n      val cLen = c.length\n      val sLen = s.length\n\
    \      for (i <- 0 until sLen) {\n        if (!cSet.contains(ans.charAt(i))) {\n\
    \          revc += \"0\"\n        }\n        ans = ans.substring(0, i) + revc\
    \ + ans.substring(i + 1)\n      }\n      if (ans != s) {\n        val a = ans.toInt\n\
    \        val b = s.toInt\n        val res = a - b\n        if (res < 0) {\n  \
    \        res += a\n        }\n        ans = \"\" + res\n      }\n      ans.toString\
    \ -> revc != revc.reverse", "        val startIndex = s.lastIndexOf(c)\n     \
    \   val endIndex = s.indexOf(c)\n        if (startIndex == -1 || endIndex == -1)\
    \ {\n            (s, false)\n        } else if (startIndex == s.lastIndexOf(c)\
    \ && endIndex == s.indexOf(c)) {\n            (s, true)\n        } else if (endIndex\
    \ == s.indexOf(c)) {\n            (s.substring(0,startIndex) + s.substring(endIndex\
    \ + 1,s.length), true)\n        } else {\n            (s.substring(0,startIndex)\
    \ + s.substring(endIndex + 1, s.length), false)\n        }", "        val resultString\
    \ = mutable.ArrayBuffer.empty[String]\n        var isPalindrome = false\n    \
    \    for (x<-0 to s.length-1){\n            if(s(x)!=c(x)) resultString.append(s(x))\n\
    \            else isPalindrome = true\n        }\n        if(isPalindrome) (resultString.reverse,true)\n\
    \        else (resultString.reverse,false)", "        var result = \"\"\n    \
    \    var reverse = false\n        for (i <- 0 until s.length) {\n            if\
    \ (s(i) != c(s.length - 1 - i)) {\n                if (reverse == false) {\n \
    \                   result += s(i)\n                    reverse = true\n     \
    \           }\n                else {\n                    result += s(i)\n  \
    \              }\n            } else {\n                reverse = false\n    \
    \        }\n        }\n        if (reverse) {\n            result = reverse(result)\n\
    \        }\n        return (result, true)", "        val d = c.toList\n      \
    \  val result = s.reverse.deleteMatchIn(s, d)\n        val isPalindrome = s.reverse\
    \ == result\n        return (result, isPalindrome)", "        val ns = mutable.StringBuilder(s).reverse.deleteCharAt(s.indexOf(c)).result\n\
    \        (ns == s, true)", "        // Write your code here\n        // We need\
    \ to reverse the string and then check if the characters are in the right place.\n\
    \        // We do this by creating a set containing the characters in s and checking\
    \ if there are any characters in c that are not in s.\n        // The code below\
    \ is for python, but you can translate it into scala yourself.\n        // I didn't\
    \ use the scala.collection.mutable.Set methods as it doesn't support the contains\
    \ method.\n        // I created a list of characters that we would have removed\
    \ from s and then checked if they were in the list.\n        // As it turns out,\
    \ scala has some built in methods for checking whether a list contains another\
    \ list, we used contains.\n        // The code below is written using for loops\
    \ as it is the easiest to read.\n        var s1 = \"\"\n        var s2 = \"\"\n\
    \        var charactersInSet = List.empty[String]\n        var i = 0\n       \
    \ var j = 0\n        for (i <- 0 until s.length) {\n            s1 += s.charAt(i)\n\
    \        }\n        for (j <- 0 until c.length) {\n            s2 += c.charAt(j)\n\
    \        }\n        charactersInSet = s2.toSet\n        for (i <- 0 until s1.length)\
    \ {\n            if (!charactersInSet.contains(s1.charAt(i))) {\n            \
    \    charactersInSet = charactersInSet ++ List.empty[String]\n            }\n\
    \        }\n        // If the characters were removed from s and then added to\
    \ charactersInSet, then\n        // s1 is the original string and s2 is the string\
    \ with the characters in c removed.\n        // Return tuple containing the result\
    \ string and true/false for checking the results.\n        return (s1, charactersInSet.forall(!(s2.contains(_))))",
  "        if (s.size < c.size) throw new IllegalArgumentException(\"s is shorter\
    \ than c\")\n        if (c.isEmpty) throw new IllegalArgumentException(\"c is\
    \ empty\")\n        if (c.head == s.last) new StringBuilder(s).delete(c.size)\n\
    \        else\n            reverseDelete(s.tail, c.drop(1)) + new StringBuilder(s).delete(c.size)",
  "        // Your code here\n        var firstIndex = s.length - 1;\n        var\
    \ secondIndex = 0;\n        var deleted = \"\";\n        while(firstIndex >= 0\
    \ && secondIndex < c.length) {\n            if(s(firstIndex) != c(secondIndex))\
    \ {\n                deleted += s(firstIndex)\n                firstIndex -= 1\n\
    \            }\n            else {\n                deleted += s(firstIndex)\n\
    \                secondIndex += 1\n            }\n        }\n        if(deleted\
    \ == s) {\n            return (deleted, true)\n        }\n        else {\n   \
    \         return (deleted, false)\n        }", "        var sArr = new Array[String](s.length)\n\
    \        var bTrue = true\n        var bFalse = false\n        val len = c.length\n\
    \        var cArr : Array[Char] = c.toCharArray\n        var n = 0\n        for(i\
    \ <- 0 until sArr.length)\n            sArr(i) = (s(len - i - 1))\n        //\
    \ print(sArr)\n        for(i <- 0 until cArr.length-1)\n            if(sArr(n)\
    \ == cArr(i))\n                n += 1\n            else\n                bFalse\
    \ = true\n        if(n < sArr.length-1)\n            bFalse = true\n        if(bFalse)\n\
    \            (n, bTrue)\n        else\n            (sArr.drop(n+1), bTrue)", " \
    \       var str = new StringBuilder(s)\n        var isPalidrome = true\n     \
    \   var i = 1\n        while(i <= str.length / 2 && isPalidrome) {\n         \
    \   if(str(i) != c(i)) {\n                str.remove(i)\n                isPalidrome\
    \ = false\n            }\n            i += 1\n        }\n        return (str.toString(),\
    \ isPalidrome)", "        val charArr = ArrayBuffer(s, c)\n        val isRevDelete\
    \ = charArr.count(_ == c) - charArr.count(_ == c)\n        charArr.removeAll(ArrayBuffer(c,\
    \ c))\n        val palindrome = charArr.mkString(\"\")\n        if ( palindrome.equals(palindrome.head)\
    \ && palindrome.tail.equals(palindrome.last) )\n            ( palindrome, true)\n\
    \        else\n            ( palindrome, false)", "        val result = s.deleteAll(c)\n\
    \        val isPalindrome = s.toString == result.toString\n        (result, isPalindrome)",
  "        var result = \"\"\n        var flag = false\n        for(i <- 0 until s.length){\n\
    \            if(s(i) == c){\n                if(result.length > 0){\n        \
    \            result += s(i)\n                    result += s(i)\n            \
    \        result += s(i)\n                    result += s(i)\n                \
    \    result += s(i)\n                    result += s(i)\n                    result\
    \ += s(i)\n                    result += s(i)\n                }else{\n      \
    \              result += s(i)\n                }\n            }else{\n       \
    \         result += s(i)\n            }\n        }\n        if (result == c.reverse){\n\
    \            flag = true\n        }\n        return (result, flag)", "       \
    \ var sb = ArrayBuffer(s)\n        var cb = ArrayBuffer(c)\n        while (sb.nonEmpty\
    \ && cb.nonEmpty) {\n            val c = cb(0)\n            cb.clear()\n     \
    \       val sb0 = sb(0)\n            sb.clear()\n            val sb1 = sb(1)\n\
    \            if (sb0 == sb1) {\n                sb.push(sb1)\n               \
    \ sb.push(c)\n            }\n        }\n        var resultString = \"\"\n    \
    \    val checkResult = sb.toString.reverse.equalsIgnoreCase(sb.toString)\n   \
    \     (resultString, checkResult)", "        val s1: String = new String(s)\n\
    \        val s1: String = deleteChar(s1, c)\n        val s2: String = new String(s1)\n\
    \        if (s2.length >= s.length)\n            (reverseDelete(s2, c), true)\n\
    \        else\n            (reverseDelete(s1, c), false)", "        val strings\
    \ = mutable.ArrayBuffer.empty[String]\n        var counts = 0\n        for( i\
    \ <- 0 until s.length ) {\n            if( s.charAt(i) == c.charAt(counts) ) {\n\
    \                strings += s.slice(i+1,counts+1)\n                counts += 1\n\
    \            }\n        }\n        if( counts == c.length ) {\n            return\
    \ ( strings.reverse, true )\n        }\n        ( strings.reverse, false )", " \
    \       var s = s\n        var c = (c ++ c).map(x => x.toChar).reverse\n     \
    \   var i = s.length\n        var resultStr = \"\"\n        var isResult = true\n\
    \        while(i > 0) {\n            var char = s(i - 1)\n            if(c.contains(char))\
    \ {\n                s = s(i--)\n            } else {\n                isResult\
    \ = false\n            }\n            resultStr += char\n        }\n        if(isResult)\
    \ {\n            resultStr\n        } else {\n            Tuple2.apply(\"palindrome\"\
    , false)\n        }", "        val result = s.filterNot(c ++ _)\n        val reversed\
    \ = result.mkString(\"\") reversed\n        reversed.isEmpty", "        var reverse\
    \ = \"\"\n        var deleted = \"\"\n        var temp = \"\"\n        for(i <-\
    \ 0 until s.length){\n            temp = s(i)\n            deleted += temp\n \
    \       }\n        for(i <- 0 until c.length){\n            temp = deleted(i)\n\
    \            reverse = reverse + temp\n        }\n        val reversed = reverse.reverse\n\
    \        val isReversed = reversed == s\n        (reversed, isReversed)", "  \
    \      val lenS = s.length\n        val lenC = c.length\n        val lc = lenC\n\
    \        var j = lenS - 1;\n        var k = lenS - 1;\n        val res1 = s.tail.takeWhile(x\
    \ => !c.contains(x));\n        val res2 = c.tail.takeWhile(x => !s.contains(x))\n\
    \        val res3 = res1.takeWhile(x => !res2.contains(x)).drop(lenC);\n     \
    \   val res4 = res3.takeWhile(x => !res1.contains(x)).drop(lenS);\n        val\
    \ res5 = res4.takeWhile(x => !res3.contains(x)).drop(lenS);\n        val res6\
    \ = res5.takeWhile(x => !res4.contains(x)).drop(lenC);\n        val res7 = res6.takeWhile(x\
    \ => !res5.contains(x)).drop(lenC);\n        val res8 = res7.takeWhile(x => !res6.contains(x)).drop(lenS);\n\
    \        val res9 = res8.takeWhile(x => !res7.contains(x)).drop(lenS);\n     \
    \   val res10 = res9.takeWhile(x => !res8.contains(x)).drop(lenC);\n        val\
    \ res11 = res10.takeWhile(x => !res9.contains(x)).drop(lenC);\n        (res11,\
    \ true);", "        val reverseString = s.reverse\n        val deleted = s.filter(_\
    \ != c)\n        val stringPalindrome = deleted.reverse.equals(reverseString)\n\
    \        Tuple2(stringPalindrome, deleted)", "        val reverseDeleteString\
    \ = s.reverse.filter( ch => c.contains(ch)).reverse\n        if (reverseDeleteString.equals(reverseDeleteString.reverse))\
    \ {\n            (reverseDeleteString, true)\n        }\n        else {\n    \
    \        (reverseDeleteString, false)\n        }", "        val result = mutable.ListBuffer.empty[String]\n\
    \        for (i <- s.indices) {\n            val index = if (i < c.length) i else\
    \ s.length - i - 1\n            if (s(i) == c(index)) {\n                result\
    \ += s(i)\n            }\n        }\n        result match {\n            case\
    \ Nil => (\"\", false)\n            case x :: Nil => (x, true)\n            case\
    \ x :: xs => (x, xs.forall(c => x == c(0))) // Check all characters of string\
    \ against the character at position 0\n        }", "        val result = new StringBuilder\n\
    \        for(i <- 0 until s.length)\n            result.append(if(s.charAt(i)\
    \ == c.charAt(0)) s.dropRight(i) else s.drop(i))\n        result.mkString.length\
    \ == s.length && result == s", "        val reversedString = reverseStringRecursively(s)\n\
    \        val resultString = reversedString.filter{ cc => cc != c }\n        return\
    \ Tuple2(resultString.reverse, resultString.reverse == resultString)", "     \
    \   val result = s.reverse.map(x => if (x == c) \"\" else x).reverse\n       \
    \ (result, s.reverse == result)", "      val listOfChars = mutable.ListBuffer.empty[Char]\n\
    \      val listOfDeletedChars = mutable.ListBuffer.empty[Char]\n      for (letter\
    \ <- s) {\n        if (letter == c) {\n          listOfChars += letter\n     \
    \     listOfDeletedChars += letter\n        }\n      }\n      val listOfCharsBackwards\
    \ = listOfChars.reverse\n      val listOfCharsForwards = listOfChars.reverse\n\
    \n      listOfCharsBackwards.zip(listOfCharsForwards).foreach{\n        case (deleted,\
    \ original) =>\n          listOfDeletedChars += deleted\n      }\n\n      (listOfDeletedChars.mkString.reverse,\
    \ listOfChars.nonEmpty == listOfChars.size)", "        // Your code here\n   \
    \     val s = s filterNot (_ == c) \n        val c = c filterNot (_ == s) \n \
    \       \n        if(s.equals(c))\n            return (s, true)\n        else\n\
    \            return (s, false)", "        // We want to find all the elements\
    \ in s that do not equal any element in the string c\n        // So we start by\
    \ making a set (Set) of all the characters in s and then subtracting them\n  \
    \      // from the characters in c, making a set of unique characters not in c,\
    \ then we convert the set\n        // back to a list, so we can iterate over it.\n\
    \        var unique : Set[String] = new Set[String](s)\n        unique.diff(c.toSet).toList",
  "        // 1. Get list of characters to remove\n        val remove = c.toList.filter(\
    \ _ != s(0) )\n        // 2. Build new string\n        val newS = remove.mkString\n\
    \        // 3. Compare strings\n        if (s == newS) ( newS, true ) else if\
    \ (newS.isEmpty) ( \"\", false ) else\n            reverseDelete( newS, c )",
  "      val startIndex = s.indexOf(c)\n      val deleted = new Array[String](s.size)\n\
    \      for (i <- 0 until startIndex) {\n        deleted(i) = s(i)\n      }\n \
    \     for (i <- startIndex+1 until s.length) {\n        deleted(i) = s(i)\n  \
    \    }\n      if (startIndex != 0 && startIndex != s.length -1) {\n        deleted(startIndex)\
    \ = s(startIndex)\n        deleted(s.length - startIndex) = s(s.length - startIndex)\n\
    \      }\n      val reverse = new Array[String](s.size)\n      for (i <- 0 until\
    \ s.length / 2) {\n        reverse(i) = deleted(s.length - 1 - i)\n      }\n \
    \     val reverseString = reverse.reverse\n      val bool = reverseString == s\n\
    \      (s + reverseString, bool)", "        val result = s.filter( x => !c.contains(x))\n\
    \        (result, s.equals(result.reverse))", "        var res = \"\"\n      \
    \  var done = false\n        for(i <- 0 until s.length()) {\n            val c\
    \ = s.charAt(i).toChar\n            if(c.toString == c.toString && c.toInt !=\
    \ c.toInt) {\n                s += c\n                done = false\n         \
    \   } else {\n                done = true\n                for(j <- 0 until c.length)\
    \ {\n                    val x = c.charAt(j).toChar\n                    if(x.toString\
    \ != x.toString && x.toInt != x.toInt) {\n                        s += x\n   \
    \                     done = false\n                    }\n                }\n\
    \            }\n        }\n        done = true\n        val r = s.reverse\n  \
    \      done = false\n        for(i <- 0 until r.length) {\n            val x =\
    \ r.charAt(i).toChar\n            if(x.toString != x.toString && x.toInt != x.toInt)\
    \ {\n                res += x\n                done = false\n            }\n \
    \       }\n        if(res == c && !done) {\n            (res, true)\n        }\
    \ else {\n            (res, false)\n        }", "        // Your code here\n \
    \       val resultString = mutable.ArrayBuffer.empty[String]\n        var i =\
    \ 0\n        var j = 0\n        var reverse = false\n        while(i <= s.length\
    \ && j <= c.length) {\n            if(s(i) == c(j)) {\n                resultString.append(s(i))\n\
    \                i += 1\n                j += 1\n            } else {\n      \
    \          reverse = true\n            }\n        }\n        if(reverse == true)\
    \ {\n            (resultString.toString.reverse, false)\n        } else {\n  \
    \          (resultString.toString.reverse, true)\n        }", "        if(s ==\
    \ null || c == null){\n            return (null, null)\n        }\n        val\
    \ result = s.reverseDelete(c).toSet\n        val reverse = c.reverseDelete(s).toSet\n\
    \        if(reverse.equals(result)){\n            return (s\"${s}${reverse}\"\
    , true)\n        }\n        return (s\"${s}${reverse}\", false)", "        val\
    \ str = s.filter( c => !s.contains(c) )\n        val isPalindrome = str.reverse.mkString.equals(str.mkString)\n\
    \        Tuple2(str, isPalindrome)", "        var reverse = scala.collection.mutable.StringBuilder(s)\n\
    \        var isReversed = true\n        for (i <- 0 until c.length)\n        \
    \    reverse = reverse + c.charAt(i)\n        reverse = reverse + c\n        val\
    \ result = reverse == reverse.init\n        Tuple2(result.toString(), result)",
  "        // Solution\n        val result = reverseDeleteRec(s, c)\n        val temp\
    \ = (\"\", false)\n        if (result._2 != temp._2) (temp.head + result._1, result._2)\n\
    \        else (temp.head + result._1, true)", "        val rd = new mutable.ListBuffer[String]()\n\
    \        var i = 0\n        var j = 0\n        while(i < s.length && j < c.length)\
    \ {\n            if(s(i) == c(j)) {\n                rd += s(i)\n            \
    \    i += 1\n                j += 1\n            } else {\n                i +=\
    \ 1\n            }\n        }\n        if(i < s.length) {\n            val last\
    \ = s.substring(i).reverse\n            if(rd.contains(last)) {\n            \
    \    return (s.substring(i + 1), true)\n            } else {\n               \
    \ return (s.substring(i), false)\n            }\n        } else if(j < c.length)\
    \ {\n            val first = c.substring(0, j)\n            if(rd.contains(first))\
    \ {\n                return (s.substring(0, i), true)\n            } else {\n\
    \                return (s, false)\n            }\n        } else {\n        \
    \    return (s.substring(0, i), false)\n        }", "        var reverseString\
    \ = \"\"\n        var isReverse = false\n        for(i <- 0 to s.length - 1) {\n\
    \            reverseString += c.charAt(i)\n        }\n        if(s == reverseString)\
    \ {\n            return (s,true)\n        } else {\n            return (s,false)\n\
    \        }", "        val slist = s.toList\n        val clist = c.toList\n   \
    \     val res = new StringBuilder(\"\")\n        var i = 0\n        var j = 0\n\
    \        var palindrome = false\n        while (i < slist.size) {\n          \
    \  while (j < clist.size) {\n                if (slist(i) == clist(j)) {\n   \
    \                 slist.delete(i)\n                    clist.delete(j)\n     \
    \               palindrome = true\n                    palindrome = !palindrome\n\
    \                }\n                j++\n            }\n            i++\n    \
    \    }\n        if (palindrome) {\n            res.reverse\n            res.toString\
    \ -> palindrome\n        } else {\n            res.reverse\n            res.toString\
    \ -> !palindrome\n        }", "        val reverseS = s.reverse\n        val reverseC\
    \ = c.reverse\n        if(reverseS.length == 0) (s, false)\n        else {\n \
    \           val sIter = reverseS.iterator\n            val cIter = reverseC.iterator\n\
    \            var sItr = sIter.next\n            var cItr = cIter.next\n      \
    \      val flag = true\n            while(sItr != reverseS.last) sItr += 1\n \
    \           while(cItr != reverseC.last) cItr += 1\n            if(!(sItr == reverseS.last))\
    \ {\n                if(sItr != reverseS.last) {\n                    if(!cItr\
    \ == reverseC.last) {\n                        if(cItr.equals(reverseC.last))\
    \ (flag = false) else (flag = true)\n                    }\n                 \
    \   else if(!cItr.equals(reverseC.last)) (flag = false)\n                }\n \
    \               else if(!cItr == reverseC.last) (flag = false)\n            }\n\
    \            if(reverseS.last != reverseC.last) (flag = false)\n            (reverseS.reverse,\
    \ flag)\n        }", "        val charMapC = Map(c -> '0')\n        val charMapS\
    \ = Map(s -> '0')\n        val deleteResult = mutable.ListBuffer.empty[String]\n\
    \        for (i <- 0 until s.length) {\n            if (charMapC.get(s(i)) !=\
    \ charMapS.get(s(i))) {\n                deleteResult += s(i)\n            }\n\
    \        }\n        if (deleteResult == s)\n            (s, true)\n        else\n\
    \            (deleteResult.reverse, false)", "        val r = new mutable.HashMap[Char,\
    \ String]()\n        for (c <- c) {\n            r += c -> \"\"\n        }\n \
    \       for (c <- s) {\n            val v = r.get(c)\n            if (v != null)\
    \ {\n                r(c) = \"\"\n            }\n        }\n        val result\
    \ = r.filterValues { case (k, v) => v == \"\" }.map { case (c, v) => c + v}\n\
    \        result.toSeq.sorted.toList match {\n            case head :: tail =>\
    \ head + (result.last == result.first)\n            case _ => false\n        }",
  "        val startIndex = s.length\n        var start = 0\n        var deleteCount\
    \ = 0\n        val result = mutable.ArrayBuffer.empty[String]\n        var remaining\
    \ = s\n\n        // Keep deleting characters\n        while (start < startIndex)\
    \ {\n            val deleted = remaining.deleteCharAt(start)\n            deleteCount\
    \ = deleteCount + 1\n            if (deleted == c) {\n                result.append((remaining.substring(0,\
    \ start)))\n                remaining = (remaining.substring(start) + remaining.substring(start\
    \ + 1))\n                start = start + 1\n            } else {\n           \
    \     start = start + 1\n            }\n        }\n\n        // check if the remaining\
    \ is palindrome\n        if (remaining.equals(\"\")) {\n            result.append(\"\
    \")\n        } else {\n            result.append(remaining)\n        }\n\n   \
    \     if (deleteCount == c.length) {\n            return (result.mkString, true)\n\
    \        } else {\n            return (result.mkString, false)\n        }", " \
    \       if (s.isEmpty) return (\"\", false)\n        val list = s.toCharArray.distinct\n\
    \        val deleted = c.toCharArray.distinct\n        var i = 0; var j = 0\n\
    \        val length = s.length\n        while(i < length && j < deleted.length)\
    \ {\n            if (list(i) == deleted(j)) {\n                i += 1 // advance\
    \ i if delete character is found\n                j += 1 // advance j if delete\
    \ character is found\n            } else {\n                i += 0 // advance\
    \ i if delete character is not found\n                j += 1\n            }\n\
    \        }\n        if (i == length) return (s, true)\n        else return (s,\
    \ false)", "        def deleteChar(s1 : String, s2 : String) : List[String] =\
    \ {\n            def deleteChar(s1 : String, s2 : String) : List[String] = {\n\
    \                def deleteChar(s1 : String, s2 : String) : List[String] = {\n\
    \                    def deleteChar(s1 : String, s2 : String) : List[String] =\
    \ {\n                        def deleteChar(s1 : String, s2 : String) : List[String]\
    \ = {\n                            def deleteChar(s1 : String, s2 : String) :\
    \ List[String] = {\n                                def deleteChar(s1 : String,\
    \ s2 : String) : List[String] = {\n                                    def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \        def deleteChar(s1 : String, s2 : String) : List[String] = {\n       \
    \                                     def deleteChar(s1 : String, s2 : String)\
    \ : List[String] = {\n                                                def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                    def deleteChar(s1 : String, s2 : String) : List[String] =\
    \ {\n                                                        def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                            def deleteChar(s1 : String, s2 : String) : List[String]\
    \ = {\n                                                                def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                                    def deleteChar(s1 : String, s2 : String)\
    \ : List[String] = {\n                                                       \
    \                 def deleteChar(s1 : String, s2 : String) : List[String] = {\n\
    \                                                                            def\
    \ deleteChar(s1 : String, s2 : String) : List[String] = {\n                  \
    \                                                              def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                                                    def deleteChar(s1 : String,\
    \ s2 : String) : List[String] = {\n                                          \
    \                                              def deleteChar(s1 : String, s2\
    \ : String) : List[String] = {\n                                             \
    \                                               def deleteChar(s1 : String, s2\
    \ : String) : List[String] = {\n                                             \
    \                                                   def deleteChar(s1 : String,\
    \ s2 : String) : List[String] = {\n                                          \
    \                                                          def deleteChar(s1 :\
    \ String, s2 : String) : List[String] = {\n                                  \
    \                                                                      def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                                                                            def\
    \ deleteChar(s1 : String, s2 : String) : List[String] = {\n                  \
    \                                                                            \
    \                  def deleteChar(s1 : String, s2 : String) : List[String] = {\n\
    \                                                                            \
    \                                        def deleteChar(s1 : String, s2 : String)\
    \ : List[String] = {\n                                                       \
    \                                                                 def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n                                \
    \                                                                            \
    \                def deleteChar(s1 : String, s2 : String) : List[String] = {\n\
    \                                                                            \
    \                                                    def deleteChar(s1 : String,\
    \ s2 : String) : List[String] = {\n                                          \
    \                                                                            \
    \              def deleteChar(s1 : String, s2 : String) : List[String] = {\n \
    \                                                                            \
    \                                                           def deleteChar(s1\
    \ : String, s2 : String) : List[String] = {\n", "        def deleteChar(str :\
    \ String, i : Int) : String = {\n            var chars = s.substring(0,i) + s.substring(i\
    \ + 1)\n            return if (chars == \"\") \"\"\n            else deleteChar(chars,\
    \ i - 1)\n        }\n        def deleteChars(str : String, i : Int) : String =\
    \ {\n            var chars = s.substring(0,i) + deleteChars(s.substring(i + 1),\
    \ i - 1)\n            return chars\n        }\n        val deleted = deleteChars(s,\
    \ 0)\n        var result = deleted\n        var check = true\n        for (c <-\
    \ c) check = check && deleted.contains(c)\n        if (check) result = deleteChar(deleted,\
    \ deleted.length)\n        else result = (\"false\", false)\n        result match\
    \ {\n            case (\"false\", false) => result\n            case (\"false\"\
    , true) => result\n            case (\"true\", false) => result\n            case\
    \ (\"true\", true) => result\n            case _ => result\n        }", "    \
    \    // Solution\n        var resultString = s\n        var isReversed = false\n\
    \        for (c <- c) {\n            resultString = resultString.replaceAll(c,\
    \ \"_\")\n        }\n        if (resultString.toUpperCase() ==\n            resultString.toUpperCase().reverse)\
    \ {\n            isReversed = true\n        }\n        return ((resultString,\
    \ isReversed), true)", "        val ss = s.toLowerCase + c.toLowerCase // string\
    \ with all the chars equal\n        val sss = ss.reverse.sliding(2) // split it\
    \ in half\n        val cs = c.toLowerCase // string with all the chars equal\n\
    \        val css = cs.reverse.sliding(2) // split it in half\n        val ins\
    \ = sss.zip(css).map { case (ssss, ccs) => ccss.reverse match {\n            case\
    \ Nil => ccs\n            case x => x.mkString\n        }}\n        val res: String\
    \ = ins.foldLeft(\"\") { (acc, x) =>\n            val xs = x.toLowerCase // string\
    \ with all the chars equal\n            val xsss = xs.reverse.sliding(2) // split\
    \ it in half\n            acc ++= xsss.map { case (xsss, ccs) => ccss.reverse\
    \ match {\n                case Nil => ccs\n                case x => x.mkString\n\
    \            }}\n            acc ++= x.mkString\n        }\n        (res, ins.forall(x\
    \ => x == res))", "        val ans = mutable.StringBuilder.new\n        s.reverse\
    \ foreach { x => if (x == c) ans += x else ans += \"\" }\n        ans.reverse.equals(s)",
  "        val result = s.filterNot(c.toSet.contains)\n        result match {\n  \
    \          case s if s.reverse.equals(s) => return (s, true)\n            case\
    \ s if s.reverse.equals(s.reverse) => return (s, true)\n            case s if\
    \ s.reverse.length < 2 => return (s, false)\n            case _ => reverseDelete(s,\
    \ c)\n        }", "        if(c.equals(\"\")) return (s, false)\n        var isReverse\
    \ = false\n        var newS = \"\"\n        for(i <- 0 until s.length){\n    \
    \        if(s.charAt(i) == c.charAt(0)) {\n                newS = newS + s.charAt(i)\n\
    \                s = s.substring(i + 1)\n                isReverse = isReverse\
    \ || (newS.reverse == newS)\n            }\n        }\n        if(newS.equals(\"\
    \")) return (s, false)\n        return (newS.reverse, isReverse)", "        var\
    \ i = 0\n        var l = s.length\n        while (i < l && !(s.charAt(i) == c.charAt(i)))\
    \ {\n            i += 1\n        }\n        l = i\n        if (l == 0) {\n   \
    \         return (s, false)\n        } else {\n            val resultString =\
    \ new StringBuilder(s)\n            resultString.deleteCharAt(l - 1)\n       \
    \     val check = reverseDelete(resultString.toString(), c)\n            check._1\
    \ += c.charAt(l - 1)\n            check._2 = (check._1 == s)\n        }", "  \
    \      val result = new StringBuilder(s)\n        val del = new StringBuilder()\n\
    \        var flag = true\n        for (i <- 0 until s.length){\n            if(del\
    \ == c && result.length == 0){\n                flag = false\n               \
    \ break\n            }\n            if(del == c && result.length == 0){\n    \
    \            flag = false\n                break\n            }\n            if(del\
    \ != c && result.length == 0){\n                break\n            }\n       \
    \     if(result.length != 0 && result.charAt(i) != s.charAt(i)){\n           \
    \     del += s.charAt(i)\n                result.deleteCharAt(i)\n           \
    \     flag = true\n            }\n        }\n        if(flag){\n            return\
    \ (result.mkString, flag)\n        }else{\n            return (\"Not palindrome\"\
    , false)\n        }", "        var i = 0\n        var j = 0\n        var bool\
    \ = true // if string is palindrome\n        var res = \"\"\n        for (i<-s.length-1\
    \ to 0 by -1) {\n            if (s.charAt(i) == c.charAt(j)) {\n             \
    \   i += 1\n                j += 1\n            }\n            else {\n      \
    \          bool =  false\n                res += s.charAt(i)\n            }\n\
    \        }\n        if (bool) {\n            return (res, true)\n        } else\
    \ {\n            return (res, false)\n        }", "        // Solution\n     \
    \   import scala.collection.immutable._\n        var resultString = s.filterNot(c.toSet).mkString\n\
    \        var isPalindrome = true\n        if (resultString.length <= c.length)\
    \ {\n            // The string is a palindrome\n            isPalindrome = true\n\
    \            // Reverse the string and check whether it is equal to its reverse\n\
    \            var reverseString = resultString.reverse\n            reverseString\
    \ match {\n                case s if s == reverseString =>\n                 \
    \   isPalindrome = false\n                case _ =>\n            }\n        }\n\
    \        val tuple = resultString.length.toString + isPalindrome.toString\n  \
    \      println(tuple.mkString(\" \"))\n        return (tuple, isPalindrome)",
  "        var i = 0\n        var reverseString = \"\"\n        var isPalindrome =\
    \ true\n\n        // reverse string and delete c from s\n        while (i < s.length){\n\
    \            reverseString += s.charAt(i)\n            i += 1\n        }\n   \
    \     if (reverseString.equals(c)) {\n            isPalindrome = false\n     \
    \   }\n        var i = 0\n        while (i < reverseString.length){\n        \
    \    if (reverseString.charAt(i) != s.charAt(i)) {\n                isPalindrome\
    \ = false\n                break\n            }\n            i += 1\n        }\n\
    \        return (s, isPalindrome)", "        // write your code here\n       \
    \ val str1= s filter (!_.contains(c)) \n        var result = str1.reverse.mkString\n\
    \        val str2 = result filter (!_.contains(c)) \n        var bool = true\n\
    \        if(str1 == str2){\n            val result2 = str2.reverse.mkString\n\
    \            if(str2 == result2){\n                bool = false\n            }\n\
    \        }\n        return (result,bool)", "        val newString = s.filter(\
    \ x => x != c.head).reverse\n        (newString == s, newString == newString.reverse)",
  "        if(s.isEmpty) tuple2(\"\", false)\n        else if(c.isEmpty) tuple2(s.reverse,\
    \ s.isEmpty)\n        else {\n            val r = s.reverse\n            val ss\
    \ = r.subList(0, r.length - c.length)\n            val result = ss.mkString(\"\
    \")\n            tuple2(result, ss.equals(r))\n        }", "        // The function\
    \ below is called a fold.  It is a function that takes in an initial value and\
    \ a function and combines them together.\n        // It iterates over every item\
    \ in the list, and applies a function to each item in the list and returns one\
    \ final value.\n        // The initial value is the second argument in the function\
    \ call.\n        // The function takes in an item from the list, and returns a\
    \ new value.\n        // Let's call this new value 'f'\n        // We can now\
    \ write our function as:\n        //      f(item) = item\n        // In other\
    \ words, f takes one item from the list and applies it to the previous function.\n\
    \n        // Step 1\n        // The list is empty so let's return the empty tuple\
    \ now\n        if (s.length == 0) {\n            return (\"\", true)\n       \
    \ }\n\n        // Step 2\n        // The list is not empty so we must iterate\
    \ over each character in the string\n        for (i <- 0 until s.length()) {\n\
    \            // Step 3\n            // The current character is the i'th character\
    \ in the string, let's call this new value 'char'\n            // We want to store\
    \ the first character in 'char' to be the current character, and the last character\
    \ to be\n            // the last character in the string. Let's call this new\
    \ value 'f' and 'l' as 'f' and 'l'\n            // The function below takes in\
    \ an item from the list 's', and returns another item to be 'f'\n            //\
    \ If the length of the character array is even, then the item is the last character\
    \ in the string,\n            // otherwise, it's the first character in the string.\
    \ Let's call this new value 'f'\n            // If the length of the character\
    \ array is even, then the character is the last character in the string,\n   \
    \         // otherwise, it's the first character in the string. Let's call this\
    \ new value 'l'\n            // We can now write our function as:\n          \
    \  //      f(item) = if (l == 0) {\n            //          char\n           \
    \ //      } else if (l == 1) {\n            //          char\n            // \
    \     } else if ((l % 2) == 0) {\n            //          char\n            //\
    \      } else if ((l % 2) != 0) {\n            //          char\n            //\
    \      }\n            // We want to add all those 'f' and 'l' together\n     \
    \       // Let's write our function as:\n            //     f(item) = if (l ==\
    \ 0) {\n            //          char\n            //      } else if (l == 1) {\n\
    \            //          char\n            //      } else if ((l % 2) == 0) {\n\
    \            //          char\n            //      } else if ((l % 2) != 0) {\n\
    \            //          char\n            //      }\n            // Step 4\n\
    \            // The function below takes in an item from the list 's', and returns\
    \ another item to be 'l'\n            // We want to store the last character to\
    \ be\n            // Let's call this new value 'f'\n            // The function\
    \ below takes in an item from the list 'c, and returns another item to be 'l'",
  "        val result = mutable.Buffer.empty[String]\n        val visited = mutable.HashSet.empty[String]\n\
    \        s.foreach { e =>\n            if (visited.contains(e)) throw new IllegalArgumentException(\"\
    String appears twice\")\n            visited.add(e)\n            if (c.contains(e))\
    \ result.addLast(e)\n        }\n        val c = c.reverse\n        val p = result.mkString\n\
    \        if (c.equals(p)) (1, false) else (p.reverse, false)", "        val newS\
    \ = deleteAllChar(s,c)\n        val newC = deleteAllChar(c,s)\n        if(newS.equals(newC))\
    \ {\n            ((newS, true))\n        } else {\n            ((newS, false))\n\
    \        }", "        // Write your code here\n        def loop(reverse: String,\
    \ str : String, c: String, i: Int): (String, Boolean) = {\n            if (i >=\
    \ c.length)\n                (reverse + str, true)\n            else\n       \
    \         loop(reverse + str.substring(0, i), str.substring(i), c, i + 1)\n  \
    \      }\n        loop(\"\" + s.reverse, s, c, 0)", "        // Write your code\
    \ here\n        if(s.isEmpty) \n            (\"\", false)\n        if(c.isEmpty)\
    \ \n            (\"\", false)\n\n        var i = s.length - 1;\n        var j\
    \ = 0;\n        var reverse = c.reverse.indexOf(0)\n        var deleted = c.filter(\
    \ x => (x != 0))\n        var string2 = reverseDelete(s, deleted)\n        return\
    \ (string2, string2.reverse == string2)", "        val result = s.foldLeft(\"\"\
    )((accumulator : String, letter : Char) => {\n            accumulator + if (c.contains(letter))\
    \ letter else \"\"\n        })\n        val isPalindrome = result == s.reverse\n\
    \        (result, isPalindrome)", "        //Write your code here\n        var\
    \ result = \"\"\n        var rev_s = \"\"\n        var flag = false\n        for\
    \ ( i <- 0 until s.length ) {\n            result += s.charAt(i)\n        }\n\
    \        for ( i <- 0 until c.length ) {\n            rev_s += c.charAt(i)\n \
    \       }\n        for ( i <- 0 until s.length ) {\n            if ( s.charAt(i)\
    \ == rev_s.charAt(i) ){\n                result = result.replace(s.charAt(i),\"\
    \")\n            }\n        }\n        if ( result == c ) {\n            flag\
    \ = true\n        }\n        return ( result, flag)", "        var newString =\
    \ \"\"\n        var isPalindrome = true\n        var i = 0\n        var j = 0\n\
    \        while (i < s.length && j < c.length) {\n            if (s(i) != c(j))\
    \ {\n                newString += s(i)\n                isPalindrome = false\n\
    \            } else {\n                i += 1\n                j += 1\n      \
    \      }\n        }\n        return newString -> isPalindrome", "        val slen\
    \ = s.length\n        val clen = c.length\n        if(slen < 0 || clen < 0) return\
    \ null\n        var rev = new StringBuilder(s)\n        var match = 0\n      \
    \  for(i <- 0 until slen) if(c.contains(s(i))) rev += s(i)\n        if(rev ==\
    \ s) return Tuple2(s, false)\n        var rev2 = new StringBuilder(rev)\n    \
    \    for(i <- 0 until slen) rev2 += s(i)\n        if(rev == rev2) return Tuple2(s,\
    \ true)\n        var rev3 = new StringBuilder(rev2)\n        for(i <- 0 until\
    \ clen) rev3 += s(i)\n        if(rev3 == rev2) return Tuple2(s, true)\n      \
    \  rev3.reverse", '        // your implementation', "        val s = s\n     \
    \   var i = 0\n        var n = s.length\n        var reverse = \"\"\n        var\
    \ forward = \"\"\n        while (i < n) {\n            if (s(i) == c(0))\n   \
    \             reverse += s(i)\n            forward += s(i)\n            i += 1\n\
    \        }\n        if (reverse == forward) {\n            return (forward, true)\n\
    \        }\n        var n = 0\n        var reverse = \"\"\n        var forward\
    \ = \"\"\n        while (n < reverse.length + forward.length) {\n            if\
    \ (s(n) == c(0)) {\n                reverse += s(n)\n                forward +=\
    \ s(n)\n                n += 1\n            }\n            n += 1\n        }\n\
    \        if reverse == forward {\n            return (forward, true)\n       \
    \ }\n        var i = 0\n        var n = 0\n        while (i < reverse.length &&\
    \ n < forward.length) {\n            if (reverse(i) == forward(n)) {\n       \
    \         i += 1\n                n += 1\n            }\n            i += 1\n\
    \            n += 1\n        }\n        if (i < reverse.length && n < forward.length)\
    \ {\n            return (forward, true)\n        }\n        if (n < forward.length)\
    \ {\n            return (forward, true)\n        }\n        if (i < reverse.length)\
    \ {\n            return (forward, false)\n        }\n        return (forward,\
    \ false)", "        var rev = \"\"\n        var found = false\n        for (i\
    \ <- s.length - 1 to 0) {\n            if (s.charAt(i) == c.charAt(0)) {\n   \
    \             rev = rev + s.charAt(i)\n                if (rev == s.reverse) {\n\
    \                    found = true\n                } else {\n                \
    \    rev = \"\"\n                }\n            } else {\n                rev\
    \ = rev + s.charAt(i)\n            }\n        }\n        (rev, found)", "    \
    \    val result = mutable.ListBuffer.empty[String]\n        val resultString =\
    \ mutable.ListBuffer.empty[String]\n        var index = 0\n        var currentChar\
    \ = s(0)\n        while(index < s.length){\n            index += 1\n         \
    \   currentChar = s(index)\n            if(currentChar == c){\n              \
    \  result.addOne(currentChar)\n                resultString.addOne(currentChar)\n\
    \            }\n        }\n        val reverseResultString = resultString.reverse\n\
    \        val check = isPalindrome(reverseResultString)\n        if(check){\n \
    \           return (result.reverse, check)\n        }\n        else {\n      \
    \      return (result.reverse.reverse, check)\n        }", "        var i = 0\n\
    \        var j = 0\n        var result = \"\"\n        while(i < s.length && j\
    \ < c.length) {\n            if(s(i) == c(j)) {\n                result += s(i)\n\
    \                i += 1\n                j += 1\n            }\n            else\
    \ if(s(i) > c(j)) {\n                result += s(i-1)\n                i += 1\n\
    \            }\n            else {\n                result += s(i+1)\n       \
    \         j += 1\n            }\n        }\n        if(result != s) {\n      \
    \      return (result, false)\n        }\n        else {\n            return (result,\
    \ true)\n        }", "        // Write code here\n        val chars = mutable.HashSet[String]()\n\
    \        val result = mutable.StringBuffer()\n        for(x <- s.toCharArray){\n\
    \            if(!chars.contains(x)){\n                chars += x\n           \
    \ }\n        }\n        for(x <- c.toCharArray){\n            if(!chars.contains(x)){\n\
    \                chars += x\n            }\n        }\n        if(chars == s.toCharArray){\n\
    \            (result.toString(), true)\n        }\n        else{\n           \
    \ (result.toString(), false)\n        }", "        val result = new Array[String](s.length)\n\
    \        for (i<- 0 until s.length) result(i) = s(i)\n        for (i<- 0 until\
    \ c.length) result(result(i)) = c(i)\n        if (c.length < 1) (s, true)\n  \
    \      else {\n            val reverse = result.map(_.toUpperCase).reverse\n \
    \           val res = (reverse.map(_.toUpperCase), true)\n            if (s.equals(reverse(res))\
    \ || (reverse.map(_.toUpperCase).forall(s.contains(_))) && result.length == c.length)\
    \ (s, true)\n            else (s, false)\n        }", "        var r : String\
    \ = \"\"\n        var b : Boolean = true\n        for (i <- 0 until s.length)\
    \ {\n            if (s(i) == c(i))\n                r ++= s(i)\n            else\n\
    \                b = False\n        }\n        return (r, b)", "        var result\
    \ : String = \"\"\n        var isDelete : Boolean = false\n        s.foreach {\
    \ i =>\n            if (i.equals(c))\n                isDelete = true\n      \
    \      result += i\n        }\n        result", "        val result = mutable.StringBuilder()\n\
    \        var i = 0\n        var j = 0\n        while (i < s.length && j < c.length)\
    \ {\n            if (s(i) != c(j)) {\n                result.append(s(i))\n  \
    \              i += 1\n            } else if (s(i) == c(j)) {\n              \
    \  i += 1\n                j += 1\n            } else {\n                i +=\
    \ 1\n                j += 1\n            }\n        }\n        if (i == s.length)\
    \ Tuple2(result.toString(), true)\n        else Tuple2(result.toString(), false)",
  "        var s = s\n        val n = s.length\n        var i = n\n        var j =\
    \ (n - 1)\n        var result = \"\"\n        var flag = false\n        while(i\
    \ >= 0 && j >= 0) {\n            if (s(i) == c(j)) {\n                s = delete(s,i,1)\n\
    \                i -= 1\n                j -= 1\n                result += s(i)\n\
    \                flag = true\n            } else if (s(i) < c(j)) {\n        \
    \        i += 1\n            } else {\n                j -= 1\n            }\n\
    \        }\n        val isPalindrome = flag\n        val resultString = result\n\
    \        val resultBoolean = if (isPalindrome) true else false\n        return\
    \ (resultString, resultBoolean)", "        var i = 0\n        var j = s.length\
    \ - 1\n        var isPalindrome = true\n        while (i < j) {\n            if\
    \ (s(i) != c(j)) {\n                isPalindrome = false\n                break\n\
    \            }\n            i += 1\n            j -= 1\n        }\n        if\
    \ (i == j) {\n            (s.tail.reverse, s.head == c.head)\n        } else {\n\
    \            (s.tail.reverse, false)\n        }", "        if (c.length == 0)\n\
    \            Tuple2(s, true)\n        else if (s.length == 0)\n            Tuple2(s,\
    \ false)\n        else if (c(0) != s(0))\n            reverseDelete(s, c.tail)\n\
    \        else\n            reverseDelete(s.tail, c)", "        val reversed =\
    \ new StringBuilder(s).reverse\n        val deleted = reversed.deleteCharAt(reversed.length()-1)\n\
    \        reversed.toString == c match {\n            case true =>\n          \
    \      val r = s.substring(0, s.length()-1) == deleted\n                if (r)\
    \ (\"true\", true) else (\"false\", false)\n            case false => (\"false\"\
    , false)\n        }", "        val resultString : String = \"\"\n        var isPalindrome:\
    \ Boolean = true\n        for (i <- s.length -1 to 0 by -1) {\n            if\
    \ (c.contains(s(i))) {\n                resultString += s(i)\n            } else\
    \ {\n                isPalindrome = false\n            }\n        }\n        return\
    \ ((resultString, isPalindrome))", "        val list = mutable.ListBuffer[Char]()\n\
    \        for(i <- 0 until s.length) {\n            val curr = s(i)\n         \
    \   if(!list.contains(curr) && !c.contains(curr)) {\n                list += curr\n\
    \            }\n        }\n        if(list.length == s.length)\n            (s.mkString,\
    \ true) //palindrome\n        else\n            (s.mkString, false) //not palindrome",
  "        var s = s\n        val c = c.toList\n        var flag = false\n       \
    \ while( c.nonEmpty && c.head != s.head ) {\n            if( c.head == s.head\
    \ ) {\n                c.tail.foreach( e => s.tail.foreach( f => s = f ) )\n \
    \               c.head = s.head\n                c.tail.foreach( e => s.tail.foreach(\
    \ f => s = f ) )\n            }\n            else if( c.head < s.head ) {\n  \
    \              c.head = s.head\n                c.tail.foreach( e => s.tail.foreach(\
    \ f => s = f ) )\n            }\n            else { // c.head > s.head\n     \
    \           s.head = c.head\n                s.tail.foreach( e => c.tail.foreach(\
    \ f => c = f ) )\n            }\n            flag = flag && s.tail.forall( e =>\
    \ c.head == e )\n        }\n        ( s, flag ) // return tuple", "        val\
    \ str = new StringBuilder(s).reverse\n        val newStr = new StringBuilder(s).reverse\n\
    \        newStr.replace(0, s.length - c.length, c.length)\n        val bool =\
    \ newStr == str\n        val newTuple = s.reverse+bool, bool\n        newTuple",
  "        var res = (\"\", false)\n        for (i <- 0 until s.length - 1) {\n  \
    \          if (s(i) != c(i)) {\n                s = s(i) :: s\n              \
    \  res = s(0) :: res, false\n            } else {\n                res = s(i)\
    \ :: res, true\n            }\n        }\n        return res, true", "       \
    \ val l1 = s.size\n        val l2 = c.size\n        if (l1 != l2) {\n        \
    \    throw new IllegalArgumentException(\"string length is not equal\")\n    \
    \    }\n        val set = new mutable.HashSet[Int]\n        for (i <- 0 until\
    \ l1) {\n            if (s(i) == c(i)) {\n                set.add(i)\n       \
    \     }\n        }\n        if (set.size == 0) {\n            return (\"\", false)\n\
    \        }\n        var str = \"\"\n        val flag = true\n        for (i <-\
    \ 0 until set.size) {\n            str = str + c(set(i))\n        }\n        return\
    \ (str, flag)", "        val indexMap = s.zipWithIndex.toMap\n        val indexSet\
    \ = indexMap.filter(_._2 == c.size).values.toSet\n        var reversedIndex =\
    \ 0\n        var index = 0\n        var result = \"\"\n        var resultSet =\
    \ new mutable.Set[String]\n        var lastResult = scala.collection.mutable.Set[String]()\n\
    \        var flag = true\n        while (index < c.size) {\n            val temp\
    \ = indexMap.getOrElse(index, \"\").getOrElse(\"\")\n            if (temp.equals(c))\
    \ {\n                result = result + temp\n                lastResult += temp\n\
    \                indexSet.remove(temp)\n                reversedIndex += 1\n \
    \               lastResult = lastResult - temp\n                lastResult.foreach\
    \ { elem =>\n                    if (resultSet.contains(elem)) {\n           \
    \             flag = false\n                    }\n                    resultSet.add(elem)\n\
    \                }\n            } else {\n                if (flag) {\n      \
    \              result = result + c\n                }\n                if (resultSet.contains(lastResult))\
    \ {\n                    flag = false\n                }\n                resultSet.add(lastResult)\n\
    \                lastResult = lastResult + c\n                indexSet.remove(lastResult)\n\
    \                reversedIndex += 1\n                lastResult = lastResult -\
    \ c\n                lastResult.foreach { elem =>\n                    if (resultSet.contains(elem))\
    \ {\n                        flag = false\n                    }\n           \
    \         resultSet.add(elem)\n                }\n            }\n            index\
    \ += 1\n        }\n        if (!flag) {\n            (result + c, reversedIndex\
    \ == 0)\n        } else {\n            (result, false)\n        }", "        val\
    \ result = (\"\", false)\n        val s1 = s.toList\n        val c1 = c.toList\n\
    \        var i = 0\n        var j = 0\n        var temp = \"\"\n        while\
    \ (i<s1.length) {\n            while (j<c1.length) {\n                if (s1(i)\
    \ == c1 (j)) {\n                    temp += s1(i)\n                    j++\n \
    \               }\n                else {\n                    temp += s1(i)\n\
    \                }\n            }\n            result = (temp, result._1)\n  \
    \          i++\n            j=0\n            temp = \"\"\n        }\n        result\
    \ = (result._1, result._2)\n        return result", "        val resultString\
    \ = mutable.StringBuilder.newBuilder\n        val checkString = mutable.ListBuffer.newBuilder\n\
    \        var inString = false\n        for (i <- 0 until s.length) {\n       \
    \     if (inString) {\n                checkString.append(s.charAt(i))\n     \
    \       } else {\n                if (s.charAt(i) == c.charAt(0)) {\n        \
    \            inString = true\n                    checkString.append(s.charAt(i))\n\
    \                } else {\n                    checkString.append(s.charAt(i))\n\
    \                    inString = false\n                }\n            }\n    \
    \    }\n        if (inString) {\n            resultString.append(checkString.reverse)\n\
    \        }\n        val checkString = checkString.mkString\n        if (checkString\
    \ == s.reverse) {\n            resultString += s.reverse\n            resultString.toString()\n\
    \        } else {\n            (resultString.toString(), false)\n        }", " \
    \       var resultString = \"\"\n        var resultBool = false \n        var\
    \ currentChar = c(0)\n        var index = 0\n        var index2 = 0\n        while(index\
    \ < s.length){\n            resultString = resultString + currentChar\n      \
    \      index2 = index\n            while(index2 < s.length && currentChar == c(index2)){\n\
    \                index2 = index2 + 1\n            }\n            if(index2 ==\
    \ s.length){\n                resultBool = true\n            }\n            currentChar\
    \ = s(index2)\n            index = index + 1\n        }\n        if(resultString\
    \ == s){\n            resultBool = true\n        }\n        return (resultString,\
    \ resultBool)", "        if (s.length != c.length)\n            return (\"\",\
    \ false)\n        var str : String = \"\"\n        var result : Boolean = false\n\
    \        for(i <- 0 until s.length) {\n            if(s(i) != c(i)) {\n      \
    \          str += s(i)\n            } else {\n                str += \"\"\n  \
    \              result = true\n            }\n        }\n        (str, result)",
  "        var newString = s\n        var newStringArray = s.toList\n        var newCArray\
    \ = c.toList\n        for {\n            currentString <- newStringArray.reverse\n\
    \            currentC <- newCArray.reverse\n            newString = newString.replace(currentString,\
    \ \"\")\n            newC = newC.replace(currentC, \"\")\n        } yield (newString,\
    \ newC == newString.toList)", "        val resultString = \"\"\n        var flag\
    \ = false\n        for(i <- 0 to s.length - 1) resultString += if(s(i) == c(0))\
    \ s(i + 1) else s(i)\n        if(resultString == s) {\n            flag = true\n\
    \        }\n        Tuple2(resultString, flag)", "        val list = s.toList\n\
    \        val list2 = c.toList\n        val len = list.length\n        val len2\
    \ = list2.length\n\n        if (len <= 0) (0, false)\n        else if (len2 <=\
    \ 0) (1, false)\n        else {\n            var i = 0\n            var j = len2\
    \ - 1\n            var result = \"\"\n            var flag = false\n         \
    \   while (i < len) {\n                while (j < len2) {\n                  \
    \  if (list(i) == list2(j)) {\n                        i += 1\n              \
    \          j += 1\n                        result += (list(i))\n             \
    \       } else {\n                        result += (list(i))\n              \
    \          i += 1\n                        j += 1\n                    }\n   \
    \             }\n                i += 1\n                j = len2 - 1\n      \
    \      }\n            if (result == s) (1, true)\n            else (0, false)\n\
    \        }", "        val cArr = c.toList\n        val charToDelete = s.indexWhere(c\
    \ => cArr(cArr.length - 1 - charToDelete) == c)\n        val newS = s.filter(_\
    \ != c)\n        newS.mkString -> charToDelete == 0", "        val newStr = s.filterNot(x\
    \ => c.contains(x))\n        (newStr, isPalindrome(newStr))", "        var str\
    \ = \"\"\n        var ans = false\n        for (x <- s) {\n            str = str\
    \ + x\n            if (x == c)\n                ans = true\n        }\n      \
    \  str = str + c\n        if (str == s)\n            ans = true\n        return\
    \ (str, ans)", "        val deleted: List[Char] = s.toCharArray\n        val notDeleted:\
    \ List[Char] = c.toCharArray\n\n        var deleteIndex = 0\n        var notDeleteIndex\
    \ = 0\n        while(notDeleteIndex < c.length) {\n            if(deleted[deleteIndex]\
    \ == notDeleted(notDeleteIndex)) {\n                deleteIndex += 1\n       \
    \         notDeleteIndex += 1\n            } else {\n                notDeleteIndex\
    \ += 1\n            }\n        }\n        val deletedChars = deleted.reverse\n\
    \        val notDeletedChars = notDeleted.reverse\n        if(deletedChars.equals(notDeletedChars))\
    \ {\n            (s.reverse, false)\n        } else {\n            (s.reverse,\
    \ true)\n        }", '        // Solution code here', "        val s = mutableStringBuilder(s)\n\
    \        val c = mutableStringBuilder(c)\n        var i = 0\n        var k = 0\n\
    \        val l = s.length\n        val r = c.length\n\n        while (i < l) {\n\
    \            if (s(i) != c(k)) {\n                s += s(i)\n            } else\
    \ {\n                s += 1\n                i += 1\n                k += 1\n\
    \            }\n        }\n        val result = s.toString\n        val isPalindrome\
    \ = s.reverse == result\n        (result, isPalindrome)", "        val sLength\
    \ = s.length\n        val cLength = c.length\n        if(s.length != c.length)\
    \ {\n            return ((\"false\",false))\n        }\n        val sP = s.toList\n\
    \        val cP = c.toList\n        var flag = true\n        for(i <- 0 until\
    \ sLength) {\n            if(sP(i) != cP(i)) {\n                sP(i) = cP(i)\n\
    \                sP.update(i+1, cP(i))\n                sP = sP.reverse\n    \
    \        }\n        }\n        if(sP == s) {\n            return ((\"true\", true))\n\
    \        }\n        return ((\"false\",false))", "        if(s.length == 0 ||\
    \ c.length == 0)\n            return (\"\", false)\n        var deleteCount =\
    \ 0\n        var resultString = \"\"\n        var isDeleted = false\n        var\
    \ backwardString = \"\"\n        for(i <- 0 until s.length){\n            if(s(i)\
    \ == c){\n                isDeleted = true\n                if(deleteCount ==\
    \ 0){\n                    resultString = backwardString\n                }else{\n\
    \                    deleteCount -= 1\n                    resultString = backwardString\
    \ + s(i)\n                }\n            }else{\n                if(isDeleted){\n\
    \                    backwardString = s(i)\n                    deleteCount +=\
    \ 1\n                }\n            }\n        }\n        if(deleteCount == 0){\n\
    \            return (resultString, true)\n        }\n        return (resultString,\
    \ false)", "        // Solves problem (2) by iterating the string s and checking\
    \ all chars in c against each char in the string s\n        // For each character\
    \ in c we check if there is a character in s that is equal to it.\n        //\
    \ If there is a character in s that is equal to it, we skip it and continue.\n\
    \        // If no chars in c are equal, we return the first char and false\n \
    \       // If all chars in c are equal, we return the first char and true\n  \
    \      val res = new StringBuilder\n        val charArray = c.toCharArray\n  \
    \      val stringArray = s.toCharArray\n        for (i <- 0 until stringArray.length)\
    \ {\n            val j = 0\n            while (j < charArray.length && stringArray(j)\
    \ == charArray(j)) {\n                j += 1\n            }\n            if (j\
    \ == charArray.length) {\n                res.append(stringArray(i))\n       \
    \     }\n        }\n        // Check if string is a palindrome\n        if (res.length\
    \ == stringArray.length) {\n            return (res.toString, true)\n        }\
    \ else {\n            return (res.toString, false)\n        }", "        // (1)\n\
    \        // reverse s and c using s\n        var reverseString = \"\"\n      \
    \  var chars : List[Char] = new ListBuffer[Char]()\n        var c : Char = c\n\
    \        while(s != \"\") {\n            reverseString += c\n            chars\
    \ += c\n            s -= 1\n        }\n        // reverse c and reverseString\n\
    \        var reverseChars = \"\"\n        var reverseC : Char = c\n        while(reverseString\
    \ != \"\") {\n            reverseChars += reverseC\n            reverseString\
    \ -= 1\n            reverseC += 1\n        }\n        // return result and check\
    \ palindrome\n        if(chars == reverseChars)\n            (reverseString, true)\n\
    \        else\n            (reverseString, false)", "        val n = s.length\n\
    \        val d = new Array[Boolean](n)\n        for ( i <- 1 to n ) {\n      \
    \      val k = i - 1\n            if ( s(i) == c(k) ) d(k) := true\n        }\n\
    \        val resultStr = new StringBuilder(s)\n        var isPalindrome = true\n\
    \        for ( i <- 1 to s.length - 1 ) {\n            if ( d(i) == true ) {\n\
    \                resultStr.replace(i, i + 1, \"_\")\n                isPalindrome\
    \ = false\n            }\n        }\n        if (isPalindrome) (resultStr, false)\
    \ else (resultStr, true)", "        var newString = \"\"\n        var newChar\
    \ = \"\"\n        var newIsTrue = true\n        var charCount = 1\n        var\
    \ i = 0\n        var j = 0\n        var found = False\n        while (i < s.length\
    \ && found == false) {\n            if (s.charAt(i) == c.charAt(j)) {\n      \
    \          found = True\n                charCount += 1\n            }\n     \
    \       else {\n                newString += s.charAt(i)\n                newChar\
    \ = c.charAt(j)\n                newIsTrue = found\n                i = i + 1\n\
    \                j = j + 1\n                found = False\n                charCount\
    \ = 1\n            }\n        }\n\n        return (newString, (newIsTrue == found))",
  "        if (s.size == 0 || c.size == 0) \n            Tuple2(\"\", false)\n   \
    \     else if (s.head == c.head) \n            (reverseDelete(s.tail, c.tail),\
    \ true)\n        else \n            (reverseDelete(s.tail, c.tail), false)", " \
    \       val list = s.toList\n        val list_c = c.toList\n        var result\
    \ = \"\"\n        val list2 = s.toList\n        val list2_c = c.toList\n     \
    \   var flag = false\n        var i = 1\n        var j = 1\n        while(i <\
    \ list2.length && j < list2_c.length){\n            if(list2(i - 1) == list2_c(j)){\n\
    \                list2.remove(i - 1)\n                list2_c.remove(j)\n    \
    \            flag = true\n            }else{\n                i += 1\n       \
    \         j += 1\n            }\n        }\n        if(flag){\n            result\
    \ = list2.reverse + list2_c.reverse\n        }else{\n            result = list2\
    \ + list2_c\n        }\n        //println(s\"$result ${s == result} ${result.equals(s)}\"\
    )\n        (result, s == result)", "        val ls = s.length\n        val lcs\
    \ = c.length\n        if(ls != lcs)\n            return (\"Not a palindrome\"\
    , false)\n        val lsc = ls - 1\n        var i = 1\n        var j = 0\n   \
    \     var k = 0\n        var isPalindrome = true\n        while(i<lsc) {\n   \
    \         if(s(i) != c(j)) {\n                isPalindrome = false\n         \
    \       break\n            }\n            i += 1\n            j += 1\n       \
    \ }\n        val result = if (isPalindrome) \"\" else s.tail\n        (result,\
    \ isPalindrome)", "        val reverseDelete = new mutable.MutableList[String]\n\
    \        var index = 0\n        for (el <- s) {\n            reverseDelete.append(el)\n\
    \        }\n        for (char <- c) {\n            reverseDelete.find(x => x ==\
    \ char)\n            index += 1\n        }\n        if (reverseDelete.length ==\
    \ index + 1)\n            (\"\" + reverseDelete.reverse, false)\n        else\n\
    \            (\"\" + reverseDelete.reverse, true)"]
stop_tokens:
- "\n    }\n"
