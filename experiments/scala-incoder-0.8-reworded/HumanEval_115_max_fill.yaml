name: HumanEval_115_max_fill
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n    // and each 1 in a row represents a single unit of water.\n    // Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  \    // and all buckets have the same capacity.\n    // Your task is to use the\
  \ buckets to empty the wells.\n    // Output the number of times you need to lower\
  \ the buckets.\n    // Example 1:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))\n\
  \    // (6l)\n    // Example 2:\n    // >>> maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l))\n    // (5l)\n    // Example 3:\n  \
  \  // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))\n    // (0l)\n    // Constraints:\n\
  \    // * all wells have the same length\n    // * 1 <= grid.length <= 10^2\n  \
  \  // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n    // * 1\
  \ <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity : Long) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) ==\
  \ (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) ==\
  \ (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (9l)) == (2l));\n    }\n\n}\n"
completions: ["        var sum = 0\n        var i = grid.length\n        while (i\
    \ > 0) {\n            sum += grid.apply(i-1).map(x => if (x == 0) capacity else\
    \ 0l).toList.foldLeft(0l) { (sum, e) => sum + e }\n            i -= 1\n      \
    \  }\n        sum", "        def maxFillUtil(grid : List[List[Long]], bucket:\
    \ List[Long], maxLength : Int, minLength : Int) : Int = {\n            val l =\
    \ grid.length\n            if(l <= minLength || l >= maxLength)\n            \
    \    return 1\n            val row = grid(l)\n            if(row(0) == bucket(0))\n\
    \                maxFillUtil(grid, bucket, maxLength, l+1)\n            else\n\
    \                if(bucket(0) == bucket(l-1))\n                    maxFillUtil(grid,\
    \ bucket, l+1, minLength)\n                else\n                    if(bucket(0)\
    \ == bucket(l-1)-1)\n                        maxFillUtil(grid, bucket, l+1, minLength)\n\
    \                    else\n                        if(bucket(l-1) == bucket(l-1))\n\
    \                            maxFillUtil(grid, bucket, l+1, minLength)\n     \
    \                   else\n                            if(bucket(l-1) == bucket(l-1)-1)\n\
    \                                maxFillUtil(grid, bucket, l+1, minLength)\n \
    \                           else\n                                maxFillUtil(grid,\
    \ bucket, minLength, l+1)\n        }\n        val res = new mutable.ArrayBuffer(0l)\n\
    \        var maxLength = 0l\n        for(l <- 1 to grid.length)\n            if(maxLength\
    \ < l)\n                maxLength = l\n        for(l <- 1 to maxLength)\n    \
    \        res += maxFillUtil(grid, new mutable.ArrayBuffer(0l), l, l)\n       \
    \ res.sum", "        var result : Long = 0\n        var i : Long = 0\n       \
    \ var j : Long = 0\n        while(i < grid.length){\n            var nextWellHasBeenFilled\
    \ : Boolean = false\n            while(j < grid(i).length){\n                if(grid[i][j]\
    \ != 0 && capacity >= grid[i][j]){\n                    grid[i][j] = 0\n     \
    \               nextWellHasBeenFilled = true\n                    capacity -=\
    \ grid[i][j]\n                }\n                j++\n            }\n        \
    \    if(!nextWellHasBeenFilled){\n                result++\n            }\n  \
    \          i++\n        }\n        return result", "        val result = mutable.ListBuffer(0)\n\
    \        for(i <- 0 until grid.length){\n            for(j <- 0 until grid(i).length){\n\
    \                result.add(grid(i)(j).map(i => i => if (i == 1) capacity/grid[0].length\
    \ else 0).sum)\n            }\n        }\n        result.foldLeft(0)(_ + _)",
  "        val bucket = mutable.ArrayBuffer(capacity)\n        val emptyCount = mutable.ArrayBuffer(capacity)\n\
    \        for (row <- grid.toStream) {\n            for (column <- row.toStream)\
    \ {\n                bucket.update(column, 1)\n                if (column < capacity)\
    \ {\n                    emptyCount.update(column, 0l)\n                }\n  \
    \          }\n        }\n\n        val answer = mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 1 to capacity) {\n            val count = (emptyCount(i) -\
    \ bucket(i)).toLong\n            if (count < answer.size) {\n                answer\
    \ = answer :+ count\n            }\n        }\n        answer.last", "       \
    \ val minCell = grid.head\n        var minCellId = 1\n        var fills = 0\n\
    \        var gridId = 0\n        var currentCell = minCell\n        while (minCell\
    \ != List.empty) {\n            val curCellId = currentCell.head\n           \
    \ val currCapacity = currentCell.tail.last\n            currentCell = currentCell.tail\n\
    \            if (currCapacity < capacity) {\n                val prevCell = grid.take(gridId).last\n\
    \                var prevCellId = 1\n                if (prevCell.head == 0) {\n\
    \                    val newCell = grid.map(_.filter(!_.isInstanceOf[List[Long]])).toList.drop(1)\n\
    \                    if (newCell.head == 0) newCell = List((1l))\n           \
    \         val newCapacity = newCell.last.tail.last\n                    if (newCapacity\
    \ < currCapacity) {\n                        newCell.init(_ + currCapacity - newCapacity)\n\
    \                        val newCellId = newCell.head.head\n                 \
    \       val newCell2Id = newCellId + 1\n                        var newCellId\
    \ = 1\n                        while (newCellId <= newCell2Id) {\n           \
    \                 var newCellId2 = newCellId + 1\n                           \
    \ var newCellId2 = 1\n                            while (newCellId2 <= newCell2Id)\
    \ {\n                                if (newCell2Id <= 10) {\n               \
    \                     if (newCellId < newCell2Id) {\n                        \
    \                val newCellId = newCellId + 1\n                             \
    \           val newCellId2 = newCellId2 + 1\n                                \
    \    } else {\n                                        break\n               \
    \                     }\n                                } else {\n          \
    \                          val newCellId = newCellId + 1\n                   \
    \                 val newCellId2 = newCellId2 + 1\n                          \
    \      }\n                            }\n                            if (newCellId\
    \ <= newCell2Id) {\n                                val newCell = newCell.toList\n\
    \                                val newCellId = newCell.head.head\n         \
    \                       val newCell2Id = newCellId + 1\n                     \
    \           var newCellId = 1\n                                while (newCellId\
    \ <= newCell2Id) {\n                                    var newCellId2 = newCellId\
    \ + 1\n                                    var newCellId2 = 1\n              \
    \                      while (newCellId2 <= newCell2Id) {\n                  \
    \                      if (newCell2Id <= 10) {\n                             \
    \               if (newCellId < newCell2Id) {\n                              \
    \                  val newCellId = newCellId + 1\n                           \
    \                     val newCellId2 = newCellId2 + 1\n                      \
    \                      } else {\n                                            \
    \    break\n                                            }\n                  \
    \                      } else {\n                                            val\
    \ newCellId = newCellId + 1\n                                            val newCellId2\
    \ = newCellId2 + 1\n                                        }\n              \
    \                      }\n                                    if (newCellId <=\
    \ new", "        // write your code here\n        val buckets = grid.map( row\
    \ => Array.ofDim[Long](row.length) )\n        var maxCount = 0\n        buckets.foreach(\
    \ row => {\n            row.foreach{ bucket => maxCount = bucket.max{bucket =>\
    \ bucket * capacity} }\n        })\n        maxCount", "        var count = 0\n\
    \        var currentCapacity = 0\n\n        for(row <- grid){\n            if(row(0)==0\
    \ && row(1)==0){\n                currentCapacity = capacity\n            } else\
    \ {\n                currentCapacity = capacity - row(0)\n            }\n    \
    \        for(i <- 1 to row.length-1){\n                for(j <- 1 to row.length-1){\n\
    \                    if(j == i){\n                        if(row(i) == 1){\n \
    \                           if(currentCapacity > capacity){\n                \
    \                currentCapacity = capacity\n                            }\n \
    \                       }\n                    } else {\n                    \
    \    if(row(i) == 0 && row(i-1) == 0 && row(i+1) == 0 && row(j) == 1){\n     \
    \                       if(currentCapacity > capacity){\n                    \
    \            currentCapacity = capacity\n                            }\n     \
    \                   }\n                    }\n                }\n            \
    \    count += 1\n                currentCapacity += 1\n            }\n       \
    \ }\n\n        count = 0\n        for(row <- grid){\n            for(i <- 1 to\
    \ row.length-1){\n                for(j <- 1 to row.length-1){\n             \
    \       if(j == i){\n                        if(row(i) == 1){\n              \
    \              if(currentCapacity > capacity){\n                             \
    \   currentCapacity = capacity\n                            }\n              \
    \          }\n                    } else {\n                        if(row(i)\
    \ == 0 && row(i-1) == 0 && row(i+1) == 0 && row(j) == 1){\n                  \
    \          if(currentCapacity > capacity){\n                                currentCapacity\
    \ = capacity\n                            }\n                        }\n     \
    \               }\n                }\n                count += 1\n           \
    \     currentCapacity += 1\n            }\n        }\n\n        return count",
  "        val n = grid.length\n        val m = grid(0).length\n        val c = new\
    \ Array[Long](m)\n        \n        val w = mutable.ArrayBuffer.fill(m, 0l)(0l)\n\
    \        val c = new Array[Long](m)\n        val d = new Array[Long](m)\n\n  \
    \      val p = new scala.collection.mutable.HashMap[Long, Int]()\n        for\
    \ (i <- 0 until m) {\n            p(grid(i)(0)) += 1\n        }\n\n        val\
    \ q = mutable.HashMap.empty[Long, Long]\n        for (i <- 0 until m) {\n    \
    \        for (j <- 0 until n) {\n                c(j) += p(grid(i)(j))\n     \
    \       }\n\n            val r = 0\n            val max = scala.math.max(scala.math.max(c(0),\
    \ c(m-1)), c(m-1)) + c(0) - capacity\n            while (max > 0) {\n        \
    \        if (max < d)(r) = max\n                max -= 1\n            }\n\n  \
    \          q(grid(i)(0)) = r\n        }\n\n        q.size", "        val result\
    \ = 0\n        if (grid.length == 1) {\n            return 1\n        }\n    \
    \    val maxHeight = grid[0].length\n        var maxRow = 0\n        var minHeight\
    \ = grid.length\n        val buckets = grid.map(_.map(_.toLong))\n        val\
    \ maxVolume = buckets.map(_.sum).max\n        val volumes = buckets.map(_.foldLeft(0l)\
    \ { (acc, val) => acc + val })\n        if (maxVolume > capacity) {\n        \
    \    return maxHeight + 1\n        }\n        var minRow = grid.length - 1\n \
    \       while (buckets.exists(_.length == 0)) {\n            minRow = minRow +\
    \ 1\n            buckets = grid.map(_.map(_.toLong))\n            maxVolume =\
    \ buckets.map(_.sum).max\n            if (maxVolume > capacity) {\n          \
    \      maxHeight = minRow + 1\n                break\n            }\n        \
    \    minHeight = minRow + 1\n        }\n        var row = 1\n        while (row\
    \ <= minHeight) {\n            var col = 1\n            var sum = 0\n        \
    \    var maxCount = 0\n            while (col <= maxHeight) {\n              \
    \  sum += buckets(row)(col)\n                if (sum > capacity) {\n         \
    \           maxCount = 1\n                    break\n                }\n     \
    \           maxCount = 0\n                col += 1\n            }\n          \
    \  if (maxCount > 0) {\n                val oldRow = row\n                val\
    \ oldCol = col\n                row += 1\n                col += 1\n         \
    \       if (row == minHeight) {\n                    minRow = oldRow\n       \
    \             minHeight = oldCol + 1\n                }\n            }\n     \
    \       if (row == minHeight) {\n                break\n            }\n      \
    \  }\n        if (row == minHeight) {\n            return 1\n        }\n     \
    \   result", "        val rowSize = grid.head.length\n        val columnSize =\
    \ grid.last.length\n        val maxBucket = capacity/rowSize\n        var totalBucket\
    \ = 0\n        var totalWater = 1\n        var row = 0\n        var column = 0\n\
    \        while (row < rowSize && column < columnSize) {\n            val bucket\
    \ = grid((row)(column))\n            totalBucket += bucket\n            totalWater\
    \ -= bucket\n            row = (row + 1) % rowSize\n            column = (column\
    \ + 1) % columnSize\n        }\n        var result = 0\n        if (totalBucket\
    \ > 0) {\n            result = Math.pow(maxBucket,columnSize-totalBucket) * Math.pow(maxBucket,rowSize-totalBucket-totalWater)\n\
    \        }\n        result", "        // Write your code here\n        var max\
    \ = 0\n        var counter = 1\n        var maxSoFar = 0\n        \n        for\
    \ (row <- grid){\n            var curr = 0\n            var currSum = 0\n    \
    \        for (i <- 0 until row.length){\n                currSum = currSum + row(i)\n\
    \                if(currSum > capacity){\n                    curr = 1\n     \
    \               currSum = 0\n                }\n            }\n            if(curr\
    \ > max){\n                max = curr\n            }\n            if(curr > maxSoFar){\n\
    \                maxSoFar = curr\n            }\n            counter = counter\
    \ + 1\n        }\n        if(max == maxSoFar){\n            counter\n        }else{\n\
    \            counter - maxSoFar\n        }", "        var count = 0\n        var\
    \ i = grid.length\n        var j = 0\n        var k = grid.headOption.map(_.length)\n\
    \        while(i < 2l) {\n            while(j < 2l) {\n                while(k\
    \ != 0l && j < k.get && j < 2l) {\n                    if(grid(i)(j) == 1l) {\n\
    \                        k -= 1\n                    } else if(grid(i)(j) == 0l)\
    \ {\n                        count += 1\n                        k += 1\n    \
    \                }\n                    j += 1\n                }\n          \
    \      j = 0\n            }\n            i = 0\n        }\n        count", " \
    \       val buckets = grid.map(_.toSet)\n        val maxCount = buckets.reduce((a,\
    \ b) => if (a.max > b.max) a else b).max\n        (maxCount + 1) * capacity -\
    \ (maxCount + 1)", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val maxBucket = m / n\n        var maxCount = 0\n        val m1 = grid.length\
    \ - 1\n        val n1 = grid[0].length - 1 \n        var i = 0\n        while\
    \ (i <= m1) {\n            var j = 0\n            while (j <= n1) {\n        \
    \        val bucket = (grid(i)(j) * capacity).toLong\n                if (bucket\
    \ > maxBucket) {\n                    maxBucket = bucket\n                   \
    \ maxCount = j.toLong\n                }\n                j += 1\n           \
    \ }\n            i += 1\n        }\n        maxCount", "        var result : Long\
    \ = 0\n        val buckets = mutable.HashMap[Long, Long]()\n        grid.foreach(row\
    \ => {\n            row.foreach(item => {\n                buckets += ((item %\
    \ capacity).asInstanceOf[Long], (item / capacity).asInstanceOf[Long])\n      \
    \      })\n        })\n        var i : Long = 0\n        while(i < buckets.size)\
    \ {\n            val capacityLeft = buckets(i)(0) - buckets(i)(1)\n          \
    \  if(capacityLeft <= 0) result += 1\n            buckets(i)(0) = buckets(i)(1)\
    \ - capacityLeft\n            i += 1\n        }\n        result", "        require\
    \ (grid.length == grid[0].length)\n        require (1 <= grid[0].length && grid[0].length\
    \ <= 10^2)\n        require (1 <= grid[0][1] && grid[0][1] <= 10^2)\n        require\
    \ (grid.length == grid.reduce((x, y) => x.size <=> y.size))\n        require (capacity\
    \ <= 10L)\n        var count = 0\n        var i = 0\n        var j = 0\n     \
    \   var l = 0\n        var maxL = 0\n        var tmp = 0\n        while (i < grid.length)\
    \ {\n            val l = grid.apply(i).max\n            if (l > maxL) {\n    \
    \            count = 0\n                maxL = l\n            }\n            while\
    \ (j < grid.apply(i).length) {\n                if (grid(i)(j) == 1) {\n     \
    \               tmp = grid.apply(i).max - l\n                    if (tmp <= capacity)\n\
    \                        count += (tmp <= 0)\n                }\n            \
    \    j += 1\n            }\n            i += 1\n        }\n        count", " \
    \       var cnt = 0\n        val res = mutable.ArrayBuffer.empty[List[Long]]\n\
    \        grid.foreach(row => {\n            val leftWells = mutable.ArrayBuffer.empty[List[Long]]\n\
    \            val rightWells = mutable.ArrayBuffer.empty[List[Long]]\n        \
    \    row.foreach(w => {\n                if (w == 1l) {\n                    leftWells\
    \ += w\n                } else {\n                    rightWells += w\n      \
    \          }\n            })\n            val rightBucket = rightWells.toList.sum\n\
    \            val leftBucket = leftWells.toList.sum\n            val leftToUse\
    \ = leftBucket - capacity\n            val rightToUse = rightBucket - capacity\n\
    \            val toUse = (rightToUse + leftToUse) / 2 // we must take at least\
    \ half the left bucket\n            if (toUse >= 0l) { // we need toUse\n    \
    \            cnt += 1\n                res += row :: leftWells\n             \
    \   res += row :: rightWells\n            }\n        })\n        cnt", "     \
    \   val m = grid.zipWithIndex.toList.sortWith(_._1 > _._1).lastOption.map(x =>\
    \ (x._2 - 1) * x._1 + x._2)\n        require(m != 0, \"grid must have at least\
    \ 1 row\")\n        require(m.length == grid.length, \"grid must have same number\
    \ of rows\")\n        require(m(0) == 1, \"all rows should have capacity 1\")\n\
    \        require(m.last < capacity, \"capacity should less than all rows\")\n\n\
    \        var buckets = m.tail\n        var n = m.length\n        var fills = 0\n\
    \n        while (n > 1) {\n            buckets = buckets.tail\n            fills\
    \ += 1\n            n -= 1\n        }\n        fills", "        val m = grid.head\n\
    \        val n = m.length\n        val bucketSize = math.min(math.max(1L, (m.toLong.maxVal\
    \ - m.toLong.minVal) / n), capacity)\n        val buckets = mutable.ArrayBuffer.fill(m,\
    \ 0)\n        for(x <- 1 to n) {\n            buckets(x - 1) = (bucketSize - buckets(x\
    \ - 1)).toLong\n        }\n        val x = 0\n        while(buckets.head < bucketSize)\
    \ {\n            val y = x\n            while(buckets(y) > 0) {\n            \
    \    buckets(y--) = buckets(y) + 1\n            }\n            x += 1\n      \
    \  }\n        x", "        var max = 0\n        val rowSize = grid.head._2.size\n\
    \        val columnSize = grid.head._1.size\n\n        for ((i, j) <- grid.indices)\
    \ {\n            val current = grid((i, j)) - capacity - 1\n            if (current\
    \ > max) {\n                max = current\n            }\n        }\n        max\
    \ / rowSize * columnSize", "        if (grid.length == 0)\n            return\
    \ 0\n        val cols = grid.head._2.size\n        val rows = grid.length\n  \
    \      val m = math.min(cols, rows)\n        val r = math.min(cols, rows)\n  \
    \      val n = math.min(rows, cols)\n        val r = math.min(r, m)\n        val\
    \ c = math.min(rows, cols)\n        val c = math.min(c, m)\n        var sum =\
    \ 0\n        var filling = 0\n        val newGrid = grid.map(_.map(_ + 0l))\n\
    \        val maxCapacity = n * capacity.toInt\n        while (maxCapacity > newGrid.head._2.sum\
    \ && filling < r * c * n) {\n            if (newGrid.head._2.sum < newGrid.head._1.sum)\
    \ {\n                newGrid.head._2.map(_.sum - newGrid.head._2.sum)\n      \
    \      }\n            if (newGrid.head._1.sum < newGrid.head._2.sum) {\n     \
    \           newGrid.head._1.map(_.sum - newGrid.head._1.sum)\n            }\n\
    \            if (newGrid.head._1.sum < newGrid.head._2.sum && newGrid.head._1.sum\
    \ < newGrid.head._2.sum) {\n                newGrid.head._1.map(_.sum - newGrid.head._2.sum)\n\
    \            }\n            newGrid.head._1.map(_.sum - newGrid.head._2.sum)\n\
    \            newGrid.head._2.map(_.sum - newGrid.head._1.sum)\n            filling\
    \ += 1\n        }\n        sum", "        var total = 0L\n        for ( i <- 0\
    \ until grid.length ) {\n            for ( j <- 1 until grid[0].length ) {\n \
    \               if ( grid(i).contains(j) ) { \n                    var count =\
    \ 0L\n                    for ( k <- 0 until capacity ) {\n                  \
    \      count += grid(i).take(k).contains(j) ? 1L : 0L\n                    }\n\
    \                    total += count * grid[0].length\n                    break\n\
    \                }\n            }\n        }\n        total", "        def recurse(row\
    \ : List[Long], bucket : mutable.Set[Long], count : Long, minFill : Long) : Long\
    \ = {\n            if (bucket.size == capacity) {\n                count += 1\n\
    \            }\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 0l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 0l, bucket, count, minFill)\n            minFill = recurse(row :+ 1l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 1l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 1l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 1l, bucket, count, minFill)\n            minFill = recurse(row :+ 0l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 0l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 1l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 1l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 0l, bucket, count, minFill)\n            minFill = recurse(row :+ 1l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 0l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 0l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)\n            minFill =\
    \ recurse(row :+ 1l, bucket, count, minFill)\n            minFill = recurse(row\
    \ :+ 1l, bucket, count, minFill)\n            minFill = recurse(row :+ 0l, bucket,\
    \ count, minFill)\n            minFill = recurse(row :+ 1l, bucket, count, minFill)\n\
    \            minFill = recurse(row :+ 1l, bucket, count, minFill)\n          \
    \  minFill = recurse(row :+ 0l, bucket, count, minFill)", "        val rowCount\
    \ = grid.length\n        val colCount = grid(0).length\n        if(rowCount >\
    \ 0 && colCount > 0) {\n            if(rowCount == 1 || colCount == 1)\n     \
    \           1\n            else\n                rowCount.product(colCount).foldLeft(0l.toLong){(res,\
    \ elem) =>\n                    if(grid(elem).sum() <= capacity)\n           \
    \             res + 1\n                    else\n                        res\n\
    \                }\n        }", "        val m = new mutable.PriorityQueue[(Long,\
    \ List[List[Long]]), mutable.PriorityQueue[(Long, List[List[Long]]), mutable.PriorityQueue[Long]]\
    \ // Use priority queue instead of max heap because it can handle duplicate keys\n\
    \        m.update(0, grid -> (0, grid -> List()))\n        val cnt = 1\n     \
    \   while (!m.isEmpty) {\n            val cur = m.dequeue()\n            val size\
    \ = cur._1\n            val curGrid = cur._2\n            val m = cur._3\n   \
    \         val capacity = curGrid.head\n            val x = curGrid.last\n\n  \
    \          x foreach {\n                case 0 => (curGrid, curGrid) foreach {\n\
    \                    case (row, _) => row.map(_ => 0)\n                }\n   \
    \             case 1 => (curGrid, curGrid) foreach {\n                    case\
    \ (row, _) => row.map(_ => 1)\n                }\n                case _ =>\n\
    \                }\n            x foreach {\n                case 0 => (curGrid,\
    \ curGrid) foreach {\n                    case (row, _) => row.map(_ => 0)\n \
    \               }\n                case 1 => (curGrid, curGrid) foreach {\n  \
    \                  case (row, _) => row.map(_ => 1)\n                }\n     \
    \           case _ =>\n                }\n            x foreach {\n          \
    \      case 0 => (curGrid, curGrid) foreach {\n                    case (row,\
    \ _) => row.map(_ => 0)\n                }\n                case 1 => (curGrid,\
    \ curGrid) foreach {\n                    case (row, _) => row.map(_ => 1)\n \
    \               }\n                case _ =>\n                }\n            x\
    \ foreach {\n                case 0 => (curGrid, curGrid) foreach {\n        \
    \            case (row, _) => row.map(_ => 0)\n                }\n           \
    \     case 1 => (curGrid, curGrid) foreach {\n                    case (row, _)\
    \ => row.map(_ => 1)\n                }\n                case _ =>\n         \
    \       }\n            x foreach {\n                case 0 => (curGrid, curGrid)\
    \ foreach {\n                    case (row, _) => row.map(_ => 0)\n          \
    \      }\n                case 1 => (curGrid, curGrid) foreach {\n           \
    \         case (row, _) => row.map(_ => 1)\n                }\n              \
    \  case _ =>\n                }\n            x foreach {\n                case\
    \ 0 => (curGrid, curGrid) foreach {\n                    case (row, _) => row.map(_\
    \ => 0)\n                }\n                case 1 => (curGrid, curGrid) foreach\
    \ {\n                    case (row, _) => row.map(_ => 1)\n                }\n\
    \                case _ ", "        var maxWellCapacity = 0\n        var curMaxWellCapacity\
    \ = 0\n        var curWellsToLow = 0\n        var curWellsToFill = 0\n       \
    \ var totalWellsToFill = 0\n        var currentLevel = 1\n        var curWell\
    \ = 0\n        for (rowIndex <- 0 until grid.length) {\n            curMaxWellCapacity\
    \ = grid[rowIndex].foldLeft(0) { (maxValue, item) =>\n                if (maxValue\
    \ > item) maxValue\n                else item\n            }\n            if (curMaxWellCapacity\
    \ > capacity) {\n                curMaxWellCapacity = capacity\n            }\n\
    \            while (currentLevel <= curMaxWellCapacity / capacity ) {\n      \
    \          curWellsToLow = (curMaxWellCapacity * currentLevel).toLong\n      \
    \          curWellsToFill += curWellsToLow\n                totalWellsToFill +=\
    \ curWellsToLow\n                currentLevel += 1\n            }\n          \
    \  while (curWellsToFill > 0) {\n                grid[rowIndex].tail.headOption\
    \ match {\n                case Some(curWell) => curWell -= 1\n              \
    \  case None => curWellsToFill -= 1\n                }\n                curWellsToFill\
    \ -= 1\n            }\n        }\n        totalWellsToFill", "        val max\
    \ = 0\n        val res = 0\n        for (a <- grid) {\n            val temp =\
    \ (a(0).asInstanceOf[Long], a(1).asInstanceOf[Long], a(2).asInstanceOf[Long])\n\
    \            val temp2 = temp._2 - temp._1\n            val temp3 = temp._3 -\
    \ temp._1\n            val temp4 = temp._3 - temp._2\n            val temp5 =\
    \ temp._4 - temp._1\n            val temp6 = temp._4 - temp._2\n            if\
    \ (temp3 > temp) {\n                if (temp4 > temp) {\n                    if\
    \ (temp6 > temp) {\n                        if (temp5 > temp) {\n            \
    \                if (temp2 > temp) {\n                                max = temp5\n\
    \                                res = 1\n                            }\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n        if (res == 0) res\n        else max", "        val rows\
    \ = grid.length // number of rows\n        val columns = grid(0).length // number\
    \ of columns\n        val maxBuckets = rows * columns // maximum number of buckets\n\
    \        val bucketCapacity = capacity / rows\n        var sum = 0 \n        for\
    \ (row <- 0 until rows; row < rows ; row++) {\n            for (column <- 0 until\
    \ columns; column < columns; column++) {\n                // use bucket\n    \
    \            if (grid[row][column] == 1)\n                {\n                \
    \    val bucket = bucket getOrElse { new Long(0); } \n                    // use\
    \ bucket\n                    bucket.update(capacity - bucket.asInstanceOf[Long],\
    \ 1l)\n                    sum = sum + bucket\n                }\n           \
    \ }\n        }\n        if (sum < bucketCapacity)\n            sum\n        else\n\
    \            maxBuckets - sum", "        def maxFillIterate(frontier : Set[Long],\
    \ grid : List[List[Long]], capacity : Long, result : Long) : Long = {\n      \
    \      result match {\n                case 0 => 0\n                case 1 =>\
    \ 0\n                case _ => {\n                    val index = frontier.head\n\
    \                    val r = frontier.tail\n\n                    if (index ==\
    \ grid.length) maxFillIterate(r, grid, capacity, 0)\n                    else\
    \ if (capacity == 0) maxFillIterate(r, grid, capacity, 1)\n                  \
    \  else {\n                        val next = grid[index].head\n             \
    \           maxFillIterate(r, grid, capacity - next, result + 1)\n           \
    \         }\n                }\n            }\n        }\n\n        val empty\
    \ = Set(1l, 0l)\n        val front = Set(1l, 0l)\n        var max = 0l\n     \
    \   var count = 0\n        for (row <- grid) {\n            count += 1\n     \
    \       var cur = 0l\n            for (cell <- row) {\n                if (cell.toLong\
    \ == 0) {\n                    cur += 1l\n                }\n            }\n \
    \           if (cur > max) {\n                max = cur\n                front\
    \ = empty\n            }\n            if (cur > max) {\n                max =\
    \ cur\n                front = empty\n            }\n        }\n        maxFillIterate(front,\
    \ grid, capacity, count)", "        var count : Long = 0\n        for (x <- 0\
    \ until grid.length) {\n            val minGrid: mutable.Map[Long, Long] = mutable.Map[Long,\
    \ Long]()\n            val buckets = mutable.Map[Long, Long]()\n            for\
    \ (y <- 0 until grid[x].length) {\n                buckets += ((x, y), capacity)\n\
    \                minGrid += ((x, y), grid[x][y].toLong)\n            }\n     \
    \       minGrid.forKeyValue { (x, y) =>\n                if (buckets.contains((x,\
    \ y))) {\n                    if (minGrid.contains((x, y))) {\n              \
    \          minGrid((x, y)) -= buckets((x, y))\n                        buckets\
    \ -= ((x, y))\n                        count += 1\n                    }\n   \
    \                 else {\n                        minGrid((x, y)) -= grid[x][y]\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        var max = 0\n        var res = 0\n        val rs = mutable.Queue[Int](0)\n\
    \        grid.foreach{row =>\n            row.foreach{c =>\n                if(c\
    \ == 0)\n                    rs.push(grid.get(rs.size))\n                else\n\
    \                    rs.pop()\n            }\n        }\n        while(!rs.isEmpty)\
    \ {\n            val r = rs.pop\n            val w = grid[r]\n            val\
    \ l = grid[r.max(0) - 1]\n            max = math.max(max, l - w)\n           \
    \ res += 1\n        }\n        if(max >= capacity)\n            max\n        else\n\
    \            0", "        var size : Int = grid.length\n        var fill : Long\
    \ = 1\n        var i : Int = 0\n        while (i < size) {\n            var j\
    \ : Int = i + 1\n            while (j < size) {\n                if (grid[i][j]\
    \ == 1l) {\n                    fill += capacity\n                } else {\n \
    \                   fill -= 1\n                }\n                j+=1\n     \
    \       }\n            i+=1\n        }\n        fill", "        val rem = grid.map(_.zipWithIndex).\n\
    \            filter(x => x._2.length == grid.length).\n            map(x => (x._2.last,\
    \ x._2)).toMap\n\n        val empty = grid.map(_.zipWithIndex).filter(x => x._2.length\
    \ == 1).map(x => (x._2.last, x._2)).toMap\n\n        val newMap = rem.foldLeft(empty)(\
    \ (m,x) => {\n            val last = m.getOrElse(x._1, 0l)\n            val m\
    \ = m.updated(x._1, last + x._2)\n            m\n        })\n        newMap.getOrElse(capacity,0l)",
  "        val m = grid.length\n        val n = grid[0].length\n        val bucket\
    \ = mutable.ArrayBuffer(capacity)\n        val result = mutable.ArrayBuffer.fill(m)\n\
    \        grid(0).foreach { n =>\n            bucket.clear()\n            grid(0).foreach\
    \ { i =>\n                bucket.add(grid(i)(n))\n            }\n            while\
    \ (!bucket.isEmpty) {\n                val k = bucket.head\n                bucket.clear()\n\
    \                grid(0).foreach { i =>\n                    if (grid(i)(n) <=\
    \ k) {\n                        bucket.add(grid(i)(n))\n                    }\n\
    \                }\n                if (bucket.size > 0) {\n                 \
    \   result.add(-1)\n                } else {\n                    result.add(0)\n\
    \                }\n            }\n        }\n        result(0)", "        var\
    \ n = 1\n        val result = new mutable.HashMap[Long, Int]()\n        for (row\
    \ <- grid) {\n            val bucketCapacity = row.last\n            var bucketSum\
    \ = 0\n            var bucketCount = 0\n            for (col <- row) {\n     \
    \           if (col == 0) bucketCount += 1\n                if (col == 1) bucketSum\
    \ += bucketCapacity\n                if (bucketCount == capacity) bucketCapacity\
    \ -= 1\n            }\n            result(bucketCount) += n\n            n *=\
    \ bucketCapacity\n        }\n        result(1l) += n\n        result(2l) += n\n\
    \        result(3l) += n\n        result(4l) += n\n        result(5l) += n\n \
    \       result(0l) += n\n        result", "        var result : Long = 0\n   \
    \     var newGrid : List[List[Long]] = grid.clone\n        val nwell = grid.map(_.length).reduce(_\
    \ + _)\n        val nrow = grid.length\n        val ncol = grid(0).length\n  \
    \      val nbucket = ceil(nwell / ncol).toInt\n        for ( i <- 0 until nrow)\
    \ {\n            for ( j <- 0 until ncol) {\n                if (grid[i][j] ==\
    \ 1) {\n                    var bucket = floor((j * ncol + i) / nbucket).toInt\n\
    \                    if (bucket <= capacity) {\n                        val x\
    \ = ((j * ncol + i) % nbucket) + 1\n                        val y = ((j * ncol\
    \ + i) / nbucket) + 1\n                        newGrid(x) = y.toLong\n       \
    \             }\n                }\n            }\n        }\n        for (i <-\
    \ 0 until nwell) {\n            if (newGrid(i) <= capacity) {\n              \
    \  result += newGrid(i).toLong\n            }\n        }\n        result", " \
    \       def findEmptyRow(i : Long, max : Long) : List[Long] = {\n            val\
    \ max = i\n            val list = List[Long]()\n            while (i < grid.length)\
    \ {\n                if (grid[max](0) != 0) {\n                    list :+= max\n\
    \                    max -= 1\n                } else {\n                    max\
    \ = 0\n                    i += 1\n                }\n            }\n        \
    \    list\n        }\n        def findEmptyColumn(j : Long, max : Long) : List[Long]\
    \ = {\n            val max = j\n            val list = List[Long]()\n        \
    \    while (j < grid.length) {\n                if (grid[j](0) != 0) {\n     \
    \               list :+= max\n                    max -= 1\n                }\
    \ else {\n                    max = 0\n                    j += 1\n          \
    \      }\n            }\n            list\n        }\n        var count = 0\n\
    \        val r = findEmptyRow(0, grid.length-1)\n        val c = findEmptyColumn(0,\
    \ grid.length-1)\n        var minCap = capacity\n        var maxCap = capacity\n\
    \        var i = 0\n        var j = 0\n        while (r.contains(0) == true &&\
    \ c.contains(0) == true) {\n            i += 1\n            j += 1\n         \
    \   minCap = max(minCap, grid[r.head](1).toLong)\n            maxCap = max(maxCap,\
    \ grid[c.head](1).toLong)\n            if (grid[r.head](1).toLong <= grid[c.head](1).toLong)\
    \ {\n                r.remove(0)\n                c.remove(0) \n             \
    \   count += grid[r.head](1).toLong\n            }\n        }\n        minCap",
  "        var count = 0;\n        var bucket = new Array[Long](10)\n        for (well\
    \ <- grid) {\n            var l = well.length\n            if (l == 0) {\n   \
    \             bucket.clear\n                count += 1\n                continue\n\
    \            }\n            var max = 0\n            for (j <- 0 until l) {\n\
    \                if (well[j] != 0l) {\n                    max += 1\n        \
    \        }\n            }\n            if (max > bucket(l)) {\n              \
    \  bucket(l) = max\n            }\n        }\n        count += (bucket.length\
    \ - 1)\n        for (i <- 0 until bucket.length) {\n            count -= bucket(bucket.length\
    \ - i - 1)\n        }\n        count", "        val grid = grid.toSet\n      \
    \  val colLen = grid(0).length\n        val rowLen = grid(0).zipWithIndex.map(_._2).max\n\
    \        \n        val res = mutable.HashSet[(Long, Long)]()\n        var count\
    \ = 0\n        \n        for (i <- 0 until colLen) {\n            val left  =\
    \ 0\n            val right = 10\n            \n            while (left < right)\
    \ {\n                val m = (left + right) / 2\n                \n          \
    \      // move upward\n                val row = grid(0).zipWithIndex.find { case\
    \ (k, v) => v >= m }._2\n                val col = row(i)\n                \n\
    \                // move right\n                val row = grid(0).zipWithIndex.find\
    \ { case (k, v) => v < m }._2\n                val col = row(i)\n            \
    \    \n                val v = grid(0).zipWithIndex.find { case (k, v) => v ==\
    \ m }._1\n                val w = v\n                \n                if (!res.contains((v,w)))\
    \ count += 1\n                \n                val nx = grid.toSeq.filter(_.contains(v))\n\
    \                if (nx.exists(_.size == 2)) break\n                \n       \
    \         val ny = grid.toSeq.filter(_.contains(w))\n                if (ny.exists(_.size\
    \ == 2)) break\n                \n                if (w >= colLen) right = m -\
    \ 1\n                else if (w <= colLen + rowLen) left = m + 1\n           \
    \     else break\n            }\n        }\n        \n        val res = res.toSeq.map(_.swap).map(_._2)\n\
    \        res.length * count", "        var max = 0\n        val m = grid.length\n\
    \        val n = grid(0).length\n        for(i <- 0 until m){\n            var\
    \ left = 0\n            for(j <- 1 until n){\n                if(i == 0 && j ==\
    \ 0){\n                    left += grid(i)(j)\n                } else if (grid(i)(j)\
    \ >= capacity){\n                    left += capacity\n                } else\
    \ {\n                    left += grid(i)(j)\n                }\n            }\n\
    \            if(left > max){\n                max = left\n            }\n    \
    \    }\n        return max", "        val gridSize = grid.size\n        val wells\
    \ = gridSize(0).toLong + gridSize(1).toLong\n        val buckets = wells * capacity\
    \ / 10\n\n        def fillRow(row: List[Long], bucket : Long, fill : Long): Unit\
    \ = {\n            row match {\n                case Nil => ()\n             \
    \   case x :: xs =>\n                    val y = x.toLong\n                  \
    \  fillRow(xs, bucket - y, fill + y)\n            }\n        }\n\n        val\
    \ empty = mutable.Queue[Long]()\n        val fill = mutable.Queue[Long]()\n\n\
    \        val result = mutable.ListBuffer.empty[Long]\n\n        // put wells into\
    \ the queue\n        empty.enqueue(wells)\n        fill.enqueue(wells)\n\n   \
    \     while !empty.isEmpty\n            if (!fill.isEmpty) {\n               \
    \ val nextWells = empty.dequeue()\n                val nextBuckets = fill.dequeue()\n\
    \n                fillRow(row, nextBuckets, nextWells)\n\n                result.addAll(fill.toList)\n\
    \            }\n\n            // put empty wells into the queue\n            empty.enqueue(nextWells)\n\
    \            fill.enqueue(nextBuckets)\n\n        scala.math.min(result.length)",
  "        val buckets = grid (1) // get a column of buckets\n        val totalWells\
    \ = grid.length // get a row of buckets\n        val maxCapacity = buckets.lastOption.get\
    \ (0) + capacity // get the maximum capacity from the last column\n        val\
    \ numFilled = mutable.ListBuffer[Long]() // initialize an ListBuffer to collect\
    \ the number of fills\n\n        // iterate the rows of the grid\n        for\
    \ (i <- 1 to totalWells) {\n            val currentCapacity = buckets(i)\n   \
    \         // if the current bucket is full, add an item to the ListBuffer to be\
    \ returned\n            if (currentCapacity >= maxCapacity) {\n              \
    \  numFilled += currentCapacity - maxCapacity\n                maxCapacity = buckets(i)\n\
    \            }\n            // otherwise, add the current row to the ListBuffer\
    \ and fill the bucket \n            else {\n                numFilled += 1\n \
    \               maxCapacity -= currentCapacity\n            }\n        }\n\n \
    \       // return the sum of all items in the ListBuffer\n        numFilled.sum",
  "        require(grid.length == 1 || grid.length == 2 || grid.length == grid.head.length,\
    \ \"invalid grid length\")\n        require(grid\n            .head\n        \
    \    .length == 1\n            && grid\n            .head\n            .head\n\
    \            .toLong == 1\n            && grid\n            .head\n          \
    \  .last\n            .toLong == 1\n            && grid.tail\n            .head\n\
    \            .toLong == 1\n            && grid\n            .tail\n          \
    \  .last\n            .toLong == 1, \"invalid grid data\")\n        require(capacity\
    \ <= 10, \"invalid capacity\")\n        val size = grid.head\n        val ret\
    \ = if (grid\n            .head\n            .toLong == 1\n            && grid\n\
    \            .last\n            .toLong == 1\n            && grid\n          \
    \  .tail\n            .toLong == 1\n            && grid\n            .tail\n \
    \           .last\n            .toLong == 1)\n            0\n        else\n  \
    \          grid\n            .head\n            .toLong == 1\n            && grid\n\
    \            .last\n            .toLong == 1\n            && grid\n          \
    \  .tail\n            .toLong == 1\n            && grid\n            .tail\n \
    \           .last\n            .toLong == 1)\n            0\n        for (i <-\
    \ 0 until size) {\n            val row = grid\n                (i + 1)\n     \
    \           .toLong == 1\n                && grid\n                (i + 1)\n \
    \               .last\n                .toLong == 1\n                && grid\n\
    \                (i + 1)\n                .tail\n                .toLong == 1\n\
    \                && grid\n                (i + 1)\n                .tail\n   \
    \             .last\n                .toLong == 1\n            val ret = ret +\
    \ (if (i > 0) {\n                val nextRow = grid\n                    (i +\
    \ 1)\n                    .toLong == 1\n                    && grid\n        \
    \            (i + 1)\n                    .last\n                    .toLong ==\
    \ 1\n                    && grid\n                    (i + 1)\n              \
    \      .tail\n                    .toLong == 1\n                    && grid\n\
    \                    (i + 1)\n                    .tail\n                    .last\n\
    \                    .toLong == 1\n                nextRow && nextRow.head.toLong\
    \ == row.head.toLong && nextRow.tail.toLong == row.tail.toLong\n             \
    \   else false)\n            } else false)\n        }\n        ret", "       \
    \ var numWells : Long = 0\n        var fillNum = 0\n\n        for(x<-grid) {\n\
    \            for(y<-x) {\n                if(y(1) > capacity) fillNum += 1\n \
    \           }\n            numWells += x.length\n        }\n\n        if(fillNum\
    \ > 0) {\n            (fillNum - 1) * capacity\n        } else {\n           \
    \ 0\n        }", "        var count = 0\n        val maxSize = grid.foldLeft(0l)((max,\
    \ row) => math.max(max, row.size))\n        var row = 0\n        while (row <\
    \ grid.length) {\n            var column = 0\n            while (column < grid[row].length)\
    \ {\n                var size = 0\n                while ( grid[row][column] !=\
    \ 0l) {\n                    size += 1\n                    column += 1\n    \
    \                if (size > maxSize || size < capacity * row) {\n            \
    \            count += 1\n                        size = 0\n                  \
    \  }\n                }\n                column += 1\n                row += 1\n\
    \            }\n            row += 1\n        }\n        count * maxSize / grid.size",
  "        val m = grid.length\n        val n = grid(0).length\n        def maxFillHelper(i\
    \ : Int, j : Int) : Long = {\n            if(i == m && j == n) return 1\n    \
    \        if(i == m || j == n) return 0\n            val ret = if (grids(i-1, j)\
    \ == 1) maxFillHelper(i-1, j-1) else maxFillHelper(i, j-1)\n            val ret\
    \ = if (grids(i, j-1) == 1) maxFillHelper(i-1, j) else maxFillHelper(i, j)\n \
    \           val ret = if (grids(i-1, j-1) == 1) maxFillHelper(i-1, j) else maxFillHelper(i,\
    \ j)\n            val ret = if (grids(i-1, j) == 1) maxFillHelper(i, j-1) else\
    \ maxFillHelper(i, j)\n            val ret = if (grids(i, j+1) == 1) maxFillHelper(i,\
    \ j) else maxFillHelper(i, j)\n            val ret = if (grids(i+1, j+1) == 1)\
    \ maxFillHelper(i+1, j+1) else maxFillHelper(i+1, j+1)\n            val ret =\
    \ if (grids(i-1, j+1) == 1) maxFillHelper(i, j+1) else maxFillHelper(i, j+1)\n\
    \            val ret = if (grids(i+1, j) == 1) maxFillHelper(i+1, j) else maxFillHelper(i+1,\
    \ j)\n            val ret = if (grids(i+1, j+1) == 1) maxFillHelper(i+1, j+1)\
    \ else maxFillHelper(i+1, j+1)\n            return ret * capacity / grids(i, j)*2\n\
    \        }\n        maxFillHelper(0, 0)", "        var bucket : mutable.Map[Long,\
    \ Int] = mutable.Map()\n        for (i <- 0 until grid.length) {\n           \
    \ val l = grids(i).head\n            bucket(l) += 1\n        }\n        var fill\
    \ = 0\n        var changes = 0\n        for (i <- 0 until grid.length) {\n   \
    \         val l = grids(i).head\n            val c = bucket(l)\n            if\
    \ (c > 0) {\n                fill += 1\n            }\n            while (fill\
    \ > 0) {\n                if (bucket(l) <= capacity) {\n                    fill\
    \ -= 1\n                } else {\n                    bucket(l) -= 1\n       \
    \         }\n                changes += 1\n            }\n        }\n        changes",
  "        val m = grid.map(_.size).max\n        val n = grid.map(_.head.length).max\n\
    \        val arr = new Array[Long](n)\n        arr(0) = capacity\n        var\
    \ maxFill = 0\n        for( i <- 1 until m ) {\n            for( j <- 1 until\
    \ n ) {\n                if( arr(j) < 0 ) arr(j) = -capacity + 1\n           \
    \     if( arr(j) > 0 ) {\n                    var total = 0\n                \
    \    var count = 0\n                    for( k <- 0 until arr(j) ) {\n       \
    \                 if( grid(i-k)(i-j) == 1 ) count += 1\n                     \
    \   total += arr(j) - k\n                    }\n                    if( total\
    \ > arr(j) ) {\n                        arr(j) = total\n                     \
    \   if( total > maxFill ) maxFill = total\n                    }\n           \
    \     }\n            }\n        }\n        maxFill", "        var ans = 1\n  \
    \      val maxBucket = capacity.toLong / grid.head.length.toLong\n        var\
    \ currentBucket = 0\n        \n        for (row <- 0 until grid.length) {\n  \
    \          var currentRow = grid[row]\n            val maxBuckets = maxBucket\
    \ / currentRow.size\n            val currentBuckets = currentBucket + maxBuckets\n\
    \            \n            for (c <- 0 until currentRow.size) {\n            \
    \    if (currentRow(c) == 0) {\n                    currentBucket += currentBuckets\n\
    \                    currentBuckets -= maxBuckets\n                }\n       \
    \         else {\n                    currentBucket += currentBuckets\n      \
    \              currentBuckets -= maxBuckets\n                }\n            }\n\
    \            \n            ans = Math.max(ans, currentBucket)\n        }\n   \
    \     ans", "        def recurse(grid: List[List[Long]], capacity : Long, cur:\
    \ Long) : Long = {\n            // base case\n            if (grid.length == 1)\
    \ {\n                if (cur.sum < capacity) {\n                    cur.sum <-\
    \ capacity\n                }\n                return cur\n            }\n   \
    \         val index = cur.toInt\n            val r = grid(index)(index).toLong\n\
    \            if (r.toLong == 1) {\n                val next = recurse(grid, capacity\
    \ - r, cur + r).toLong\n                next.sum <- next.sum + capacity\n    \
    \            return next\n            } else if (r.toLong == 0) {\n          \
    \      val next = recurse(grid, capacity, cur + r).toLong\n                next.sum\
    \ <- next.sum + capacity\n                return next\n            }\n       \
    \ }\n        val result = recurse(grid, capacity, 0l)\n        if (result.sum\
    \ == capacity) {\n            result.sum\n        } else {\n            -1\n \
    \       }", "        val rowsLength = grid.length\n        val colsLength = grid(0).length\n\
    \        if (rowsLength == colsLength) {\n            0\n        }\n        if\
    \ (rowsLength > colsLength) {\n            0\n        }\n        else {\n    \
    \        val maxBuckets = rowsLength * colsLength\n            val maxBucketsCapacity\
    \ = capacity\n            val rowToRemove = 0\n            val colToRemove = 0\n\
    \            val currentMaxBuckets = maxBuckets\n            val currentCapacity\
    \ = maxBucketsCapacity\n            val grid = grid.toList\n            val buckets\
    \ = mutable.Set[Long]().toList.iterator\n            var sum = 0\n           \
    \ while (currentMaxBuckets != 0) {\n                if (currentCapacity == 0)\
    \ {\n                    buckets = buckets.filter(_.toLong < 0)\n            \
    \    }\n                if (buckets.size == 0) {\n                    currentCapacity\
    \ += 1\n                }\n                else {\n                    val maxBucketsBefore\
    \ = buckets.filter(_.toLong > 0).toList.length\n                    if (currentCapacity\
    \ - maxBucketsBefore == 0) {\n                        currentCapacity += 1\n \
    \                   }\n                }\n                buckets = buckets.filter(_.toLong\
    \ <= 0).toList.iterator\n                sum += maxBuckets\n                currentMaxBuckets\
    \ -= 1\n            }\n            maxBuckets\n        }", "        val m = grid.length\n\
    \        val n = grid(0).length\n        val bucket = mutable.ListBuffer[Long](capacity)\n\
    \        val result = mutable.ListBuffer[Long]()\n        var i : Int = 0\n  \
    \      var j : Int = 0\n        var left : Int = 0\n        var right : Int =\
    \ 0\n        while (i < m && j < n) {\n            if (grid(i)(j).toLong == 1)\
    \ {\n                bucket.clear()\n                bucket.addAll(grid(i)(j -\
    \ 1).toLong to grid(i)(j + n).toLong)\n                for (k <- bucket) {\n \
    \                   left += k\n                }\n                for (k <- bucket.tail)\
    \ {\n                    right += k\n                }\n                result\
    \ += left - right\n                i += 1\n                j += 1\n          \
    \  } else {\n                i += 1\n                j += 1\n            }\n \
    \       }\n        bucket.clear()\n        bucket.addAll(grid(i)(j).toLong to\
    \ grid(i)(j + n).toLong)\n        for (k <- bucket) {\n            left += k\n\
    \        }\n        for (k <- bucket.tail) {\n            right += k\n       \
    \ }\n        result -= left + right\n        result match {\n            case\
    \ x if x <= 0 => 0\n            case _ => result.sum\n        }", "        def\
    \ maxFillInternal(grid : List[List[Long]], capacity : Long) : List[List[Long]]\
    \ = {\n            def fillBucket(bucket : Long, grid : List[List[Long]]): List[List[Long]]\
    \ = bucket match {\n                case 0 => grid // empty bucket\n         \
    \       case 1 => grid.drop(1) // fill bucket with one unit of water\n       \
    \         case _ => fillBucket(bucket.drop(1), grid.drop(1))\n            }\n\
    \            grid.map(_.toList).reduce(fillBucket(_, capacity))\n        }\n \
    \       val answer = maxFillInternal(grid, capacity)\n        answer.foldLeft(0l){\
    \ (sum, current) => sum + current.map(_.toLong).sum }", "        val map = new\
    \ mutable.HashMap[List[Long], Long]()\n        val result = mutable.ListBuffer.empty[Long]\n\
    \        val bucket = mutable.ListBuffer.empty[Long]\n        grid.foreach(row\
    \ => bucket.append(0l))\n        grid.foreach(row => map.put(row, 0l))\n     \
    \   grid.foreach(row => bucket.append(0l))\n        grid.foreach(row => bucket.foreach(cell\
    \ => map(cell) = bucket.sum))\n        map.foreach { case (row, cell) => bucket.foreach(cell\
    \ => if (bucket.sum == 0) bucket.push(cell + capacity) else if (bucket.sum ==\
    \ cell) bucket.push(cell - capacity))}\n        bucket.foreach(cell => if (bucket.sum\
    \ == cell) bucket.push(cell - capacity))\n        var i = 1\n        while (i\
    \ < bucket.sum) {\n            if (bucket.sum - i < bucket.sum) bucket.take(bucket.sum\
    \ - i).foreach(x => map(x.toLong) = bucket.sum)\n            else bucket.foreach(x\
    \ => map(x.toLong) = bucket.sum - i)\n            i += 1\n        }\n        result\
    \ = bucket.sum\n        result", "        var counter = mutable.Map[List[Long],\
    \ Int]().withDefaultValue(0)\n        for(i <- 0 until grid.length) {\n      \
    \      for(j <- 0 until grid[0].length)\n                if(grid[i][j] == 0) {\n\
    \                    val cur = counter.get(grid[i])\n                    if(cur\
    \ != 0) counter(grid[i]) = cur + 1\n                }\n        }\n        for(i\
    \ <- 0 until grid.length) {\n            val cur = counter(grid[i])\n        \
    \    if(cur > 0) counter(grid[i]) = cur - 1\n        }\n        if(counter.forall(_\
    \ > 0l)) {\n            val res = counter.maxBy(_._1)._1.toLong\n            if(res\
    \ > capacity) -1\n            else res\n        } else 0l", "        val x = grid(0).length\n\
    \        val y = grid(0).zipWithIndex.filter(_._1 == 0).map(_._2).max\n      \
    \  val maxx = grid(0).zipWithIndex.filter(_._1 == 1).map(_._2).max\n        val\
    \ maxy = grid(0).zipWithIndex.filter(_._1 == 2).map(_._2).max\n        val xx\
    \ = if (maxx == 0) x else maxx - x\n        val yy = if (maxy == 0) y else maxy\
    \ - y\n        if (Math.min(xx, yy, yy) == xx) yy else xx - yy", "        var\
    \ sum = 0\n        var minCapacity = 0\n        for (row <- grid) {\n        \
    \    val rowCapacities = row.map(_.toLong)\n            minCapacity = math.min(minCapacity,\
    \ rowCapacities.max)\n            sum += rowCapacities.sum\n        }\n      \
    \  if (sum > capacity) sum else sum - minCapacity", "        var max = 0\n   \
    \     var fill = 0\n        var index = 0\n        for (row <- grid){\n      \
    \      max = Math.max(max, row.length)\n        }\n        for (row <- grid){\n\
    \            fill = row.foldLeft(0l) { (max, cur) => {\n                val x\
    \ = if (cur == 0) capacity else max - 1\n                val y = if (cur == 0)\
    \ capacity else cur - 1\n                if (x <= y) return cur\n            \
    \    if (cur == 0) return max\n                return max\n            }}\n  \
    \          index += 1\n        }\n        max", "        def dfs(grid : List[List[Long]],\
    \ currentRow : Int, currentCol : Int, currentWell : Int) : Unit = {\n        \
    \    val currentBucket = grid[currentRow](currentCol)\n            if(currentWell\
    \ == 0 && currentBucket < capacity)\n                currentBucket += 1\n    \
    \        else if(currentWell == 1 && currentBucket > 0)\n                currentBucket\
    \ -= 1\n            else if(currentWell == 0 && currentBucket == 0)\n        \
    \        dfs(grid, currentRow + 1, currentCol, currentWell + 1)\n            else\
    \ if(currentWell == 1 && currentBucket == 1)\n                dfs(grid, currentRow\
    \ + 1, currentCol, currentWell - 1)\n        }\n        val maxRow = 0\n     \
    \   val maxCol = 0\n        val maxWell = 0\n        for(row <- grid.indices)\
    \ {\n            for(col <- grid(0).indices) {\n                val currentBucket\
    \ = grid[row](col)\n                if(currentWell == 0 && currentBucket < capacity)\n\
    \                    currentBucket += 1\n                else if(currentWell ==\
    \ 1 && currentBucket > 0)\n                    currentBucket -= 1\n          \
    \      else if(currentWell == 0 && currentBucket == 0)\n                    dfs(grid,\
    \ row, col, 1)\n                else if(currentWell == 1 && currentBucket == 1)\n\
    \                    dfs(grid, row, col, -1)\n                if(currentWell >\
    \ maxWell)\n                    maxWell = currentWell\n                if(currentCol\
    \ > maxCol)\n                    maxCol = currentCol\n                if(row >\
    \ maxRow)\n                    maxRow = row\n            }\n        }\n      \
    \  (maxRow - maxCol) + maxWell", "        require(grid.length == grid[0].shape.length\
    \ && grid[0].length == grid[1].length,\n            \"grid: ${grid.length}, grid[0].length:\
    \ ${grid[0].shape.length}, grid[1].length: ${grid[1].length}\")\n        val newGrid\
    \ = grid.map(_.map(_.toLong))\n        val rowSize = grid[0].shape.length\n  \
    \      val colSize = grid[0].length\n        var currentMax = capacity\n     \
    \   var maxCount = 0\n        for ((r, c) <- grid.zipWithIndex) {\n          \
    \  val rIdx = r / rowSize\n            val cIdx = c / colSize\n            val\
    \ rValue = newGrid((rIdx))\n            val cValue = newGrid((cIdx))\n       \
    \     currentMax = rValue.map(cValue).max\n            maxCount = if (currentMax\
    \ > capacity) maxCount + 1 else maxCount\n        }\n        require(maxCount\
    \ <= rowSize * colSize, \"maxCount: ${maxCount}\")\n        currentMax", "   \
    \     require(grid.length == grid(0).length)\n        require(grid(0).length ==\
    \ 1)\n        val max = 0\n        val index = 0\n        for (row <- 0 until\
    \ grid.length) {\n            if (grid[row].isEmpty) {\n                for (col\
    \ <- 0 until grid[row].length) {\n                    val value = grid((row *\
    \ grid[0].length) + col)\n                    val oldCount = max\n           \
    \         if (value == 0) {\n                        val newCount = Math.max(0,\
    \ maxCount.get(index) + 1)\n                        if (newCount > oldCount) {\n\
    \                            max = newCount\n                        }\n     \
    \               }\n                    else max = Math.max(max, newCount)\n  \
    \                  maxCount.update(index, max)\n                    index += 1\n\
    \                }\n            }\n        }\n        return max", "        val\
    \ buckets = mutable.PriorityQueue[mutable.PriorityQueue[Long]](\n            new\
    \ mutable.PriorityQueue[Long](capacity, new scala.math.Ordering[Long] {\n    \
    \            override def compare(x: Long, y: Long): Int = x - y\n           \
    \ })\n        )\n        val bucketIndexes = mutable.PriorityQueue[Long](-1L,\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        val bucketCapacity = mutable.PriorityQueue[Long](capacity,\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        val bucketIndexesList = mutable.PriorityQueue[List[Long]](List(-1L),\
    \ new scala.math.Ordering[Long] {\n            override def compare(x: Long, y:\
    \ Long): Int = x - y\n        })\n        for (row <- grid) {\n            val\
    \ index = row.zipWithIndex.map(_._1).max\n            buckets.add(new mutable.PriorityQueue[Long](row.length,\
    \ new scala.math.Ordering[Long] {\n                override def compare(x: Long,\
    \ y: Long): Int = x - y\n            }))\n            bucketIndexes.enqueue(index)\n\
    \            bucketCapacity.enqueue(row.length)\n        }\n        val bucketCount\
    \ = 0\n        val bucketCapacityCount = 0\n        while (!buckets.isEmpty) {\n\
    \            bucketCount += 1\n            val index = bucketIndexes.dequeue()\n\
    \            bucketCapacityCount += bucketCapacity.dequeue()\n            val\
    \ bucket = buckets.dequeue()\n            var bucketIndex = -1\n            var\
    \ bucketCapacity = -1\n            while (bucket != null) {\n                bucketIndex\
    \ = index\n                bucketCapacity = bucketCapacityCount\n            \
    \    bucket = bucket.dequeue()\n            }\n            val capacityToAdd =\
    \ bucketCapacity - bucketCapacityCount\n            val capacityToRemove = bucketCapacityCount\
    \ - bucketCapacity\n            buckets.enqueue(\n                new mutable.PriorityQueue[Long](\n\
    \                    bucket.enqueue(\n                        bucket.dequeue()\
    \ + capacityToAdd\n                    )\n                )\n            )\n \
    \           bucketIndexes.enqueue(bucketIndex)\n            bucketCapacityCount\
    \ += capacityToRemove\n        }\n        bucketCount", "        val map = collection.mutable.Map[Long,\
    \ List[Long]]()\n        for (row <- grid)\n        {\n            val key = row(1).asInstanceOf[Long]\n\
    \            val list = map.get(key).orElse(List()) \n            list :+= 0\n\
    \            map += key -> list\n        }\n        var i = 0\n        while (i\
    \ < grid.length)\n        {\n            val buckets = map.get(capacity).map(_.asInstanceOf[Long]).toArray\n\
    \            if (buckets.length > 0)\n            {\n                val index\
    \ = buckets.indexOf(0)\n                if (index > -1)\n                {\n \
    \                   map.get(capacity).remove(index)\n                    i +=\
    \ index\n                }\n                else\n                    i += 1\n\
    \            }\n            else\n                i += 1\n        }\n        i\
    \ + 1", "        val n = grid.length\n        val m = grid(0).length\n       \
    \ val map = mutable.HashMap[(List[Long], List[Long]), Int]()\n        for (i <-\
    \ 0 until m) {\n            for (j <- 0 until n) {\n                if (grid(i)(j)\
    \ == 1) {\n                    val bucket = map.getOrElse((List(grid(i)(j).toLong,\
    \ grid(i)(j + 1).toLong, grid(i)(j + 2).toLong), capacity), capacity)\n      \
    \              map.put((List(grid(i)(j).toLong, grid(i)(j + 1).toLong, grid(i)(j\
    \ + 2).toLong), bucket)\n                }\n            }\n        }\n       \
    \ for (pair <- map.keys) {\n            map((pair._1, pair._2))\n        }", " \
    \       require(grid.length == grid.head.size,\n               \"grid.length must\
    \ be the same as grid.head.size\")\n        require(grid\n                 .map(_.size)\n\
    \                 .sum == 1,\n               \"all cells in each row must occupy\
    \ the same well\")\n        require(grid\n                 .map(_.size)\n    \
    \             .sum == grid\n                 .map(_.size)\n                 .sum,\n\
    \               \"all cells in each column must occupy the same well\")\n    \
    \    require(capacity > 0, \"capacity must be positive\")\n        require(grid\n\
    \                 .map(_.length)\n                 .sum == grid\n            \
    \     .map(_.length)\n                 .sum,\n               \"all cells in each\
    \ well must occupy the same space\")\n        require(grid\n                 .zipWithIndex\n\
    \                 .map(_.toList)\n                 .map(l => l.length == grid\n\
    \                                  .zipWithIndex\n                           \
    \       .filter(!_.toList.contains(l.head))\n                                \
    \  .map(_.head)\n                                  .contains(l.last))\n      \
    \           .forall(!_),\n               \"all cells in each well must occupy\
    \ the same space\")\n        require(grid\n                 .zipWithIndex\n  \
    \               .map(_.toList)\n                 .map(l => l.length == grid\n\
    \                                  .zipWithIndex\n                           \
    \       .filter(!_.toList.contains(l.head))\n                                \
    \  .map(_.last)\n                                  .contains(l.head))\n      \
    \           .forall(!_),\n               \"all cells in each well must occupy\
    \ the same space\")\n        val buckets = grid\n            .zipWithIndex\n \
    \           .map(_.toList)\n            .map(l => l.length == grid\n         \
    \                     .zipWithIndex\n                              .filter(!_.toList.contains(l.head))\n\
    \                              .map(_.head)\n                              .contains(l.last))\n\
    \            .flatMap(!_)\n            .map(bucket => 0l to bucket)\n        \
    \    .toList\n            .sorted\n        val usedBuckets = mutable.ListBuffer.empty[Int]\n\
    \        val result = mutable.ListBuffer.empty[Int]\n        for (i <- 1 to buckets.size\
    \ - 1) {\n            val r = i + buckets(i) - buckets(i - 1)\n            if\
    \ (r > 0) {\n                val leftBucket = buckets(i)\n                val\
    \ leftBuckets = buckets.drop(i)\n                val rightBuckets = buckets.take(r)\n\
    \                val leftKey = buckets(i) - leftBucket\n                val rightKey\
    \ = leftBucket - buckets(r)\n                if (leftBucket + r == buckets.last)\
    \ {\n                    val newKey = leftBucket + r\n                    ", " \
    \       var currentCapacity : Long = 0\n        var isEmpty : Boolean = true\n\
    \        var numOfEmpty : Int = 0\n        var buckets : List[List[Long]] = List()\n\
    \        var bucketIndex = 0\n        grid.foreach(r => {\n            if (r.isEmpty)\
    \ isEmpty = true\n            buckets = r :: buckets\n        })\n        if (isEmpty)\
    \ bucketIndex += buckets.size * 1\n        while(!isEmpty && bucketIndex < buckets.size\
    \ * capacity) {\n            isEmpty =  buckets(0).isEmpty\n            if (isEmpty)\
    \ {\n                buckets(0) = buckets(0).take(capacity)\n                currentCapacity\
    \ += 1\n            }\n            buckets(0) = buckets(0).drop(capacity)\n  \
    \          bucketIndex += 1\n            numOfEmpty += 1\n            buckets(0)\
    \ = buckets(0).take(capacity)\n            bucketIndex += 1\n        }\n     \
    \   currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex -= 1\n\
    \        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex -=\
    \ 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n  \
    \      numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.size\
    \ * 1\n        currentCapacity -= 1\n        numOfEmpty -= 1\n        bucketIndex\
    \ -= 1\n        numOfEmpty -= buckets.size * 1\n        currentCapacity -= 1\n\
    \        numOfEmpty -= 1\n        bucketIndex -= 1\n        numOfEmpty -= buckets.",
  "        def dfs(grid : List[List[Long]], i : Int, j : Int, visited : Set[Int],\
    \ visitedCount : Int) : Long = {\n            if(visited.contains(i) && visited.contains(j))\
    \ {\n                return visitedCount\n            }\n            if(grid[i][j]\
    \ == 0) {\n                visited.add(i)\n                visited.add(j)\n  \
    \              visitedCount += 1\n                return dfs(grid, i + 1, j, visited,\
    \ visitedCount)\n            }\n            if((grid[i][j] == 1) && (i != grid.length\
    \ - 1 && j != grid[i].length - 1)) {\n                visited.add(i)\n       \
    \         visited.add(j)\n                visitedCount += 1\n                return\
    \ dfs(grid, i + 1, j, visited, visitedCount)\n            }\n            visitedCount\
    \ += 0\n            return visitedCount\n        }\n        var visited = new\
    \ mutable.HashSet[Int]()\n        visited.add(0)\n        visited.add(grid.length\
    \ - 1)\n        return dfs(grid, 0, 0, visited, 0)", "        val result = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var n = 0\n\
    \        while (i < grid.length && j < grid[i].length) {\n            result +=\
    \ math.max(grid(i)(j) - capacity, grid[j](i)) - capacity\n            k = i\n\
    \            while (k >= 0 && j >= 0) {\n                n += grid[k](i)\n   \
    \             grid[k-1] = grid[k-1].drop(i+1)\n                j--\n         \
    \       k--\n            }\n            i = k + 1\n            j = n\n       \
    \     n = 0\n        }\n        result", "        val count = new mutable.HashMap[List[Long],\
    \ Long]()\n        val result = new mutable.HashMap[List[Long], Long]()\n    \
    \    grid.foreach(row => {\n            row.foreach(bucket => {\n            \
    \    if (count.contains(bucket)) {\n                    count(bucket) = count(bucket)\
    \ + 1 \n                } else {\n                    count.put(bucket, 1)\n \
    \               }\n            })\n        })\n        count.foreach(bucket =>\
    \ {\n            if (count(bucket) > 1) {\n                val index = bucket.min\n\
    \                val value = count(bucket)\n                if (value > 0) {\n\
    \                    if (result.contains(bucket)) {\n                        result(bucket)\
    \ = result(bucket) + value\n                    } else {\n                   \
    \     result(bucket) = value\n                    }\n                }\n     \
    \       }\n        })\n        val total = count(count.keys.max)\n        result.foreach(bucket\
    \ => {\n            if (count(bucket) > 1) {\n                val value = count(bucket)\n\
    \                if (value > 0) {\n                    count(bucket) = count(bucket)\
    \ - 1 \n                }\n            }\n        })\n        result.values.sum",
  "        val buckets = mutable.HashMap[Long, Int]()\n        val result = 0\n  \
    \      for (r <- 0 until grid.length) {\n            val rowMax = grid(r)\n  \
    \          for (c <- 0 until rowMax.length) {\n                if (!rowMax.contains(0l)\
    \ && !rowMax.contains(1l)) {\n                    val bucketId = rowMax.foldLeft(0l)((x,\
    \ y) => x | y)\n                    if (buckets.contains(bucketId)) {\n      \
    \                  val oldValue = buckets(bucketId)\n                        buckets(bucketId)\
    \ = oldValue + 1\n                        if (oldValue > capacity) {\n       \
    \                     result = math.max(result, buckets(bucketId))\n         \
    \               }\n                    }\n                }\n            }\n \
    \       }\n        result", "        if (grid == null || grid.isEmpty) 0\n   \
    \     val numWells = grid.head.size\n        val bucketSize = capacity / numWells\n\
    \        val totalCapacity = capacity\n        val buckets = mutable.ArrayBuffer[mutable.ArrayBuffer[Long]]()\n\
    \        for (i <- 1 to numWells)\n            for (j <- 1 to numWells)\n    \
    \            if (j < i)\n                    buckets += mutable.ArrayBuffer[Long]()\n\
    \        // The bucket is full\n        if (buckets.isEmpty || totalCapacity <\
    \ buckets.last.last)\n            return 0\n        val numBuckets = buckets.last.length\n\
    \        val minBucketCapacity = totalCapacity / numBuckets\n        // The bucket\
    \ cannot exceed the total capacity\n        if (buckets.last.last > totalCapacity)\n\
    \            return 0\n        // The bucket is empty and there exists an empty\
    \ bucket\n        if (buckets.last.isEmpty && buckets.last.last == 0l)\n     \
    \       return 0\n        // The buckets are empty\n        if (buckets.last.last\
    \ == 0l)\n            return 1\n        val fillBucket = buckets.last.last\n \
    \       val bucketCapacity = buckets.last.last\n        val bucketsLeft = numBuckets\
    \ - fillBucket\n        // The bucket is empty and there exists an empty bucket\n\
    \        if (buckets.last.isEmpty && buckets.last.last == 0l)\n            return\
    \ 0\n        // The buckets are full\n        if (bucketsLeft == 0)\n        \
    \    return 0\n        // The bucket is full\n        if (bucketCapacity == minBucketCapacity)\n\
    \            return maxFill(grid.tail, bucketCapacity)\n        // The bucket\
    \ is empty and there exists an non-empty bucket\n        if (bucketCapacity ==\
    \ totalCapacity && buckets.last.isEmpty && buckets.last.last != 0l)\n        \
    \    return maxFill(grid.tail, bucketCapacity)\n        // The bucket is empty\
    \ and there exists an non-empty bucket\n        if (bucketCapacity == totalCapacity)\n\
    \            return 1 + maxFill(grid.tail, bucketCapacity)\n        // The bucket\
    \ is full\n        if (bucketCapacity < minBucketCapacity)\n            return\
    \ 0\n        // The bucket is empty and there exists an non-empty bucket\n   \
    \     if (bucketCapacity == minBucketCapacity)\n            return 1 + maxFill(grid.tail,\
    \ bucketCapacity)\n        // The bucket is empty and there exists an non-empty\
    \ bucket\n        if (bucketCapacity < totalCapacity)\n            return 1 +\
    \ maxFill(grid.tail, bucketCapacity)\n        // The bucket is full\n        return\
    \ 0", "        val rowCount = grid.length\n        val colCount = grid(0).length\n\
    \        \n        val max = 0l\n        var temp : Long = 0l\n        var i :\
    \ Int = 0\n        var j : Int = 0\n        \n        for(i <- 0 until rowCount){\n\
    \            for(j <- 0 until colCount){\n                temp = grid[i][j].toLong\n\
    \                while(grid[i][j] == 1l){\n                    if(temp < capacity){\n\
    \                        temp += 1l\n                    } else {\n          \
    \              temp -= 1l\n                    }\n                    \n     \
    \               if(temp > max){\n                        max = temp\n        \
    \            }\n                    \n                    if(temp == 0){\n   \
    \                     temp = 1l\n                    }\n                }\n  \
    \          }\n        }\n        \n        max", "        // Your code here\n\
    \        val map = mutable.HashMap[Long, Long]()\n        for( row <- 0 until\
    \ grid.length)\n        {\n            for( column <- 0 until grid[0].length)\n\
    \            {\n                map.put(row, column)\n            }\n        }\n\
    \n        var i = 0\n        var j = 0\n        var count = 0\n        while(i\
    \ < grid.length && j < grid[0].length)\n        {\n            count = map.get(grid(i)(j))\n\
    \            if(count == 0)\n            {\n                i +=1\n          \
    \      map.put(grid(i)(j), capacity)\n                j += 1\n               \
    \ map.put(grid(i)(j), capacity)\n            }\n            else if(count < capacity)\n\
    \            {\n                i += 1\n            }\n            else\n    \
    \        {\n                j += 1 \n            }\n        }\n        count",
  "        var buckets = mutable.ArrayBuffer.empty[Int]\n        for (row <- 0 until\
    \ grid.length) {\n            buckets += 0 until capacity.toInt\n        }\n \
    \       \n        for (bucket <- buckets) {\n            var wells = 0\n     \
    \       var water = 0\n            var current = 0\n            while (current\
    \ < grid.length && water < capacity) {\n                val row = current.toInt\n\
    \                val col = current.toInt\n                val value = grid[current]\n\
    \                val value = if (value == 0l) 0l else 1l\n                if (value\
    \ != 0l && buckets(bucket + value) == buckets(bucket + 1))\n                 \
    \   wells += 1\n                water += 1\n                current += 1\n   \
    \         }\n            if (water > capacity)\n                return wells *\
    \ 2\n        }\n        return 0l", "        // Write your code here\n       \
    \ var total = 0\n        val map = scala.collection.mutable.HashMap.empty[Long,\
    \ Long]\n        grid.foreach{\n            row => {\n                row.foreach{\n\
    \                    v => {\n                        map  += v\n             \
    \       }\n                }\n            }\n        }\n        map.foreach(\n\
    \            v => {\n                if (v <= capacity) {\n                  \
    \  total += 1\n                }\n            }\n        )\n        return total",
  "        val m = grid.length\n        val n = grid(0).length\n        val buckets\
    \ = Array.ofDim[Long](m, n)\n        for ((i, j) <- 0 until m) {\n           \
    \ for (k <- 0 until n) {\n                buckets(i, j) = if (grid(i)(k) == 0)\
    \ capacity else 0\n            }\n        }\n        return maxFillHelper(buckets,\
    \ m, n)", "        val height  = grid.length\n        val width   = grid(0).get.length\n\
    \        val minVal  = math.min(width, height)\n        var count = 0\n      \
    \  var index = 0\n        while(index<height) {\n            var index2 = 0\n\
    \            while(index2<width) {\n                val value = grid((index+minVal-1)/minVal,(index2+minVal-1)/minVal)\n\
    \                if(value == 1l) {\n                    count+=1;\n          \
    \      }\n                index2+=1\n            }\n            index+=1\n   \
    \     }\n        math.max(1,Math.ceil(Math.sqrt(count*capacity/width*height/minVal)).toInt)",
  "        // write your code here\n        val totalSize = grid.reduce(_ + _)\n \
    \       if (totalSize == 0l)\n            return 0\n        val size = totalSize\
    \ / capacity\n        val bucket = mutable.ArrayBuffer(capacity).view.take(size)\n\
    \        val empty = mutable.ArrayBuffer(capacity).view.take(size)\n        val\
    \ countMap = mutable.HashMap[List[Long], Long]()\n        grid.foreach { row =>\n\
    \            row.foreach { bucket => bucket.foreach { empty => empty.foreach {\
    \ _ <- 0 } }\n            empty.clear()\n            bucket.foreach { bucket =>\
    \ empty.add(bucket) }\n        }\n        val maxCount = countMap.max { case (_,\
    \ count) => count }\n        countMap.values.toList.max", "        val m = grid.map(_.length).max\n\
    \        val n = grid.map(_.last).max\n        // find first non-zero cell\n \
    \       val i = grid (0 until m) (0 until n).find(_.nonEmpty)\n        // use\
    \ recursion to fill all cells, return the count\n        val count = maxFillUtil(grid,\
    \ i, m, n, capacity)\n        // the return value can be replaced with 'count'\n\
    \        count", "        if (grid.length == 1) {\n            grid(0).map(_.toInt).sum\n\
    \        } else {\n            var result : Long = 0\n            var fillRow\
    \ : List[List[Long]] = grid.head\n            var fillCol : List[Long] = grid.head\n\
    \n            for (x <- grid.length) {\n                for (y <- x.toInt) {\n\
    \                    var currentCol : List[Long] = fillCol.tail\n            \
    \        var currentRow : List[Long] = fillRow.tail\n\n                    var\
    \ currentMax: Long = currentCol.foldLeft(0l) { (max: Long, current: Long) => max\
    \ max max }\n                    var currentIndex: Long = currentRow.foldLeft(0l)\
    \ { (max: Long, current: Long) => max max max }\n\n                    var current:\
    \ Long = currentCol.foldLeft(0l) { (max: Long, current: Long) => max max max }\n\
    \                    if (current == capacity) {\n                        currentMax\
    \ = currentMax.toLong - currentIndex.toLong\n                        result =\
    \ result + currentMax\n                    }\n                }\n            \
    \    fillRow = fillRow.tail\n                fillCol = fillCol.tail\n        \
    \    }\n            result\n        }", "        require(grid.length == grid.head.size)\n\
    \        var n = 0\n        var max = 0\n        val rowCount = grid.head.size\n\
    \        var index = 0\n        while(index < rowCount) {\n            require(rowCount\
    \ > index)\n            require(index > 0)\n            require(index != rowCount)\n\
    \            val row = grid(index)\n            val colCount = row.size\n    \
    \        var colIndex = 0\n            while(colIndex < colCount) {\n        \
    \        require(colCount > colIndex)\n                require(colIndex > 0)\n\
    \                require(colIndex != colCount)\n                val col = rows(index)\n\
    \                val value = grid(index)(colIndex)\n                if(value !=\
    \ 0) {\n                    require(index > 0)\n                    require(colCount\
    \ > colIndex)\n                    require(colIndex > 0)\n                   \
    \ require(colIndex != colCount)\n                    var maxValue = 0l\n     \
    \               var colMaxValue = 0l\n                    val maxCol = grid(index\
    \ - 1)\n                    val maxRow = grid(index + 1)\n                   \
    \ val colMin = grid(index - 1)(colIndex)\n                    val colMax = grid(index\
    \ + 1)(colIndex)\n                    val minCol = grid(index - 1)(colCount)\n\
    \                    val minRow = grid(index + 1)(colCount)\n                \
    \    val colRange = colMax - colMin + 1\n                    var rowRange = 0l\n\
    \                    val maxColValue = max(maxCol)\n                    val minColValue\
    \ = min(minCol)\n                    val maxRowValue = max(maxRow)\n         \
    \           val minRowValue = min(minRow)\n                    val minColRange\
    \ = minColValue - minColValue + 1\n                    val maxColValue = max(maxCol)\n\
    \                    val minColValue = min(minCol)\n                    val maxRowValue\
    \ = max(maxRow)\n                    val minRowValue = min(minRow)\n         \
    \           val minRowRange = minRowValue - minRowValue + 1\n                \
    \    val colValue = col(colIndex)\n                    val rowValue = row(colIndex)\n\
    \                    val colMaxValue = max(colMax)\n                    val rowMaxValue\
    \ = max(rowMax)\n                    val colMinValue = min(colMin)\n         \
    \           val rowMinValue = min(rowMin)\n                    val colRangeValue\
    \ = colRangeValue + 1\n                    val rowRangeValue = rowRangeValue +\
    \ 1\n                    maxValue = math.max(maxValue, value)\n              \
    \      colMaxValue = math.max(colMaxValue, colValue)\n                    rowMaxValue\
    \ = math.max(rowMaxValue, rowValue)\n                    colMinValue = math.min(colMinValue,\
    \ colValue)\n                    rowMinValue = math.min(rowMinValue, rowValue)\n",
  "        var totalWells = grid.head\n\n        totalWells match {\n            case\
    \ head :: tail => maxFill(tail, capacity)\n            case _ => 0\n        }",
  "        if (grid.length < 1 || grid.head.length < 1 || grid.head.headOption.isEmpty\
    \ || grid.tail.length < 1 || grid.tail.tailOption.isEmpty) {\n            return\
    \ 0\n        }\n        // val buckets = grid.map(_.toLong)\n        // val result\
    \ = buckets.count(_ == 0) // count the non zero buckets\n        val buckets =\
    \ grid.map(_.toLong).toSet\n        val result = (buckets.count(_ == 0) - (buckets.count(_\
    \ == 0) - capacity)).toLong\n        // println(buckets.count(_ == 0) - (buckets.count(_\
    \ == 0) - capacity))\n        return result", "        val totalBuckets = grid.length\n\
    \        if (totalBuckets == 0) {\n            return 0\n        }\n        var\
    \ buckets = List[Long]()\n        for (i <- 0 until totalBuckets) {\n        \
    \    buckets += grid(i)(0).toLong\n        }\n        var numBuckets = 0\n   \
    \     var currentBucket = 0\n        var currentBucketCapacity = 0\n        while\
    \ (buckets.nonEmpty) {\n            if (currentBucketCapacity >= capacity) {\n\
    \                numBuckets += 1\n                currentBucketCapacity -= capacity\n\
    \                currentBucket += 1\n            }\n            val availableCapacity\
    \ = currentBucketCapacity - grid(currentBucket)(1).toLong\n            buckets\
    \ = buckets.dropWhile(bucket => bucket <= availableCapacity)\n            currentBucketCapacity\
    \ -= grid(currentBucket)(1).toLong\n        }\n        return numBuckets", " \
    \       val rowSum = grid.sum\n        val maxVal = Math.min(rowSum, capacity)\n\
    \        val counter = collection.mutable.HashMap.empty[Long, Int]\n        for\
    \ (row <- grid.indices) {\n            for (column <- grid) {\n              \
    \  if (rowSum - row.toLong >= maxVal) {\n                    maxVal -= row.toLong\n\
    \                    counter.put(row.toLong, counter.getOrElse(row.toLong, 0)\
    \ + 1l)\n                }\n            }\n        }\n        val res = counter.filter{\
    \ case (count, value) => (value - count) > 0 }\n        return res.map(_._1).sum",
  "        val rows        = grid.length\n        val cols        = grid[0].length\n\
    \        val maxBuckets = math.max(rows,cols)\n        val buckets     = scala.collection.mutable.ArrayBuffer.fill[Long](maxBuckets)\n\
    \        val rowsLow     = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        val colsLow     = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for ((i,j) <- 1 to maxBuckets) {\n            if (buckets(i)==0l.toLong\
    \ && buckets(j)==0l.toLong && grid[i][j].toLong==1l.toLong && i<rows && j<cols)\
    \ {\n                buckets(i) = grid[i][j].toLong\n                buckets(j)\
    \ = 0l.toLong\n            }\n        }\n        for (i <- 1 to maxBuckets) {\n\
    \            if (buckets(i).toLong==1l.toLong) {\n                rowsLow += buckets(i).toLong\n\
    \                colsLow += buckets(i).toLong\n            }\n        }\n    \
    \    rowsLow.length", "        var count = 0\n        var min = Long.MaxValue\n\
    \        val res = mutable.ArrayBuffer(0)\n        var max = 0\n        for (r\
    \ <- 0 until grid.length){\n            for (c <- 0 until grid[r].length){\n \
    \               if(max < grid[r][c]){\n                    max = grid[r][c]\n\
    \                }\n            }\n            if(max < min){\n              \
    \  min = max\n            }\n            res += grid[r]\n        }\n        for(i\
    \ <- 0 until res.length){\n            if(res(i) < min)\n                count\
    \ += 1\n        }\n        count", "        val maxBuckets = grid.toList.flatMap(_.toList).groupBy(_\
    \ % capacity)\n        val sumOfBuckets = grid.toList.flatMap(_.toList).sum\n\
    \        val maxBucketsCap = maxBuckets.map(_._2.length).max\n        val buckets\
    \ = (1 to maxBucketsCap).map(x => 0L).toList ++ maxBuckets.map(_._2.map(y => y).sum).toList\n\
    \        val bucketsCap = buckets.max\n        val numBucketsRem = bucketsCap\
    \ - capacity\n        if(numBucketsRem > 0){\n            maxFill(grid.map(_.removeAll(0))\
    \ ++ grid.map(_.removeAll(0)) ++ buckets.map(_.remove(0)), capacity)\n       \
    \ }else{\n            maxBucketsCap - numBucketsRem \n        }", "        //\
    \ write your code here\n        grid.foldLeft(0l)((max, currentRow) => {\n   \
    \         if(max == 0) (max += currentRow.foldLeft(0l){(max, currentCol) =>\n\
    \                if((currentCol % 2) == 0) max += currentCol\n               \
    \ else max - currentCol\n            }, 0)\n            else (max -= currentRow.foldLeft(0l){(max,\
    \ currentCol) =>\n                if((currentCol % 2) == 0) max += currentCol\n\
    \                else max - currentCol\n            }, 0)\n        })", "    \
    \    val rowMax = grid.head.map(x => x.toLong)\n        val colMax = grid.last.map(x\
    \ => x.toLong)\n        val gridSize = grid.length\n        val colSum = grid.map(_.toLong).sum\n\
    \        val rowSum = grid.map(_.toLong).sum\n        val currentCapacity = colSum\
    \ * (rowSum / gridSize) * (colSum / rowSum)\n        var count = 0\n        var\
    \ j = 0\n        for (i <- 0 to (gridSize - 1)) {\n            while (j < colSum)\
    \ {\n                if (gridSize(i) - capacity <= j) {\n                    count\
    \ += 1\n                    j = 0\n                }\n                j += 1\n\
    \            }\n        }\n        count", "        var counter = Long.MaxValue\n\
    \        for (i <- 1 to grid.length-1) {\n            for (j <- 1 to grid[i].length-1)\
    \ {\n                counter += 1\n                if (grid(i-1,j-1)+capacity<=grid[i][j])\
    \ {\n                    grid(i-1,j-1) = grid[i][j]\n                    counter\
    \ = maxFill((grid,capacity),counter)\n                }\n            }\n     \
    \   }\n        counter", "        require(grid.length == grid(0).length)\n   \
    \     var max = 0\n        var i = 0\n        var j = 0\n        while (i < grid.length)\
    \ {\n            while (j < grid[0].length && grid(i)(j) < capacity) j++\n   \
    \         while (j < grid[0].length && grid(i)(j) == capacity) j++\n         \
    \   if (j == grid[0].length) j = 0\n            max = Math.max(max, j)\n     \
    \       i += 1\n        }\n        max", "        val n = grid.length\n      \
    \  val m = grid.head.size\n        val x = new mutable.HashMap[Long, Int]()\n\
    \        var cur = 0\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                if (grid(i)(j) != 0) {\n                    val\
    \ k = capacity.toInt - (grid(i)(j) * capacity)\n                    if (k > 0)\
    \ {\n                        val v = x(grid(i)(j))\n                        if\
    \ (v < k) {\n                            x(grid(i)(j)) = k\n                 \
    \           cur = cur + k\n                        }\n                    }\n\
    \                }\n            }\n        }\n        cur", "        val height\
    \ = (grid map _.length).toSet\n        val width = (grid map _.last).toSet\n \
    \       val grid = (grid map (_.toList).toList)\n        if (grid.length == 1)\
    \ 0\n        else if (width.size < height) width.size * capacity\n        else\
    \ if (height.size < width) height.size * capacity\n        else (height.size +\
    \ width.size) * (capacity/2)", "        var max = 0\n        var current = 0\n\
    \        var currentMax = 0\n        var currentMin = 0\n        var bucket =\
    \ mutable.BitSet(capacity)\n        for (row <- grid.indices) {\n            val\
    \ temp = grid[row]\n            var next = 0\n            var j = 0\n        \
    \    var k = 0\n            var count = 0\n            var prev = 0\n        \
    \    while (j < temp.length) {\n                if (temp(j) == 1) {\n        \
    \            bucket.set(temp)\n                    count = count + 1\n       \
    \             if (count == 1) next = temp(j)\n                    if (prev ==\
    \ 0) prev = temp(j)\n                    if (prev != 0) {\n                  \
    \      current = k\n                        currentMin = k\n                 \
    \       currentMax = k\n                        bucket.clear(prev)\n         \
    \               bucket.clear(next)\n                        count = 0\n      \
    \              }\n                    prev = temp(j)\n                    next\
    \ = temp(j)\n                    k = k + 1\n                }\n              \
    \  j = (j + 1) % temp.length\n            }\n            current = k\n       \
    \     currentMin = k\n            currentMax = k\n            bucket.clear(prev)\n\
    \            bucket.clear(next)\n            bucket.clear(current)\n        }\n\
    \        for (bucket <- bucket.iterator) {\n            current = bucket.nextClearBit(0)\n\
    \            if (current > currentMax) {\n                max = currentMax\n \
    \           }\n            else if (current < currentMin) {\n                max\
    \ = currentMin\n            }\n            else {\n                max = current\n\
    \            }\n        }\n        return max", "        val buckets = mutable.Map[Long,\
    \ Long]()\n        var total = 0\n        var count = 0\n        for (r <- 1 to\
    \ grid.length) {\n            for (c <- 1 to grid(r).length) {\n             \
    \   if (c != grid(r).length) {\n                    buckets += ((grid(r).length,\
    \ c) -> grid[r](c))\n                }\n            }\n            total += grid(r).sum\n\
    \            count += 1\n        }\n        var index = 0\n        var max = 0\n\
    \        for (bucket <- buckets) {\n            if ((bucket._1 -> bucket._2) <\
    \ (max -> grid[(bucket._2).floor.toLong]).sum) {\n                max = bucket._1\
    \ -> bucket._2\n                index = bucket._1\n            }\n        }\n\
    \        total += max\n        count -= 1\n        count += index\n        total\
    \ += count\n        return total", "        val maxCol = grid.map(_.length).max\n\
    \        val maxRow = grid.maxBy(_.length).getOrElse(0 :: Nil).length\n      \
    \  val map = mutable.Map[Int, (Int, Int)]().withDefaultValue((maxRow, maxCol))\n\
    \        for (row <- 0 until maxRow; col <- 0 until maxCol)\n            map +=\
    \ (row -> col) -> (row,col)\n        \n        val totalFills = 0 until map.length\n\
    \        \n        while(map.length > 0) {\n            val (row, col) = map.head\n\
    \            totalFills += 1\n            map.remove(col).foreach(m => map -=\
    \ (col._1 -> m))\n        }\n        \n        totalFills * capacity", "     \
    \   val buckets = grid.map{case List(a,b,c,d) => (a.toLong,b.toLong,c.toLong,d.toLong)}\n\
    \        val map = buckets.toMap\n        val fillableBuckets = map.filter(_._2.toLong\
    \ - _._2.toLong < capacity).toList\n        fillableBuckets.map(_._1.toLong).sum",
  "        val result = mutable.Map[Long, List[List[Long]]]()\n\n        // fill each\
    \ row with empty buckets\n        for(i <- 0 until grid.length)\n            for(j\
    \ <- 0 until grid[i].length)\n                if((grid(i,j) % 2) == 0)\n     \
    \               result(grid(i,j)) = List(List(grid(i,j))) :: result(grid(i,j))\n\
    \                else\n                    result(grid(i,j)) = List(List(grid(i,j)))\
    \ :: result(grid(i,j))\n\n        // fill each bucket with water\n        val\
    \ buckets = mutable.Map[Long, Long]()\n        for(i <- 0 until capacity.toInt)\n\
    \            buckets(i) = 0\n\n        for(i <- 0 until grid.length)\n       \
    \     for(j <- 0 until grid[i].length)\n                if((grid(i,j) % 2) ==\
    \ 0)\n                    buckets(result(grid(i,j))(1)) = grid(i,j)\n        \
    \        else\n                    buckets(result(grid(i,j))(2)) = grid(i,j)\n\
    \n        val current = 0L\n        val count = 0L\n        while(current <= capacity.toInt)\
    \ {\n            val next = buckets(current).toInt\n            buckets(current)\
    \ = current + 1\n            current++\n            if(buckets(current) < capacity.toInt)\
    \ {\n                if(buckets(next) == 0)\n                    count += 1\n\
    \                buckets(current) = next + 1\n            }\n            buckets(current)\
    \ = 0L\n        }\n        count", "        require(grid.length == grid[0].length)\n\
    \        require(grid.length == grid[1].length)\n        require(grid.length ==\
    \ grid[2].length)\n        require(capacity >= 1)\n        require(grid.length\
    \ >= 3)\n\n        val numWells = grid[0].length\n        val bucketCapacities\
    \ = grid\n            .map(_.map(_.toLong))\n            .map(_.toArray.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.toList)\n\
    \            .map(_.toList)\n            .map(_.toList)\n            .map(_.to",
  "        val m = new mutable.HashMap[Long, Long]()\n        for (i <- 0 until grid.length)\
    \ {\n            for (j <- 0 until grid[0].length) {\n                if (grid[i][j]\
    \ > 0) {\n                    m.putIfAbsent(j + 1, 0L)\n                    m(j\
    \ + 1) = m(j + 1) + capacity\n                }\n            }\n        }\n  \
    \      val result = m.toSeq.map(x => x._2 - x._1).max\n        if (result == 0l)\
    \ {\n            0\n        } else {\n            result\n        }", "      \
    \  val rowMax = grid.foldLeft((1l, 0l)) { case ((maxRow, maxCol), row) =>\n  \
    \          if (row[maxCol] == 1l) {\n                (maxRow + row[maxCol].toLong,\
    \ maxCol)\n            } else {\n                (maxRow, maxCol)\n          \
    \  }\n        }\n        (maxRow - capacity, rowMax._1)", "        if (grid.isEmpty)\
    \ 0\n        else if (grid.head.length != 1) 0\n        else {\n            val\
    \ row = grid.head\n            val left = maxFill(row.tail, 1)\n            val\
    \ right = maxFill(row.init, capacity)\n            val fill = left.toLong + right.toLong\n\
    \            if (fill > capacity) maxFill(grid, capacity)\n            else maxFill(row.init\
    \ :+ row.tail.head, fill)\n        }", "        val m = grid.map(_.length)\n \
    \       val n = grid.map(_.head.length)\n        var ret = 0\n        for (i <-\
    \ 0 to m.get(0).max if m.get(i) > 0) {\n            if (m(i) > 0) {\n        \
    \        ret += m(i) * n(i)\n            }\n        }\n        for (i <- 0 to\
    \ m.get(m.length - 1).max if m.get(i) > 0) {\n            if (m(i) > 0) {\n  \
    \              ret += m(i) * n(i)\n            }\n        }\n        for (i <-\
    \ 0 to m.get(m.length - 1).max if m.get(i) > 0) {\n            if (m(i) > 0) {\n\
    \                ret += m(i) * n(i)\n            }\n        }\n        for (i\
    \ <- 0 to m.get(m.length - 1).max if m.get(i) > 0) {\n            if (m(i) > 0)\
    \ {\n                ret += m(i) * n(i)\n            }\n        }\n        for\
    \ (i <- 0 to m.get(m.length - 1).max if m.get(i) > 0) {\n            if (m(i)\
    \ > 0) {\n                ret += m(i) * n(i)\n            }\n        }\n     \
    \   for (i <- 0 to m.get(m.length - 1).max if m.get(i) > 0) {\n            if\
    \ (m(i) > 0) {\n                ret += m(i) * n(i)\n            }\n        }\n\
    \        return ret", "        // Write your code here.\n        val minVal =\
    \ math.min(grid.map(_.length).max,\n                             grid.map(_(1).length).max)\n\
    \        val maxVal = math.min(grid.map(_.length).max,\n                     \
    \        grid.map(_(1).length).max)\n        val delta = (capacity / minVal)\n\
    \        var count = 0\n        for(i <- 0 to maxVal-minVal) {\n            val\
    \ l1 = i / delta\n            val l2 = i % delta\n            val min = l1 * delta\
    \ + l2\n            val max = l1 * delta + delta + l2\n            if (grid((min+minVal).toInt,\
    \ (max+maxVal).toInt).length < capacity) count = count+1\n        }\n        count",
  "        var i : Int = 0\n        var j : Int = 0\n        var min : Long = Long.MaxValue\n\
    \        var max : Long = 0\n        var result : Long = 0\n        while (i <=\
    \ grid.length && j <= grid[0].length && j < grid[0].length + 1) {\n          \
    \  if (grid[i][j] == 1l) {\n                if (capacity > max) {\n          \
    \          max = capacity\n                }\n                min = min + grid[i][j]\n\
    \            } else if (grid[i][j] == 0l) {\n                if (capacity < min)\
    \ {\n                    min = capacity\n                }\n                max\
    \ = max + grid[i][j]\n            }\n            j += i\n            i += 1\n\
    \        }\n        result = max\n        capacity = min\n        while (capacity\
    \ < max) {\n            capacity = capacity / 2\n        }\n        return result\
    \ * capacity", "        val n = grid.length\n        val m = grid[0].length\n\
    \        val dp = new Array[Long](m)\n        // initialize all values in dp to\
    \ -1\n        for (i <- 0 until m) {\n            dp(i) = -1\n        }\n    \
    \    // fill all cells that have a 1\n        for (i <- 0 until n) {\n       \
    \     val minIndex = math.min(i, m - 1)\n            val maxIndex = math.max(i,\
    \ m - 1)\n            for (j <- minIndex to maxIndex) {\n                if (grid(i)(j)\
    \ != 0) {\n                    dp(i) = math.max(dp(i), dp(i + 1) + grid(i)(j))\n\
    \                }\n            }\n        }\n        // return the max value\
    \ from the dp matrix\n        dp.max", "        // Write your code here.\n   \
    \     var res = 0\n        var i = grid.length -1\n        var j = grid(0).length\
    \ -1\n        while (i >= 0) {\n            while (j >= 0) {\n               \
    \ if (grid(i)(j) == 1) {\n                    res += 1\n                    i\
    \ -= 1\n                    j -= 1\n                } else {\n               \
    \     j -= 1\n                }\n            }\n            i -= 1\n        }\n\
    \        while (i >= 0) {\n            while (j >= 0) {\n                if (grid(i)(j)\
    \ == 0) {\n                    res += 1\n                    i -= 1\n        \
    \            j -= 1\n                } else {\n                    j -= 1\n  \
    \              }\n            }\n            i -= 1\n        }\n        res",
  "        val grid = mutable.ArrayBuffer(grid)\n        grid.map(_.map(x => x match\
    \ {\n            case 0 => -1\n            case 1 => 0\n            case -1 =>\
    \ 1\n        }))\n\n        val rows = grid.map(_.size)\n        val columns =\
    \ grid.head.length\n        val capacity = capacity\n\n        val grid = mutable.ArrayBuffer(grid)\n\
    \        val allBuckets = mutable.ArrayBuffer(capacity - 1, capacity - 1, capacity\
    \ - 1, capacity - 1)\n\n        grid.map { row =>\n            val bucket = row(0)\n\
    \            val newRow = grid.map(row => 0 :: row.drop(1): _*)\n\n          \
    \  allBuckets.map(bucket => (bucket, newRow))\n        }.flatten.toSeq.sortBy(_._1).reverse\
    \ map { case (bucket, newRow) =>\n            val size = newRow.map(x => 0 ::\
    \ x).sum\n            size match {\n                case 0 => bucket\n       \
    \         case _ =>\n                    if (newRow.map(x => 0 :: x).sum < 0)\
    \ bucket - 1 else bucket\n            }\n        }.foldLeft(0)((acc, curr) =>\
    \ if (curr >= capacity) acc + 1 else acc)\n", "        var count : Long = 0\n\
    \        var buckets : List[List[Long]] = Nil\n        var i : Int = 0\n     \
    \   while (i < grid.length) {\n            if (grid(i)(0) > 0) {\n           \
    \     buckets = buckets :+ grid(i)(0)\n                count += grid(i)(0)\n \
    \               i += 1\n            } else {\n                if (grid(i)(0) ==\
    \ 1) {\n                    buckets = buckets :+ grid(i)(1)\n                \
    \    count += grid(i)(1)\n                    i += 1\n                }\n    \
    \            buckets = buckets :+ capacity\n                count += capacity\n\
    \                i += 1\n            }\n        }\n        count", "        val\
    \ rows     = grid.length\n        val columns  = grid(0).toLong\n\n        var\
    \ count : Long = 0\n        var bucket = capacity\n        for (i <- 0 until rows)\
    \ {\n            val water  = grids(i)\n            val bucket = math.max(0, bucket\
    \ - water)\n            count += math.min(bucket, 1L)\n        }\n        count",
  "        grid.map(_.toSet).foldLeft(0l){ (maxValue, nextValue) =>\n            val\
    \ buckets = nextValue.toSet\n            if (buckets.size < maxValue) maxValue\
    \ else buckets.min\n        }", "        var ans = -1\n        var i = grid.length\n\
    \        var j = grid(0).length\n        var bucket = new Array[Long](j)\n   \
    \     var cnt = 0\n        var lower = 1\n        var higher = 1\n        var\
    \ minBucket = 0\n        var maxBucket = 0\n\n        while (i-- > 0 && j-- >\
    \ 0) {\n            bucket(j) = 0\n            if (grid(i)(j) == 0) {\n      \
    \          lower = bucket.takeWhile(x => x < 0).last\n                higher =\
    \ bucket.takeWhile(x => x > 0).last\n                minBucket = math.min(minBucket,\
    \ lower, higher)\n                maxBucket = math.max(maxBucket, lower, higher)\n\
    \                cnt += math.min(lower, higher)\n                if (cnt < capacity)\
    \ {\n                    bucket(j) = 1\n                }\n            }\n   \
    \     }\n        ans = minBucket + math.min(1, minBucket + maxBucket)\n      \
    \  return ans", "        def dfs(grid : List[List[Long]], idx : Long, bucket :\
    \ Long) : List[List[Long]] = {\n            if (grid == Nil) Nil\n           \
    \ else if (grid == Nil :&& bucket < capacity) List(List(bucket))\n           \
    \ else if (!grid.isEmpty) {\n                val nextGrid = grid.tail\n      \
    \          val nextBucket = bucket - grid((idx-1).toInt)((idx-1).toInt).toLong\n\
    \                val nextCanBeEmpty : Boolean = nextGrid.isEmpty && nextBucket\
    \ < capacity\n                if (nextCanBeEmpty) dfs(nextGrid, idx+1, nextBucket)\n\
    \                else {\n                    val nextBuckets = dfs(nextGrid, idx+1,\
    \ nextBucket)\n                    if (nextBuckets == Nil || nextBuckets.head\
    \ < nextBucket) {\n                        nextBuckets :+ List(bucket)\n     \
    \               } else {\n                        nextBuckets\n              \
    \      }\n                }\n            } else Nil\n        }\n        dfs(grid,\
    \ 0, capacity).headOption.getOrElse(0)", "        val n = grid.length\n      \
    \  if (n == 0) 0\n        else if (n == 1) 1\n        else if (n == 2 && grid[0][1]\
    \ > 0) 1\n        else if (n == 3) 0\n        else {\n            val buckets\
    \ = mutable.ArrayBuffer(capacity)\n            val grid2 = grid.map(_.reverse).map{\
    \ case List(a,b,c) => (a,b,c) }\n            for ((a,b,c) <- grid2) buckets +=\
    \ 0\n\n            val fillBuckets = mutable.ArrayBuffer(grid2.length-1)\n   \
    \         val bucketsCopy = buckets.toList\n            val grid3 = (grid2 +++\
    \ grid2).toList\n            val res = grid3.map{ case List(a,b,c) => (a,b,c)\
    \ }\n            val fillBucketsRes = fillBuckets.toList\n            val bucketsCopyRes\
    \ = bucketsCopy.toList\n\n            while (true) {\n                if (fillBuckets(0)\
    \ == 0) return res.length\n                val a = fillBuckets(0)\n          \
    \      val b = fillBuckets(1)\n                val c = fillBuckets(2)\n      \
    \          if (a > 0) fillBuckets(0) = bucketsCopy(bucketsCopy.indexOf(a) - 1)\n\
    \                if (b > 0) fillBuckets(1) = bucketsCopy(bucketsCopy.indexOf(b)\
    \ - 1)\n                if (c > 0) fillBuckets(2) = bucketsCopy(bucketsCopy.indexOf(c)\
    \ - 1)\n\n                val b = res(fillBuckets(0))\n                val c =\
    \ res(fillBuckets(1))\n                val a = res(fillBuckets(2))\n         \
    \       if (a > 0 && a < n && a.head == 1) fillBuckets(0) = fillBucketsRes(fillBucketsRes.indexOf(a)\
    \ - 1)\n                if (b > 0 && b < n && b.head == 1) fillBuckets(1) = fillBucketsRes(fillBucketsRes.indexOf(b)\
    \ - 1)\n                if (c > 0 && c < n && c.head == 1) fillBuckets(2) = fillBucketsRes(fillBucketsRes.indexOf(c)\
    \ - 1)\n            }\n        }", "        var bucket : Long = 1l\n        var\
    \ max = 0l\n        var fill = 0l\n        for (row <- grid) {\n            var\
    \ count : Long = 0\n            var fill = 0\n            for (col <- row) {\n\
    \                if (col.toLong == bucket) {\n                    fill += 1\n\
    \                    count += fill\n                    if (count > max) {\n \
    \                       max = count\n                    }\n                }\n\
    \                else {\n                    count += 0l\n                }\n\
    \            }\n            bucket += 1\n            fill += 0l\n            if\
    \ (fill > max) {\n                max = fill\n            }\n        }\n     \
    \   return max", "        val buckets = grid.map(x => new Array[Long](capacity))\n\
    \        for(i <- 0 until buckets.length-1) {\n            for(j <- 0 until buckets(i).length)\
    \ {\n                buckets(i)(j) = buckets(i)(j) + 1\n            }\n      \
    \  }\n        var i = buckets.length - 1\n        var j = 0\n        val count\
    \ = buckets.foldLeft(0l) { (i, j) =>\n            var newI = i\n            var\
    \ newJ = j\n            var maxCount = 0\n            while (newI > 0) {\n   \
    \             if (buckets(newI)(newJ) <= buckets(newI-1)(newJ)) {\n          \
    \          newI = newI - 1\n                } else {\n                    if (buckets(newI)(newJ)\
    \ > maxCount) {\n                        maxCount = buckets(newI)(newJ)\n    \
    \                }\n                    newI = newI - 1\n                }\n \
    \           }\n            while (newJ > 0) {\n                if (buckets(i)(newJ)\
    \ <= buckets(i)(newJ-1)) {\n                    newJ = newJ - 1\n            \
    \    } else {\n                    if (buckets(i)(newJ) > maxCount) {\n      \
    \                  maxCount = buckets(i)(newJ)\n                    }\n      \
    \              newJ = newJ - 1\n                }\n            }\n           \
    \ count = maxCount\n            count + newI + newJ\n        }\n        count",
  "        val numRows = grid.length\n        val numColumns = grid(0).length\n  \
    \      val numWells = numRows * numColumns\n        val numBuckets = numWells\
    \ * (capacity / 10)\n        val numBucketsCap = numBuckets\n        val buckets\
    \ = (0 to numBucketsCap).map(i => Array.fill(numColumns)(0l).toList)\n       \
    \ val wells = (0 to numWells).map(i => Array.fill(numRows)(0l).toList)\n     \
    \   for (i <- 0 until numRows) {\n            for (j <- 0 until numColumns) {\n\
    \                if (grid(i)(j) != 0l) {\n                    buckets(grid(i)(j).toLong\
    \ * capacity / 10).updated(j, 0)\n                }\n            }\n        }\n\
    \        var numWellsFilled = 0\n        for (i <- 0 until numRows) {\n      \
    \      for (j <- 0 until numColumns) {\n                if (buckets(i)(j) != 0l)\
    \ {\n                    numWellsFilled = numWellsFilled + 1\n               \
    \     wells(i)(j) = wells(i)(j) + buckets(i)(j).last\n                    buckets(i)(j)\
    \ = 0l\n                }\n            }\n        }\n        buckets.reverse.foldLeft(0l)\
    \ {\n            (sum, i) =>\n            sum + i\n        }", "        val bucket\
    \ = mutable.TreeMap[Int, Long]()\n        val result = mutable.HashMap[Int, Int]()\n\
    \        var cnt = 0\n        var col = 0\n        for (row <- 0 until grid.length)\
    \ {\n            var rowSum = 0\n            var found = 0\n            val r\
    \ = grid[row]\n            while (col < r.length) {\n                rowSum +=\
    \ r.get(col)\n                found += r.get(col) == 1 // count how many 1 we\
    \ found \n                col += 1\n            }\n            if (rowSum > 0)\
    \ {\n                cnt += found\n                val k = found.toDouble\n  \
    \              if (bucket.size < k) {\n                    bucket.size += k\n\
    \                    result((cnt / bucket.size).toInt) += ((cnt % bucket.size).toInt\
    \ * bucket.size / k).toInt\n                }\n            }\n            col\
    \ += 1\n        }\n        result.map {\n            case (k, cnt) => k -> cnt.toDouble\n\
    \        }.maxBy(_._1).get._2", "        val res : List[List[Long]] = ListBuffer.empty[List[Long]]\n\
    \        for ( r <- 0 to grid.length - 1 ) {\n            for ( c <- 0 to grid[r].length\
    \ - 1 ) {\n                val b : List[Long] = grid[r](c).asInstanceOf[List[Long]]\n\
    \                if( b.contains(0) || b.contains(capacity) ){\n              \
    \      if( b.contains(0) ){\n                        res(r).append(capacity)\n\
    \                        res(r).append(0)\n                    } else {\n    \
    \                    res(r).append(0)\n                        res(r).append(capacity)\n\
    \                    }\n                } else {\n                    res(r).append(0)\n\
    \                    res(r).append(0)\n                }\n            }\n    \
    \    }\n        scala.util.Sorting.quickSort(res(_))\n        res(0).last", " \
    \       val wells = grid.map{ case List(x: Long, y: Long, w: Long) => x -> y ->\
    \ w }.toMap\n        val buckets = mutable.Map[Long, mutable.Set[Long]]()\n  \
    \      for (well in wells) {\n            buckets.get(well._1).fold(Set[Long]())\
    \ { case (bucket, list) => bucket += well._2 }\n        }\n        buckets.values.reduce(_\
    \ + _).map(_.toLong).max", "        // sort grid by its y coordinate\n       \
    \ val sortedGrid : List[(Int, List[Long])] = grid.sortBy(_._1)\n        // fill\
    \ each row with capacity (sort by y coordinate again)\n        val sortedGridFilled\
    \ : List[(Int, List[Long])] = sortedGrid.foldLeft(List.empty[(Int, List[Long])])\
    \ {\n            case(res, currRow) =>\n                if (currRow._1 == sortedGrid.last._1)\
    \ res.reverse.map(_ => (currRow._1, currRow._2))\n                else res.reverse.map(_\
    \ => (currRow._1, currRow._2 :+ sortedGridFilled.last._2.last.last + capacity))\n\
    \        }\n        // remove all rows with capacity in it\n        val sortedGridFilledWithoutCapacity\
    \ : List[(Int, List[Long])] = sortedGridFilled\n            .filter(_._2.last\
    \ != capacity)\n        // count how many times you have to lower it (by taking\
    \ previous row's cell)\n        val counting : List[(Int, List[Long])] = sortedGridFilledWithoutCapacity.foldLeft(List.empty[(Int,\
    \ List[Long])]) {\n            case(res, currRow) =>\n                if (currRow._1\
    \ == res.last._1) res.reverse.map(_ => (currRow._1, currRow._2))\n           \
    \     else res.reverse.map(_ => (currRow._1, currRow._2 :+ counting.last._2.last.last\
    \ + 1))\n        }\n        \n        sortedGridFilledWithoutCapacity.last._2",
  "        val max = new mutable.HashMap[Long,Long]()\n        val m = new mutable.HashMap[Long,Long]()\n\
    \        val temp = new mutable.HashMap[Long,Long]()\n        for (row in grid)\
    \ {\n            for (bucket <- row) {\n                max += (bucket -> (bucket.toLong\
    \ * capacity))\n                if (bucket > 0) m.put(bucket, 1l)\n          \
    \  }\n        }\n        max.foreach(bucket => temp.put(bucket._1, bucket._2.toLong))\n\
    \        val min = (1 to capacity).reduce(temp(_), (_, num) => if (num > _) num\
    \ else _)\n        val ret = 0\n        while (m.size > 0) {\n            val\
    \ nextM = new mutable.HashMap[Long,Long]()\n            val nextM2 = new mutable.HashMap[Long,Long]()\n\
    \            val nextMax = new mutable.HashMap[Long,Long]()\n            for (bucket\
    \ <- m.keys) {\n                val num = m.get(bucket)\n                if (num\
    \ < min) nextM.put(bucket, num + capacity)\n                else nextM.put(bucket,\
    \ num - capacity)\n                val num2 = max.get(bucket)\n              \
    \  if (num2 > 0) {\n                    val num3 = nextMax.get(bucket)\n     \
    \               if (num3 > 0) {\n                        if (num3 > num2) nextM2.put(bucket,\
    \ num3 + capacity)\n                        else nextM2.put(bucket, num3 - capacity)\n\
    \                    }\n                    else {\n                        if\
    \ (num2 > num3) nextM2.put(bucket, num2 + capacity)\n                        else\
    \ nextM2.put(bucket, num2 - capacity)\n                    }\n               \
    \ }\n            }\n            m = nextM\n            max = nextMax\n       \
    \ }\n        return min", "        val w = grid.head\n        val rw = w.map(_\
    \ - w.sum).map(w => if (w < 0) -1 else 1)\n        val wl = w.sum\n        val\
    \ c = capacity\n        val rc = rw.sum\n        val c = Math.min(c, wl)\n   \
    \     val rc = Math.min(rc, wl)\n        if (wl == 0) 0\n        else if (c ==\
    \ 0) 1\n        else {\n            val r = Math.ceil(c * rc / wl)\n         \
    \   val r = Math.min(r, wl - rw)\n            val m = r * w\n            var count\
    \ = 1\n            val m = Math.ceil(count * w / wl)\n            if (r < rw)\
    \ maxFill(grid.tail, r + rw)\n            else {\n                val rc = Math.ceil(r\
    \ * m / wl)\n                val rc = Math.min(rc, wl - rw)\n                val\
    \ m = Math.ceil(r * w / wl)\n                var count = 0\n                while\
    \ (count * w < wl) count += 1\n                if (count == 1) 0\n           \
    \     else {\n                    val m = Math.ceil(count * w / wl)\n        \
    \            maxFill(grid.tail, m + 1l)\n                }\n            }\n  \
    \      }", "        val n = grid.length\n        var result : Long = 0\n     \
    \   var currentMax = capacity\n        for( i <- 0 until n ) {\n            var\
    \ currentCount : Long = 0\n            for( j <- 0 until currentMax ) {\n    \
    \            if( (grid[i][j] == 0l) && (j+1 < currentMax) ){\n               \
    \     currentCount += 1\n                    currentMax -= 1\n               \
    \ }\n            }\n            result = math.max(result, currentCount)\n    \
    \    }\n        result", "        val w = getW(grid)\n        val i = findEmpty(w,\
    \ capacity)\n        if(i != -1) return 0\n        val ret: Long = 0\n       \
    \ if(grid.get(i).size == 1) return grid.get(i).get(0).toLong\n        val bucket\
    \ = grid.get(i).filter( x=> x != 0 )\n        var count = 0\n        while(bucket.nonEmpty)\
    \ {\n            val bucketSize: Long = bucket.size\n            while(bucketSize\
    \ > 0) {\n                val nextBucketSize = bucketSize - bucket.last\n    \
    \            bucket.last = 0\n                bucketSize = nextBucketSize\n  \
    \              count += getW(grid)\n                i += 1\n            }\n  \
    \          bucket.last = 0\n            count += getW(grid)\n            i +=\
    \ 1\n        }\n        ret", "        val maxCapacity = grid.map(_.length).max\n\
    \        require(maxCapacity >= capacity)\n        var counter : Long = 0\n\n\
    \        grid.map(_.map(x => x match {\n            case 0 => 0\n            case\
    \ 1 => 1\n        }).foreach{ row =>\n            var j = 0\n            while(j\
    \ < row.length && row[j] != 0) {\n                val currentCapacity = j\n  \
    \              val newCapacity = currentCapacity - capacity\n                if(newCapacity\
    \ < 0) {\n                    newCapacity = 0\n                }\n           \
    \     row.setLength(j, newCapacity)\n                j++\n            }\n    \
    \    })\n        counter", "        val map = new mutable.HashMap[Long, List[Long]]().withDefaultValue(List())\n\
    \        for(i <- 1 to (grid.length + 1).asInstanceOf[Long])\n        for( j <-\
    \ 1 until (grid[i-1].length + 1).asInstanceOf[Long]){\n            map.getOrElse(grid(i)(j),\
    \ List.empty).append(capacity)\n        }\n        val res = mutable.ArrayBuffer.empty[Long]\n\
    \        for(key <- map.keys){\n            val v = map.get(key)\n           \
    \ val x = v(0)\n            val y = v(1)\n            res += v.length\n      \
    \      for(i <- 1 to (grid.length + 1).asInstanceOf[Long])\n            for( j\
    \ <- 1 until (grid[i-1].length + 1).asInstanceOf[Long]){\n                if((x+i)<=grid.length\
    \ || (y+j)<=grid[0].length && grid(x+i)(y+j) == 0 && v.length > (capacity * 2)){\n\
    \                    res += 1\n                    map((x+i)(y+j) - 1).remove(0)\n\
    \                }\n            }\n        }\n        res", "        // Use mutable\
    \ to count number of times\n        var count : mutable.Map[Long, Int] = mutable.Map[Long,\
    \ Int]()\n        // We need two nested loop to complete the algorithm\n     \
    \   for ((i, j) <- grid.zipWithIndex) {\n            // If all well has already\
    \ been filled, we can skip them\n            if (grid[i][j] == 0l) {\n       \
    \         count = count + (i.toLong -> 0l)\n                continue\n       \
    \     }\n            // We need two loops to fill well of size 1 first\n     \
    \       for ((k) <- 1 to grid[i][j]) {\n                count = count + (i.toLong\
    \ -> k.toLong)\n            }\n            // Then we need to check if there are\
    \ any well of size greater than 1\n            // If so, we can use other technique\
    \ to find out how many we can fill from bucket\n            // For instance, we\
    \ need to use two loop to check how many we can fill from bucket\n           \
    \ // We first check how many we can fill from bucket of size 1\n            for\
    \ ((k) <- 1 to grid[i][j]) {\n                // If it is already filled, we skip\
    \ it\n                if (grid[i][j] == 0l) {\n                    count = count\
    \ + (i.toLong -> k.toLong)\n                    continue\n                }\n\
    \                // Otherwise, we can fill from bucket of size 2\n           \
    \     // We need to check how many we can fill from bucket of size 2\n       \
    \         for (l <- 1 to grid[i][j]) {\n                    // If it is already\
    \ filled, we skip it\n                    if (grid[i][j] == 0l) {\n          \
    \              count = count + (i.toLong -> k.toLong)\n                      \
    \  continue\n                    }\n                    // Otherwise, we can fill\
    \ from bucket of size 3\n                    // We need to check how many we can\
    \ fill from bucket of size 3\n                    for (m <- 1 to grid[i][j]) {\n\
    \                        // If it is already filled, we skip it\n            \
    \            if (grid[i][j] == 0l) {\n                            count = count\
    \ + (i.toLong -> k.toLong)\n                            continue\n           \
    \             }\n                        // Otherwise, we can fill from bucket\
    \ of size 4\n                        // We need to check how many we can fill\
    \ from bucket of size 4\n                        for ((n) <- 1 to grid[i][j])\
    \ {\n                            // If it is already filled, we skip it\n    \
    \                        if (grid[i][j] == 0l) {\n                           \
    \     count = count + (i.toLong -> k.toLong)\n                               \
    \ continue\n                            }\n                            // Otherwise,\
    \ we can fill from bucket of size 5\n                            // We need to\
    \ check how many we can fill from bucket of size 5\n                         \
    \   for (o <- 1 to grid[i][j]) {\n                                // If it is\
    \ already filled, we skip it\n                                if (grid[i][j] ==\
    \ 0l) {\n                                    count = count + (i.toLong -> k.toLong)\n\
    \                                    continue\n                              \
    \  }\n                                // Otherwise, we can fill from bucket of\
    \ size 6\n                                // We need to ", "        var ret :\
    \ Long = 0\n        val rowNum : Long = grid.length\n        val colNum : Long\
    \ = grid(0).length\n        val bucketCapacity : Long = capacity\n        val\
    \ bucketNum : Int = ((bucketCapacity - 1) / rowNum).toInt\n        val bucket\
    \ = mutable.ArrayBuffer.fill(rowNum)(0l)\n        // bucket index start from 0\
    \ -> number of buckets = 9\n        for (i <- 0 until rowNum) {\n            for\
    \ (j <- 0 until colNum) {\n                val bucket : Int = ((bucketCapacity\
    \ - 1) / rowNum).toInt\n                if (bucket(numToList(i, j)) <= 0) {\n\
    \                    ret += 1\n                    bucket(numToList(i, j)) = bucket(bucketNum\
    \ - 1)\n                } else {\n                    bucket(numToList(i, j))\
    \ = bucket(numToList(i, j))\n                }\n            }\n        }\n   \
    \     ret", "        val m = grid.size\n        val n = grid.head.get.length\n\
    \        val b = capacity\n\n        def dfs(i : Int, j : Int, b : Long) : Int\
    \ = {\n            if (i == m && j == n) return b\n            if (i == m) return\
    \ 0\n            if (j == n) return 0\n            if (grid[i][j] == 0) return\
    \ 0\n            val res = dfs(i + 1, j, (b + grid[i][j])%b) + dfs(i, j + 1, b)\n\
    \            grid[i][j] = res > b ? res - b : 0\n            res\n        }\n\n\
    \        var cnt = 0\n        var i : Int = 0\n        var j : Int = 0\n     \
    \   while (i < m && j < n) {\n            val cnt = dfs(i, j, b)\n           \
    \ if (cnt == 0) i += 1\n            if (cnt == 0) j += 1\n        }\n        cnt",
  "        val maxCount = 1\n        val newGrid = grid.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(x.size == 0 || y.size == 0) newX :+ 0\n       \
    \         else if(x.size == 1 && y.size == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse\n        val newCap = capacity\n\
    \        newGrid.foldLeft[List[List[Long]]](List[List[Long]]()) { \n         \
    \   (x, y) => {\n                val newX = x\n                val newY = y\n\
    \                if(newX(0) == 0 && newY(0) == 0) newX :+ 0\n                else\
    \ if(newX(0) == 1 && newY(0) == 0) newX :+ 1\n                else newX :+ 0\n\
    \            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(0) == 1) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(0) == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(1) == 0) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(1) == 0) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(1) == 1) newX :+ 0\n     \
    \           else if(newX(0) == 1 && newY(1) == 1) newX :+ 1\n                else\
    \ newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(0) == 0 && newY(0) == 1 && newY(1) == 1) newX\
    \ :+ 1\n                else newX :+ 0\n            }\n        }.reverse.foldLeft[List[List[Long]]](List[List[Long]]())\
    \ { \n            (x, y) => {\n                val newX = x\n                val\
    \ newY = y\n                if(newX(1) == 0 && newY(0) == 1) new", "        val\
    \ buckets = grid.zipWithIndex.map { case (w, i) => Bucket (w, i.toLong) }\n  \
    \      // create a list of bucket capacities\n        val capacities = buckets.map\
    \ { b => b.capacity }\n        // iterate over the grid columns\n        for (col\
    \ <- 0 until grid.length) {\n            // calculate the bucket index this column\
    \ belongs to\n            val bucketIndex = col.toLong / capacity\n          \
    \  // iterate over the grid rows\n            for (row <- 0 until grid.length)\
    \ {\n                // if the current row belongs to the current column then\n\
    \                if (row == col) {\n                    // add an extra capacity\
    \ if the grid at that row and column is empty\n                    if (buckets.get(bucketIndex).isEmpty)\
    \ buckets.get(bucketIndex).capacity += 1\n                    // otherwise do\
    \ nothing\n                    else {\n                        buckets.get(bucketIndex).capacity\
    \ -= 1\n                        buckets.get(bucketIndex).minCapacity -= 1\n  \
    \                  }\n                }\n                // if the current row\
    \ does not belong to the current column then\n                else {\n       \
    \             // add the extracapacity if the grid at that row and column is empty\n\
    \                    if (buckets.get(bucketIndex).isEmpty) buckets.get(bucketIndex).capacity\
    \ += 1\n                    // otherwise do nothing\n                    else\
    \ {\n                        buckets.get(bucketIndex).capacity -= 1\n        \
    \                buckets.get(bucketIndex).minCapacity -= 1\n                 \
    \   }\n                }\n            }\n            // iterate over the buckets\
    \ starting at the current column\n            for (bucket <- buckets.drop(bucketIndex))\
    \ {\n                // if the bucket is empty then add a new row to the current\
    \ column\n                if (bucket.isEmpty) bucket.capacity += 1\n         \
    \       // otherwise do nothing\n                else {\n                    bucket.capacity\
    \ -= 1\n                    bucket.minCapacity -= 1\n                }\n     \
    \       }\n        }\n        buckets.foldLeft(1l)((a, b) => if (a == b) a else\
    \ a + b)", "        grid.zipWithIndex.map { case (row, index) =>\n           \
    \ val buckets = row.span(x => x == 1).toList\n            val newCapacity = capacity\
    \ - buckets.map(_.length).sum\n            val newRow = if (buckets.isEmpty) row\
    \ else row.drop(buckets.head.length)\n            val newGrid = if (buckets.isEmpty)\
    \ grid else grid.map { case (row, index) =>\n                if (index == buckets.head)\
    \ newRow.concat(buckets.tail)\n                else row\n            }\n     \
    \       newGrid.zipWithIndex.map { case (newRow, index) =>\n                if\
    \ (index == buckets.head) newRow.toLong else 0\n            }.sum\n        }.max",
  "        // write your code here\n        var count : Long = 0\n        var maxCount\
    \ : Long = 0\n        for(r <- 0 until grid.length){\n            for(c <- 0 until\
    \ grid[0].length){\n                var bucket : Long = grid(r).get(c)\n     \
    \           var count : Long = 0\n                while(bucket != 0 && capacity\
    \ > 0){\n                    count += bucket\n                    bucket -= 1\n\
    \                    capacity -= 1\n                }\n                count +=\
    \ capacity\n                if(count > maxCount){\n                    maxCount\
    \ = count\n                }\n            }\n        }\n        return maxCount",
  "        var rowSize = grid.map(_.size).max\n        var maxRow = grid(0).size\n\
    \        var maxCol = grid.maxBy(_.size).size\n        \n        if(maxCol !=\
    \ rowSize) {\n            return -1l\n        }\n        \n        var count =\
    \ 0\n        var row = 0\n        while(row < maxRow) {\n            val currentRow\
    \ = grid(row)\n            val maxCol = currentRow.size\n            val nextRow\
    \ = row + 1\n            \n            while(nextRow < maxRow) {\n           \
    \     if(currentRow(nextRow) == 1l) {\n                    if(nextRow < maxRow)\
    \ {\n                        currentRow(nextRow) = 0l\n                      \
    \  nextRow = nextRow + 1\n                        count = count + 1\n        \
    \            } else {\n                        currentRow(nextRow) = 1l\n    \
    \                    count = count + 1\n                        nextRow = nextRow\
    \ + 1\n                    }\n                } else {\n                    if(nextRow\
    \ < maxRow) {\n                        currentRow(nextRow) = 1l\n            \
    \            nextRow = nextRow + 1\n                        count = count + 1\n\
    \                    } else {\n                        currentRow(nextRow) = 0l\n\
    \                        nextRow = nextRow + 1\n                        count\
    \ = count + 1\n                    }\n                }\n            }\n     \
    \       \n            row = nextRow\n        }\n        \n        return count",
  "      assert(grid.length == grid\n        .map(_.length)\n        .reduce((a, b)\
    \ => a + b)\n        .toLong)\n      assert(grid.head.length == 1)\n      assert(capacity\
    \ <= grid.head(0).toLong)\n\n      val buckets = new mutable.HashMap[Long, Long]\n\
    \      val bucketsWithoutLast = grid.tail\n        .map(row => row.map(_.toLong)).flatten\n\
    \        .distinct\n        .groupBy(x => x)\n        .filter(_._2 > capacity)\n\
    \        .mapValues(x => x.size)\n      bucketsWithoutLast.foreach {\n       \
    \ case (bucket, value) => buckets.put(bucket, value)\n      }\n      buckets.maxBy(_._2)._1",
  "      val b = new mutable.HashMap[Long, List[Long]]()\n      var count = 0\n  \
    \    grid.foreach{ x =>\n        x.foreach{ y =>\n          if (b.contains(y))\n\
    \            b.getOrElse(y, Nil).foreach{ x =>\n              if (x >= capacity)\
    \ {\n                count += 1 // count the amount of times we need to lower\
    \ the buckets\n                val newCapacity = b.getOrElse(y, Nil).filterNot(_\
    \ >= capacity).min\n                b.put(y, newCapacity.map{x => x + 1}.toList)\n\
    \              } else {\n                b.put(y, b.getOrElse(y, Nil).map{x =>\
    \ x + 1}.toList)\n              }\n            }\n          else\n           \
    \ b += y -> List(1L)\n        }\n      }\n      count", "        val rows = grid.length\n\
    \        val cols = grid[0].length\n\n        var i = 0\n        var j = 0\n \
    \       var max = 0\n\n        var counter = Int().asInstanceOf[Int]\n\n     \
    \   while (i < rows) {\n            var sum = 0\n\n            while (j < cols)\
    \ {\n                sum += grid(i)(j)\n                j++\n            }\n\n\
    \            if (sum >= capacity) {\n                counter += 1\n          \
    \  }\n            max = Math.max(max, counter)\n            i += 1\n         \
    \   j = 0\n        }\n\n        max + 1", "        // 1. First we define the bucket\
    \ to be the row and column of the grid that has the maximum value when transformed\n\
    \        var maxRow : Int = grid.length-1\n        var maxCol : Int = grid(0).length-1\n\
    \        var maxVal = grid(0).getOrElse(0l)\n        for(r <- 0 until grid.length-1)\
    \ {\n            for(c<- 0 until grid(0).length-1) {\n                var curVal\
    \ = grid(r).getOrElse(0l)\n                if(curVal > maxVal) {\n           \
    \         maxVal = curVal\n                    maxRow = r\n                  \
    \  maxCol = c\n                }\n            }\n        }\n        // 2. We need\
    \ to empty each bucket so that it can refill its capacity\n        // 3.1. The\
    \ bucket has all the water we can extract from it. We will use this bucket to\
    \ help us empty the wells\n        val bucket = grid(maxRow).dropRight(maxCol).toList.take(maxCol).reverse.takeRight(grid((maxRow-1).toInt).length).reverse\n\
    \        // 3.2 We will use another bucket to help us empty the wells when the\
    \ wells are full\n        val bucket2 = grid(maxRow-1).dropRight(maxCol).toList.take(maxCol).reverse.takeRight(grid((maxRow-1).toInt).length).reverse\n\
    \        // 4. Now we can fill the buckets\n        for(i <- 0 until bucket.length)\
    \ {\n            val bucketElement = bucket(i)\n            for(j <- 0 until bucketElement.length)\n\
    \                bucket(bucketElement(j))(i) = 0\n        }\n        // 5. Finally\
    \ we can calculate the result\n        var result : Long = bucket.length\n   \
    \     for(r <- 0 until grid.length-1) {\n            for(c <- 0 until grid((maxRow-1).toInt).length-1)\
    \ {\n                var curVal = grid(r).getOrElse(0l)\n                var newVal\
    \ : Long = 0\n                if(curVal != 0l) {\n                    newVal =\
    \ (curVal * (capacity-1)).floor\n                    result += newVal - (curVal\
    \ * (capacity-1)).floor\n                }\n            }\n        }\n       \
    \ result", "        val rec : PartialFunction[List[List[Long]], Int] = { case\
    \ head :: tail => tail.size; case head :: tail => tail.size + maxFill(tail, capacity);\
    \ }\n        val total = rec(grid)\n        val minRec = rec\n        val maxRec\
    \ = rec\n        val minRec2 = rec\n        val maxRec2 = rec\n        for(i <-\
    \ 1 to grid.length; j <- 1 to grid[0].length) total = (total + minRec(grid).orElse(0)\
    \ + maxRec(grid).orElse(0)) if (total < capacity) minRec = total else maxRec =\
    \ total\n        for(i <- 1 to grid.length; j <- 1 to grid[0].length) total =\
    \ (total + minRec2(grid).orElse(0) + maxRec2(grid).orElse(0)) if (total < capacity)\
    \ minRec2 = total else maxRec2 = total\n        (maxRec - minRec) max maxRec -\
    \ minRec + (maxRec2 - minRec2) max maxRec2 - minRec2", "        val rows = grid.length\n\
    \        val cols = grid(0).length\n        var currentCap = capacity\n\n    \
    \    // find all buckets\n        def findBuckets(row: Int, col: Int): List[List[Long]]\
    \ = grid\n            .take(rows)\n            .drop(1)\n            .take(cols)\n\
    \            .drop(1)\n            .flatMap(_.map((_)))\n\n        // find empty\
    \ buckets\n        def findEmptyBuckets(row: Int, col: Int): List[List[Long]]\
    \ = findBuckets(row, col)\n            .filter(x => x == 0l)\n            .takeWhile(_\
    \ != 0l)\n            .dropWhile(_ != 0l)\n\n        // find new empty buckets\n\
    \        def findNewBuckets(row: Int, col: Int, currentCap: Long): List[List[Long]]\
    \ = findEmptyBuckets(row, col)\n            .map(x => if(x % currentCap == 0)\
    \ 0l else currentCap * x / (x + 1l))\n            .takeWhile(_ <= currentCap)\n\
    \            .dropWhile(_ >= currentCap)\n\n        // new cap per bucket\n  \
    \      def newCap(currentCap: Long): Long = currentCap / 2\n\n        // new bucket\n\
    \        def newBucket(row: Int, col: Int, currentCap: Long): List[List[Long]]\
    \ =\n            findNewBuckets(row, col, currentCap).map(x => (x+1l).toLong)\n\
    \n        // fill empty buckets\n        def fillEmptyBuckets(row: Int, col: Int,\
    \ currentCap: Long): List[List[Long]] = findNewBuckets(row, col, currentCap)\n\
    \            .flatMap(x => List(newBucket(row, col, currentCap), newBucket(row,\
    \ col + 1, currentCap)))\n            .filter(_._1 != 0l)\n\n        // fill all\
    \ buckets\n        def fillAllBuckets(row: Int, col: Int, currentCap: Long): List[List[Long]]\
    \ = findNewBuckets(row, col, currentCap)\n            .flatMap(x => List(newBucket(row,\
    \ col, currentCap), newBucket(row, col + 1, currentCap)))\n            .filter(_._1\
    \ != 0l)\n\n        // fill all buckets\n        def fillAllBuckets2(row: Int,\
    \ col: Int, currentCap: Long): List[List[Long]] = findNewBuckets(row, col, currentCap)\n\
    \            .flatMap(x => List(newBucket(row, col, currentCap), newBucket(row,\
    \ col + 1, currentCap)))\n            .filter(_._1 != 0l)\n\n        val result\
    \ = (findEmptyBuckets(0,0)\n            .foldLeft((currentCap, fillAllBuckets2(0,0,\
    \ currentCap))){", "        var totalWater : Long = 0\n        var water: Int\
    \ = 0\n\n        val totalRow = grid.length\n        val totalCol = grid[0].length\n\
    \n        if(totalRow == 0 || totalCol == 0){\n            return 0\n        }\n\
    \n        for(row <- 1 to totalRow){\n            for(col <- 1 to totalCol){\n\
    \                val row = grid[row - 1]\n                val col = grid[col -\
    \ 1]\n                val totalColWithinWell = row.length + col.length\n     \
    \           val bucket = math.max(math.min(bucketCapacity.toLong, totalColWithinWell\
    \ / 2), 1).toInt\n                if(bucket == 0){\n                    water\
    \ += 1\n                }\n                totalWater += bucket\n            }\n\
    \        }\n\n        totalWater -= water\n        totalWater += math.max(math.min(bucketCapacity.toLong,\
    \ totalRow * totalCol), 1).toInt\n        totalWater -= capacity\n\n        totalWater",
  "        val nBuckets = grid.head.length\n        val bucketCap = math.pow(10, nBuckets.toInt)\n\
    \        val buckets = new Array[List[Long]](nBuckets)\n        for (i  <- 0 until\
    \ (grid.length-1)) buckets(i) = grid(i).take(bucketCap)\n        val newCapacity\
    \ = capacity - bucketCap\n        var index = 0\n        val nextGrids = new Array[List[Long]](nBuckets)\n\
    \        for (i  <- 0 until (grid.length-1)) {\n            val bucket = buckets(i)\n\
    \            if (bucket > capacity) index++\n            else {\n            \
    \    val bucketIndex = buckets.indexWhere(x => x >= bucket)\n                newCapacity\
    \ -= 1\n                nextGrids(bucketIndex) = grid(i)\n                buckets(i)\
    \ = bucket\n            }\n        }\n        val maxIndex = index\n        val\
    \ nextGridArray = nextGrids.toList\n        var max = 0\n        var count = 0\n\
    \        for (i  <- 0 until (nextGridArray.length-1)) {\n            val nextGridIndex\
    \ = nextGridArray(i).length\n            val gridIndex = grid.length\n       \
    \     if (nextGridIndex > gridIndex) count++\n            else {\n           \
    \     if (nextGridIndex > maxIndex) max = nextGridIndex\n                nextGridArray(i)\
    \ = grid(i).take(nextGridIndex)\n            }\n        }\n        if (count >\
    \ max) max\n        else maxFillNoRep(grid, capacity, nextGridArray.toList(0),\
    \ nextGridArray.toList(1))", "        val grid2d = grid.map(_.map(_.toLong))\n\
    \        val minCapacity = math.min(grid2d.map(_.length).max,grid2d.map(_.zipWithIndex.map(_.length).max).max)\n\
    \        if (minCapacity > capacity) 0 else minCapacity - capacity", "       \
    \ val buckets = grid.map(_.toList)\n        var need = capacity\n        buckets.foreach(_.foreach(need\
    \ = math.min(need, _)))\n        need", "        val buckets = mutable.Map[Long,\
    \ Long]()\n        var max = 0\n        var maxCount = 0\n        grid.foreach\
    \ { case (l: List[Long]) =>\n            l.foreach { case (b: Long) =>\n     \
    \           buckets += (b -> buckets.getOrElse(b, 0L) + 1)\n            }\n  \
    \      }\n        buckets.foreach { case (b: Long, count: Long) =>\n         \
    \   if(max < count) max = count\n        }\n        if(max > capacity) max -=\
    \ 1\n        if(max > 0) maxCount += max\n        maxCount", "        // O(n^2)\n\
    \        val map = grid.zipWithIndex.filter{ case (w, i) => w == 0 }.map{case\
    \ (w, i) => (i, w)}.toMap\n        // O(n^2)\n        val bucket = grid.zipWithIndex.filter{\
    \ case (w, i) => w == 1 }.map{case (w, i) => (i, w)}.toMap\n        // O(n^2)\n\
    \        val bucket2 = grid.zipWithIndex.filter{ case (w, i) => w == 0 }.map{case\
    \ (w, i) => (i, w)}.toMap\n        // O(n^2)\n        val bucket3 = grid.zipWithIndex.filter{\
    \ case (w, i) => w == 1 }.map{case (w, i) => (i, w)}.toMap\n        // O(n)\n\
    \        val map = map + (bucket + bucket2 + bucket3)\n        // O(n^2)\n   \
    \     val max = map.filter{ case (k,v) => v > capacity }.maxBy(_._1)._2\n    \
    \    // O(1)\n        map", "        val n = grid.length\n        val m = grid.head.length\n\
    \        val maxFill = 0\n        var lastRow = 0\n        var lastCol = 0\n \
    \       var count = 0\n        val nextCol = lastCol + 1\n        while(count\
    \ < capacity) {\n            val maxCol = if (nextCol == m) n else nextCol\n \
    \           val maxRow = if (lastRow == n) n else lastRow\n            val newRow\
    \ = grid.apply(maxRow)\n            val newCol = grid.apply(maxCol)\n        \
    \    val bucket = newCol.indexOf(1l)\n            val newVal = newRow.apply(bucket)\n\
    \            val value = newVal.toLong\n            val diff = value - capacity\n\
    \            if (diff > 0)\n                count += diff\n            val nextVal\
    \ = newRow.apply(bucket + 1)\n            nextVal.toLong - capacity\n        }\n\
    \        count", "        val nWell = grid.length\n        val nColumn = grid.head.length\n\
    \        val grid = mutable.ArrayBuffer.empty[List[Long]](nWell)\n        var\
    \ max = 0\n        var min = 0\n        for (i <- 0 until nWell)\n           \
    \ grid += 0 :: Nil\n\n        for (i <- 0 until nWell) {\n            grid +=\
    \ grid(i)\n            if (grid(i).length == nColumn) {\n                for (j\
    \ <- 0 until nColumn) {\n                    if (grid[i].exists(_ == j))\n   \
    \                     max += 1\n                    else\n                   \
    \     min += 1\n                }\n            }\n        }\n\n        if (min\
    \ < max) max\n        else\n            min * capacity", "        val wells =\
    \ mutable.Map[Long,List[Long]]()\n        for ((row,rows) <- grid) {\n       \
    \     val buckets = mutable.ListBuffer.empty[Long]\n            for (i <- 0 until\
    \ rows.length)\n                if (row(i) == 1) buckets += 1\n            wells\
    \ += (row.toLong -> buckets)\n        }\n        var i = 0\n        while (i<capacity)\
    \ {\n            val buckets = wells(i)\n            i += 1\n            if (buckets.isEmpty)\
    \ i-1\n            else buckets.min - 1\n        }", "      val buckets = grid.map(_.toSet).map(_.size)\n\
    \      val maxBuckets = buckets.max\n      (0 until maxBuckets).toSeq.foldLeft(0)((acc,\
    \ _) => acc + (buckets.takeWhile(_ == _).sum - buckets.dropWhile(_ == _).sum))",
  "        val numRows = grid.length\n        val numCols = grid.head.length\n   \
    \     val fill = (0 until numCols).filter(x => x % 2 != 0).foldLeft(1l)((x, y)\
    \ => x * y)\n        val grid = grid.map(x => x.map(y => (y, 0))).map(_.toList)\n\
    \        val numFill = grid.map(x => x.map(y => y % 2 == 0).sum).foldLeft(0l)((x,\
    \ y) => x + y)\n        val result = numFill / numRows * capacity - fill\n   \
    \     result", "        // fill a rectangle from each well with water, if \n \
    \       // the water cannot fill the well, \n        // lower the capacity of\
    \ the well\n        // if the water can fill the well, \n        // increase the\
    \ capacity of the well\n        // we use a priority queue to ensure that the\
    \ max is determined\n        // by priority \n        val p = PriorityQueue[((Int,\
    \ Long), Boolean)]\n        val result = mutable.ListBuffer.empty[Long]\n    \
    \    for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(0).length)\
    \ {\n                if (grid(i)(j) ==  0) {\n                    // fill a rectangle\
    \ from each well with water, if \n                    // the water cannot fill\
    \ the well, \n                    // lower the capacity of the well\n        \
    \            // if the water can fill the well, \n                    // increase\
    \ the capacity of the well\n                    p.enqueue(((i,j), false))\n  \
    \              } else {\n                    // the water can fill the well, \n\
    \                    // increase the capacity of the well\n                  \
    \  p.enqueue(((i,j), true))\n                }\n            }\n        }\n   \
    \     // dequeue all items that can fill the well\n        while(!p.isEmpty) {\n\
    \            val item = p.dequeue\n            if (item._2) {\n              \
    \  result += (item._1._1 * item._1._2)\n            }\n        }\n        // return\
    \ result\n        result.max", "        val emptyWells = mutable.Map[Long, Long]()\n\
    \        grid.foreach { row =>\n            row.foreach { j =>\n             \
    \   emptyWells(j) match {\n                    case Some(well) => {\n        \
    \                val emptyCount = emptyWells(j)\n                        emptyWells(j)\
    \ = 0\n                        val remain = well - capacity\n                \
    \        if(remain <= emptyCount) {\n                            emptyWells +=\
    \ (j -> remain)\n                        }\n                    }\n          \
    \          case None => \n                }\n            }\n        }\n      \
    \  emptyWells.valuesIterator.foldLeft((1l, 0l))((acc, next) => if(acc._1 < next._1)\
    \ (acc._1, next._1) else next)", "        def getTotalArea(grid : List[List[Long]]):\
    \ Long = {\n            val totalArea = 0L\n            for(i <- 0 until grid.length)\
    \ {\n                for(j <- 0 until grid[i].length) {\n                    totalArea\
    \ += grid[i][j].toLong\n                }\n            }\n            totalArea\n\
    \        }\n\n        def getBucketCapacity(bucketCapacity : Long, grid : List[List[Long]]):\
    \ Long = {\n            val bucketCapacity = bucketCapacity.toInt\n          \
    \  val totalArea = getTotalArea(grid)\n            bucketCapacity * (totalArea\
    \ / grid().length).toInt\n        }\n\n        def getTotalWaterInBucket(bucket\
    \ : List[Long], grid : List[List[Long]]): Long = {\n            var totalWater\
    \ = 0L\n            for(i <- 0 until bucket.length) {\n                totalWater\
    \ += bucket[i].toLong * grid()(i)(j)\n            }\n            totalWater\n\
    \        }\n\n        val totalBucket = grid.length zip grid().map(_.length).max\n\
    \        val bucketCapacity = capacity / totalBucket\n\n        var totalWaterInBucket\
    \ = 0L\n        var bucketsNeedToBeRemoved = new Array[Long](totalBucket)\n  \
    \      for(i <- 0 until totalBucket) {\n            totalWaterInBucket = getTotalWaterInBucket(grid(i),\
    \ grid)\n            val needToBeRemoved = totalWaterInBucket - bucketCapacity\n\
    \            if(needToBeRemoved > 0) {\n                bucketsNeedToBeRemoved(i)\
    \ = needToBeRemoved\n            }\n        }\n\n        var maxWater = 0L\n \
    \       for(i <- 0 until bucketsNeedToBeRemoved.length) {\n            maxWater\
    \ = Math.max(maxWater, bucketsNeedToBeRemoved(i) + getBucketCapacity(bucketCapacity,\
    \ grid))\n        }\n        maxWater", "        def recurse(w : List[Long], b\
    \ : List[Long], c : Long) : Long = {\n            if (w.length == 0) return c\n\
    \            if (b.length == 0) return recurse(w, b, c+w(w.head))\n          \
    \  if (w(w.head) == 0) return recurse(w, b, c+recurse(w, b, c))\n            return\
    \ recurse(w, b, c+recurse(w, b, c+w(w.head)))\n        }\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val b = mutable.ArrayBuffer(capacity)\n\
    \        for (i <- 0 until n) b += 0\n        recurse(grid, b, 0)", "        val\
    \ rows = grid.length\n        val columns = grid(0).length\n        val empty\
    \ = rows.toLong * columns.toLong\n        val toBeEmpty = capacity - empty\n \
    \       val filler = (0 until rows).map(i => 0 until columns).map(j => (0l).asInstanceOf[List[Long]])\n\
    \        val list = List[List[Long]](List(grid))\n        val toBeEmpty = capacity\
    \ - empty\n        val toBeFilled = (0 until rows).map(i => 0 until columns).map(j\
    \ => (0l).asInstanceOf[List[Long]])\n        toBeEmpty match {\n            case\
    \ i if i >= list.size => 0\n            case i if (list(i).length == 0) => 0\n\
    \            case i =>\n                val filler = (0 until i).map(j => 0 until\
    \ columns).map(k => (0l).asInstanceOf[List[Long]])\n                val list =\
    \ List[List[Long]](list.toBuffer)\n                val toBeEmpty = capacity -\
    \ empty\n                val toBeFilled = (0 until i).map(j => 0 until columns).map(k\
    \ => (0l).asInstanceOf[List[Long]])\n                toBeEmpty match {\n     \
    \               case i if i >= list.size => 0\n                    case i if (list(i).length\
    \ == 0) => 0\n                    case i =>\n                        val filler\
    \ = (0 until i).map(j => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n\
    \                        val list = List[List[Long]](list.toBuffer)\n        \
    \                val toBeEmpty = capacity - empty\n                        val\
    \ toBeFilled = (0 until i).map(j => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n\
    \                        toBeEmpty match {\n                            case i\
    \ if i >= list.size => 0\n                            case i if (list(i).length\
    \ == 0) => 0\n                            case i =>\n                        \
    \        val filler = (0 until i).map(j => 0 until columns).map(k => (0l).asInstanceOf[List[Long]])\n\
    \                                val list = List[List[Long]](list.toBuffer)\n\
    \                                val toBeEmpty = capacity - empty\n          \
    \                      val toBeFilled = (0 until i).map(j => 0 until columns).map(k\
    \ => (0l).asInstanceOf[List[Long]])\n                                toBeEmpty\
    \ match {\n                                    case i if i >= list.size => 0\n\
    \                                    case i if (list(i).length == 0) => 0\n  \
    \                                  case i =>\n                               \
    \         ", "        val bucket = mutable.ArrayBuffer(capacity).scanLeft(0l)(_\
    \ + _)\n        \n        for(row <- 0 until grid.size) {\n            val row1\
    \ = row.copy\n            val row2 = row.copy\n            for(col <- 0 until\
    \ grid(0).size) {\n                val currentCount = bucket(col - 1 )\n     \
    \           val newCount = row1(col - 1).plus(row2(col - 1).minus(currentCount))\n\
    \                bucket(col - 1 ) = newCount\n            }\n        }\n     \
    \   \n        bucket.sum", "        val size = grid.size\n        if (size ==\
    \ 0) 0 else (grid.map(_(1)).sum - grid(0).sum) * capacity / grid(0).sum", "  \
    \      val totalCapacity : Long = grid.map(_.size).sum\n\n        var totalWater\
    \ : Long = 0\n\n        // create buckets\n        var buckets : List[Long] =\
    \ List.fill(grid.size)(0L)\n        grid.foreach{ row =>\n            val currentCapacity\
    \ = row.size\n            val currentWater = 1L\n            val currentBucket\
    \ = buckets(row.index.toInt)\n            val newCapacity = currentCapacity +\
    \ currentWater\n            buckets(row.index.toInt) = if (currentCapacity < newCapacity)\
    \ currentCapacity else newCapacity\n        }\n\n        // fill buckets\n   \
    \     var fillCount : Long = 0\n        while(totalWater < totalCapacity) {\n\
    \            // check buckets left\n            var checkCount : Long = 0\n  \
    \          while(buckets.map(_.toInt).sum > 0) {\n                val currentBucket\
    \ = buckets.map(_.toInt).sum - 1\n                val currentCapacity = buckets(currentBucket)\n\
    \                val currentWater = grid\n                currentWater.foreach{\
    \ case (k, v) => if (k == currentBucket) v -= 1 }\n                checkCount\
    \ += 1\n                buckets(currentBucket) = currentCapacity\n           \
    \ }\n\n            // fill bucket\n            if (checkCount == 0) {\n      \
    \          totalWater += buckets.last\n                buckets = buckets.dropRight(1)\n\
    \            }\n            else {\n                fillCount += 1\n         \
    \       totalWater += buckets(buckets.size - 1)\n                buckets = buckets.tail\n\
    \            }\n        }\n\n        return fillCount", "        // init\n   \
    \     val m = grid.length\n        val n = grid.head._2.length\n        val w\
    \ = immutable.ArrayBuffer.empty[Long](n)\n        val r = immutable.ArrayBuffer.empty[Long](n)\n\
    \        val f = immutable.ArrayBuffer.empty[Long](n)\n        val l = immutable.ArrayBuffer.empty[Long](n)\n\
    \        val b = immutable.ArrayBuffer.empty[Long](n)\n        var flag = false\n\
    \        val bucket = immutable.ArrayBuffer.empty[Long](n)\n        for (i <-\
    \ 0 until m){\n            for (j <- 0 until n){\n                if (grid(i)(j)\
    \ == 1) {\n                    flag =  true\n                    bucket(j) = capacity\n\
    \                } else {\n                    flag =  false\n               \
    \ }\n                if (flag == true) {\n                    r.update(j, 0)\n\
    \                }\n                l.update(j, 1)\n                f.update(j,\
    \ 0)\n                b.update(j, 1)\n            }\n        }\n        val x\
    \ = r.reduceLeft( (a, b) => a + b )\n        val y = b.reduceLeft( (a, b) => a\
    \ + b )\n        val z = immutable.ArrayBuffer.empty[Long](n)\n        for (j\
    \ <- 0 until n){\n            if (x==1 && y==0) {\n                z(j) = z(j)+1\n\
    \            } else if (x==1 && y==1) {\n                z(j) = z(j)+1\n     \
    \       } else if (x==1 && y==-1) {\n                z(j) = z(j)+1\n         \
    \   } else if (x==-1 && y==1) {\n                z(j) = z(j)+1\n            }\
    \ else if (x==-1 && y==-1) {\n                z(j) = z(j)+1\n            } else\
    \ if (x==1 && y==-2) {\n                z(j) = z(j)+1\n            } else if (x==-1\
    \ && y==-2) {\n                z(j) = z(j)+1\n            }\n        }\n     \
    \   val z = z.reduceLeft( (a, b) => a + b )\n        return (z-bucket.sum)", " \
    \       val rows = new collection.mutable.ListBuffer[Long]()\n        var max\
    \ = 0l\n        grid.foreach{ row => \n            if(row(0) > 0) max += 1\n \
    \           rows ++= row\n        }\n        grid.foreach{ row => \n         \
    \   if(row(0) > 0) max -= 1\n        }\n        val index = Collections.binarySearch(rows,\
    \ capacity)\n        if(index < 0) index else max -= index\n        max", "  \
    \      var curBuck = 0\n        var maxBuck = 0\n        var count = 0\n     \
    \   var prev = 0\n        for(i <- 1 to grid.length) {\n            for(j <- 1\
    \ to grid(i).length) {\n                count +=1\n                if(prev !=\
    \ grid[i][j]) {\n                    curBuck += 1\n                    if(curBuck\
    \ > capacity) {\n                        maxBuck = count\n                   \
    \     curBuck = 0\n                    }\n                    count = 0\n    \
    \            }\n                prev = grid[i][j]\n            }\n        }\n\
    \        maxBuck", "        if (grid.isEmpty)\n            return 0\n        var\
    \ max : Long = 0\n        for (row <- grid) {\n            if (row.length > 1)\
    \ {\n                var n = 0\n                for (j <- 1 to row.length - 1)\n\
    \                    n += if (row[j] % 2 == 1) capacity else -capacity\n     \
    \           if (n > max)\n                    max = n\n            }\n       \
    \ }\n        max ", "        if(grid.isEmpty) {\n            return 0\n      \
    \  }\n        // find max capacity of bucket\n        val maxCapacity = grid.max((a,\
    \ b) => b.last - a.last).last\n        // count number of filling needed\n   \
    \     var count = 0\n        for(row <- grid.zipWithIndex; bucket <- row.last){\n\
    \            if(bucket.last > maxCapacity) {\n                count += maxCapacity\
    \ - bucket.last\n            }\n        }\n        return count", "        if(grid.isEmpty)\n\
    \            return 0\n        var cnt : Long = 0\n        for(r <- 1 to grid.length-1)\
    \ {\n            if(capacity < 0)\n                break\n            cnt += grid(r-1).sum\n\
    \            grid[r-1] = grid[r-1].filter(_ != 1)\n            grid[r-1].foreach{\
    \ x =>\n                val d = grid(r-1).lastIndex - r-1\n                if(d\
    \ < 0)\n                    break\n                grid[r-1].remove(x)\n     \
    \           grid[r-1].last = x\n                grid[r-1].foreach{ x =>\n    \
    \                if(x <= 0)\n                        break\n                 \
    \   grid[r-1].insert(x, 0)\n                }\n            }\n            grid[r-1].foreach{\
    \ x =>\n                if(x <= 0)\n                    break\n              \
    \  grid[r-1].remove(x)\n                grid[r-1].last = x\n                grid[r-1].foreach{\
    \ x =>\n                    if(x <= 0)\n                        break\n      \
    \              grid[r-1].insert(x, 0)\n                }\n            }\n    \
    \    }\n        cnt", "        val rows = grid.length\n        val cols = grid(0).get.length\n\
    \        val numWells = rows * (cols - 1)\n        val numBuckets = capacity /\
    \ cols \n        val res = new mutable.HashMap[Long, Long]\n        val numRes\
    \ = new mutable.HashMap[Long, Long]\n        val startTime = System.currentTimeMillis()\n\
    \        val numRes = cols * rows * numBuckets // 1 million records\n        val\
    \ res = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numBuckets)\n  \
    \      val startTime1 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 10 million\n        val res1 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime2 = System.currentTimeMillis()\n        val numRes = numWells\
    \ * numBuckets // 100 million\n        val res2 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numBuckets)\n\
    \        val startTime3 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res3 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime4 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res4 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime5 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res5 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime6 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res6 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime7 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res7 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(numWells)\n\
    \        val startTime8 = System.currentTimeMillis()\n        val numRes = numBuckets\
    \ * numWells // 1 million\n        val res8 = numRes.toArray.zipWithIndex.toList.sortBy(-_._2).take(num",
  "        val N = grid.length\n        val M = grid(0).length\n        val fill =\
    \ mutable.HashMap[Long, Int]()\n        for (i <- 0 until N) {\n            for\
    \ (j <- 0 until M) {\n                if (grid[i][j].toLong == 0) {\n        \
    \            val bucket = capacity / M\n                    if (fill.getOrElse(bucket,\
    \ 0l).isDefined) {\n                        fill.put(bucket, fill.get(bucket)+1)\n\
    \                        grid[i][j] = 1l\n                    }\n            \
    \    }\n            }\n        }\n        fill.map(_._2).reduce((x,y)=>x+y).toLong",
  "        val numRows = grid.length\n        val numColumns = grid(0).length\n  \
    \      var maxCap = capacity\n        val rem = numRows * numColumns - capacity\n\
    \        val rem = rem / numRows\n        val ret = rem.toLong\n\n        val\
    \ res = mutable.ArrayBuffer.empty[Long]\n        // find the max number of rows\
    \ you can empty using max capacity with row index\n        val maxRows = (rem:\
    \ Long) match {\n            case \"1\" => numRows - 1\n            case x =>\
    \ x\n        }\n        \n        val minRows = (maxRows * numColumns) / (numRows\
    \ - 1)\n        val minRows = minRows.toLong\n\n        ret += minRows\n     \
    \   ret += maxRows\n        \n        val res1 = (maxRows / numColumns).toLong\n\
    \        if (res1 > 0) {\n            ret += res1\n        }\n        res ++=\
    \ res1\n        res", "        var count = Long.MaxValue\n        grid.foreach{\
    \ row =>\n            if(row.length == 1) count = count + 1\n        }\n     \
    \   if(count == 0) return 0\n        var maxCount = 0\n        var newGrid = grid.map{\
    \ row => row.map{ value =>\n            if((value & 1) == 1) return 0\n      \
    \      else return capacity\n        } }\n        while(newGrid.forall{ row =>\n\
    \            row.foreach{ value =>\n                if((value & 1) == 0) newGrid.foreach{\
    \ row =>\n                    row.foreach{ value =>\n                        if((value\
    \ & 1) == 0) newGrid -= 1\n                        else newGrid += capacity\n\
    \                    }\n                }\n            }\n        })\n       \
    \ newGrid.foreach{ row =>\n            count = count - row.length\n          \
    \  count = count - row.last\n            if((count & 1) == 1) return count - 1\n\
    \            if((count & 1) == 0) return count + 1\n        }\n        return\
    \ 0", "        // write your code here\n        var max = 0\n        var n = 0\n\
    \        val m = grid.length\n        val n = grid(0).length\n        for(i <-\
    \ 0 until m){\n            for(j <- 0 until n){\n                if(grid(i)(j)\
    \ ==0){\n                    grid(i)(j) = 1\n                    grid(i)(j) =\
    \ capacity\n                    val x = i - 1\n                    val y = j -\
    \ 1\n                    val capacity = capacity\n                    val minCapacity\
    \ = 0\n                    val maxCapacity = capacity * 10\n                 \
    \   while(x >=0){\n                        while(y >=0){\n                   \
    \         if(grid(x).length == minCapacity){\n                               \
    \ grids(x).remove(y)\n                                grids(x).remove(y)\n   \
    \                             break\n                            }\n         \
    \                   y -= 1\n                        }\n                      \
    \  x -= 1\n                        minCapacity = minCapacity * 10\n          \
    \          }\n                    while(y >=0){\n                        while(x\
    \ >=0){\n                            if(grid(x).length == maxCapacity){\n    \
    \                            grids(x).remove(y)\n                            \
    \    grids(x).remove(y)\n                                break\n             \
    \               }\n                            x -= 1\n                      \
    \  }\n                        y -= 1\n                        maxCapacity = maxCapacity\
    \ * 10\n                    }\n                    grids(x).add(x)\n         \
    \           grids(x).add(y)\n                    while(x >=0){\n             \
    \           while(y >=0){\n                            if(grid(x).length == minCapacity){\n\
    \                                grids(x).remove(y)\n                        \
    \        grids(x).remove(y)\n                                break\n         \
    \                   }\n                            y -= 1\n                  \
    \      }\n                        x -= 1\n                        minCapacity\
    \ = minCapacity * 10\n                    }\n                    while(y >=0){\n\
    \                        while(x >=0){\n                            if(grid(x).length\
    \ == maxCapacity){\n                                grids(x).remove(y)\n     \
    \                           grids(x).remove(y)\n                             \
    \   break\n                            }\n                            x -= 1\n\
    \                        }\n                        y -= 1\n                 \
    \       maxCapacity = maxCapacity * 10\n                    }\n              \
    \      grids(x).add(x)\n                    grids(x).add(y)\n                }\n\
    \            }\n        }\n        for(i <- 0 until m){\n            for(j <-\
    \ 0 until n){\n                if(grid(i)(j) ==1){\n                    val x\
    \ = i - 1\n                    val y = j - 1\n                    val capacity\
    \ = capacity\n                    val minCapacity = 0\n                    val\
    \ maxCapacity = capacity * 10\n                    while(x >=0){\n           \
    \             while(y >=0){\n                            if(grid(x).length ==\
    \ minCapacity){\n                                grids(x).remove(y)\n        \
    \                        grids(x).remove(y)\n                                break\n\
    \                            }\n                            y -= 1\n         \
    \               }\n                        x -= 1\n                        min",
  "        // write your code here\n        var count = 0\n        val rowLength =\
    \ grid.map(_.size).max\n        val rowCapacity = grid.map(_.map(_.toInt)).max\n\
    \        if (rowLength != rowCapacity) {\n            count = 0\n        }\n \
    \       else {\n            count = rowLength - rowCapacity\n        }\n     \
    \   val maxWidth = grid.map(_.size).max\n        val maxHeight = grid.map(_.size).max\n\
    \        if (maxWidth == 0 || maxHeight == 0) {\n            return count\n  \
    \      }\n        else {\n            val maxCapacity = grid.map(_.map(_.toInt)).max\n\
    \            if (maxCapacity != capacity) {\n                return count\n  \
    \          }\n            else {\n                val minWidth = grid.map(_.size).min\n\
    \                val minHeight = grid.map(_.size).min\n                val minCapacity\
    \ = grid.map(_.map(_.toInt)).min\n                val maxCapacity = grid.map(_.map(_.toInt)).max\n\
    \                count += minWidth * (minHeight - minCapacity)\n             \
    \   count += minWidth * (maxCapacity - capacity)\n                count += maxWidth\
    \ * (minCapacity - capacity)\n                count += maxWidth * (maxCapacity\
    \ - capacity)\n                count += minHeight * (maxCapacity - capacity)\n\
    \                return count\n            }\n        }", "        val maxCount\
    \ = 1\n        val gridSize = grid.size\n        val map = new mutable.HashMap[Long,\
    \ List[Long]]()\n        for (row <- 0 until gridSize) {\n            val currentCount\
    \ = map.get(grid(row)(0)).length\n            map.put(grid(row)(0), grid(row)(0))::grid(row)(1)::List(grid(row)(2))\n\
    \            if (currentCount > maxCount) {\n                maxCount = currentCount\n\
    \            }\n        }\n        if (maxCount > capacity) {\n            maxCount\n\
    \        } else {\n            (maxCount - capacity) * map(capacity)(0)\n    \
    \    }", "        val buckets = (1 to grid.length).map { i =>\n            mutable.HashMap[Long,\
    \ Long](1 -> 0)\n        }\n        grid.map { row =>\n            if (row.length\
    \ == 1) buckets(row(0)) -= 1\n            else buckets(row(0)) -= 1\n        \
    \    buckets(row(0)) += 1\n        }\n        buckets.maxBy(_._1)._1", "     \
    \   // Your code here\n        var nwell = 0\n        var nbucket = 0\n      \
    \  var nlow = 0\n        var nold = 0\n        var nfill = 0\n        for (row\
    \ <- grid) {\n            nwell = row.length\n            for (col <- row) {\n\
    \                if (col == 1 || col == 0) {\n                    nlow = nwell\n\
    \                    nold = nwell\n                } else {\n                \
    \    nlow = nold\n                    nold = nwell\n                }\n      \
    \          if (capacity-nold < nlow) {\n                    nlow = nlow - 1\n\
    \                    nbucket = nbucket - 1\n                    nfill = nfill\
    \ + 1\n                }\n            }\n        }\n        if (nbucket < nfill)\n\
    \            return nfill\n        else\n            return nbucket", "      \
    \  val rows = grid.length\n        val cols = grid(0).length\n        val buckets\
    \ = Array.ofDim[Long](cols)\n        (0 until cols).foreach(i => {\n         \
    \   buckets(i) = 0\n        })\n        val helper = mutable.ArrayBuffer.empty[(List[List[Long]],\
    \ List[Long])]\n        val stack = mutable.Stack.empty[(List[List[Long]], List[Long])]\n\
    \        helper.append((grid, 0l))\n        helper.append((stack.toList, 0l))\n\
    \        while(!helper.isEmpty) {\n            val pair = helper.pop()\n     \
    \       val buckets = pair._1.toList\n            val value = pair._2\n      \
    \      val newBuckets = mutable.ArrayBuffer.empty[Long]\n            val newValue\
    \ = value\n            buckets.zipWithIndex.foreach(i => {\n                if(i._1\
    \ == 1) {\n                    newBuckets += (i._2 + 1)\n                } else\
    \ {\n                    newBuckets += i._2\n                }\n            })\n\
    \            buckets.foreach(i => {\n                if((i + 1) > newBuckets.length)\
    \ {\n                    newBuckets += (i - (newBuckets.length))\n           \
    \     }\n            })\n            newBuckets.foreach(i => {\n             \
    \   if((i - 1) < 0) {\n                    newBuckets += i\n                }\n\
    \            })\n            newValue -= newBuckets.length\n            buckets.foreach(i\
    \ => {\n                if((i + 1) > newBuckets.length) {\n                  \
    \  newBuckets += (i - (newBuckets.length))\n                }\n            })\n\
    \            newBuckets.foreach(i => {\n                if((i - 1) < 0) {\n  \
    \                  newBuckets += i\n                }\n            })\n      \
    \      stack.push((pair._1, newValue))\n            val newGrid = mutable.ArrayBuffer.empty[List[Long]]\n\
    \            (0 until rows).foreach(j => {\n                newGrid += mutable.ArrayBuffer.empty[Long]\n\
    \                (0 until cols).foreach(k => {\n                    newGrid(k)\
    \ += if (buckets(k) == 0) 0 else buckets(k)\n                })\n            })\n\
    \            helper.append((newGrid, newValue))\n        }\n        stack.toList.map(p\
    \ => p._2).max", "        var count = 0\n        var max = 0\n        for (row\
    \ <- grid) {\n            for (bucket <- row) {\n                if ((bucket >\
    \ max) || (count == 0)) {\n                    max = bucket\n                \
    \    count = 0\n                }\n                if (bucket == max) {\n    \
    \                count += 1\n                }\n            }\n        }\n   \
    \     return max", "        def minBucket(grid : List[List[Long]], capacity :\
    \ Long) : Long = {\n            def countInRow(grid : List[List[Long]], row: List[Long],\
    \ capacity : Long) : Int = {\n                var count = 0\n                for\
    \ (i <- 0 to grid.length - 1) {\n                    if (grid[i] == row) {\n \
    \                       count += 1\n                    }\n                }\n\
    \                if (count == capacity) {\n                    count -= 1\n  \
    \              }\n                count\n            }\n            var minCount\
    \ = sys.maxInt\n            var minRow = List[Long]()\n            for (i <- 0\
    \ to grid.length - 1) {\n                if (minCount > countInRow(grid, grid[i],\
    \ capacity)) {\n                    minRow = grid\n                    minCount\
    \ = countInRow(grid, grid[i], capacity)\n                }\n            }\n  \
    \          minCount\n        }\n\n        def countInRow(grid : List[List[Long]],\
    \ row: List[Long], capacity : Long) : Int = {\n            var count = 0\n   \
    \         for (i <- 0 to grid.length - 1) {\n                if (grid[i] == row)\
    \ {\n                    count += 1\n                }\n            }\n      \
    \      if (count == capacity) {\n                count -= 1\n            }\n \
    \           count\n        }\n        val n = grid.length\n        val m = grid[0].length\n\
    \        var maxCount = sys.maxInt\n        var maxRow = List[Long]()\n      \
    \  var curCount = sys.maxInt\n        for (i<- 0 to n - 1) {\n            if (maxCount\
    \ < countInRow(grid, grid[i], capacity)) {\n                maxRow = grid\n  \
    \              maxCount = countInRow(grid, grid[i], capacity)\n            }\n\
    \        }\n        for (i<- 0 to m - 1) {\n            if (maxCount < countInRow(grid,\
    \ List(grid[0](i)), capacity)) {\n                maxRow = grid\n            \
    \    maxCount = countInRow(grid, List(grid[0](i)), capacity)\n            }\n\
    \        }\n        (maxCount, maxRow)", "        // write your code here\n  \
    \      val rowCount = grid.length\n        val colCount = grid.head._2.length\n\
    \        val bucketCount = rowCount * colCount\n        val buckets = mutable.Buffer.empty[List[Long]](bucketCount)\n\
    \n        for (i <- 0 until rowCount) {\n            val row = grid(i)\n     \
    \       for (j <- 0 until colCount) {\n                val well = row.toLong\n\
    \                val bucket = well.toLong\n                if (bucket < capacity)\
    \ {\n                    buckets += List(bucket)\n                }\n        \
    \    }\n        }\n\n        var sum = 0\n        for (bucket <- buckets) {\n\
    \            val well = bucket.toLong\n            if (well > capacity) {\n  \
    \              sum += 1\n            }\n        }\n\n        return sum", "  \
    \      val rowMax = grid.map(_.length).max\n        val colMax = grid.map(_.head.length).max\n\
    \        if (rowMax == 0 || colMax == 0)\n            return 0\n        val rowMin\
    \ = grid.map(_.length).min\n        val colMin = grid.map(_.head.length).min\n\
    \        var count = 0\n        for (row <- 1 to rowMax) {\n            for (col\
    \ <- 1 to colMax) {\n                val cells = grid.filter{ case (l,r) =>\n\
    \                    val maxRow = row max r\n                    val minRow =\
    \ row min r\n                    val maxCol = col max l\n                    val\
    \ minCol = col min l\n                    r > l && l > 0 && r < colMax && l <\
    \ colMin && r >= minRow && l >= minCol\n                }\n                val\
    \ bucketSize = (cells.length - 1).toLong\n                if (bucketSize < capacity)\n\
    \                    count += 1\n                else\n                    count\
    \ += capacity - bucketSize\n            }\n        }\n        count", "      \
    \  val result = new mutable.ListBuffer[Int]\n        var total = 0\n        \n\
    \        for (h <- 0 until grid.length) {\n            total += grid(h).sum\n\
    \        }\n        \n        val maxCap = total / capacity\n        val minCap\
    \ = total / grid.length\n        val maxBucket = (maxCap - minCap) * capacity\
    \ + minCap\n        val bucketCount = 1\n        \n        while (bucketCount\
    \ < maxBucket) {\n            for (h <- 0 until grid.length) {\n             \
    \   val cur = grid[h].sum\n                if (cur <= minCap) {\n            \
    \        val l = grid[h]\n                    l.clear()\n                    val\
    \ r = grid[h]\n                    r.clear()\n                    val newBucket\
    \ = (maxCap - minCap) * capacity + minCap\n                    \n            \
    \        if (newBucket > bucketCount) {\n                        result += bucketCount\n\
    \                        bucketCount += newBucket\n                    }\n   \
    \             }\n            }\n            \n            maxBucket = (maxCap\
    \ - minCap) * capacity + minCap\n            bucketCount += 1\n        }\n   \
    \     \n        result match {\n            case x if x > 0 => x.toLong\n    \
    \        case x if x == 0 => -1\n            case x if x < 0 => 0\n        }",
  "        require(grid.length == 1)\n        require(grid.head.size == 2)\n     \
    \   require(grid.head._1 == 1 && grid.head._2 == 1)\n        require(0 <= capacity\
    \ && capacity <= 10)\n        require(grid.head._3 > 0)\n        var currentCount\
    \ : Long = 0\n        var maxCount : Long = 1\n        var emptyCount : Long =\
    \ 0\n        var emptyCells = grid(0)\n        emptyCells ++= grid(0)\n      \
    \  emptyCells ++= grid(0)\n        var i = 0\n        var j = 0\n        var maxCount\
    \ : Long = 1\n        var emptyCount : Long = 0\n        while (i < grid.length)\
    \ {\n            while (j < grid[0].length) {\n                emptyCells = grid(i)(j)\n\
    \                if (emptyCells == 0l) {\n                    currentCount +=\
    \ 1\n                    emptyCount += 1\n                    emptyCells ++= grid(i)(j)\n\
    \                    maxCount += 1 // For this row, not every column needs to\
    \ be filled\n                }\n                if (currentCount >= capacity)\
    \ {\n                    emptyCount += maxCount // This is because we need to\
    \ leave a row even if some columns fill up\n                    maxCount = 1\n\
    \                    currentCount = 0\n                }\n                j++\n\
    \            }\n            maxCount += 1\n            currentCount = 0\n    \
    \        i++\n            emptyCount += 1\n        }\n        if (emptyCount >\
    \ 0) maxCount += emptyCount // We need to leave one row if some columns fill up\n\
    \        return maxCount", "        if (grid.length == 1) return 0\n        if\
    \ (grid.length == 0) return 0\n        if (grid == List.empty) return 0\n    \
    \    val m = grid.head\n        val n = grid.last\n        val maxCount = m.zipWithIndex.foldLeft((0l,\
    \ 0l))((c, (m, i)) => {\n            if (c._2 > 0) c._2 else c._2 = 1\n      \
    \      if (c._1 > capacity) c._1 else c._1 = capacity\n            (c, i)\n  \
    \      })\n        return maxCount._1 + 1", "        grid.headOption.map {\n \
    \           case List() => 0\n            case _ => 1\n        }.getOrElse(1)\n\
    \n        val m = grid.length\n        val n = grid(0).length\n        var i :\
    \ Int = 0\n        var j : Int = 0\n        var max = 0\n\n        while (i <\
    \ m && j < n) {\n            if (grid[i][j] < capacity) {\n                val\
    \ c = grid[i][j]\n                grid[i][j] = 0\n                max = 0\n  \
    \              val count = maxFill( grid (i, j + 1) , capacity) - c\n        \
    \        grid[i][j] = c\n                max = math.max(max, count)\n        \
    \        i = i + 1\n            }\n            else if (grid[i][j] == 0) {\n \
    \               i = i + 1\n            }\n            else {\n               \
    \ j = j + 1\n            }\n        }\n        max", "        var count = 1\n\
    \        var min = 0\n        var max = grid.length - 1\n        while(max >=\
    \ min) {\n            while(min <= max && grid(max)(1) == 0) {\n             \
    \   max = max - 1\n            }\n            while(min <= max && grid(min)(1)\
    \ == 0) {\n                min = min + 1\n            }\n            if(grid(max)(0)\
    \ > 0) {\n                count = count + capacity(grid(max)(0)) * Math.max(0,\
    \ grid(max)(1) - grid(min)(1))\n                min = min + 1\n            }\n\
    \            else {\n                count = count + capacity(grid(max)(0)) *\
    \ Math.max(0, grid(min)(1) - grid(max)(1))\n                max = max - 1\n  \
    \          }\n        }\n        count", "        val buckets = grid.getOrElse(List[Long](0l.toLong),\
    \ List[Long](0l.toLong))\n        val bucketMap = mutable.Map[Long, Long]()\n\
    \        var bucketNbr = 0\n        for (b <- buckets) {\n            if (bucketMap.get(b)\
    \ == null) {\n                bucketMap(b) = bucketNbr\n                bucketNbr\
    \ += 1\n            }\n        }\n\n        var fillNbr = 1\n        var maxNbr\
    \ = 0\n        var grid2 = new Array[List[Long]](grid.length)\n        for (i\
    \ <- 0 until grid.length) {\n            var rowNbr = 0\n            var isFilled\
    \ = false\n            var row = grid.get(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (rowNbr == bucketMap.get(row.get(j))) {\n            \
    \        if (j + 1 <  row.length) {\n                        rowNbr += 1\n   \
    \                     if (rowNbr == capacity) {\n                            isFilled\
    \ = true\n                        }\n                    }\n                }\n\
    \            }\n            if (isFilled) {\n                grid2(i) = row\n\
    \                fillNbr += 1\n            } else {\n                grid2(i)\
    \ = List(rowNbr)\n                maxNbr += 1\n            }\n        }\n\n  \
    \      maxNbr", "        val buckets = mutable.ArrayBuffer(capacity)\n       \
    \ val wells = mutable.ArrayBuffer.empty[List[Long]]\n        for (row <- grid)\
    \ {\n            val row = row.toList.sortBy(_.toLong)\n            val bucket\
    \ = row(0)\n            wells ++= row\n            buckets += bucket\n       \
    \ }\n        val emptyWells = buckets.toSet.diffSet(Set(1l.toLong))\n        val\
    \ res = (wells.length - emptyWells).longValue()\n        if (res > capacity) res\
    \ else capacity", "        val maxCount = 1\n        val emptyCount = 0\n    \
    \    val result = grid.map(row => {\n            if (row.head == 0)\n        \
    \        maxCount += 1\n            else\n                emptyCount += 1\n  \
    \          row\n        }).sum + 1\n        while (emptyCount > 0) {\n       \
    \     val newEmptyCount = grid.map(row => {\n                if (row.head == 0)\n\
    \                    maxCount += 1\n                else\n                   \
    \ emptyCount -= 1\n                row\n            }).sum + 1\n            if\
    \ (newEmptyCount - emptyCount >= 1)\n                break\n            else {\n\
    \                emptyCount = newEmptyCount\n                maxCount = grid.map(row\
    \ => {\n                    if (row.head == 0)\n                        maxCount\
    \ += 1\n                    else\n                        emptyCount -= 1\n  \
    \                  row\n                }).sum + 1\n            }\n        }\n\
    \        result", "        // Your code here\n        val m = grid.head.size\n\
    \        var total = 0\n        grid.foreach(row => \n            row.foreach(value\
    \ => \n                total += if(value == 1l) capacity else 0\n            ))\n\
    \        val max1 = total.toInt / m\n        val max2 = ((total % m) * m) - max1\n\
    \        math.max(max1, max2)", '        // write your code here', "        val\
    \ row = grid(0).toList\n        val buckets = row.map(_.toLong)\n        var max\
    \ = 0\n        for (i <- 1 to grid.length-1) {\n            for (j <- 1 to row(i).length-1)\
    \ {\n                val newBucket = buckets(j)\n                val newCapacity\
    \ = capacity\n                val newBucketCap = newCapacity - newBucket\n   \
    \             val newRow = row(i).filterNot(newBucket).map(_ + newBucketCap).toList\n\
    \                val newGrid = grid :+ newRow\n                if (newBucketCap\
    \ > max) {\n                    max = newBucketCap\n                }\n      \
    \      }\n        }\n        max", "        val buckets = grid.map(_.toArray).\n\
    \            zipWithIndex.\n            map(x => mutable.HashMap(x -> x._2)).\n\
    \            foldLeft(mutable.HashMap.empty[Long, Int]()) {\n            case\
    \ (m, (bucket, index)) => m.updated(index, m.getOrElse(index, 0) + bucket)\n \
    \       }\n        buckets.foldLeft(0)(x => math.max(x, x.getOrElse(1, 0)))",
  "        val map = new mutable.HashMap[Long, List[Long]]\n        grid.foreach {\
    \ row =>\n            row.foreach { column =>\n                map.get(column)\
    \ match {\n                    case Some(list) => list ::= row\n             \
    \       case None => map += (column -> row)\n                }\n            }\n\
    \        }\n        var count = 0\n        map foreach { case (column, rows) =>\n\
    \            val min = rows.min\n            val max = rows.max\n            if\
    \ (max - min < capacity / rows.size) {\n                count += 1\n         \
    \       if (map.contains(min)) map.remove(min) match {\n                    case\
    \ Some(list) => list ::= column\n                    case None => map += (column\
    \ -> column)\n                }\n            }\n        }\n        count", " \
    \       val m = grid.length\n        val n = grid(0).length\n        val buckets\
    \ = Vector.tabulate(n)((i, _) => capacity)\n        (m > 0 && n < 10L*10L && grid.forall(_.forall(_\
    \ == 0)) ||\n           m == 0l && n == 0l && grid.forall(_.forall(_ == 0)) ||\n\
    \           m == 0 && n == 0l && grid.forall(_.forall(_ == 0)))\n            ?\
    \ 0\n            : findMax(grid, buckets)", "        val bucketSize = capacity\n\
    \        val grid = mutable.ArrayBuffer.empty[List[Long]]\n        for (i <- 0\
    \ until grid.length){\n            grid += i :: Nil\n        }\n        val result\
    \ = mutable.ArrayBuffer.empty[Long]\n        var next = 1\n        for (i <- 0\
    \ until grid.length - 1){\n            for (j <- 0 until grid[i].length - 1){\n\
    \                val nextBuckets = next / bucketSize\n                next +=\
    \ 1\n                val buckets = grid.map(_.map(i => if (i == j) 1l else 0l))\n\
    \                val bucket = buckets(i)\n                val nextValue = bucket\
    \ * nextBuckets\n                for (k <- 0 until bucketSize - 1){\n        \
    \            if (!(nextValue + k + 1 < bucketSize)){\n                       \
    \ nextValue += k + 1\n                    }\n                }\n             \
    \   val value = nextValue + bucket * nextBuckets\n                result += value\n\
    \            }\n        }\n        result.toList.length", "        val m = grid.length\n\
    \        val n = grid(0).length\n        var max = 0\n        grid(0).foreach(x\
    \ => { \n            if (x == 1) \n                max += 1\n        })\n    \
    \    (1 to m).map(x => (0 to n).map(y => grid(x).map(z => if (z == 0) capacity\
    \ else z).sum).sum).reduce((x, y) => if (x > y) x else y)", "        // write\
    \ your code here\n        val newGrid = grid.map { row =>\n            val r =\
    \ mutable.ArrayBuffer.empty[Long]\n            row.foreach(x => r.synchronized\
    \ += x)\n            r\n        }.toList\n\n        val maxLength = mutable.ArrayBuffer.empty[Long]\n\
    \        var counter = 0\n\n        while(newGrid.isEmpty) {\n            val\
    \ max = newGrid.map(x => x.sum).max\n            if(max == capacity) counter +=\
    \ 1\n            if(max > capacity) {\n                val r = newGrid.map(x =>\
    \ x.sum).dropWhile(x => x == capacity)\n                maxLength += r.min\n \
    \               newGrid = r.toList\n            } else {\n                maxLength\
    \ += max\n                newGrid = newGrid.dropWhile(x => x == max).toList\n\
    \            }\n        }\n\n        maxLength.max", "        val buckets = mutable.HashSet[Long](capacity)\n\
    \        grid foreach {\n            case x if x.forall(x => buckets add x) =>\n\
    \                buckets = buckets.filterNot(x => x == 0)\n        }\n       \
    \ buckets.foldLeft(0l)((a, b) => if (b > a) b - a else a)"]
stop_tokens:
- "\n    }\n"
