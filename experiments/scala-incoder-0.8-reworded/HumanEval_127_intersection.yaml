name: HumanEval_127_intersection
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given two intervals,\n    // where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n    // The given intervals are\
  \ closed which means that the interval (start, end)\n    // includes both start\
  \ and end.\n    // For each given interval, it is assumed that its start is less\
  \ or equal its end.\n    // Your task is to determine whether the length of intersection\
  \ of these two \n    // intervals is a prime number.\n    // Example, the intersection\
  \ of the intervals (1, 3), (2, 4) is (2, 3)\n    // which its length is 1, which\
  \ not a prime number.\n    // If the length of the intersection is a prime number,\
  \ return \"YES\",\n    // otherwise, return \"NO\".\n    // If the two intervals\
  \ don't intersect, return \"NO\".\n    // [input/output] samples:\n    // >>> intersection(((1l,\
  \ 2l)), ((2l, 3l)))\n    // (\"NO\")\n    // >>> intersection(((-1l, 1l)), ((0l,\
  \ 4l)))\n    // (\"NO\")\n    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))\n \
  \   // (\"YES\")\n    def intersection(interval1 : Tuple2[Long, Long], interval2\
  \ : Tuple2[Long, Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
  \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
  \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
  YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
  \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
  \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
  \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
  NO\")));\n    }\n\n}\n"
completions: ["        def gcd(a : Long, b : Long) : Long = {\n            if (a ==\
    \ 0) b\n            else gcd(b, a%b)\n        }\n        val length = interval1._2\
    \ - interval1._1 + interval2._2 - interval2._1 + 1\n        if (length != 1) {\n\
    \            return \"NO\"\n        }\n        val interval1_start = interval1._1\n\
    \        val interval1_end = interval1._2\n        val interval2_start = interval2._1\n\
    \        val interval2_end = interval2._2\n        val interval_length = interval1_end\
    \ - interval1_start + interval2_end - interval2_start + 1\n        if (interval_length\
    \ != 1) {\n            return \"NO\"\n        }\n        val gcd_interval_length\
    \ = gcd(interval_length, interval_length)\n        var gcd_intersection_length\
    \ = gcd(interval_length, interval_length / gcd_interval_length)\n        var gcd_difference_length\
    \ = interval_length / gcd_interval_length\n        val result = if (gcd_intersection_length\
    \ == 1) {\n            \"YES\"\n        } else {\n            var gcd_result =\
    \ 1\n            while (gcd_result * gcd_intersection_length < interval_length)\
    \ {\n                gcd_result = gcd_result * gcd_intersection_length\n     \
    \       }\n            if (interval_length / gcd_result == 1) {\n            \
    \    val gcd_difference_start = interval1_start / gcd_result\n               \
    \ val gcd_difference_end = interval1_end / gcd_result\n                if (gcd_difference_start\
    \ == gcd_difference_end) {\n                    gcd_result = gcd_result * gcd_difference_start\n\
    \                    val gcd_difference_start = interval2_start / gcd_result\n\
    \                    val gcd_difference_end = interval2_end / gcd_result\n   \
    \                 if (gcd_difference_start == gcd_difference_end) {\n        \
    \                gcd_result = gcd_result * gcd_difference_start\n            \
    \            val gcd_difference_start = interval1_start / gcd_result\n       \
    \                 val gcd_difference_end = interval1_end / gcd_result\n      \
    \                  if (gcd_difference_start == gcd_difference_end) {\n       \
    \                     gcd_result = gcd_result * gcd_difference_start\n       \
    \                     val gcd_difference_start = interval2_start / gcd_result\n\
    \                            val gcd_difference_end = interval2_end / gcd_result\n\
    \                            if (gcd_difference_start == gcd_difference_end) {\n\
    \                                gcd_result = gcd_result * gcd_difference_start\n\
    \                                val gcd_difference_start = interval1_start /\
    \ gcd_result\n                                val gcd_difference_end = interval1_end\
    \ / gcd_result\n                                if (gcd_differen", "        if(interval1._1\
    \ >= interval2._1 && interval1._1 <= interval2._2)\n            interval1._1.toString\n\
    \        else\n            if(interval1._1 >= interval2._1 && interval1._1 <=\
    \ interval2._2)\n                interval2._1.toString\n            else\n   \
    \             if(interval1._1 >= interval2._1 && interval1._1 <= interval2._2)\n\
    \                    interval1._2.toString\n                else\n           \
    \         if(interval1._1 >= interval2._1 && interval1._1 <= interval2._2)\n \
    \                       interval2._2.toString\n                    else\n    \
    \                    \"NO\"", "        var intervalList1 = interval1._2.toInt\n\
    \        var intervalList2 = interval2._2.toInt\n        var result = \"\"\n \
    \       if (intervalList1 == intervalList2 && intervalList2 != 0) {\n        \
    \    result += \"YES\"\n        } else if (intervalList1 != intervalList2) {\n\
    \            result += \"NO\"\n        } else if (intervalList1 == 0) {\n    \
    \        result += \"NO\"\n        } else if (intervalList2 == 0) {\n        \
    \    result += \"NO\"\n        } else {\n            val xs = List((-1L, interval1._1),\
    \ (0L, interval2._1))\n            val ys = List((interval2._1, 5L))\n       \
    \     val xy = zip(xs, ys)\n            val intersection = xy.filter(_._2 < _._2)\n\
    \            if (intersection.nonEmpty) {\n                val inter = intersection.head._2\n\
    \                val interval = intersection.head._1\n                val primes\
    \ = primeFactors(inter)\n                if (primes.contains(inter)) {\n     \
    \               result += \"YES\"\n                } else {\n                \
    \    result += \"NO\"\n                }\n            } else {\n             \
    \   result += \"NO\"\n            }\n        }\n        result", "        val\
    \ start = interval1._1\n        val end = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        \n        if(end>start2 && end2>start)\
    \ {\n            val start2Min = if (start2 < start) start2 else start\n     \
    \       val end2Max = if (end2 > end) end2 else end\n            val startMin\
    \ = if (start2 < start) start else start2\n            val endMax = if (end2 >\
    \ end) end else end2\n            val result = primeChecker(start2Min, end2Max,\
    \ startMin, endMax)\n            \n            if(result==0) \"NO\" else result.toString\n\
    \        } else {\n            \"NO\"\n        }", '        if (interval1._2 <
    interval2._1 || interval1._2 > interval2._2) "NO" else "YES"', "        //get\
    \ interval1's length\n        var interval1_length = interval1._2 - interval1._1\
    \ \n        //get interval2's length\n        var interval2_length = interval2._2\
    \ - interval2._1 \n        //check if interval1's length <= interval2's length\n\
    \        if (interval1_length <= interval2_length){\n            val length =\
    \ interval1_length\n            val end = interval1._1 + length\n            val\
    \ start = end - length\n            val start = start.toLong\n            val\
    \ end = end.toLong\n            val interval = scala.collection.mutable.TreeMap[Long,\
    \ String]()\n            val intervals = scala.collection.mutable.TreeMap[Long,\
    \ Long]()\n            val primes = scala.collection.mutable.TreeMap[Long, String]()\n\
    \            val primesLength = scala.collection.mutable.TreeMap[Long, Long]()\n\
    \            var count = 0\n            while (start <= end){\n              \
    \  interval += (start -> \"YES\")\n                intervals += (start -> length)\n\
    \                primes += (start -> \"NO\")\n                primesLength +=\
    \ (start -> intervals(start))\n                count += 1\n                start\
    \ += 1\n            }\n            for (prime <- primesLength.keysIterator){\n\
    \                val primeLength = primesLength(prime)\n                if (primeLength\
    \ >= intervals(prime)){\n                    interval += (prime -> \"NO\")\n \
    \                   intervals += (prime -> intervals(prime))\n               \
    \     primes += (prime -> \"YES\")\n                    primesLength += (prime\
    \ -> intervals(prime))\n                    count += 1\n                }\n  \
    \          }\n            if (count == length){\n                val lengths =\
    \ intervals.mapValues(v => v.toString)\n                val primesLengths = primesLength.mapValues(v\
    \ => v.toString)\n                if (primes.isEmpty == false){\n            \
    \        var primesTrue = \"\"\n                    for (prime <- primes.keysIterator){\n\
    \                        primesTrue += primes(prime) + \"|\"\n               \
    \     }\n                    if (primesTrue == primesLengths.last){\n        \
    \                return \"YES\"\n                    }\n                }else{\n\
    \                    return \"NO\"\n                }\n            }\n       \
    \ }\n        else{\n            val length = interval2_length\n            val\
    \ end = interval2._1 + length\n            val start = end - length\n        \
    \    val start = start.toLong\n            val end = end.toLong\n            val\
    \ interval = scala.collection.mutable.TreeMap[Long, String]()\n            val\
    \ intervals = scala.collection.mutable.TreeMap[Long, Long]()\n            val\
    \ primes = scala.collection.mutable.TreeMap[Long, String]()\n            val prime",
  "        val x1 = interval1._1\n        val x2 = interval1._2\n        val y1 =\
    \ interval2._1\n        val y2 = interval2._2\n        if(x1 > x2) (x1,x2) else\
    \ (x2,x1)\n        val s1 =  (x2-x1)\n        val s2 = (y2-y1)\n        val i1\
    \ = (x2-x1)/s1\n        val i2 = (y2-y1)/s2;\n        val xy = x1*y1\n       \
    \ if(i1 == 0 && i2 == 0) \"NO\"\n        else if((i1/xy)==(i2/xy) || i1 < 0 ||\
    \ i2 < 0) \"NO\"\n        else if(i1==0 && i2 < 0) \"NO\"\n        else if(i1==0\
    \ && i2 > 0) \"NO\"\n        else if(i1 > 0 && i2 == 0) \"NO\"\n        else if(i1\
    \ > 0 && i2 > 0) \"YES\"\n        else if(i1 < 0 && i2 > 0) \"NO\"\n        else\
    \ if(i1 > 0 && i2 < 0) \"YES\"\n        else if(i1 < 0 && i2 == 0) \"YES\"\n \
    \       else if(i1 < 0 && i2 < 0) \"YES\"\n        else if(i1 > 0 && i2 == 0)\
    \ \"YES\"\n        else if(i1 > 0 && i2 > 0) \"YES\"\n        else if(i1 < 0 &&\
    \ i2 > 0) \"YES\"\n        else if(i1 < 0 && i2 < 0) \"YES\"", "        val start1\
    \ = interval1._1\n        val end1 = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        val result1 = if (start1 > end1) start1\
    \ else end1\n        val result2 = if (start2 > end2) start2 else end2\n     \
    \   val isIntersecting = !(start1 <= result2 && result2 <= end1) && !(start2 <=\
    \ result1 && result1 <= end2)\n        if (isIntersecting) (\"YES\") else (\"\
    NO\")", "        val result = scala.collection.mutable.Set.empty[Int]\n      \
    \  val interval1Min = interval1._1\n        val interval1Max = interval1._2\n\
    \        val interval2Min = interval2._1\n        val interval2Max = interval2._2\n\
    \n        if (interval1Min > interval2Max)\n        {\n            result = \"\
    NO\"\n        }\n        else if (interval1Max < interval2Min)\n        {\n  \
    \          result = \"NO\"\n        }\n        else\n        {\n            result\
    \ = \"YES\"\n        }", "        val start = interval1._1\n        val end =\
    \ interval2._1\n        var result = \"NO\"\n        val leftInterval = interval1._2\n\
    \        val rightInterval = interval2._2\n        val leftLength = leftInterval\
    \ - start\n        val rightLength = rightInterval - end\n        if (leftLength\
    \ == 0 || rightLength == 0) {\n            result = \"NO\"\n        } else {\n\
    \            val maxLength = Math.max(leftLength, rightLength)\n            val\
    \ isIntersect = (maxLength % 2 == 0) && ((start + rightLength - maxLength) ==\
    \ maxLength)\n            if (isIntersect) {\n                result = \"YES\"\
    \n            } else {\n                result = \"NO\"\n            }\n     \
    \   }\n        result", "        val intersection = (interval1._1, interval2._2)\n\
    \        if (intersection._1 >= intersection._2)\n            \"NO\"\n       \
    \ else\n            if (intersection._1 < intersection._2)\n                if\
    \ (interval1._1 == interval2._1 && interval1._2 == interval2._1)\n           \
    \         \"YES\"\n                else\n                    if (interval1._1\
    \ == interval2._1)\n                        \"YES\"\n                    else\n\
    \                        if (interval1._2 == interval2._2)\n                 \
    \           \"YES\"\n                        else\n                          \
    \  if (interval1._2 < interval2._2)\n                                if (interval1._1\
    \ == interval2._2)\n                                    \"YES\"\n            \
    \                    else\n                                    if (interval1._1\
    \ == interval2._2)\n                                        \"YES\"\n        \
    \                            else\n                                        if\
    \ (interval1._2 == interval2._1)\n                                           \
    \ \"NO\"\n                                        else\n                     \
    \                       if (interval1._2 < interval2._1)\n                   \
    \                             \"NO\"\n                                       \
    \     else\n                                                if (interval1._1 ==\
    \ interval2._2)\n                                                    \"YES\"\n\
    \                                                else\n                      \
    \                              \"NO\"\n            else\n                \"NO\"",
  "        val start = min(interval1._1, interval2._1)\n        val end = max(interval1._2,\
    \ interval2._2)\n\n        var prime = List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97).filter(x\
    \ => start<=x && x<=end).length()\n        var count = 0\n        var count =\
    \ 0\n        var count = 0\n        while(prime<1) {\n            count += 1\n\
    \            prime = List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97).filter(x\
    \ => start<=x && x<=end).length()\n        }\n        if (prime==1) {\n      \
    \      val x = List(1,2,3,4,5,6,7,8,9,10).filter(x => start<=x && x<=end).length()\n\
    \            val y = List(1,2,3,4,5,6,7,8,9,10).filter(x => start<=x && x<=end).length()\n\
    \            if (x==y) {\n                count = 1\n            }\n        }\n\
    \        val result = count\n        if (prime==2) {\n            if (count <=\
    \ 2) {\n                return \"YES\"\n            } else {\n               \
    \ return \"NO\"\n            }\n        } else {\n            if (count <= 2)\
    \ {\n                return \"NO\"\n            } else {\n                return\
    \ \"YES\"\n            }\n        }", "        val i1 = interval1._1 * 1000\n\
    \        val i2 = interval1._2 * 1000\n        val j1 = interval2._1 * 1000\n\
    \        val j2 = interval2._2 * 1000\n        if (i2 < j1) {\n            val\
    \ temp = i1\n            i1 = i2\n            i2 = temp\n        }\n        if\
    \ (i1 > j2) {\n            val temp = j1\n            j1 = j2\n            j2\
    \ = temp\n        }\n        val length = j2 - j1\n        if (length < 1) {\n\
    \            return (\"NO\")\n        }\n        if (length == 1) {\n        \
    \    val i = i1\n            val j = j1\n            if (i == j && j > 0) {\n\
    \                return (\"YES\")\n            }\n        }\n        val m = i2\
    \ - i1 + 1\n        if (m == 2) {\n            if (j1 > 0) {\n               \
    \ val a = interval1._1\n                val b = interval2._1\n               \
    \ if (a >= b) {\n                    val temp = j1\n                    j1 = j2\n\
    \                    j2 = temp\n                }\n            }\n           \
    \ if (j1 == 0) {\n                return (\"YES\")\n            }\n        }\n\
    \        val m = length\n        if (m == 2) {\n            val a = interval1._1\n\
    \            val b = interval2._1\n            if (a > b) {\n                val\
    \ temp = i1\n                i1 = i2\n                i2 = temp\n            }\n\
    \        }\n        if (m == 1) {\n            val a = interval1._1\n        \
    \    val b = interval2._1\n            if (a < b) {\n                val temp\
    \ = i1\n                i1 = i2\n                i2 = temp\n            }\n  \
    \      }\n        val result = j1 * m % i1\n        if (result < 0) {\n      \
    \      return (\"NO\")\n        }\n        if (result >= i2) {\n            return\
    \ (\"NO\")\n        }\n        val temp = i1\n        i1 = i2\n        i2 = temp\n\
    \        return (\"YES\")", "        val num1 = interval1._1\n        val num2\
    \ = interval1._2\n        val num3 = interval2._1\n        val num4 = interval2._2\n\
    \        if (num1 >= num2)\n        {\n            if (num2 >= num3)\n       \
    \     {\n                if (num3 >= num4)\n                {\n              \
    \      if (num1 == num3 || num1 == num4)\n                    {\n            \
    \            return \"NO\"\n                    }\n                    if (num2\
    \ == num3 || num2 == num4)\n                    {\n                        return\
    \ \"NO\"\n                    }\n                    if (num1 > num3)\n      \
    \              {\n                        return \"NO\"\n                    }\n\
    \                    if (num1 > num4)\n                    {\n               \
    \         return \"NO\"\n                    }\n                    if (num2 <\
    \ num3)\n                    {\n                        return \"NO\"\n      \
    \              }\n                    if (num2 < num4)\n                    {\n\
    \                        return \"NO\"\n                    }\n              \
    \      if (num1 < num3)\n                    {\n                        return\
    \ \"YES\"\n                    }\n                    if (num1 < num4)\n     \
    \               {\n                        return \"YES\"\n                  \
    \  }\n                    val length1 = num1 - num2\n                    val length2\
    \ = num3 - num4\n                    if (length1 == length2)\n               \
    \     {\n                        if (length1 == 0)\n                        {\n\
    \                            return \"YES\"\n                        }\n     \
    \                   else\n                        {\n                        \
    \    return \"NO\"\n                        }\n                    }\n       \
    \             if (length1 == length2 && length1 != 0)\n                    {\n\
    \                        return \"YES\"\n                    }\n             \
    \       if (length1 == length2 || length1 != length2)\n                    {\n\
    \                        return \"NO\"\n                    }\n              \
    \  }\n                else\n                {\n                    if (num2 >\
    \ num4)\n                    {\n                        return \"NO\"\n      \
    \              }\n                    if (num1 < num3)\n                    {\n\
    \                        return \"YES\"\n                    }\n             \
    \       if (num2 < num4)\n                    {\n                        return\
    \ \"YES\"\n                    }\n                    if (num1 > num4)\n     \
    \               {\n                        return \"YES\"\n                  \
    \  }\n                    if (num3 > num4)\n                    {\n          \
    \              return \"YES\"\n                    }\n                }\n    \
    \        }\n            else\n            {\n                if (num3 > num4)\n\
    \                {\n                    return \"NO\"\n                }\n   \
    \             if (num1 < num3)\n                {\n                    return\
    \ \"YES\"\n                }\n                if (num2 < num4)\n             \
    \   {\n                    return \"YES\"\n                }\n               \
    \ if (num1 > num4)\n                {\n                    return \"YES\"\n  \
    \              }\n                if (num3 > num4)\n                {\n      \
    \              return \"YES\"\n                }\n            }\n        }\n \
    \       else\n        {\n            if (num3 > num4)\n            {\n       \
    \         return \"NO\"\n            }\n            if (num1 < num3)\n       \
    \     {\n                return \"YES\"\n            }\n            if (num2 <\
    \ num4)\n            {\n                return \"YES\"\n            }\n      \
    \      if (num1 > num4)", "        def find(i1 : Tuple2[Long, Long], i2 : Tuple2[Long,\
    \ Long], i: Long, j: Long) : Boolean = {\n            // base case: both are equal\
    \ to each other\n            if(i1 == i2) return true\n            if(i1._2 >\
    \ i2._2) return false\n            if(i1._2 < i2._2) return false\n\n        \
    \    // if both are greater than current i value then it's ok\n            if(j\
    \ == i._2) return true\n\n            // if both are lesser than current i value\
    \ then it is not ok\n            if(j < i._2) return false\n\n            // if\
    \ i is lesser than j\n            if(j == i._2) return false\n\n            //\
    \ if both are greater than current j value\n            if(j == i._2) return false\n\
    \n            if(i1._2 < i2._2) return false\n\n            // if i is lesser\
    \ than j and i1._2 < i2._2 then it is not ok\n            if(j < i._2 && i1._2\
    \ < i2._2) return false\n\n            // if both are greater than current j value\n\
    \            if(j == i._2) return false\n\n            // if both are less than\
    \ current i value then it is ok\n            if(j == i._2) return true\n\n   \
    \         // if i is greater than j and i1._2 < i2._2 then it is ok\n        \
    \    if(j > i._2 && i1._2 < i2._2) return true\n\n            // if both are less\
    \ than current j value\n            if(j > i._2 && i1._2 < i2._2) return false\n\
    \n            if(i1._2 > i2._2) return false\n\n            // if i is greater\
    \ than j and i1._2 > i2._2 then it is not ok\n            if(j > i._2 && i1._2\
    \ > i2._2) return false\n\n            // if both are greater than current j value\n\
    \            if(j == i._2) return false\n\n            // if both are less than\
    \ current i value then it is ok\n            if(j == i._2) return true\n\n   \
    \         // if i is greater than j and i1._2 > i2._2 then it is ok\n        \
    \    if(j > i._2 && i1._2 > i2._2) return true\n\n            // if i is greater\
    \ than j and i1._2 > i2._2 then it is ok\n            if(j > i._2 && i1._2 > i2._2)\
    \ return true\n\n            // return false\n            false\n        }\n \
    \       var interval11 = interval1\n        var interval21 = interval2\n     \
    \   var interval1 = interval1._1, interval2 = interval2._1\n        var interval11\
    \ = interval1._", "        val start = interval1._1\n        val end = interval1._2\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        if(start\
    \ < end2 && start < start2)\n            intersect(start, end2, interval1, interval2)\n\
    \        else if(end > end2 && end > start2)\n            intersect(start2, end2,\
    \ interval1, interval2)\n        else\n            \"NO\"", "        def checkIfPrime(x\
    \ : Int) : Boolean = {\n            val l = new mutable.LinkedList[Int]()\n  \
    \          val temp = new mutable.LinkedList[Int]()\n            for(i <- 1 to\
    \ x/2){\n                l.add(i)\n            }\n            l.foreach(x => {\n\
    \                for(i <- 1 to x/2){\n                    temp.add(x)\n      \
    \          }\n            })\n            l.toSet == temp.toSet\n        }\n \
    \       val start = interval1._1\n        val end = interval1._2\n        val\
    \ startPrime = checkIfPrime(start)\n        val endPrime = checkIfPrime(end)\n\
    \        if(startPrime && endPrime){\n            if(start < end){\n         \
    \       return\"YES\"\n            }\n            else{\n                return\"\
    NO\"\n            }\n        }\n        else{\n            return\"NO\"\n    \
    \    }", '        if (interval1._1 <= interval2._1 && interval1._2 >= interval2._2)
    "YES" else "NO"', "        var i1 = interval1._1\n        var i2 = interval2._1\n\
    \        var j1 = interval1._2\n        var j2 = interval2._2\n        var len\
    \ = 0\n        var flag = false\n        if (i1 == i2) { \n            flag =\
    \ true\n        }\n        else if ((j1 < j2) && !flag) {\n            len = (i1\
    \ - j1)\n        }\n        else if ((j1 > j2) && !flag) {\n            len =\
    \ (j2 - i1)\n        }\n        else if ((j1 < j2) && (j1 > j2) && !flag) {\n\
    \            len = ((i1 - j1) + j2)\n        }\n        else if (j1 < j2) && (j1\
    \ > j2) && (!flag) {\n            len = ((i1 - j1) + j2)\n        }\n        if\
    \ ((len == 1) && !flag) {\n            return \"YES\"\n        }\n        else\
    \ if ((len % 2) == 0) \"NO\" else \"YES\"", "        val start = min(interval1._1,\
    \ interval2._1)\n        val end = max(interval1._2, interval2._2)\n        val\
    \ range = end - start\n        val primes = Range(2, range).filter(_ => start\
    \ <= _ && _ < end).filter(x => !(x % 2 == 0)).takeWhile(x => x < range).toList\n\
    \        if (primes.contains(range)) {\n            val result = primes.find(_\
    \ => interval2._1 <= _ && _ < interval2._2).map(x => start - x).collectFirst(_\
    \ == 0 ).map(_ => if(_ == 1) \"YES\" else \"NO\").getOrElse(\"NO\")\n        \
    \    result \n        }\n        else \n            \"NO\"", "        var a =\
    \ interval1._1;\n        var b = interval1._2;\n        var c = interval2._1;\n\
    \        var d = interval2._2;\n\n        if (a < b) (a, b) match {\n        \
    \    case (h, u) if h < u =>\n                (a, c) match {\n               \
    \     case (h, u) if h < u =>\n                        (a, d) match {\n      \
    \                      case (h, u) if h < u =>\n                             \
    \   \"NO\"\n                            case (h, u) =>\n                     \
    \           \"NO\"\n                        }\n                    case (h, u)\
    \ =>\n                        \"NO\"\n                }\n            case (h,\
    \ u) =>\n                \"NO\"\n        }\n        else if (a < c) (c, d) match\
    \ {\n            case (h, u) if h < u =>\n                (c, d) match {\n   \
    \                 case (h, u) if h < u =>\n                        (c, d) match\
    \ {\n                            case (h, u) if h < u =>\n                   \
    \             \"NO\"\n                            case (h, u) =>\n           \
    \                     \"NO\"\n                        }\n                    case\
    \ (h, u) =>\n                        \"NO\"\n                }\n            case\
    \ (h, u) =>\n                \"NO\"\n        }\n        else (d, c) match {\n\
    \            case (h, u) if h < u =>\n                (d, c) match {\n       \
    \             case (h, u) if h < u =>\n                        (d, d) match {\n\
    \                            case (h, u) if h < u =>\n                       \
    \         \"NO\"\n                            case (h, u) =>\n               \
    \                 \"NO\"\n                        }\n                    case\
    \ (h, u) =>\n                        \"NO\"\n                }\n            case\
    \ (h, u) =>\n                \"NO\"\n        }", "        def prime(num : Long)\
    \ : Boolean = {\n            var p = true;\n            val m = 2l;\n        \
    \    while (p && m < num) {\n                val q = m + (num - m) / m * m;\n\
    \                val r = num - q;\n                val m = r / m;\n          \
    \      val p = r > m && r > p;\n            }\n            p\n        }\n    \
    \    def isIntersect(a:Long, b:Long, c:Long) : Boolean = {\n            val m1\
    \ = a + (c - a) / (c - b) * b;\n            val m2 = b + (c - b) / (c - a) * a;\n\
    \            val x = Math.sqrt(m1 - m2);\n            (x == m1) || (x == m2);\n\
    \        }\n        if(interval1._1 < interval1._2 && interval1._2 < interval2._1\
    \ &&\n           interval1._3 < interval1._2 && interval1._3 < interval2._2) {\n\
    \            if (isIntersect(interval1._1, interval2._2, interval2._1) &&\n  \
    \             (prime(interval1._2) - prime(interval1._3))) {\n               \
    \ return \"YES\";\n            } else {\n                return \"NO\";\n    \
    \        }\n        } else if (interval1._1 < interval1._2 && interval1._2 < interval2._1\
    \ &&\n          interval1._3 < interval2._2 && interval2._3 < interval1._1) {\n\
    \            if (isIntersect(interval1._1, interval1._2, interval1._3) &&\n  \
    \             (prime(interval2._2) - prime(interval2._3))) {\n               \
    \ return \"YES\";\n            } else {\n                return \"NO\";\n    \
    \        }\n        } else if (interval1._1 < interval2._2 && interval1._2 < interval2._1\
    \ &&\n          interval1._3 < interval2._2 && interval1._3 < interval2._1) {\n\
    \            if (isIntersect(interval1._1, interval1._2, interval1._3) &&\n  \
    \             (prime(interval2._2) - prime(interval2._3))) {\n               \
    \ return \"YES\";\n            } else {\n                return \"NO\";\n    \
    \        }\n        } else if (interval1._1 < interval1._2 && interval1._2 < interval2._1\
    \ &&\n          interval2._3 < interval1._2 && interval1._3 < interval2._1) {\n\
    \            if (isIntersect(interval1._1, interval2._2, interval2._3) &&\n  \
    \             (prime(interval1._2) - prime(interval1._3))) {\n               \
    \ return \"YES\";\n            } else {\n                return \"NO\";\n    \
    \        }\n        } else if (interval1._1 < interval1._2 && interval1._2 < interval2._1\
    \ &&\n          interval2._3 < interval2._2 && interval1._3 < interval", "   \
    \     // Write your code here\n        val intervals = mutable.Set[Tuple2[Long,\
    \ Long]]()\n        val start = interval1._1\n        val end = interval1._2\n\
    \        val start_new = interval2._1\n        val end_new = interval2._2\n  \
    \      if (start > end) return(\"NO\")\n        if (start_new > end_new) return(\"\
    NO\")\n        intervals += (interval2)\n        while(!intervals.isEmpty){\n\
    \            val interval = intervals.toSet\n            intervals.remove(interval)\n\
    \            val intersection = interval._1\n            val length = interval._2\n\
    \            if ((start <= intersection) && (intersection < end)){\n         \
    \       if (length == end_new - start_new + 1){\n                    println(\"\
    yes\")\n                    return(\"YES\")\n                }\n             \
    \   println(\"no\")\n                return(\"NO\")\n            }\n         \
    \   if (length < end_new - start_new + 1){\n                println(\"no\")\n\
    \                return(\"NO\")\n            }\n            intervals += (Tuple2(intersection,\
    \ start + length))\n        }\n        println(\"no\")\n        return(\"NO\")",
  "        val interval1Array = interval1._1.toLongArray.map(_.toLong)\n        val\
    \ interval2Array = interval2._1.toLongArray.map(_.toLong)\n        val intersectionArray\
    \ = interval1Array.intersect(interval2Array)\n        val count = intersectionArray.size\n\
    \        if (intersectionArray.size == 2) {\n            val diff = intersectionArray(0)\
    \ - intersectionArray(1) //diff is length of intersection between interval1 and\
    \ interval2\n            if (diff % 2 == 0 && diff <= (interval1._1 + interval2._1))\
    \ {\n                return \"YES\"\n            } else {\n                return\
    \ \"NO\"\n            }\n        }\n        else {\n            return \"NO\"\n\
    \        }", "        val start = interval1._1\n        val end = interval1._2\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        val\
    \ start = math.min(start, start2)\n        val end = math.max(end, end2)\n   \
    \     if(start < end) if(end - start == 2) \"YES\" else \"NO\"\n        else throw\
    \ new IllegalArgumentException(\"the intervals don't intersect\")", '        if
    (interval1._2 < interval2._1 || interval1._2 > interval2._2) "NO" else "YES"',
  "        val l1 = interval1._1\n        val l2 = interval2._1\n        val r1 =\
    \ interval1._2\n        val r2 = interval2._2\n\n        // If the interval are\
    \ disjoint, return \"NO\"\n        if (l1 >= r2 || l2 >= r1) return \"NO\"\n\n\
    \        // If the length are equal, return \"YES\"\n        val len1 = l1 - r1\n\
    \        val len2 = l2 - r2\n        if (len1 == len2) \"YES\"\n\n        // If\
    \ the length is divisible by 3, return \"YES\"\n        if (len1 % 3 == 0 || len2\
    \ % 3 == 0) \"YES\"\n\n        // If the length of intersection is prime number,\
    \ return \"YES\"\n        if (isPrime(len1) and isPrime(len2)) \"YES\"\n\n   \
    \     // If the length of intersection is not prime number, return \"NO\"\n  \
    \      else return \"NO\"", "        def primeCheck(i1 : Long, i2 : Long) : Boolean\
    \ = {\n            val i1l = i1.toInt\n            val i2l = i2.toInt\n      \
    \      val i1Range = i1l*(i1l-1)\n            val i2Range = i2l*(i2l-1)\n    \
    \        val i1Rangel = (i1l*i1l-1)\n            val i2Rangel = (i2l*i2l-1)\n\
    \            val i1l2 = (i1l*i2l-1)\n            val i2l2 = (i2l*i1l-1)\n    \
    \        for (i2 <- 0 until i1l-1)\n            for (i1 <- 0 until i2l-1)\n  \
    \          if (i1l*i2+i2l*i1+i1l*i2l*i2 != i1l*i2l*i1+i2l*i1l*i2)\n          \
    \  if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n            if (i1l*i2+i2l*i1+i1l*i2l*i2\
    \ == i1l*i2l*i1+i2l*i1l*i2)\n            if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n\
    \            if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n        \
    \    if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n            if (i1l*i2+i2l*i1+i1l*i2l*i2\
    \ == i1l*i2l*i1+i2l*i1l*i2)\n            if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n\
    \            if (i1l*i2+i2l*i1+i1l*i2l*i2 == i1l*i2l*i1+i2l*i1l*i2)\n        \
    \    if (i1l*i2+i2l*i1+i1l", "        //  1\u3001\u6C42\u4E24\u4E2A\u533A\u95F4\
    \u7684\u4EA4\u96C6\uFF0C\u8FD9\u662F\u4E00\u4E2Aset\uFF0C\u5176\u4E2D\u6BCF\u4E2A\
    \u5143\u7D20\u662F\u4E24\u4E2Aintervals\u7684\u5DEE\u7684\u5DEE\u503C\n      \
    \  //  2\u3001\u53D6\u5E76\u96C6\uFF0C\u4EA4\u96C6\u7684\u7ED3\u679C\u662F\u4E00\
    \u4E2Aset\uFF0C\u5176\u4E2D\u6BCF\u4E2A\u5143\u7D20\u662F\u4E24\u4E2Aintervals\u7684\
    \u5DEE\u7684\u5DEE\u503C\n        //  3\u3001\u6C42\u5DEE\u7684\u5DEE\u503C\u662F\
    \u4E00\u4E2A\u6570\uFF0C\u5982\u679C\u4E3A0\uFF0C\u5219\u4E0D\u662F\u4E00\u4E2A\
    \u5408\u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F1\n        //\
    \  4\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E3A1\uFF0C\u5219\u662F\u5408\u6CD5\
    \u7684\u6C42\u89E3\n        //  5\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\
    \u4E3A0\uFF0C\u5219\u662F\u4E0D\u5408\u6CD5\u7684\u6C42\u89E3\n        //  6\u3001\
    \u5982\u679C\u5DEE\u7684\u5DEE\u503C\u662F1\uFF0C\u5219\u8BA4\u4E3A\u4E24\u4E2A\
    \u533A\u95F4\u7684\u4EA4\u96C6\u4E3A1\uFF0C\u4E5F\u5C31\u662F\u4E00\u4E2A\u5408\
    \u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F2\n        //  7\u3001\
    \u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\u662F1\uFF0C\u5219\u8BA4\u4E3A\u4E24\
    \u4E2A\u533A\u95F4\u7684\u4EA4\u96C6\u662F\u975E\u6CD5\u7684\u6C42\u89E3\uFF0C\
    \u8FD9\u65F6\u5019\u5C31\u662F3\n        //  8\u3001\u5982\u679C\u5DEE\u7684\u5DEE\
    \u503C\u662F0\uFF0C\u5219\u8BA4\u4E3A\u4E24\u4E2A\u533A\u95F4\u7684\u4EA4\u96C6\
    \u662F\u975E\u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F4\n  \
    \      //  9\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\u662F0\uFF0C\u5219\
    \u8BA4\u4E3A\u4E24\u4E2A\u533A\u95F4\u7684\u4EA4\u96C6\u662F\u5408\u6CD5\u7684\
    \u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F5\n        //  10\u3001\u5982\u679C\
    \u5DEE\u7684\u5DEE\u503C\u4E0D\u662F0\uFF0C\u5219\u8BA4\u4E3A\u4E24\u4E2A\u533A\
    \u95F4\u7684\u4EA4\u96C6\u4E0D\u5408\u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\
    \u5019\u5C31\u662F6\n        //  11\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\
    \u662F0\uFF0C\u5219\u8BA4\u4E3A\u4E24\u4E2A\u533A\u95F4\u7684\u4EA4\u96C6\u4E0D\
    \u5408\u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F7\n        //\
    \  12\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\u662F0\uFF0C\u5219\u8BA4\
    \u4E3A\u4E24\u4E2A\u533A\u95F4\u7684\u4EA4\u96C6\u4E0D\u5408\u6CD5\u7684\u6C42\
    \u89E3\uFF0C\u8FD9\u65F6\u5019\u5C31\u662F8\n        //  13\u3001\u5982\u679C\u5DEE\
    \u7684\u5DEE\u503C\u4E0D\u662F0\uFF0C\u5219\u8BA4\u4E3A\u4E24\u4E2A\u533A\u95F4\
    \u7684\u4EA4\u96C6\u4E0D\u5408\u6CD5\u7684\u6C42\u89E3\uFF0C\u8FD9\u65F6\u5019\
    \u5C31\u662F9\n        //  14\u3001\u5982\u679C\u5DEE\u7684\u5DEE\u503C\u4E0D\u662F\
    0\uFF0C\u5219\u8BA4\u4E3A\u4E24", "        // initialize variables\n        var\
    \ left1 = interval1._1\n        var left2 = interval1._2\n        var right1 =\
    \ interval2._1\n        var right2 = interval2._2\n        // compute length of\
    \ intersection\n        var length_intersection = right1 - left1\n        var\
    \ length_union = right2 - left2\n        if (length_union == length_intersection)\
    \ {\n            // if length of union equals to length of intersection, the two\
    \ intervals intersect\n            // return \"YES\"\n            return \"YES\"\
    \n        }\n        else {\n            // if length of union is not equal to\
    \ the length of intersection, the two intervals don't intersect\n            //\
    \ return \"NO\"\n            return \"NO\"\n        }", "        var count = 0\n\
    \        var i1 = interval1._1;\n        var i2 = interval1._2;\n        var j1\
    \ = interval2._1;\n        var j2 = interval2._2;\n        while(i1 <= j1 && j2\
    \ <= i2){\n            count += 1\n            if(i1 == j1) \n               \
    \ if(i2 == j2) \n                    count += 2\n                else\n      \
    \              count += 1\n            else if(i1 == j2)\n                if(i2\
    \ == j1)\n                    count += 2\n                else\n             \
    \       count += 1\n            i1 += 1\n            j1 += 1\n        }\n    \
    \    if(count % 2 == 0) \n            return \"NO\"\n        else\n          \
    \  return \"YES\"", "        val start = interval1._1\n        val end = interval2._1\n\
    \        if (start >= end) {\n            return \"NO\"\n        }\n        val\
    \ s1 = interval1._2\n        val s2 = interval2._2\n        val s = s1 - s2\n\
    \        val a = s2 / s\n        val b = s2 - a * s\n        if (s == 1) {\n \
    \           if (a % 2 == 0) {\n                if (a % 3 == 0) {\n           \
    \         if (a % 5 == 0) {\n                        return \"YES\"\n        \
    \            }\n                }\n            }\n        }\n        if (s >=\
    \ 3) {\n            if (s % 2 == 0) {\n                if (s % 3 == 0) {\n   \
    \                 if (s % 5 == 0) {\n                        return \"YES\"\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ (a == 2) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n \
    \                   if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return \"YES\"\n                        }\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (s == 1) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n \
    \                   if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return \"YES\"\n                        }\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (s == 1) {\n            if (a % 2 == 0) {\n                if (a % 3 == 0) {\n\
    \                    if (a % 5 == 0) {\n                        return \"YES\"\
    \n                    }\n                }\n            }\n        }\n       \
    \ if (s == 1) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n\
    \                    if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return \"YES\"\n                        }\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (s == 1) {\n            if (a % 2 == 0) {\n                if (a % 3 == 0) {\n\
    \                    if (a % 5 == 0) {\n                        return \"YES\"\
    \n                    }\n                }\n            }\n        }\n       \
    \ if (s == 1) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n\
    \                    if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return \"YES\"\n                        }\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (s == 1) {\n            if (a % 2 == 0) {\n                if (a % 3 == 0) {\n\
    \                    if (a % 5 == 0) {\n                        return \"YES\"\
    \n                    }\n                }\n            }\n        }\n       \
    \ if (s == 1) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n\
    \                    if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return \"YES\"\n                        }\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (s == 1) {\n            if (a % 2 == 0) {\n                if (a % 3 == 0) {\n\
    \                    if (a % 5 == 0) {\n                        return \"YES\"\
    \n                    }\n                }\n            }\n        }\n       \
    \ if (s == 1) {\n            if (b == 2) {\n                if (b % 2 == 0) {\n\
    \                    if (b % 3 == 0) {\n                        if (b % 5 == 0)\
    \ {\n                            return ", '        if(interval1._2 <= interval2._1
    && interval1._2 >= interval2._2) "YES" else "NO"', "        val interval1_low\
    \ = interval1._1\n        val interval1_high = interval1._2\n        val interval2_low\
    \ = interval2._1\n        val interval2_high = interval2._2\n\n        // Return\
    \ false when there is no intersection\n        if(interval1_low > interval2_low\
    \ || interval1_high < interval2_high) return \"NO\"\n\n        // Return false\
    \ when there is an intersection\n        if(interval1_low >= interval2_low &&\
    \ interval1_high <= interval2_high) return \"NO\"\n\n        // Return true when\
    \ there is no intersection\n        if(interval1_low >= interval2_low && interval1_high\
    \ >= interval2_high) return \"YES\"\n\n        // Return true when there is an\
    \ intersection\n        return \"YES\"", '        if (interval1._2 > interval2._2)
    "NO" else "YES"', "        val length1 = interval1._2\n        val length2 = interval2._2\n\
    \        if (length1 < length2) return \"NO\"\n        if (length1 > length2)\
    \ return \"NO\"\n        if (length1 == length2) return \"YES\"\n        val length\
    \ = math.min(length1, length2)\n        for (i <- 0 until length) {\n        \
    \    val value1 = interval1._1.toLong + i\n            val value2 = interval2._1.toLong\
    \ + i\n            if (value1 > value2) return \"NO\"\n            if (value1\
    \ < value2) return \"NO\"\n        }\n        return \"YES\"", "        val a\
    \ = interval1._1 \n        val b = interval1._2\n        val c = interval2._1\n\
    \        val d = interval2._2\n        if (b < c || a < d) \"NO\" else \"YES\"",
  "        val i1x = interval1._1\n        val i1y = interval1._2\n        val i2x\
    \ = interval2._1\n        val i2y = interval2._2\n\n        if (i1x < i2x && i1y\
    \ < i2y) {\n            if (i1x + i1y == i2x || i1x - i1y == i2x) {\n        \
    \        if (i1x <= i2x) {\n                    if (i1y <= i2y) {\n          \
    \              if (i1y <= i1x) \"NO\" else \"NO\" else \"YES\"\n             \
    \       } else \"NO\" else \"NO\" else \"YES\"\n                } else {\n   \
    \                 if (i1y <= i2y) \"NO\" else \"NO\" else \"YES\"\n          \
    \      }\n            } else \"NO\" else \"NO\" else \"YES\"\n        } else \"\
    NO\" else \"NO\" else \"YES\"", "        val int1 = interval1._1.toInt\n     \
    \   val int2 = interval1._2.toInt\n        val int3 = interval2._1.toInt\n   \
    \     val int4 = interval2._2.toInt\n        if(int1 < int2) {\n            val\
    \ tmp = int1\n            int1 = int2\n            int2 = tmp\n        }\n   \
    \     if(int3 > int4) {\n            val tmp = int3\n            int3 = int4\n\
    \            int4 = tmp\n        }\n        if(int1 < int3) {\n            val\
    \ tmp = int1\n            int1 = int3\n            int3 = tmp\n        }\n   \
    \     if(int2 > int4) {\n            val tmp = int2\n            int2 = int4\n\
    \            int4 = tmp\n        }\n        val int5 = int2 * int2\n        val\
    \ int6 = int4 * int4\n        val int7 = int5 * int4\n        val int8 = int6\
    \ * int4\n        if((int1 - int3) == 0 && (int2 - int4) == 0) {\n           \
    \ \"NO\"\n        } else if (int5 == int6) {\n            if((int3 - int5) ==\
    \ 0) {\n                \"NO\"\n            } else if(((int4 - int6) == 0) ||\
    \ (int5 == int7) || (int5 == int8)) {\n                \"NO\"\n            } else\
    \ {\n                \"YES\"\n            }\n        } else if((int5 - int6) ==\
    \ 0) {\n            if((int3 - int5) == 0) {\n                \"NO\"\n       \
    \     } else if(((int4 - int6) == 0) || (int5 == int7) || (int5 == int8)) {\n\
    \                \"YES\"\n            } else {\n                \"NO\"\n     \
    \       }\n        } else if((int5 == int6) && (int5 == int7) && (int5 == int8)\
    \ && (int3 - int4) == 0) {\n            \"YES\"\n        } else if((int5 == int6)\
    \ && (int5 == int7) && (int5 == int8) && (int4 - int3) == 0) {\n            \"\
    NO\"\n        } else if((int5 == int6) && (int5 == int7) && (int5 == int8) &&\
    \ (int4 - int3) != 0) {\n            \"NO\"\n        } else {\n            \"\
    NO\"\n        }", "        val start = interval1._1\n        val end = interval2._1\n\
    \        if (interval1._2 <= interval2._2) {\n            if (interval2._2 <=\
    \ interval1._2) {\n                if (start <= end) \"YES\" else \"NO\"\n   \
    \         } else {\n                if (interval1._2 < end) \"YES\" else \"NO\"\
    \n            }\n        } else {\n            if (interval1._2 < start) \"YES\"\
    \ else \"NO\"\n        }", "        // Write your code here\n        val firstSet\
    \ = Set((interval1._1, interval1._2))\n        val secondSet = Set((interval2._1,\
    \ interval2._2))\n        firstSet intersect secondSet.toSet", "        // your\
    \ code goes here\n        if(interval1._2 > interval2._1){\n            if(interval1._1\
    \ == interval2._1){\n                return \"NO\"\n            }\n          \
    \  return \"YES\"\n        }\n        if(interval1._2 < interval2._1){\n     \
    \       if(interval1._1 == interval2._1){\n                return \"NO\"\n   \
    \         }\n            return \"YES\"\n        }\n        if(interval1._2 ==\
    \ interval2._1){\n            return \"NO\"\n        }\n        if(interval1._1\
    \ == interval2._2){\n            return \"NO\"\n        }\n        return \"YES\"",
  "        val start = interval1._1\n        val end = interval2._1\n        val len1\
    \ = interval1._2\n        val len2 = interval2._2\n        val intersect = if(start\
    \ > end) None\n        else { val left = start + 1; val right = end; while(left\
    \ < right) {\n            val mid = (left + right) / 2;\n            val a = interval1._1;\n\
    \            val b = interval2._1;\n            if(mid == a && mid < b) left =\
    \ mid + 1;\n            else if(mid > a && mid < b) right = mid - 1;\n       \
    \     else left; }}}\n        intersect.map(i => if(len1 == len2) \"YES\" else\
    \ \"NO\").getOrElse(\"NO\")", "        val first = interval1._1\n        val last\
    \ = interval1._2\n        val first2 = interval2._1\n        val last2 = interval2._2\n\
    \n        // If two intervals don't intersect, return \"NO\".\n        if (first\
    \ > last || first2 > last2) return \"NO\"\n\n        // If two intervals intersect,\
    \ \n        // calculate length of intersection\n        val len1 = math.abs(first\
    \ - last)\n        val len2 = math.abs(first2 - last2)\n        val len = Math.min(len1,\
    \ len2)\n\n        val isPrime = math.ceil(len / 2) == len\n        if (isPrime)\
    \ \"YES\" else \"NO\"", "        var str = \"\"\n        var interval_prime =\
    \ 0\n        var interval_length = 0\n\n        var intersect = if(interval1._1\
    \ < interval1._2) true else false\n        var interval1_length = if(interval1._1\
    \ > interval1._2) true else false\n        var interval2_length = if(interval2._1\
    \ > interval2._2) true else false\n\n        if(intersect){\n            while(interval1._1\
    \ < interval2._1){\n                interval_prime = interval1._1\n          \
    \      interval_length = interval1._2\n                interval1 = (interval1._2\
    \ + interval1._1, 1)\n            }\n            while(interval1._2 < interval2._2){\n\
    \                interval_prime = interval1._2\n                interval_length\
    \ = interval1._1\n                interval1 = (interval1._1, interval1._2 + 1)\n\
    \            }\n        }else{\n            while(interval1._1 < interval2._2){\n\
    \                interval_prime = interval1._2\n                interval_length\
    \ = interval1._1\n                interval1 = (interval1._2, interval1._1 + 1)\n\
    \            }\n            while(interval1._2 < interval2._1){\n            \
    \    interval_prime = interval1._1\n                interval_length = interval1._2\n\
    \                interval1 = (interval1._1 + interval1._2, interval1._2)\n   \
    \         }\n        }\n\n        if(interval1_length == interval_length && interval2_length\
    \ == interval_length){\n            str = \"YES\"\n        }else{\n          \
    \  str = \"NO\"\n        }\n        return str", "        val int1 = interval1._1;\
    \ val int2 = interval1._2\n        val int3 = interval2._1; val int4 = interval2._2\n\
    \        \n        val len1 = len((int1, int2))\n        val len2 = len((int3,\
    \ int4))\n        \n        if (len1 != len2) \"NO\" else \"YES\"", "        val\
    \ range1 = interval1._2 - interval1._1 + 1\n        val range2 = interval2._2\
    \ - interval2._1 + 1\n        val intersection = range1 * range2\n        if (intersection\
    \ == 0)\n            \"NO\"\n        else if (isPrime(intersection)) \"YES\"\n\
    \        else if (intersection > 0) \"NO\"\n        else intersection.map(x =>\
    \ (x - interval1._1)/interval1._2 % 2).toString.reverse", "        val start1\
    \ = interval1._1.toInt\n        val start2 = interval2._1.toInt\n        val end1\
    \ = interval1._2.toInt\n        val end2 = interval2._2.toInt\n\n        if (start2\
    \ < start1 || end2 < end1) return \"NO\"\n        if (start2 == end2) return \"\
    NO\"\n        val left = max(start1, end2)\n        val right = min(start1, end2)\n\
    \        if (left == right) return \"NO\"\n\n        // if (right - left == 1)\
    \ \"YES\" else ...\n        if (end - start == 1) \"YES\" else \"NO\"", "    \
    \    val x1 = interval1._1\n        val x2 = interval2._1\n        val y1 = interval1._2\n\
    \        val y2 = interval2._2\n\n        val x1 = x1.toInt\n        val x2 =\
    \ x2.toInt\n        val y1 = y1.toInt\n        val y2 = y2.toInt\n\n        val\
    \ length = math.max(math.abs(x1 - x2), math.abs(y1 - y2))\n        var i = x1\n\
    \        var j = y1\n        val result = mutable.Set.empty[Int]\n        val\
    \ prime = List(2, 3, 5)\n        while (i <= x2 && j <= y2) {\n            if\
    \ (math.abs(i - j) <= length) {\n                result += math.min(math.min(i,\
    \ j), math.max(i, j))\n                i += 2\n                j += 2\n      \
    \      }\n            else {\n                result += (math.min(i, j) - math.max(i,\
    \ j))\n                i += math.min(math.min(i, j), math.max(i, j))\n       \
    \         j += math.min(math.min(i, j), math.max(i, j))\n            }\n     \
    \   }\n        if (result.size < 2) \"NO\" else \"YES\"", "        val a1 = interval1._1\n\
    \        val a2 = interval1._2\n        val b1 = interval2._1\n        val b2\
    \ = interval2._2\n        val len1 = math.max(math.min(a1, b1), math.min(a2, b2))\n\
    \        val len2 = math.max(math.min(a1, b2), math.min(a2, b1))\n        val\
    \ intv1 = math.min(a1, b1)\n        val intv2 = math.max(a2, b2)\n        if(intv1\
    \ == intv2){\n            \"NO\"\n        }\n        else if(intv1 > intv2){\n\
    \            val newstart = a2 > b2 ? b1 : b1\n            val newend = a2 > b2\
    \ ? a2 : a2\n            intersection(newstart, newend)\n        }\n        else\
    \ if(intv1 < intv2){\n            val newstart = a1 > b1 ? a1 : b1\n         \
    \   val newend = a1 > b1 ? b2 : b2\n            intersection(newstart, newend)\n\
    \        }\n        else{\n            val newstart = math.max(a1, b1)\n     \
    \       val newend = math.min(a2, b2)\n            intersection(newstart, newend)\n\
    \        }", "        if(interval1._1 > interval1._2 || interval2._1 > interval2._2)\
    \ return \"NO\"\n        if(interval1._1 < interval2._1 && interval1._2 >= interval2._2)\
    \ return \"NO\"\n        if(interval2._1 < interval1._1 && interval2._2 >= interval1._2)\
    \ return \"NO\"\n        var i = 0\n        var j = 0\n        var intersect =\
    \ 0\n        while(i < interval1._1 && j < interval2._1) {\n            if(interval1._1\
    \ <= interval1._2 && interval2._1 <= interval2._2) \n                intersect\
    \ = interval1._1 + interval2._1 - interval1._2 - interval2._2\n            else\n\
    \                intersect = interval1._1 + interval2._1 - interval1._2 - interval2._2\n\
    \            if((i ^ j) % intersect == 0) {\n                if(intersect % 2\
    \ == 0) return \"NO\"\n                else return \"YES\"\n            } else\
    \ if(intersect > 2) {\n                if(intersect % 2 == 1) return \"NO\"\n\
    \                else return \"YES\"\n            } else if(intersect == 2) {\n\
    \                if(i % 2 == 0) return \"YES\"\n                else return \"\
    NO\"\n            } else if(intersect == 1) {\n                if(i % 2 == 1)\
    \ return \"YES\"\n                else return \"NO\"\n            } else if(intersect\
    \ == 0) {\n                if(i % 2 == 0) return \"YES\"\n                else\
    \ return \"NO\"\n            }\n            i = i + 1\n            j = j + 1\n\
    \        }", "        if (interval2._1 < interval1._1) {\n            val tmp\
    \ = interval2._1\n            interval2._1 = interval1._1\n            interval1._1\
    \ = tmp\n        }\n\n        if (interval2._2 < interval1._2) {\n           \
    \ val tmp = interval2._2\n            interval2._2 = interval1._2\n          \
    \  interval1._2 = tmp\n        }\n\n        if (interval1._1 == interval1._2)\
    \ \"NO\" else \"YES\"", "        val i1Length = interval1._2 - interval1._1 +\
    \ 1\n        val i2Length = interval2._2 - interval2._1 + 1\n        val length\
    \ = math.min(i1Length, i2Length)\n        val set1 = interval1._1 until interval1._2\n\
    \        val set2 = interval2._1 until interval2._2\n        var isPrime = true\n\
    \        for (i1 <- set1; i2 <- set2) {\n            if (i1 <= i2) {\n       \
    \         val sum = i1 + i2\n                val prod = i1Length * i2Length -\
    \ sum\n                if (prod != 0) {\n                    if (sum + prod ==\
    \ length) {\n                        isPrime = false \n                    }\n\
    \                }\n            }\n        }\n        if (isPrime) {\n       \
    \     \"YES\"\n        } else {\n            \"NO\"\n        }", "        var\
    \ interval : List[(Long, Long)] = List()\n        var tempInterval : List[(Long,\
    \ Long)] = List()\n        var interval2 : List[(Long, Long)] = List()\n     \
    \   for (i <- interval1._1 until interval1._2) {\n            for (j <- interval2._1\
    \ until interval2._2) {\n                interval = List(interval1(i), interval2(j))\n\
    \                tempInterval = List((interval(1) -> interval(2)), (interval(2)\
    \ -> interval(3)))\n                if (intersection(tempInterval, interval))\
    \ {\n                    return \"YES\"\n                }\n            }\n  \
    \      }\n        return \"NO\"", "        if(interval1(0).isLTEQ(interval2(1)))\
    \ \n            return \"NO\"\n        if(interval1(1).isLTEQ(interval2(1))) \n\
    \            return \"NO\"\n        if(interval1(1).isLTEQ(interval2(0))) \n \
    \           return \"YES\"\n        return \"NO\"", "        val first = interval1._1\n\
    \        val second = interval1._2\n        val first2 = interval2._1\n      \
    \  val second2 = interval2._2\n        val firstMinusSecond = first - second\n\
    \        val secondMinusFirst = second - first\n        val firstMinusSecond2\
    \ = first2 - second2\n        val secondMinusFirst2 = second2 - first2\n     \
    \   val firstMinusSecond2 = first2 - second2\n        val firstMinusSecond = first\
    \ - second\n        val secondMinusFirst = second - first\n        val firstMinusSecond2\
    \ = first2 - second2\n        val secondMinusFirst2 = second2 - first2\n     \
    \   val firstMinusSecond2 = first2 - second2\n        val secondMinusFirst2 =\
    \ second2 - first2\n        val firstMinusSecond = first - second\n        val\
    \ secondMinusFirst = second - first\n        val firstMinusSecond2 = first2 -\
    \ second2\n        val secondMinusFirst2 = second2 - first2\n        val firstMinusSecond\
    \ = first - second\n        val secondMinusFirst = second - first\n        val\
    \ firstMinusSecond2 = first2 - second2\n        val secondMinusFirst2 = second2\
    \ - first2\n        val firstMinusSecond = first - second\n        val secondMinusFirst\
    \ = second - first\n        val firstMinusSecond2 = first2 - second2\n       \
    \ val secondMinusFirst2 = second2 - first2\n        val firstMinusSecond = first\
    \ - second\n        val secondMinusFirst = second - first\n        val firstMinusSecond2\
    \ = first2 - second2\n        val secondMinusFirst2 = second2 - first2\n     \
    \   val firstMinusSecond = first - second\n        val secondMinusFirst = second\
    \ - first\n        val firstMinusSecond2 = first2 - second2\n        val secondMinusFirst2\
    \ = second2 - first2\n        val firstMinusSecond = first - second\n        val\
    \ secondMinusFirst = second - first\n        val firstMinusSecond2 = first2 -\
    \ second2\n        val secondMinusFirst2 = second2 - first2\n        val firstMinusSecond\
    \ = first - second\n        val secondMinusFirst = second - first\n        val\
    \ firstMinusSecond2 = first2 - second2\n        val secondMinusFirst2 = second2\
    \ - first2\n        val firstMinusSecond = first - second\n        val secondMinusFirst\
    \ = second - first\n        val firstMinusSecond2 = first2 - second", "      \
    \  val interval1Start = interval1._1\n        val interval1End = interval1._2\n\
    \        val interval2Start = interval2._1\n        val interval2End = interval2._2\n\
    \        val interval1Length = interval1End - interval1Start + 1\n        val\
    \ interval2Length = interval2End - interval2Start + 1\n        if(interval1Length\
    \ < interval2Length)\n            \"NO\"\n        else if(interval1Length > interval2Length)\n\
    \            \"YES\"\n        else {\n            val interval1Start = interval1._1\n\
    \            val interval1End = interval1._2\n            val interval2Start =\
    \ interval2._1\n            val interval2End = interval2._2\n            val interval1Length\
    \ = interval1End - interval1Start + 1\n            val interval2Length = interval2End\
    \ - interval2Start + 1\n            val intersectionLength = (interval1Length\
    \ - interval2Length) / 2\n            val isPrime = (0 until intersectionLength).forall(x\
    \ => {\n                val a = interval1Start + x\n                val b = interval2Start\
    \ + x\n                a <= b && b < interval1End && (interval1End - a) * (interval2End\
    \ - b) <= 0\n            })\n            if(isPrime)\n                \"YES\"\n\
    \            else\n                \"NO\"\n        }", "        def gcd(a: Long,\
    \ b: Long): Long = {\n            if (a == 0) b\n            else gcd(b % a, a)\n\
    \        }\n        def lcm(a: Long, b: Long): Long = {\n            val m = a\
    \ * b / gcd(a, b)\n            val r = a / gcd(a, b)\n            val m = m.toLong\n\
    \            val r = r.toLong\n            m ++ \"l\" ++ r\n        }\n      \
    \  val start = interval1._1\n        val end = interval2._1\n        val length\
    \ = end - start\n        // if their length is less than or equal to 2\n     \
    \   if (length <= 2) \"NO\"\n        else {\n            val common = gcd(length,\
    \ 2)\n            // the length of their intersection is 2 if they are both less\
    \ than or equal to common\n            if (common <= length) \"YES\"\n       \
    \     // if their intersect is less than or equal to common\n            else\
    \ if (common < 2) \"NO\"\n            // if their intersect is greater than common\n\
    \            else lcm(common, 2) + \"l\" + lcm(common, 2) \n        }", "    \
    \    val start = interval1._1 \n        val end = interval1._2\n        val start\
    \ = interval2._1 \n        val end = interval2._2\n        if(start <= end){\n\
    \            val length = end - start \n            if(length == 1){\n       \
    \         return \"NO\"\n            }\n            if(length == 2){\n       \
    \         if(isPrime(length)) return \"YES\"\n                else \"NO\"\n  \
    \          }\n            val temp = length / 2\n            if(isPrime(temp))\n\
    \                return \"YES\"\n            else \"NO\"\n        }\n        \"\
    NO\"", "        val isIntersecting = interval1._2 < interval2._1 && interval1._2\
    \ > interval2._2 // If these intervals do not intersect, return \"NO\".\n    \
    \    val primeLength = (interval1._1 - interval2._1).filter { n => n % 2 != 0\
    \ }.size // Find the length of intersection of these two intervals.\n        if(isIntersecting\
    \ && primeLength == 2 ) {\n            \"YES\"\n        }\n        else if(!isIntersecting\
    \ && primeLength == 1) {\n            \"NO\"\n        }\n        else if(!isIntersecting\
    \ && primeLength == 0) {\n            \"NO\"\n        }\n        else {\n    \
    \        \"NO\"\n        }", "        if(interval1._1 < interval1._2 && interval2._1\
    \ < interval2._2 && interval1._2 > interval2._2){\n            if (interval1._1\
    \ < interval2._1){\n                val tmp = interval1\n                interval1\
    \ = interval2\n                interval2 = tmp\n            }\n            if(interval2._1\
    \ < interval1._1){\n                val tmp = interval1\n                interval1\
    \ = interval2\n                interval2 = tmp\n            }\n            if(interval1._2\
    \ > interval2._2){\n                val tmp = interval1\n                interval1\
    \ = interval2\n                interval2 = tmp\n            }\n            if(interval1._2\
    \ > interval2._2){\n                val tmp = interval1\n                interval1\
    \ = interval2\n                interval2 = tmp\n            }\n            val\
    \ l1 = interval1._1\n            val l2 = interval1._2\n            val r1 = interval2._1\n\
    \            val r2 = interval2._2\n            if(l1 > r2){\n               \
    \ val tmp = interval1\n                interval1 = interval2\n               \
    \ interval2 = tmp\n            }\n            if(l2 > r1){\n                val\
    \ tmp = interval1\n                interval1 = interval2\n                interval2\
    \ = tmp\n            }\n            if(l1 > r1){\n                val tmp = interval1\n\
    \                interval1 = interval2\n                interval2 = tmp\n    \
    \        }\n            if(l2 > r2){\n                val tmp = interval1\n  \
    \              interval1 = interval2\n                interval2 = tmp\n      \
    \      }\n            if(l1 < r1 && l2 < r2){\n                val tmp = interval1\n\
    \                interval1 = interval2\n                interval2 = tmp\n    \
    \        }\n            if(l1 < r2 && l2 < r1){\n                val tmp = interval1\n\
    \                interval1 = interval2\n                interval2 = tmp\n    \
    \        }\n            if(l1 < r1 && l2 > r2){\n                val tmp = interval1\n\
    \                interval1 = interval2\n                interval2 = tmp\n    \
    \        }\n            if(l2 < r1 && l1 > r2){\n                val tmp = interval1\n\
    \                interval1 = interval2\n                interval2 = tmp\n    \
    \        }\n            val res = scala.util.Try{\n                val interval\
    \ = (interval1._1, interval1._2)\n                val interval2 = (interval2._1,\
    \ interval2._2)\n                if (interval._1 < interval2._1 && interval._2\
    \ > interval2._1){\n                    val tmp = interval\n                 \
    \   interval = interval2\n                    interval2 = tmp\n              \
    \  }\n                if(interval._1 < interval2._1 && interval._2 < interval2._1){\n\
    \                    val tmp = interval\n                    interval = interval2\n\
    \                    interval2 = tmp", "        val int1 = interval1._1, int2\
    \ = interval2._1\n        val int3 = interval1._2, int4 = interval2._2\n     \
    \   if ((int1 > int3) || (int2 > int4)) \"NO\" else \"YES\"", "        val start\
    \ = max(interval1._1, interval2._1)\n        val end = min(interval1._2, interval2._2)\n\
    \        val intervalLength = end - start\n        if (intervalLength < 2) \"\
    NO\" else \"YES\"", "        def isPrime(x : Int) : Boolean = {\n            for\
    \ (i <- 1 until x by 2) {\n                if (x % i == 0) {\n               \
    \     return false\n                }\n            }\n            true\n     \
    \   }\n        var x = interval1._1\n        var y = interval1._2\n        var\
    \ z = interval2._1\n        var w = interval2._2\n        if (!(x>=y && x>=z))\
    \ {\n            return \"NO\"\n        }\n        if (!(z>=x && z>=w)) {\n  \
    \          return \"NO\"\n        }\n        if (isPrime(x+y) && isPrime(x+z)\
    \ && isPrime(y+w)) {\n            return \"YES\"\n        }\n        return \"\
    NO\"", '        // TODO: your implementation here', "        val intersection\
    \ = interval1._1 intersect interval2._1\n        val length = intersection.length\n\
    \        if (length == interval1._1) {\n            return \"NO\"\n        } else\
    \ if (length == interval2._1) {\n            return \"NO\"\n        } else if\
    \ (length == 2) {\n            return \"YES\"\n        } else {\n            val\
    \ prime = length.filter(_ => 0 until length forall { x => x%prime==0 })\n    \
    \        if (prime == length) {\n                return \"YES\"\n            }\
    \ else {\n                return \"NO\"\n            }\n        }", "        val\
    \ interval1Length = interval1._2 - interval1._1\n        val interval2Length =\
    \ interval2._2 - interval2._1\n        if(interval1Length < 0 || interval2Length\
    \ < 0) \"NO\"\n        else interval1Length == interval2Length ? \"YES\" : \"\
    NO\"", "        val first = interval1._1\n        val last = interval1._2\n  \
    \      val second  = interval2._1\n        val third  = interval2._2\n       \
    \ \n        if(first < second && second < third) return \"NO\"\n        if(first\
    \ < second && third < first) return \"NO\"\n        if(second < third && third\
    \ < first) return \"NO\"\n        if(first == second) return \"NO\"\n        \n\
    \        var length : Int = 0\n        for(x <- first until second){\n       \
    \     for(y <- first until third){\n                if(x != y  && x != y && y\
    \ != x && y != x && y != y  && x != y) length++\n            }\n        }\n  \
    \      if (length == 2 || length == 3) return \"YES\"\n        return \"NO\"",
  "        // write your code here\n        val start1 = interval1._1\n        val\
    \ end1 = interval1._2\n        val start2 = interval2._1\n        val end2 = interval2._2\n\
    \        if ((start1 > end2) || (start2 > end1)) \"NO\" else \"YES\"", "     \
    \   def isPrime(x : Long) : Boolean = {\n            var flag : Boolean = false\n\
    \            var i : Long = 1\n            while (i <= x && !flag) {\n       \
    \         if (x % i == 0) {\n                    flag = true\n               \
    \ }\n                i += 1\n            }\n            if (flag)\n          \
    \      return false\n            else\n                return true\n        }\n\
    \n        def findPrimeIntervals(interval : Tuple2[Long, Long]): Boolean = {\n\
    \            var flag : Boolean = false\n            var i : Long = 1\n      \
    \      while (i <= interval._1 && !flag) {\n                if (interval._1 %\
    \ i == 0) {\n                    flag = true\n                }\n            \
    \    i += 1\n            }\n            if (flag)\n                return true\n\
    \            else\n                return false\n        }\n\n        def findPrimeIntervals(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]): Boolean = {\n       \
    \     var flag : Boolean = false\n            var i : Long = 1\n            while\
    \ (i <= interval1._1 && !flag) {\n                if (interval1._1 % i == 0) {\n\
    \                    flag = true\n                }\n                i += 1\n\
    \            }\n            if (flag)\n                return true\n         \
    \   else\n                return false\n        }\n\n        def findPrimeIntervals(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]): Boolean = {\n       \
    \     var flag : Boolean = false\n            var i : Long = 1\n            while\
    \ (i <= interval1._1 && !flag) {\n                if (interval1._1 % i == 0) {\n\
    \                    flag = true\n                }\n                i += 1\n\
    \            }\n            if (flag)\n                return true\n         \
    \   else\n                return false\n        }\n\n        def findPrimeIntervals(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]): Boolean = {\n       \
    \     var flag : Boolean = false\n            var i : Long = 1\n            while\
    \ (i <= interval1._1 && !flag) {\n                if (interval1._1 % i == 0) {\n\
    \                    flag = true\n                }\n                i += 1\n\
    \            }\n            if (flag)\n                return true\n         \
    \   else\n                return false\n        }\n\n        def findPrimeIntervals(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]): Boolean = {\n       \
    \     var flag : Boolean = false\n            var i : Long = 1\n            while\
    \ (i <= interval1._1 && !flag) {\n                if (interval1._1 % i == 0) {\n\
    \                    flag = true\n                }\n                i += 1\n\
    \            }\n            if (flag)\n                return true\n         \
    \   else\n                return false\n        }\n\n        def findPrimeIntervals(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]): Boolean = {\n       \
    \     var flag : Boolean = false\n            var i : Long = 1\n            while\
    \ (i <= interval1._1 && !flag) {\n                if (", '        // TODO:', " \
    \       val start = interval1._1\n        val end = interval2._1\n        if (start\
    \ < end) {\n            val s1 = interval1._2\n            val s2 = interval2._2\n\
    \            val l = s2 - s1\n            val p = (s2 - start + 1) * (s1 - end)\
    \ / 2\n            if (s1 != s2 && l == 1)\n                p += (s2 - start +\
    \ 1) * (s1 + end) / 2\n            if (p % 2 == 0) \"YES\" else \"NO\"\n     \
    \       else \"NO\"\n        } else {\n            val s1 = interval1._2\n   \
    \         val s2 = interval2._2\n            val l = s1 - s2\n            val\
    \ p = (s1 + end - start) * (s1 - end) / 2\n            if (s1 != s2 && l == 1)\n\
    \                p += (s1 + end - start) * (s2 + end) / 2\n            if (p %\
    \ 2 == 0) \"YES\" else \"NO\"\n            else \"NO\"\n        }", "        if\
    \ (interval1._1 <  interval2._1)\n            return \"NO\"\n        if (interval1._1\
    \ == interval2._1 && interval1._2 >= interval2._2)\n            return \"NO\"\n\
    \        if (interval1._1 == interval2._1 && interval1._2 <= interval2._2)\n \
    \           return \"YES\"\n        val length = interval1._2 - interval1._1 +\
    \ interval2._2 - interval2._1;\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        val primes = collection.mutable.MutableList[Boolean]()\n\
    \        while (i < length && j < length) {\n            if (interval1._1 + i\
    \ < interval2._1 && interval1._1 + j < interval2._2)\n                if (interval1._2\
    \ + i < interval2._1 && interval1._2 + j < interval2._2)\n                   \
    \ primes += false\n                else\n                    primes += true\n\
    \            else\n                if (interval1._1 + i < interval2._1 && interval1._1\
    \ + j >= interval2._2)\n                    primes ++= false\n               \
    \ else if (interval1._1 + i >= interval2._1 && interval1._1 + j < interval2._2)\n\
    \                    primes += false\n                else\n                 \
    \   primes += true\n            i += 1\n            j += 1\n        }\n      \
    \  var count = 0\n        primes.foreach(x => {\n            if (x)\n        \
    \        count += 1\n        })\n        if (count < 2)\n            return \"\
    NO\"\n        if (count == 2)\n            return \"YES\"", "        val start1\
    \ = interval1._1\n        val end1 = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        val startRange = new Range(start1, end1)\n\
    \        val endRange = new Range(start2, end2)\n        val intersectionRange\
    \ = startRange.intersect(endRange)\n        if (intersectionRange == (start1,\
    \ end1)) \"YES\" else \"NO\"", "        var x = 0\n        var y = 0\n       \
    \ val interval1_start_end = interval1._1.toLong <= interval1._2.toLong\n     \
    \   val interval2_start_end = interval2._1.toLong <= interval2._2.toLong\n   \
    \     if(interval1_start_end && interval2_start_end){\n            x = interval1._1.toLong\n\
    \            y = interval1._2.toLong\n        }\n        if(x < y){\n        \
    \    return \"NO\"\n        }\n        if(y < x){\n            return \"NO\"\n\
    \        }\n        if(x != y){\n            var x_end = x\n            var y_end\
    \ = y\n            while(y_end <= x_end){\n                val check_interval\
    \ = (x_end, y_end).toLong\n                if(check_interval %2 != 0){\n     \
    \               return \"NO\"\n                }\n                x_end += 1\n\
    \                y_end += 1\n            }\n        }\n        if(x == y){\n \
    \           return \"NO\"\n        }\n        if(x != y){\n            var x_end\
    \ = x\n            var y_end = y\n            while(x_end <= y_end){\n       \
    \         val check_interval = (x_end, y_end).toLong\n                if(check_interval\
    \ %2 != 0){\n                    return \"NO\"\n                }\n          \
    \      x_end += 1\n                y_end += 1\n            }\n        }\n    \
    \    return \"YES\"", "        val s1 = interval1._1\n        val s2 = interval1._2\n\
    \        val s3 = interval2._1\n        val s4 = interval2._2\n        if (s1\
    \ < s2 && s2 < s3) return \"YES\"\n        if (s1 > s2 && s2 > s3) return \"NO\"\
    \n        if (s1 > s3 && s3 < s4) return \"YES\"\n        if (s2 < s3 && s3 <\
    \ s4) return \"NO\"\n        if (s1 < s2 && s2 > s3) return \"NO\"\n        if\
    \ (s1 < s3 && s3 > s4) return \"YES\"\n        if (s2 < s3 && s3 < s4) return\
    \ \"NO\"", "        val a1 = interval1._1\n        val a2 = interval1._2\n   \
    \     val b1 = interval2._1\n        val b2 = interval2._2\n        val a1_prime\
    \ = math.gcd(a1, b1)\n        val a2_prime = math.gcd(a2, b2)\n        val min1\
    \ = math.min(a1, b1)\n        val max1 = math.max(a1, b1)\n        val min2 =\
    \ math.min(a2, b2)\n        val max2 = math.max(a2, b2)\n        val result =\
    \ \"NO\"\n        if ((a1_prime * a2_prime) > 0) {\n            if (math.gcd(a1,\
    \ b1) > math.gcd(a2, b2)) result = \"YES\"\n            else result = \"NO\"\n\
    \        }\n        return result", "        val start1 = interval1._1\n     \
    \   val end1 = interval1._2\n        val start2 = interval2._1\n        val end2\
    \ = interval2._2\n        val startMin = start1.min(start2)\n        val endMin\
    \ = end1.min(end2)\n        val startMax = start1.max(start2)\n        val endMax\
    \ = end1.max(end2)\n        if (startMin == endMin && startMax == endMax)\n  \
    \          \"NO\"\n        else if (startMin == endMin)\n            \"NO\"\n\
    \        else if (startMax == endMax)\n            \"YES\"\n        else if (startMin\
    \ >= start2 && startMax <= end2)\n            \"NO\"\n        else\n         \
    \   \"YES\"", "        val interval1Start = interval1._1\n        val interval1End\
    \ = interval1._2\n        val interval2Start = interval2._1\n        val interval2End\
    \ = interval2._2\n\n        def isPrime(number:Long) : Boolean = {\n         \
    \   for {\n                i <- 2 to math.ceil(math.sqrt(number))\n          \
    \      if number % i == 0\n            } yield {\n                false\n    \
    \        }\n            true\n        }\n        def isNotPrime(number:Long) :\
    \ Boolean = {\n            for {\n                i <- 2 to math.ceil(math.sqrt(number))\n\
    \                if number % i != 0\n            } yield {\n                true\n\
    \            }\n            false\n        }\n\n        def isInside(number:Long)\
    \ : Boolean = {\n            interval2Start <= number && number <= interval2End\n\
    \        }\n        def isNotInside(number:Long) : Boolean = {\n            interval1Start\
    \ <= number && number <= interval1End\n        }\n\n        val intersectionCount\
    \ = interval1End - interval1Start + interval2End - interval2Start + 1\n      \
    \  if ((intersectionCount % 2 == 0) && (isPrime(intersectionCount) == false))\n\
    \            return \"NO\"\n        else if(isNotPrime(intersectionCount) == false)\n\
    \            return \"YES\"\n        else if (isInside(interval1Start) && isInside(interval1End))\n\
    \            if (isNotInside(interval2Start) && isNotInside(interval2End))\n \
    \               if (isPrime(interval1Start + interval1End))\n                \
    \    if (isPrime(interval2Start + interval2End))\n                        if (interval1Start\
    \ <= interval2Start && interval1End <= interval2End)\n                       \
    \     return \"YES\"\n                        return \"NO\"\n            return\
    \ \"NO\"\n        else \n            return \"NO\"", "        def isPrime(n :\
    \ Long) : Boolean = {\n            var result = true\n            for{\n     \
    \           i <- 2 to (math.sqrt(n).toLong + 1)\n                if(n % i == 0)\n\
    \                    result = false\n            }\n            result\n     \
    \   }\n        val len = interval1._1.toLong - interval1._2.toLong\n        if(len\
    \ == 0) \"NO\" else \"YES\"", "        val start = interval1._1\n        val end\
    \ = interval2._1\n        val len1 = interval1._2\n        val len2 = interval2._2\n\
    \        val len1ToEnd = len1 - end\n        val len2ToEnd = len2 - end\n    \
    \    if(len1ToEnd >= len2ToEnd) return \"NO\"\n        if(len1ToEnd <= 0) return\
    \ \"NO\"\n        if(len1ToEnd == 0) return \"NO\"\n        if(len1ToEnd % 2 ==\
    \ 0) return \"NO\"\n        if(len2ToEnd % 2 == 0) return \"NO\"\n        if(len1ToEnd\
    \ > 0 && !(len1ToEnd % 2 == 0 && len2ToEnd % 2 == 0)){\n            val startPrime\
    \ = math.ceil(math.sqrt((start)))\n            val endPrime = math.ceil(math.sqrt((end)))\n\
    \            val startPrimeEndPrime = math.ceil(math.sqrt((startPrime) * (endPrime)))\n\
    \            val result = if(startPrime > endPrime)\n                math.floor(startPrimeEndPrime\
    \ / startPrime) * (endPrime + startPrimeEndPrime / endPrime)\n            else\n\
    \                math.floor(startPrimeEndPrime / endPrime) * (startPrime + startPrimeEndPrime\
    \ / startPrime)\n            if(result >= len1ToEnd && result <= len2ToEnd) \n\
    \                \"YES\"\n            else \"NO\"\n        }\n        else \n\
    \            \"NO\"", "        val i1 = interval1._1\n        val i2 = interval1._2\n\
    \        val j1 = interval2._1\n        val j2 = interval2._2\n        if (i1\
    \ < j2) (if (i2 < j1) \"YES\" else \"NO\") else \"NO\"", "        val a  = interval1._1\n\
    \        val b  = interval1._2\n        val c = interval2._1\n        val d =\
    \ interval2._2\n        if((a > d) || (b > c)) return \"NO\"\n        if((a <\
    \ c) || (b < d)) return \"NO\"\n        val m = (a + b + c + d) / 2\n        if(m\
    \ == (a+b+c+d)) return \"YES\"\n        val m1 = m - 1\n        val m2 = m1 +\
    \ 1\n        val l1 = interval1._1 - a1\n        val l2 = interval2._1 - a2\n\
    \        if(m1%l1 == 0) intersection(m1, m2) else intersection(m2, m1)", "   \
    \     val length = interval1._2 - interval1._1\n        val length2 = interval2._2\
    \ - interval2._1\n        val intersect = length * length2\n        if(length\
    \ * length2 == 0)\n          \"NO\"\n        else if(length * length2 % 1 != 0)\n\
    \          \"NO\"\n        else if(length == 0)\n          \"NO\"\n        else\
    \ if(length == 1)\n          \"YES\"\n        else if(length2 != 0)\n        \
    \  \"NO\"\n        else if(length2 == 0)\n          \"NO\"\n        else\n   \
    \       if(length < length2)\n          \"YES\"\n          else\n          \"\
    NO\"", "        val isIntersection = interval1._2 >= interval2._1 && interval1._2\
    \ <= interval2._2\n        if(isIntersection){\n            if (interval1._1 ==\
    \ interval2._1 && interval1._2 == interval2._2){\n                return \"NO\"\
    \n            }\n            else {\n                return \"YES\"\n        \
    \    }\n        }\n        else {\n            return \"NO\"\n        }", "  \
    \      val int1 = interval1._1\n        val int2 = interval2._1\n        val int3\
    \ = interval1._2\n        val int4 = interval2._2\n        val int5 = (int3 -\
    \ int1).abs * (int4 - int2).abs\n        if (int5 == 0) \"NO\" else \"YES\"",
  "        val start = interval1._1\n        val end = interval1._2\n        val start2\
    \ = interval2._1\n        val end2 = interval2._2\n        if(start < end){\n\
    \            if(start < start2){\n                if(end2 < end){\n          \
    \          if(start % end2 == 0){\n                        if(end2 % end == 0){\n\
    \                            if(start % end == 0){\n                         \
    \       if(end % start2 == 0){\n                                    if(start2\
    \ % start2 == 0){\n                                        return \"YES\"\n  \
    \                                  }\n                                }\n    \
    \                        }\n                        }\n                    }\n\
    \                }\n            }\n        }\n        return \"NO\"", "      \
    \  val start = interval1._1;\n        val end = interval1._2;\n        val start2\
    \ = interval2._1;\n        val end2 = interval2._2;\n        // check the length\
    \ of the intersection.\n        if(end-start==end2-start2){\n            val i1\
    \ = (start.toLong*start+end.toLong*end).toInt % 2l\n            val i2 = (start2.toLong*start2+end2.toLong*end2).toInt\
    \ % 2l\n            if(i1 % 2 == 0 & i2 % 2 == 0){\n                return \"\
    YES\"\n            }\n        }\n        \"NO\"", "        // The length of intersection\
    \ of two intervals is the maximum of their length\n        val l = Math.max(interval1._1,\
    \ interval2._1)\n        val h = Math.max(interval1._2, interval2._2)\n      \
    \  // The length of intersection of two intervals is the length of their intersection\n\
    \        // We need to know how many integers intersect each interval in order\
    \ to determine if its length is prime or not\n        val count = findIntersection(l,h,interval1,interval2)\n\
    \        // if the intersected length is prime then return \"YES\"\n        if(count*2\
    \ == h) return \"YES\"\n        // if the intersected length is not prime then\
    \ return \"NO\"\n        return \"NO\"", "        val start = interval1._1\n \
    \       val end = interval2._1\n        val startPrime = prime(start)\n      \
    \  val endPrime = prime(end)\n        if(startPrime == endPrime) {\n         \
    \   if(prime(interval1._2) == prime(interval2._2)) {\n                return \"\
    YES\"\n            }\n        }\n        if(startPrime != endPrime) {\n      \
    \      return \"NO\"\n        }\n        val intersection = if (start < end) {\n\
    \            val temp = start\n            start = end\n            end = temp\n\
    \        }\n        val length = end - start\n        if(length == 1) {\n    \
    \        return \"YES\"\n        }\n        if (length == 2) {\n            if\
    \ (prime(startPrime) == prime(endPrime)) {\n                if (start == end)\
    \ {\n                    if (prime(interval1._1) != prime(interval2._1)) {\n \
    \                       return \"NO\"\n                    }\n               \
    \ }\n                if (prime(startPrime) != prime(endPrime)) {\n           \
    \         return \"NO\"\n                }\n            }\n        }\n       \
    \ return \"NO\"", "        val interval1start = interval1._1.toLong\n        val\
    \ interval1end = interval1._2.toLong\n        val interval2start = interval2._1.toLong\n\
    \        val interval2end = interval2._2.toLong\n        val start = math.min(interval1start,\
    \ interval2start)\n        val end = math.max(interval1end, interval2end)\n  \
    \      val len = math.max(end - start, 1)\n        if(len == 0) \"NO\"\n     \
    \   else {\n            // if start < end, there is no intersection\n        \
    \    if(interval1start < interval1end && interval2start < interval2end) {\n  \
    \              return \"NO\"\n            }\n            // if start >= end, there\
    \ is no intersection\n            if(interval1start >= interval1end && interval2start\
    \ >= interval2end) {\n                return \"NO\"\n            }\n         \
    \   // if start < end, there is an intersection\n            if(interval1start\
    \ < interval1end && interval2start >= interval2end) {\n                val leftIntersect\
    \ = interval1end - interval1start\n                val rightIntersect = end -\
    \ interval2end\n                if(leftIntersect <= rightIntersect) {\n      \
    \              return \"YES\"\n                } else {\n                    return\
    \ \"NO\"\n                }\n            }\n            // if start >= end, there\
    \ is an intersection\n            if(interval1start >= interval1end && interval2start\
    \ < interval2end) {\n                val leftIntersect = interval1end - interval1start\n\
    \                val rightIntersect = end - interval2start\n                if(leftIntersect\
    \ <= rightIntersect) {\n                    return \"YES\"\n                }\
    \ else {\n                    return \"NO\"\n                }\n            }\n\
    \            // if start < end, there is an intersection\n            if(interval1start\
    \ < interval1end && interval2start < interval2end) {\n                val leftIntersect\
    \ = interval1end - interval1start\n                val rightIntersect = end -\
    \ interval2start\n                if(leftIntersect <= rightIntersect) {\n    \
    \                return \"YES\"\n                } else {\n                  \
    \  return \"NO\"\n                }\n            }\n            // if start >=\
    \ end, there is an intersection\n            if(interval1start >= interval1end\
    \ && interval2start >= interval2end) {\n                val leftIntersect = interval1end\
    \ - interval1start\n                val rightIntersect = end - interval2start\n\
    \                if(leftIntersect <= rightIntersect) {\n                    return\
    \ \"YES\"\n                } else {\n                    return \"NO\"\n     \
    \           }\n            }\n        }", "        // Solution 1 -- check if interval1\
    \ and interval2 intersect\n        // Check whether they intersect\n        if\
    \ (interval1._2 <= interval2._1 && interval2._2 <= interval1._1) \"NO\" else \"\
    YES\"\n\n        // Solution 2 -- compute length and check whether it is prime\n\
    \        // Compute length\n        def computeLength(interval1: Tuple2[Long,\
    \ Long], interval2: Tuple2[Long, Long]): Long = {\n            val length = math.min(interval2._1\
    \ - interval1._1, interval1._2 - interval2._2)\n            if (length == 0) 0\
    \ else (length / 2)\n        }\n        def computeLengthOfIntersection(interval1:\
    \ Tuple2[Long, Long], interval2: Tuple2[Long, Long]): Long = {\n            val\
    \ length = computeLength(interval1, interval2)\n            if (length == 0) 0\
    \ else {\n                val startInterval = math.min(interval1._1, interval2._1)\n\
    \                val endInterval = math.max(interval1._2, interval2._2)\n    \
    \            computeLengthOfIntersection(Tuple2(startInterval, endInterval), length)\n\
    \            }\n        }\n\n        // Check for both cases (intersection or\
    \ no intersection)\n        if (computeLengthOfIntersection(interval1, interval2)\
    \ == 0) \"NO\"\n        else (if (computeLength(interval1, interval2) == 1) \"\
    YES\" else \"NO\")", "        val start = interval1._1\n        val end = interval1._2\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        if\
    \ (end2 < start || start2 < end) throw new ArithmeticException(s\"$start $end\
    \ $start2 $end2\")\n\n        val intervalsIntersected = mutable.Set[(Long, Long)]()\n\
    \        for (i <- start..end) {\n            val currentInterval = (i, i)\n \
    \           val currentInterval2 = (i+1, i+1)\n            if (currentInterval\
    \ !in intervalsIntersected && currentInterval2 !in intervalsIntersected) {\n \
    \               intervalsIntersected += currentInterval\n                intervalsIntersected\
    \ += currentInterval2\n            }\n        }\n        if (intervalsIntersected.isEmpty)\
    \ throw new ArithmeticException(\"intersection of two intervals does not exists\"\
    )\n        val intersectionLen = intervalsIntersected.size\n        val isPrime\
    \ = intersectionLen % 2 == 0 // check if intersectionLen, divided by 2, is a whole\
    \ number\n        if (isPrime) intervalsIntersected.size else \"NO\"", "     \
    \   // write your code here\n        val start1 = interval1._1\n        val end1\
    \ = interval1._2\n        val start2 = interval2._1\n        val end2 = interval2._2\n\
    \        if(start2 < end1 && start1 < end2)\n        {\n            val interval\
    \ = start2 :+ (end2)\n            val length1 = interval.length\n            val\
    \ length2 = interval2.length\n            val length = if (length1 < length2)\
    \ length1 else length2\n            val length = math.min(length, length1-length2)\n\
    \            if(length >= 2L)\n            {\n                val list2 = interval2.toList\n\
    \                val list1 = interval1.toList\n                val set1 = list1.filter(!_\
    \ == end1).map(_.toInt)\n                val set2 = list2.filter(!_ == end2).map(_.toInt)\n\
    \                val set3 = list2.filter(!_ == end2).map(_.toInt)\n          \
    \      val set4 = list1.filter(!_ == end1).map(_.toInt)\n                val set5\
    \ = list2.filter(!_ == end2).map(_.toInt)\n                val set6 = list1.filter(!_\
    \ == end1).map(_.toInt)\n                if(set1.intersect(set2).length == set1.length)\n\
    \                {\n                    val list4 = interval1.toList\n       \
    \             val list3 = interval2.toList\n                    val set2 = list2.filter(!_\
    \ == end2).map(_.toInt)\n                    val set3 = list3.filter(!_ == end3).map(_.toInt)\n\
    \                    val set4 = list3.filter(!_ == end3).map(_.toInt)\n      \
    \              val set5 = list4.filter(!_ == end4).map(_.toInt)\n            \
    \        val set6 = list4.filter(!_ == end4).map(_.toInt)\n                  \
    \  if(set2.intersect(set3).length == set2.length)\n                    {\n   \
    \                     if(set1.intersect(set4).length == set1.length)\n       \
    \                 {\n                            val list2 = interval2.toList\n\
    \                            val list3 = interval1.toList\n                  \
    \          val set1 = list1.filter(!_ == end1).map(_.toInt)\n                \
    \            val set2 = list2.filter(!_ == end2).map(_.toInt)\n              \
    \              val set3 = list3.filter(!_ == end3).map(_.toInt)\n            \
    \                val set4 = list3.filter(!_ == end3).map(_.toInt)\n          \
    \                  val set5 = list4.filter(!_ == end4).map(_.toInt)\n        \
    \                    val set6 = list4.filter(!", "        val interval1start =\
    \ interval1._1\n        val interval1end = interval1._2\n        val interval2start\
    \ = interval2._1\n        val interval2end = interval2._2\n\n        val intersectionStart\
    \ = interval1start < interval2start ? interval1start : interval2start\n      \
    \  val intersectionEnd = interval1end < interval2end ? interval1end : interval2end\n\
    \        val intersectionLength = intersectionEnd - intersectionStart\n\n    \
    \    if (intersectionLength > 0){\n            var primeNumber = 0\n         \
    \   val primeNumbers = mutable.ListBuffer[Long]()\n\n            for(i <- 0 to\
    \ intersectionLength){\n                primeNumber += math.pow(interval1start\
    \ - intersectionStart + i, 2)\n                primeNumbers += primeNumber\n \
    \           }\n\n            primeNumber /= 2\n            if(primeNumbers.contains(primeNumber))\
    \ {\n                return \"YES\"\n            } else {\n                return\
    \ \"NO\"\n            }\n        }\n        else{\n            return \"NO\"\n\
    \        }", "        val start = interval1._1\n        val end = interval1._2\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        val\
    \ interval1 = (start, end)\n        val interval2 = (start2, end2)\n        val\
    \ result1 = interval1.intersect(interval2)\n        val result2 = result1.length\n\
    \        if (result2 == 0) \"NO\"\n        else result2.toString.isPrime.toString\
    \ + \"YES\"", "        val a = interval1._1\n        val b = interval1._2\n  \
    \      val c = interval2._1\n        val d = interval2._2\n        val x = (c-a).abs\
    \ * (d-b).abs\n        val y = (d-a).abs * (c-b).abs\n        val length = Math.max(x,\
    \ y)\n        if (length == 0) \"NO\" else \"YES\"", "        def isPrime(n: Long):\
    \ Boolean = \n            if (n % 2 == 0) \n                false\n          \
    \  else \n                (n: Int => n >= 2) && (n) filter { \n              \
    \      x => x % 2 == 0 \n                } forall { \n                    x =>\
    \ x % n == 0 \n                }\n\n        // If the two intervals do not intersect\
    \ or are same,\n        // return the empty string.\n        if (interval1._1\
    \ < interval1._2 && interval2._1 < interval2._2)\n            return \"\"\n  \
    \      \n        // If the two intervals do intersect and they are same,\n   \
    \     // count the number of overlapping intervals.\n        val numOverlap =\
    \ \n            (interval1._2, interval2._2) map { \n                (x, y) =>\
    \ if (x == y) 0 else 1 \n            }.reduce((x, y) => x + y)\n\n        val\
    \ numOverlapIsPrime = \n            if (numOverlap == 0) \n                \"\
    NO\" \n            else if (isPrime(numOverlap)) \n                \"YES\"\n \
    \           else \n                \"NO\"\n        \n        numOverlapIsPrime",
  "        // TODO: define your solution here\n        // ...\n        val length\
    \ = interval1._2 >= interval2._2 ? interval1._2 - interval2._2 : interval2._2\
    \ - interval1._2\n        if(length == 2) \"YES\" else \"NO\"", "        var firstInterval\
    \ = interval1._1\n        var secondInterval = interval2._1\n        var firstIntervalEnd\
    \ = interval1._2\n        var secondIntervalEnd = interval2._2\n        var isPrime\
    \ = true\n        if (firstIntervalEnd < secondIntervalEnd || firstIntervalEnd\
    \ < secondInterval) {\n            isPrime = false\n        } else {\n       \
    \     if (firstIntervalStart > secondIntervalEnd || firstIntervalStart < secondIntervalStart)\
    \ {\n                isPrime = false\n            } else {\n                val\
    \ temp1 = firstInterval\n                val temp2 = secondInterval\n        \
    \        val temp3 = firstIntervalEnd\n                val temp4 = secondIntervalEnd\n\
    \                while (temp1 > temp3 && temp2 > temp4) {\n                  \
    \  if (temp2 <= temp1)\n                        break\n                    if\
    \ (temp3 <= temp4)\n                        break\n                    val temp5\
    \ = temp1\n                    val temp6 = temp2\n                    if (temp5\
    \ > temp6) {\n                        val temp = temp5\n                     \
    \   temp5 = temp6\n                        temp6 = temp\n                    }\n\
    \                    val temp7 = temp3\n                    val temp8 = temp4\n\
    \                    if (temp7 > temp8) {\n                        val temp =\
    \ temp7\n                        temp7 = temp8\n                        temp8\
    \ = temp\n                    }\n                    if (temp5 == temp7) {\n \
    \                       val temp9 = temp5\n                        temp5 = temp9\n\
    \                    }\n                    if (temp6 == temp8) {\n          \
    \              val temp10 = temp6\n                        temp6 = temp10\n  \
    \                  }\n                    if (temp5 == temp6 && temp5 == temp8)\
    \ {\n                        val temp11 = temp5\n                        temp5\
    \ = temp11\n                    }\n                    if (temp6 == temp7 && temp6\
    \ == temp8) {\n                        val temp12 = temp6\n                  \
    \      temp6 = temp12\n                    }\n                    if (temp5 ==\
    \ temp7) {\n                        val temp13 = temp5\n                     \
    \   temp5 = temp13\n                    }\n                    if (temp6 == temp8)\
    \ {\n                        val temp14 = temp6\n                        temp6\
    \ = temp14\n                    }\n                    if (temp5 == temp6 && temp6\
    \ == temp7 && temp6 == temp8) {\n                        val temp15 = temp5\n\
    \                        temp5 = temp15\n                    }\n             \
    \       if (temp7 == temp8 && temp7 == temp9) {\n                        val temp16\
    \ = temp7\n                        temp7 = temp16\n                    }\n   \
    \                 if (temp8 == temp9) {\n                        val temp17 =\
    \ temp8\n                        temp8 = temp17\n                    }\n     \
    \               if (temp5 == temp11) {\n                        val temp18 = temp5\n\
    \                        temp5 = temp18\n                    }\n             \
    \       if (temp6 == temp12) {\n                        val temp19 = temp", " \
    \       // Write your code here\n        val a1 = interval1._1\n        val b1\
    \ = interval1._2\n        val a2 = interval2._1\n        val b2 = interval2._2\n\
    \        val min = (a1 < b2) ? a1 : b2\n        val max = (a1 > b2) ? a1 : b2\n\
    \        val length = max - min\n        if (length < 0) \"NO\" else \"YES\"",
  "        var i = 0\n        while(i < interval1._1 && !(interval1._2 <= interval2._1\
    \ && interval1._2 >= interval2._2)) {\n            i += 1\n        }\n       \
    \ if(i != interval1._1 && !(interval1._2 <= interval2._1 && interval1._2 >= interval2._2))\
    \ {\n            return \"NO\"\n        } else {\n            val j = 0\n    \
    \        while(j < interval2._1 && !(interval2._2 <= interval1._1 && interval2._2\
    \ >= interval1._2)) {\n                j += 1\n            }\n            if(j\
    \ != interval2._1 && !(interval2._2 <= interval1._1 && interval2._2 >= interval1._2))\
    \ {\n                return \"NO\"\n            } else {\n                if(interval1._2\
    \ > interval2._1 && interval2._2 > interval1._2) {\n                    return\
    \ \"NO\"\n                }\n                if(interval1._2 < interval2._1 &&\
    \ interval2._2 < interval1._2) {\n                    return \"NO\"\n        \
    \        }\n                var i = interval1._1\n                var j = interval2._1\n\
    \                while(i < interval1._2 || j > interval2._2) {\n             \
    \       if(i < interval1._2 && j < interval2._2) {\n                        if(i\
    \ == interval1._2 && j == interval2._2) {\n                            return\
    \ \"YES\"\n                        }\n                        val z = interval1._2-i\n\
    \                        val w = interval2._2-j\n                        if(z\
    \ == 0 || w == 0) {\n                            return \"NO\"\n             \
    \           }\n                        if(z*w == 0) {\n                      \
    \      i +=1\n                            j +=1\n                        } else\
    \ {\n                            return \"NO\"\n                        }\n  \
    \                  } else {\n                        if(i < interval1._2 && j\
    \ >= interval2._2) {\n                            i +=1\n                    \
    \    } else {\n                            j +=1\n                        }\n\
    \                    }\n                }\n            }\n        }", "      \
    \  val start = interval1._1\n        val end = interval1._2\n        val start2\
    \ = interval2._1\n        val end2 = interval2._2\n\n        var intersect = Interval.empty\n\
    \        if(start < end2 && start < start2) { intersect = interval1\n        }\
    \ else if (start < start2 && start > end2) { intersect = interval2\n        }\
    \ else if (end < start2 && end < end2) { intersect = interval1\n        } else\
    \ if (end > start2 && end > end2) { intersect = interval2\n        } else if (start\
    \ > end2 && start > start2) { intersect = interval1\n        } else if (end >\
    \ end2 && end > start2) { intersect = interval2\n        } else {\n          \
    \  intersect = interval2\n        }\n        intersect.length match {\n      \
    \      case 2 if (intersect.isPrime)   => \"YES\"\n            case 1 if (intersect.isPrime)\
    \  => \"NO\"\n            case _ => \"\"\n        }", "        var length : Long\
    \ = 0\n        var start : Long = 0\n        var end : Long = 0\n        var intersection\
    \ : Long = 0\n\n        if (interval1._1 <= interval2._1 && interval2._1 <= interval1._1)\
    \ {\n            start = Math.max(interval1._1, interval2._1)\n            end\
    \ = Math.min(interval1._2, interval2._2)\n            length = end - start\n \
    \       }\n        else if (interval1._1 <= interval2._1 && interval2._1 > interval1._1)\
    \ {\n            start = Math.max(interval1._1, interval2._1)\n            end\
    \ = Math.min(interval1._1, interval2._1)\n            length = end - start\n \
    \       }\n        else if (interval1._1 > interval2._1 && interval2._1 <= interval1._1)\
    \ {\n            start = Math.max(interval1._1, interval2._1)\n            end\
    \ = Math.min(interval1._1, interval2._1)\n            length = end - start\n \
    \       }\n        else if (interval1._1 <= interval2._1 && interval2._1 > interval1._1)\
    \ {\n            start = Math.max(interval1._1, interval2._1)\n            end\
    \ = Math.min(interval1._1, interval2._1)\n            length = end - start\n \
    \       }\n        else {\n            start = Math.max(interval1._1, interval2._1)\n\
    \            end = Math.min(interval1._1, interval2._1)\n            length =\
    \ end - start\n        }\n\n        intersection = length / 2\n        if (length\
    \ != 0) {\n            if ((length == 2 && start % 2 == 0) || (length == 4 &&\
    \ start % 2 == 1) || (length == 3 && start % 2 == 2) || (length == 5)) {\n   \
    \             if ((length == 2 && end % 2 == 0) || (length == 4 && end % 2 ==\
    \ 1) || (length == 3 && end % 2 == 2) || (length == 5)) {\n                  \
    \  if ((length == 2 && start % 2 == 0 && end % 2 == 0) || (length == 4 && start\
    \ % 2 == 1 && end % 2 == 1) || (length == 3 && start % 2 == 2 && end % 2 == 2)\
    \ || (length == 5)) {\n                        if ((length == 2 && start % 2 ==\
    \ 0 && end % 2 == 0) || (length == 4 && start % 2 == 1 && end % 2 == 1) || (length\
    \ == 3 && start % 2 == 2 && end % 2 == 2) || (length == 5)) {\n              \
    \              if ((length == 2 && start % 2 == 0 && end % 2 == 0) || (length\
    \ == 4 && start % 2 == 1 && end % 2 == 1) || (length == 3 && start % 2 == 2 &&\
    \ end % 2 == 2) || (length == 5)) {\n                                if ((length\
    \ == 2 && start % 2 == 0 && end % 2 == 0) || (length == 4 && start % 2 == 1 &&\
    \ end % 2 == 1) || (length == 3 && start % 2 == 2 && end % 2 == 2) || (length\
    \ == 5)) {\n                                    if (end % 2 == 0) {\n        \
    \                                if ((length == 2 && start ", "        val interval1End\
    \ = interval1._1\n        val interval1Start = interval1._2\n        val interval2End\
    \ = interval2._1\n        val interval2Start = interval2._2\n        val interval1EndPlus1\
    \ = interval1End + 1\n        val interval2StartPlus1 = interval2Start + 1\n \
    \       val common = interval1Start < interval2End && interval2Start < interval1End\n\
    \        if (common) interval1EndPlus1 > interval2StartPlus1 else \"NO\" else\
    \ \"NO\"", "        val interval1Start = interval1._1\n        val interval1End\
    \ = interval1._2\n        val interval2Start = interval2._1\n        val interval2End\
    \ = interval2._2\n        val resultIntersection = mutable.ListBuffer[(Long, Long)]()\n\
    \        val resultLength = mutable.ListBuffer[Int]()\n        // 1. Find common\
    \ parts of interval\n        resultIntersection ++= interval1.filter{case(a, b)\
    \ => a <= b}.filter{case(a, b) => a >= b}\n        resultIntersection ++= interval2.filter{case(a,\
    \ b) => a <= b}.filter{case(a, b) => a >= b}\n        // 2. Find length of common\
    \ part\n        resultLength ++= resultIntersection.length\n        // 3. Find\
    \ intervals whose start is less than the end\n        resultIntersection.filter{case(a,\
    \ b) => a < b}.foreach{case(a, b) => resultLength += 1}\n        // 4. Find intervals\
    \ whose end is greater than the start\n        resultIntersection.filter{case(a,\
    \ b) => a > b}.foreach{case(a, b) => resultLength += 1}\n        // 5. Find intervals\
    \ whose start is greater than the end\n        resultIntersection.filter{case(a,\
    \ b) => a > b}.foreach{case(a, b) => resultLength += 1}\n        // 6. Find intervals\
    \ whose end is less than the start\n        resultIntersection.filter{case(a,\
    \ b) => a < b}.foreach{case(a, b) => resultLength += 1}\n        // 7. Find intervals\
    \ whose start is equal to the end\n        resultIntersection.filter{case(a, b)\
    \ => a == b}.foreach{case(a, b) => resultLength += 1}\n        // 8. Find intervals\
    \ whose start is less than the end and end is greater than the start\n       \
    \ resultIntersection.filter{case(a, b) => a < b && b > a}.foreach{case(a, b) =>\
    \ resultLength += 1}\n        // 9. Find intervals whose start is greater than\
    \ the end and end is less than the start\n        resultIntersection.filter{case(a,\
    \ b) => a > b && b < a}.foreach{case(a, b) => resultLength += 1}\n        // 10.\
    \ Find intervals whose start is equal to the end and end is greater than the start\n\
    \        resultIntersection.filter{case(a, b) => a == b && b > a}.foreach{case(a,\
    \ b) => resultLength += 1}\n        // 11. Find intervals whose start is less\
    \ than the end and end is less than the start\n        resultIntersection.filter{case(a,\
    \ b) => a < b && b < a}.foreach{case(a, b) => resultLength += 1}\n        // 12.\
    \ Find intervals whose start is greater than the end and end is greater than the\
    \ start\n        resultIntersection.filter", "        def isPrime(n : Long) :\
    \ Boolean = {\n            if (n == 1 || n == 2) return true\n            if (n\
    \ % 2 == 0 || n == 3) return false\n            val root = math.sqrtDouble(n)\n\
    \            for (i <- 3 to root) {\n                if (n % i == 0 || n % (i\
    \ + 1) == 0) return false\n            }\n            return true\n        }\n\
    \        val r1 = interval1._2\n        val r2 = interval2._2\n        val s1\
    \ = interval1._1\n        val s2 = interval2._1\n        if (s1 < s2) r1 = r1\
    \ + 1\n        if (s1 > s2) r2 = r2 + 1\n        if (r1 > r2) \"NO\"\n       \
    \ else if (r1 == r2) \"YES\"\n        else isPrime(r1 - r2) ? \"YES\" : \"NO\"",
  "        val start = Math.max(interval1._1, interval2._1)\n        val end = Math.min(interval1._2,\
    \ interval2._2)\n        val len: Int = end - start\n        if (len == 0 || len\
    \ == 1)\n          return \"NO\"\n        var foundPrime = true\n        for (i:\
    \ Int <- 0 until len) {\n          val nextStart = start + i\n          val nextEnd\
    \ = nextStart + i\n          if (nextStart < end && nextEnd < end && !isPrime(nextEnd)\
    \ && !isPrime(nextStart)) {\n            foundPrime = false\n          }\n   \
    \     }\n        if (foundPrime)\n          return \"YES\"\n        else\n   \
    \       return \"NO\"", "        if (interval1 == null || interval2 == null)\n\
    \            return \"NO\"\n        if (interval1._2 < interval2._1)\n       \
    \     return \"NO\"\n        if (interval1._2 < interval2._2)\n            return\
    \ \"NO\"\n        val li = interval1._1 - interval2._1, ri = interval2._1 - interval1._1\n\
    \        if (li > 0 && ri > 0) {\n            if (li == 2 && ri == 2) {\n    \
    \            if (interval1._1 == interval2._1 && interval1._2 == interval2._2)\n\
    \                    return \"YES\"\n            }\n            if (li == 2 &&\
    \ ri != 2 && li % 2 == 0 && ri % 2 != 0) {\n                if (interval1._1 ==\
    \ interval2._1 && interval1._2 == interval2._2)\n                    return \"\
    YES\"\n            }\n            if (li != 2 && ri == 2 && li % 2 != 0 && ri\
    \ % 2 == 0) {\n                if (interval1._1 == interval2._1 && interval1._2\
    \ == interval2._2)\n                    return \"YES\"\n            }\n      \
    \      if (li != 2 && ri != 2 && li % 2 == 0 && ri % 2 == 0) {\n             \
    \   if (interval1._1 == interval2._1 && interval1._2 == interval2._2)\n      \
    \              return \"YES\"\n            }\n        }\n        return \"NO\"",
  '      if(interval1._1 < interval2._1 && interval1._2 < interval2._1) "NO" else
    "YES"', "        val start = interval1._1\n        val end = interval2._1\n  \
    \      val start2 = interval1._2\n        val end2 = interval2._2\n        if\
    \ (start > end) {\n            val temp = start\n            start = end\n   \
    \         end = temp\n        }\n        if (start2 > end2) {\n            val\
    \ temp = start2\n            start2 = end2\n            end2 = temp\n        }\n\
    \        var length : Int = 0\n        for (x<-start to end) {\n            for\
    \ (y<-start2 to end2) {\n                if (x != y) {\n                    length\
    \ = length + (x * y)\n                }\n            }\n        }\n        val\
    \ isPrime = length == 2\n        if (isPrime)\n            {\n               \
    \ return \"YES\"\n            }\n        else\n            {\n               \
    \ return \"NO\"\n            }", "      val start1 = interval1._1\n      val end1\
    \ = interval1._2\n      val start2 = interval2._1\n      val end2 = interval2._2\n\
    \      val length = end1.maxBy(_) - start1.maxBy(_) + 1\n      val inter = length\
    \ / 2\n      val isPrime = length.toString match {\n        case \"1\" | \"2\"\
    \ | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" |\
    \ \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\"\
    \ | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"\
    29\" | \"30\" | \"31\" | \"32\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" |\
    \ \"38\" | \"39\" | \"40\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\"\
    \ | \"47\" | \"48\" | \"49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"\
    55\" | \"56\" | \"57\" | \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" |\
    \ \"64\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"72\"\
    \ | \"73\" | \"74\" | \"75\" | \"76\" | \"77\" | \"78\" | \"79\" | \"80\" | \"\
    81\" | \"82\" | \"83\" | \"84\" | \"85\" | \"86\" | \"87\" | \"88\" | \"89\" |\
    \ \"90\" | \"91\" | \"92\" | \"93\" | \"94\" | \"95\" | \"96\" | \"97\" | \"98\"\
    \ | \"99\" => \"YES\"\n        case \"10\" | \"11\" | \"12\" | \"13\" | \"14\"\
    \ | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" | \"20\" | \"21\" | \"22\" | \"\
    23\" | \"24\" | \"25\" | \"26\" | \"27\" | \"28\" | \"29\" | \"30\" | \"31\" |\
    \ \"32\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\" | \"38\" | \"39\" | \"40\"\
    \ | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"48\" | \"\
    49\" | \"50\" | \"51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"56\" | \"57\" |\
    \ \"58\" | \"59\" | \"60\" | \"61\" | \"62\" | \"63\" | \"64\" | \"65\" | \"66\"\
    \ | \"67\" | \"68\" | \"69\" | \"70\" | \"71\" | \"72\" | \"73\" | \"74\" | \"\
    75\" | \"76\" | \"77\" | \"78\" | \"79\" | \"80\" | \"81\" | \"82\" | \"83\" |\
    \ \"84\" | \"85\" | \"86\" | \"87\" | \"88\" | \"89\" | \"90\" | \"91\" | \"92\"\
    \ | \"93\" | \"94\" | \"95\" | \"96\" | \"97\" | \"98\" | \"99\" => \"NO\"\n \
    \       case _ => \"NO\"\n      }\n      inter.toString() match {\n        case\
    \ \"0\" => \"NO\"\n        case \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\"\
    \ | \"7\" | \"8\" | \"9\" | \"10\" | \"11\" | \"", "        def intersect_helper(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long], acc : mutable.Map[Long,\
    \ Long]) : Unit = {\n            val start = interval1._1\n            val end\
    \ = interval1._2\n            val start2 = interval2._1\n            val end2\
    \ = interval2._2\n            if(start > end2) return\n            if(start2 >\
    \ end) return\n            if(start == end2 && start2 < end) return\n        \
    \    if(start == start2 && start < end2) return\n            if(start < start2\
    \ && end < end2) return\n            val intersect = start + (end - start2)\n\
    \            val length = math.min(end, end2) - math.max(start, start2)\n    \
    \        if(length == 0) return\n            if(intersect in acc) return\n   \
    \         val new_acc = mutable.Map(intersect: Long)\n            new_acc += start\n\
    \            new_acc += end2\n            intersect_helper(interval2, interval2,\
    \ new_acc)\n            intersect_helper(interval1, interval2, new_acc)\n    \
    \    }\n        val start_acc = mutable.Map()\n        val end_acc = mutable.Map()\n\
    \        intersect_helper(interval1, interval2, start_acc)\n        intersect_helper(interval2,\
    \ interval1, end_acc)\n        if(start_acc.size != 0 && end_acc.size != 0) {\n\
    \            var result = \"\"\n            for(i <- start_acc ++ end_acc) {\n\
    \                if(result != \"\") result += \"-\"\n                result +=\
    \ i\n            }\n            if(result != \"\") result += \"-\"\n         \
    \   if(result.length == 1) {\n                val result_int = result.toInt\n\
    \                if(result_int == 1) result += \"1\"\n                if(result_int\
    \ == 2) result += \"2\"\n                if(result_int == 3) result += \"3\"\n\
    \            }\n            if(!result.isPrime) result += \"NO\"\n           \
    \ else result += \"YES\"\n            result\n        }\n        else if (!(interval1._1\
    \ < interval1._2 && interval1._2 < interval2._1 && interval2._1 < interval2._2))\
    \ \"NO\"\n        else if (!(interval1._1 <= interval1._2 && interval1._2 <= interval2._1\
    \ && interval2._1 <= interval2._2)) \"NO\"\n        else \"\"", "        val isIntersect\
    \ = interval1._2 >= interval2._1\n        if(isIntersect)\n            \"YES\"\
    \n        else\n            \"NO\"", "        val int1 = interval1._1 // left\
    \ boundary of interval1\n        val int2 = interval1._2 // right boundary of\
    \ interval1\n        val int3 = interval2._1 // left boundary of interval2\n \
    \       val int4 = interval2._2 // right boundary of interval2\n        val start1\
    \ = int1.getOrElse(0l, 0l) // left boundary of interval1\n        val start2 =\
    \ int2.getOrElse(0l, 0l) // right boundary of interval1\n        val end1 = int3.getOrElse(0l,\
    \ 0l) // left boundary of interval2\n        val end2 = int4.getOrElse(0l, 0l)\
    \ // right boundary of interval2\n        val intervalsLen1 = end1.toLong - start1.toLong\n\
    \        val intervalsLen2 = end2.toLong - start2.toLong\n        if(intervalsLen1\
    \ < 0 || intervalsLen2 < 0)\n            return \"NO\"\n        val length1 =\
    \ intervalsLen1.toInt\n        val length2 = intervalsLen2.toInt\n        val\
    \ length = length1 + length2\n        if(length1 == 0 || length2 == 0)\n     \
    \       return \"NO\"\n        if(length == 1 || length2 == 1)\n            return\
    \ \"YES\"\n        var isPrime = true\n        var count = 0\n        var isPrimeTmp\
    \ = true\n        var isPrimeTmp2 = true\n        for(i <- 1 until length){\n\
    \            val currentLength = i\n            if(count < currentLength && isPrimeTmp)\
    \ {\n                var currentPrime = true\n                var currentPrimeTmp\
    \ = true\n                val currentNum1 = i\n                val currentNum2\
    \ = i - 1\n                for(j <- 1 to currentLength){\n                   \
    \ val currentNum = currentNum1 + j\n                    val currentLen = j\n \
    \                   if(currentNum > currentLen){\n                        break\n\
    \                    }\n                    val currentNum3 = currentNum1 + currentLen\
    \ - 1\n                    val currentNum4 = currentNum1 - j\n               \
    \     if(currentNum3 == currentNum4){\n                        break\n       \
    \             }\n                    if(currentNum3 == currentNum || (j == 1 &&\
    \ ((currentNum % 2) == 0 || currentNum % 3 == 0))){\n                        break\n\
    \                    }\n                    currentPrimeTmp = false\n        \
    \            if(isPrimeTmp2){\n                        val currentNum5 = currentNum1\
    \ + currentLen\n                        val currentNum6 = currentNum1 - currentLen\n\
    \                        val currentNum7 = currentNum5 - currentLen\n        \
    \                currentPrime = (currentNum5 == currentNum6)\n               \
    \         currentPrimeTmp = (currentNum6 == currentNum7)\n", "        var isIntersecting\
    \ : Boolean = false\n\n        // get start of interval1\n        val startInterval1\
    \ = interval1._1;\n\n        // get end of interval1\n        val endInterval1\
    \ = interval1._2;\n\n        // get start of interval2\n        val startInterval2\
    \ = interval2._1;\n\n        // get end of interval2\n        val endInterval2\
    \ = interval2._2;\n\n        // check if the two intervals intersect or not\n\
    \        if (startInterval1 < endInterval1 && startInterval2 < endInterval2) {\n\
    \            isIntersecting = true\n        } else if (startInterval1 < endInterval1\
    \ && startInterval2 > endInterval2) {\n            isIntersecting = true\n   \
    \     } else if (startInterval1 < endInterval2 && startInterval2 < endInterval2)\
    \ {\n            isIntersecting = true\n        }\n\n        if (isIntersecting\
    \ == true) {\n            intersectionString := s\"The intersection of intervals\
    \ ($startInterval1, $endInterval1), ($startInterval2, $endInterval2) is ($startInterval2,\
    \ $endInterval2), which its length is $endInterval2, which is not a prime number.\"\
    \n            return intersectionString\n        } else {\n            intersectionString\
    \ := s\"The intervals don't intersect.\"\n            return intersectionString\n\
    \        }", "        // write your code here\n        val start = interval1._1\
    \ \n        val end = interval1._2\n        val start2 = interval2._1\n      \
    \  val end2 = interval2._2\n\n        val inter = if(start <= end2 && start2 <=\
    \ end) \n        intersection else \"\"\n\n        if(inter.length > 1) {\n  \
    \          inter.length == 1 && inter.head == 1 && inter.last == 1 ? \"YES\" :\
    \ \"NO\"\n        } else {\n            inter.length == 1 && inter.head == -1\
    \ && inter.last == -1 ? \"YES\" : \"NO\"\n        }", "        // O(n), n = length\
    \ of interval1 + length of interval2\n        var i = 0\n        var j = 0\n \
    \       var intersection = \"\"\n\n        // O(n), n = length of interval1 +\
    \ length of interval2\n        while (i < interval1._1 && j < interval2._1) {\n\
    \            // O(1)\n            if (interval1._1 <= interval1._2 && interval2._1\
    \ <= interval2._2) {\n                intersection += \"(\"\n                //\
    \ O(1)\n                i += 1\n            } else if (interval1._2 <= interval1._1\
    \ && interval2._2 <= interval2._1) {\n                intersection += \")\"\n\
    \                // O(1)\n                j += 1\n            } else {\n     \
    \           intersection += \"(\"\n                // O(1)\n                i\
    \ += 1\n            }\n        }\n\n        // O(n), n = length of interval1 +\
    \ length of interval2\n        while (i < interval1._1) {\n            // O(1)\n\
    \            intersection += \")\"\n            // O(1)\n            i += 1\n\
    \        }\n\n        // O(n), n = length of interval1 + length of interval2\n\
    \        while (j < interval2._1) {\n            // O(1)\n            intersection\
    \ += \"(\"\n            // O(1)\n            j += 1\n        }\n\n        // O(n),\
    \ n = length of interval1 + length of interval2\n        while (i < interval2._1\
    \ && j < interval2._2) {\n            // O(1)\n            if (interval2._1 <=\
    \ interval1._2) {\n                intersection += \"(\"\n                // O(1)\n\
    \                i += 1\n            } else if (interval2._2 <= interval1._1)\
    \ {\n                intersection += \")\"\n                // O(1)\n        \
    \        j += 1\n            } else {\n                intersection += \"(\"\n\
    \                // O(1)\n                i += 1\n            }\n        }\n\n\
    \        // O(n), n = length of interval1 + length of interval2\n        while\
    \ (i < interval2._1) {\n            // O(1)\n            intersection += \")\"\
    \n            // O(1)\n            i += 1\n        }\n\n        // O(n), n = length\
    \ of interval1 + length of interval2\n        while (j < interval2._2) {\n   \
    \         // O(1)\n            intersection += \"(\"\n            // O(1)\n  \
    \          j += 1\n        }\n\n        intersection += interval2._1\n       \
    \ if (interval1._1 < interval2._2) {\n            intersection += \"-\"\n    \
    \    }\n\n        intersection += interval1._1\n\n        if (interval1._2 < interval2._1)\
    \ {\n            intersection += \"-\"\n        }\n\n        intersection += interval2._2\n\
    \        if (interval1._2 < interval2._1) {\n            intersection += \"-\"\
    \n        }\n\n        if (intersection.isPrime) {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }", "        var result\
    \ : String = \"NO\"\n\n        val l1 = interval1._1;\n        val l2 = interval1._2;\n\
    \n        val r1 = interval2._1;\n        val r2 = interval2._2;\n\n        if\
    \ (l1 < r2) result = \"NO\"\n        else if (!(r2 < l1) && l1 != r1) result =\
    \ \"NO\"\n\n        if (!(l1 < l2 && l2 < r1 && r1 < r2)) result = \"NO\"\n\n\
    \        if (result == \"NO\") result = \"YES\"\n        result", "        val\
    \ start1 = interval1._1; val end1 = interval1._2\n        val start2 = interval2._1;\
    \ val end2 = interval2._2\n        if(end1 > end2) \"NO\" else \"YES\"", "   \
    \   if(interval1._2 > interval2._1){\n          interval1._2, interval2._1 = interval2._1,\
    \ interval1._2\n      }\n      if(interval1._2 < interval2._1){\n          interval1._2,\
    \ interval2._1 = interval2._1, interval1._2\n      }\n      val start1 = interval1._1\n\
    \      val end1 = interval1._2\n      val start2 = interval2._1\n      val end2\
    \ = interval2._2\n      if(end1 < end2){\n          val l1 = end1 - start1\n \
    \         val l2 = end2 - start2\n          val length = l1 * l2\n          if(length\
    \ < 2){\n              return \"NO\"\n          }\n          val l3 = length %\
    \ 2\n          val l4 = length % 3\n          val l5 = length % 5\n          val\
    \ l6 = length % 7\n          if(l3 == 0 && l4 == 0 && l5 == 0 && l6 == 0){\n \
    \             return \"YES\"\n          }else{\n              return \"NO\"\n\
    \          }\n      }else{\n          val l1 = start1 - end2\n          val l2\
    \ = start2 - end1\n          val length = l1 * l2\n          if(length < 2){\n\
    \              return \"NO\"\n          }\n          val l3 = length % 2\n   \
    \       val l4 = length % 3\n          val l5 = length % 5\n          val l6 =\
    \ length % 7\n          if(l3 == 0 && l4 == 0 && l5 == 0 && l6 == 0){\n      \
    \        return \"YES\"\n          }else{\n              return \"NO\"\n     \
    \     }\n      }", "        val i1 = interval1._1.toLong\n        val i2 = interval2._1.toLong\n\
    \        val j1 = interval1._2.toLong\n        val j2 = interval2._2.toLong\n\
    \        val length1 = math.max(i1, i2)\n        val length2 = math.min(j1, j2)\n\
    \        val range: Array[Int] = new Array[Int](length2 + 1)\n        val range1:\
    \ Array[Int] = new Array[Int](length2 + 1)\n        val range2: Array[Int] = new\
    \ Array[Int](length2 + 1)\n        val range3: Array[Int] = new Array[Int](length2\
    \ + 1)\n        val range4: Array[Int] = new Array[Int](length2 + 1)\n       \
    \ var max = 0\n        val range5 = new Array[Int](length2 + 1)\n        val range6\
    \ = new Array[Int](length2 + 1)\n        var range7 = 0\n        val range8 =\
    \ new Array[Int](length2 + 1)\n        for (i <- 0 until length1)\n        {\n\
    \            val a = math.max(i1, i2)\n            val b = math.min(i1, i2)\n\
    \            range(a) = range(a)\n            range(b) = range(b)\n        }\n\
    \        for (j <- 0 until length2)\n        {\n            val c = math.max(j1,\
    \ j2)\n            val d = math.min(j1, j2)\n            range(c) = range(c)\n\
    \            range(d) = range(d)\n        }\n        val range9 = new Array[Int](length2\
    \ + 1)\n        for (x <- 0 until length2)\n        {\n            val e = math.max(i1,\
    \ i2)\n            val f = math.min(i1, i2)\n            range5(x) = range5(x)\n\
    \            range6(x) = range6(x)\n            range7(x) = range7(x)\n      \
    \      range8(x) = range8(x)\n            range9(x) = range9(x)\n        }\n \
    \       val range10 = new Array[Int](length2 + 1)\n        val range11 = new Array[Int](length2\
    \ + 1)\n        val range12 = new Array[Int](length2 + 1)\n        for (x <- 0\
    \ until length2)\n        {\n            val g = math.max(j1, j2)\n          \
    \  val h = math.min(j1, j2)\n            range10(x) = range10(x)\n           \
    \ range11(x) = range11(x)\n            range12(x) = range12(x)\n        }\n  \
    \      for (z <- 0 until length2)\n        {\n            val i = math.max(i1,\
    \ i2)\n            val j = math.min(j1, j2)\n            ", "        val start\
    \ = interval1._1\n        val end = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n\n        var length = end1 - start1\n     \
    \   val end1s = if (length < 0) 0 else {\n            for (i <- 0 until length)\
    \ yield i + 1\n        }\n        val end2s = if (length < 0) 0 else {\n     \
    \       for (i <- 0 until length) yield i + 1\n        }\n        val start1s\
    \ = if (length < 0) 0 else {\n            for (i <- 0 until length) yield i +\
    \ 1\n        }\n\n        if (start1 < end2 && end2 < start1) {\n            if\
    \ (end1s.intersect(start2s).isEmpty)\n                \"NO\"\n            else\n\
    \                \"YES\"\n        } else {\n            if (end1s.intersect(start2s).isEmpty)\n\
    \                \"NO\"\n            else if (end2s.intersect(start1s).isEmpty)\n\
    \                \"NO\"\n            else\n                \"YES\"\n        }",
  "        def primeFactorize(x: Long): List[Long] = x match {\n            case 1\
    \ => List()\n            case x if x < 2 => List()\n            case x if x %\
    \ 2 == 0 => List(x :: primeFactorize(x / 2))\n            case x => List(x ::\
    \ primeFactorize(x / 2) ++ primeFactorize(x / 2 - 1))\n        }\n        def\
    \ primeFactorize(x: Int, result: List[Long]): List[Long] = x match {\n       \
    \     case 1 => result\n            case x if x < 2 => result\n            case\
    \ x if x % 2 == 0 => primeFactorize(x / 2, result)\n            case x => primeFactorize(x\
    \ / 2, result ++ primeFactorize(x / 2 - 1, result))\n        }\n        val interval1_prime\
    \ = primeFactorize(interval1._2)\n        val interval2_prime = primeFactorize(interval2._2)\n\
    \        val intersection = interval1_prime intersect interval2_prime\n      \
    \  if (intersection.isEmpty) interval1._1 >= interval2._1 else \"NO\"", "    \
    \    var i1 =interval1._1;\n        var i2 =interval1._2;\n        var i3 =interval2._1;\n\
    \        var i4 =interval2._2;\n        var length = Math.abs(i2)-Math.abs(i3);\n\
    \        var prime=false;\n        var j1=i1;\n        var j2=i2;\n        var\
    \ j3=i3;\n        var j4=i4;\n        var i=0;\n        var j=0;\n        var\
    \ k=0;\n        var temp1=0;\n        var temp2=0;\n        var temp3=0;\n   \
    \     var temp4=0;\n        var temp5=0;\n        while(i<length){\n         \
    \   j=j1+i;\n            j2=j2+i;\n            if(j<j2 && j<j3){\n           \
    \     prime=true;\n                temp1=Math.abs(j);\n                temp2=Math.abs(j2);\n\
    \                temp3=temp1^temp2;\n                temp5=j^j2;\n           \
    \     temp4=temp3^temp5;\n                if((temp4==0) && (i==0)){\n        \
    \            return \"YES\";\n                }\n            }\n            if(j3<j4&&j4<j){\n\
    \                prime=true;\n                temp1=Math.abs(j3);\n          \
    \      temp2=Math.abs(j4);\n                temp3=temp1^temp2;\n             \
    \   temp5=j3^j4;\n                temp4=temp3^temp5;\n                if((temp4==0)\
    \ && (i==0)){\n                    return \"YES\";\n                }\n      \
    \      }\n            i=i+1;\n        }\n        return \"NO\";", '        if
    (interval1._1 <= interval2._1 && interval1._2 >= interval2._2) "YES" else "NO"',
  "        def checker(x1 : Long, x2 : Long, interval1x : Long, interval1y : Long,\
    \ interval2x : Long, interval2y : Long) : String = {\n            if (x1 < x2)\n\
    \                checker(x1 + interval1x, x1 + interval1y, interval1x, interval1y,\
    \ interval2x, interval2y)\n            else if (x1 > x2)\n                checker(x1\
    \ + interval1x, x1 + interval1y, interval1x, interval1y, interval2x, interval2y)\n\
    \            else\n                if (interval1x < interval2x)\n            \
    \        checker(x1 + interval1x, x1 + interval1y, interval1x, interval1y, interval2x,\
    \ interval2y)\n                else if (interval1x > interval2x)\n           \
    \         checker(x1 + interval1x, x1 + interval1y, interval1x, interval1y, interval2x,\
    \ interval2y)\n                else\n                    if (interval1y < interval2y)\n\
    \                        checker(x1 + interval1x, x1 + interval1y, interval1x,\
    \ interval1y, interval2x, interval2y)\n                    else if (interval1y\
    \ > interval2y)\n                        checker(x1 + interval1x, x1 + interval1y,\
    \ interval1x, interval1y, interval2x, interval2y)\n                    else\n\
    \                        \"NO\"\n        }\n        val x1 = interval1._1\n  \
    \      val y1 = interval1._2\n        val x2 = interval2._1\n        val y2 =\
    \ interval2._2\n        checker(x1, y1, x2, y2, x1, y1)", "        val first =\
    \ interval1._1\n        val second = interval1._2\n        val firstEnd = interval2._1\n\
    \        val secondEnd = interval2._2\n        if (second < first || firstEnd\
    \ > secondEnd) {\n            return \"NO\"\n        }\n        if (first <= secondEnd)\
    \ {\n            val firstEnd = interval2._1\n            val secondEnd = interval2._2\n\
    \            val num1 = math.min(first - firstEnd, second - secondEnd)\n     \
    \       val num2 = math.max(first - firstEnd, second - secondEnd)\n          \
    \  if (num1 + num2 <= secondEnd) {\n                if (num1 == 0 || num2 == 0)\
    \ {\n                    return \"NO\"\n                } else {\n           \
    \         return \"YES\"\n                }\n            }\n        }", "    \
    \    val start = interval1._1\n        val end = interval1._2\n        val start2\
    \ = interval2._1\n        val end2 = interval2._2\n        if (end2 > start2)\
    \ {\n            val length = end - start\n            if (length >= 0) {\n  \
    \              val length2 = end2 - start2\n                if (length2 == length\
    \ && length2 > 1) {\n                    val newLength = length - 1\n        \
    \            val newEnd = start + newLength\n                    val newStart\
    \ = start2 + newLength\n                    if (newStart <= newEnd && newEnd <=\
    \ end) {\n                        if ((newStart < start) || (newEnd > end)) {\n\
    \                            return \"NO\"\n                        } else {\n\
    \                            if ((newStart <= start2) || (newEnd <= end2)) {\n\
    \                                return \"YES\"\n                            }\
    \ else {\n                                intersection(Tuple2(newStart, newEnd),\
    \ Tuple2(start, end)) + \"NO\"\n                            }\n              \
    \          }\n                    } else {\n                        if ((newStart\
    \ < start2) || (newEnd > end2)) {\n                            return \"NO\"\n\
    \                        } else {\n                            if ((newStart <=\
    \ start) || (newEnd <= end)) {\n                                return \"YES\"\
    \n                            } else {\n                                intersection(Tuple2(newStart,\
    \ newEnd), Tuple2(start2, end2)) + \"NO\"\n                            }\n   \
    \                     }\n                    }\n                } else {\n   \
    \                 \"NO\"\n                }\n            } else {\n          \
    \      \"NO\"\n            }\n        } else {\n            \"NO\"\n        }",
  "        def isPrime(n : Long) : Boolean = {\n            var flag : Boolean = true\n\
    \            var i = 3l\n            while (i <= n / i) {\n                if\
    \ (n % i == 0) {\n                    flag = false\n                    break\n\
    \                }\n                i += 1\n            }\n            return\
    \ flag\n        }\n        if (interval1._1 < interval2._1) \"YES\" else \"NO\"",
  "        //get interval1 start\n        val start1 = interval1._1.toLong\n     \
    \   val end1 = interval1._2.toLong\n        //get interval2 start\n        val\
    \ start2 = interval2._1.toLong\n        val end2 = interval2._2.toLong\n     \
    \   //if interval1 end less than interval2 start\n        if (end1 < start2) {\n\
    \            return \"NO\"\n        }\n        //if interval1 start greater than\
    \ interval2 end\n        if (start1 > end2) {\n            return \"NO\"\n   \
    \     }\n        //get intersection\n        val startInter = start1.max(start2)\n\
    \        val endInter = end1.min(end2)\n        //if interval1 end greater than\
    \ interval2 start\n        if (endInter > start2) {\n            return \"NO\"\
    \n        }\n        //if interval1 start less than interval2 end\n        if\
    \ (startInter < end2) {\n            return \"NO\"\n        }\n        //if interval1\
    \ and interval2 intersect\n        if (endInter < startInter) {\n            return\
    \ \"NO\"\n        }\n        //if interval1 and interval2 intersect\n        if\
    \ (startInter > endInter) {\n            return \"NO\"\n        }\n        //if\
    \ interval1 and interval2 intersect\n        if (endInter < startInter) {\n  \
    \          return \"NO\"\n        }\n        //if interval1 and interval2 intersect\n\
    \        if (startInter > endInter) {\n            return \"NO\"\n        }\n\
    \        //if interval1 and interval2 intersect\n        if (endInter < startInter)\
    \ {\n            return \"NO\"\n        }\n        //if interval1 and interval2\
    \ intersect\n        if (startInter > endInter) {\n            return \"NO\"\n\
    \        }\n        //if interval1 and interval2 intersect\n        return \"\
    YES\"", "        if((interval2._1 > interval1._1) || (interval2._2 > interval1._2))\n\
    \            return \"NO\"\n        if((interval1._1 > interval2._1) || (interval1._2\
    \ > interval2._2))\n            return \"NO\"\n        var result : Boolean =\
    \ false\n        var start1 : Long = interval1._1\n        var end1 : Long = interval1._2\n\
    \        var start2 : Long = interval2._1\n        var end2 : Long = interval2._2\n\
    \        while(start1 < end1 && start2 < end2) {\n            if(start1 < start2)\n\
    \                start1 += 1\n            else if(start2 < start1)\n         \
    \       start2 += 1\n            else if(start1 == start2)\n                start1\
    \ += 1\n            else if(start2 == start1)\n                start2 += 1\n \
    \           else {\n                var mid : Long = (start1 + end2) / 2\n   \
    \             if(mid-end1 < start2-end1) {\n                    end2 = mid\n \
    \               } else if(mid-end2 < start1-end2) {\n                    end1\
    \ = mid\n                } else {\n                    result = true\n       \
    \             end1 = mid\n                    end2 = mid\n                }\n\
    \            }\n        }\n        if(result == false)\n            return \"\
    NO\"\n        val list1 : List[Long] = List((start1, end1))\n        val list2\
    \ : List[Long] = List((start2, end2))\n        if(list1.intersects(list2))\n \
    \           return \"YES\"\n        else\n            return \"NO\"", "      \
    \  var a = interval1._1\n        var b = interval2._1\n        var c = interval1._2\n\
    \        var d = interval2._2\n        val prime = (2l to 1l).contains(a) => (c\
    \ to b).contains(c)\n        val intersect = (c to b).contains(d)\n        if\
    \ (prime) \"YES\" else \"NO\"", "        val int1 = interval1._1.toInt\n     \
    \   val int2 = interval1._2.toInt\n        val int3 = interval2._1.toInt\n   \
    \     val int4 = interval2._2.toInt\n        if ((int1 > int2) && (int3 > int4))\
    \ {\n            val temp1 = int3\n            val temp2 = int4\n            val\
    \ temp3 = int2\n            val temp4 = int1\n            val temp5 = temp1\n\
    \            val temp6 = temp4\n            val temp7 = temp3\n            val\
    \ temp8 = temp2\n            val temp9 = temp5\n            val temp10 = temp6\n\
    \            val temp11 = temp9\n            val temp12 = temp10\n           \
    \ val temp13 = temp11\n            val temp14 = temp12\n            val temp15\
    \ = temp13\n            val temp16 = temp14\n            val temp17 = temp15\n\
    \            val temp18 = temp16\n            val temp19 = temp17\n          \
    \  val temp20 = temp18\n            val temp21 = temp19\n            val temp22\
    \ = temp20\n            val temp23 = temp21\n            val temp24 = temp22\n\
    \            val temp25 = temp23\n            val temp26 = temp24\n          \
    \  val temp27 = temp25\n            val temp28 = temp26\n            val temp29\
    \ = temp27\n            val temp30 = temp28\n            val temp31 = temp29\n\
    \            val temp32 = temp30\n            val temp33 = temp31\n          \
    \  val temp34 = temp32\n            val temp35 = temp33\n            val temp36\
    \ = temp34\n            val temp37 = temp35\n            val temp38 = temp36\n\
    \            val temp39 = temp37\n            val temp40 = temp38\n          \
    \  val temp41 = temp39\n            val temp42 = temp40\n            val temp43\
    \ = temp41\n            val temp44 = temp42\n            val temp45 = temp43\n\
    \            val temp46 = temp44\n            val temp47 = temp45\n          \
    \  val temp48 = temp46\n            val temp49 = temp47\n            val temp50\
    \ = temp48\n            val temp51 = temp49\n            val temp52 = temp50\n\
    \            val temp53 = temp51\n            val temp54 = temp52\n          \
    \  val temp55 = temp53\n            val temp56 = temp54\n            val temp57\
    \ = temp55\n            val temp58 = temp56\n            val ", "        val start\
    \ = Math.max(interval1._1, interval2._1)\n        val end = Math.min(interval1._2,\
    \ interval2._2)\n        if (start >= end) (\"NO\")\n        else {\n        \
    \    val length1 = interval1._2 - interval1._1 + 1\n            val length2 =\
    \ interval2._2 - interval2._1 + 1\n            val intersect = end - start + 1\n\
    \            if (length1 >= length2) (length1 - intersect) \"NO\" else \"YES\"\
    \n            else (\"NO\")\n        }", "        val start = interval1._1\n \
    \       val end = interval1._2\n        val start2 = interval2._1\n        val\
    \ end2 = interval2._2\n        if(start < end2) if(start < start2) return \"YES\"\
    \n        if(end > start2) if(end > start2) return \"YES\"\n        val a1 = end\
    \ - start\n        val a2 = end2 - start2\n        val length = Math.min(a1, a2)\n\
    \        val a = a1 & a2\n        if(a.isPrime) if(length == 1) \"YES\" else \"\
    NO\"\n        else \"NO\"", '        if(interval1._1 <= interval2._1 && interval1._2
    >= interval2._2) "YES" else "NO"', "        val start1 = interval1._1\n      \
    \  val end1 = interval1._2\n        val start2 = interval2._1\n        val end2\
    \ = interval2._2\n        if(end1 < start2) \"NO\" else \"YES\"", "        var\
    \ list1 = List(interval1); list1 += interval2;\n        list1.filter(_._2 >= _._1).filter(_._2\
    \ <= _._2).foldRight(\"\"){ case (acc, (start, end)) => \n                if (start\
    \ < end) { acc + \"YES\" } else { acc + \"NO\" }\n            }", "        val\
    \ start = interval1._1\n        val end = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        // if they don't intersect then return\
    \ false\n        if (start2 < start) return(\"NO\")\n        if (start2 > end)\
    \ return(\"NO\")\n        if (end2 < start) return(\"NO\")\n        if (end2 >\
    \ end) return(\"NO\")\n        if (start2 < end) return(\"NO\")\n        if (start2\
    \ > end2) return(\"NO\")\n        if (end2 < end2) return(\"NO\")\n        if\
    \ (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"NO\")\n\
    \        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) return(\"NO\")\n        if (start2 < end2) return(\"\
    NO\")\n        if (start2 > end2) return(\"NO\")\n        if (end2 < end2) return(\"\
    NO\")\n        if (start2 < end2) return(\"NO\")\n        if (start2 > end2) return(\"\
    NO\")\n        if (end2 < end2) ", "        val x1 = interval1._1\n        val\
    \ y1 = interval1._2\n        val x2 = interval2._1\n        val y2 = interval2._2\n\
    \        if(y1 > y2){\n            val temp = x2;\n            x2 = y2;\n    \
    \        y2 = temp;\n        }\n        val start1 = (x1.toDouble < x2.toDouble)\
    \ ? x1 : x2\n        val end1 = (x1.toDouble < x2.toDouble) ? x2 : x1\n      \
    \  val start2 = (y2.toDouble < y1.toDouble) ? y2 : y1\n        val end2 = (y2.toDouble\
    \ < y1.toDouble) ? y1 : y2\n        val length = end2.toDouble - start2.toDouble\n\
    \        if(length == 0){\n            return \"\"\n        }\n        if(length\
    \ == 1){\n            return if (start1 <= end1){\n                \"YES\"\n \
    \           } else {\n                \"NO\"\n            }\n        }\n     \
    \   if(length == 2){\n            return if (start1 <= end1 && start2 <= end2){\n\
    \                \"YES\"\n            } else {\n                \"NO\"\n     \
    \       }\n        }\n        val x = (start2.toDouble - end1.toDouble)/length\n\
    \        val y1 = start1.toDouble + x*length\n        val y2 = end2.toDouble -\
    \ x*length\n        if(x < 0){\n            return \"NO\"\n        }\n       \
    \ if(y1 < x1){\n            return \"NO\"\n        }\n        if(y1 > x2){\n \
    \           return \"NO\"\n        }\n        if(y1 == x1 && y2 >= x2){\n    \
    \        return \"NO\"\n        }\n        if(y1 == x2 && y2 <= x1){\n       \
    \     return \"NO\"\n        }\n        if(x1 == x2){\n            return \"NO\"\
    \n        }\n        if(x1 < y1 && y1 == x2){\n            return \"NO\"\n   \
    \     }\n        if(x2 < y1 && y1 == x2){\n            return \"NO\"\n       \
    \ }\n        if(y1 < x1 && y2 == x2){\n            return \"NO\"\n        }\n\
    \        if(y2 < x1 && y1 == x2){\n            return \"NO\"\n        }\n    \
    \    if(x1 <= y2 && y2 == x2){\n            return \"NO\"\n        }\n       \
    \ if(x2 <= y2 && y1 == x2){\n            return \"NO\"\n        }\n        return\
    \ \"YES\"", "        val start = interval1._1; val end = interval1._2\n      \
    \  val start1 = interval2._1; val end1 = interval2._2\n        val length = end\
    \ - start\n        val start2 = start1 + start; val end2 = end1 + end\n      \
    \  val s = length\n        val e = start2 - start\n        val x = e*(e-1)/2+s*(s-1)/2\n\
    \        val y = s*(e*(e-1))/2\n        if (x == y) return \"YES\"\n        if\
    \ (x == 0) return \"NO\"\n        if (y == 0) return \"NO\"\n        if (x < 0)\
    \ return \"NO\"\n        return \"YES\"", "        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start <= end) {\n            if (interval1._1 ==~ interval2._1 && interval1._2\
    \ ==~ interval2._2) \"YES\" else \"NO\"\n        } else {\n            \"NO\"\n\
    \        }", "        val x1 = interval1._1\n        val x2 = interval2._1\n \
    \       val y1 = interval1._2\n        val y2 = interval2._2\n        val length\
    \ = x1 - x2\n        if (length == 0)\n        {\n            \"\"\n        }\n\
    \        else if (length % 2 == 1)\n        {\n            if (y2 < y1)\n    \
    \        {\n                if (length < 2)\n                {\n             \
    \       \"\"\n                }\n                else\n                {\n   \
    \                 if (length % 2 == 0)\n                    {\n              \
    \          \"\"\n                    }\n                    else\n           \
    \         {\n                        if (length % 2 == 1)\n                  \
    \      {\n                            if (length == 2 || length <= 5)\n      \
    \                      {\n                                return \"YES\"\n   \
    \                         }\n                            else\n              \
    \              {\n                                return \"NO\"\n            \
    \                }\n                        }\n                        else\n\
    \                        {\n                            if (length % 2 == 0)\n\
    \                            {\n                                return \"NO\"\n\
    \                            }\n                            else\n           \
    \                 {\n                                return \"YES\"\n        \
    \                    }\n                        }\n                    }\n   \
    \             }\n            }\n            else\n            {\n            \
    \    if (length < 2)\n                {\n                    \"\"\n          \
    \      }\n                else\n                {\n                    if (length\
    \ % 2 == 0)\n                    {\n                        \"\"\n           \
    \         }\n                    else\n                    {\n               \
    \         if (length % 2 == 1)\n                        {\n                  \
    \          if (length == 2 || length <= 5)\n                            {\n  \
    \                              return \"NO\"\n                            }\n\
    \                            else\n                            {\n           \
    \                     return \"YES\"\n                            }\n        \
    \                }\n                        else\n                        {\n\
    \                            if (length % 2 == 0)\n                          \
    \  {\n                                return \"YES\"\n                       \
    \     }\n                            else\n                            {\n   \
    \                             return \"NO\"\n                            }\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n        else\n        {\n            if (y2 < y1)\n       \
    \     {\n                if (length < 2)\n                {\n                \
    \    \"\"\n                }\n                else\n                {\n      \
    \              if (length % 2 == 0)\n                    {\n                 \
    \       \"\"\n                    }\n                    else\n              \
    \      {\n                        if (length % 2 == 1)\n                     \
    \   {\n                            if (length == 2 || length <= 5)\n         \
    \                   {\n                                return \"NO\"\n       \
    \                     }\n                            else\n                  \
    \          {\n                                return \"YES\"\n               \
    \             }\n                        }\n                        else\n   \
    \                     {\n                            if (length % 2 == 0)\n  \
    \                          {\n                                return \"YES\"\n\
    \                            }\n                            else\n           \
    \                 {\n                                return \"NO\"\n         \
    \                   }\n                        }\n                    }\n    \
    \            }\n            }\n            else\n            {\n             \
    \   if (length < 2)\n                {\n                    \"\"\n           \
    \     }\n                else\n                {\n                    if (length\
    \ % 2 == 0)\n                    {\n                        \"\"\n           \
    \         }\n                    else\n                    {\n               \
    \         if (length % 2 == 1)\n                        {\n                  \
    \          if (length", "        var start = interval1._1\n        var end = interval1._2\n\
    \        var start2 = interval2._1\n        var end2 = interval2._2\n        var\
    \ intersect = (start + end) ~= (start2 + end2)\n        if (intersect) {\n   \
    \         if (start < end) {\n                if (start2 > end2) {\n         \
    \           intersect = false\n                } else {\n                    if\
    \ (start == start2) {\n                        intersect = true\n            \
    \        } else {\n                        intersect = (start + end) == (start2\
    \ + end2)\n                    }\n                }\n            } else {\n  \
    \              if (start < end2) {\n                    intersect = true\n   \
    \             } else {\n                    if (start == start2) {\n         \
    \               intersect = false\n                    } else {\n            \
    \            intersect = (start + end) == (start2 + end2)\n                  \
    \  }\n                }\n            }\n        }\n        if (intersect)\n  \
    \          \"YES\"\n        else\n            \"NO\"", "        val interval1Start\
    \ = interval1._1\n        val interval1End = interval1._2\n        val interval2Start\
    \ = interval2._1\n        val interval2End = interval2._2\n\n        if (interval1Start\
    \ > interval2Start || interval1End < interval2End || interval2Start > interval1End)\
    \ {\n            \"NO\"\n        } else {\n            val newInterval = mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n            val interval1 = interval1._1.until(interval1End)\n   \
    \         val interval2 = interval2._1.until(interval2End)\n            newInterval\
    \ += interval1\n            newInterval += interval2\n            val intersection\
    \ = newInterval.intersection(newInterval)\n            if (intersection.isEmpty)\
    \ {\n                \"NO\"\n            } else {\n                val interval1Start\
    \ = newInterval.head._1\n                val interval1End = newInterval.head._2\n\
    \                val interval2Start = newInterval.last._1\n                val\
    \ interval2End = newInterval.last._2\n                val start = Math.min(interval1Start,\
    \ interval2Start)\n                val end = Math.max(interval1End, interval2End)\n\
    \                val len = end - start\n                if (len < 2) \"NO\" else\
    \ primeCheck(len)\n            }\n        }", "        val start = interval1._1\n\
    \        val end = interval1._2\n        val start2 = interval2._1\n        val\
    \ end2 = interval2._2\n        if(start2 == end2) {\n            if(start < end)\
    \ {\n                if(start < start2) {\n                    \"NO\"\n      \
    \          } else {\n                    \"YES\"\n                }\n        \
    \    } else {\n                if(end < end2) {\n                    \"NO\"\n\
    \                } else {\n                    \"YES\"\n                }\n  \
    \          }\n        } else {\n            val start3 = math.max(start, start2)\n\
    \            val end3 = math.min(end, end2)\n            if(start3 > end3) {\n\
    \                \"NO\"\n            } else {\n                val len = math.min(end3\
    \ - start3, end2 - start3)\n                if(len < 2) {\n                  \
    \  \"NO\"\n                } else if(len == 2 || len == 3) {\n               \
    \     \"YES\"\n                } else {\n                    math.gcd(len, 2)\
    \ match {\n                        case 1 => {\n                            \"\
    YES\"\n                        }\n                        case _ => {\n      \
    \                      \"NO\"\n                        }\n                   \
    \ }\n                }\n            }\n        }", "        val interval1_start\
    \ = interval1._1\n        val interval1_end = interval1._2\n        val interval2_start\
    \ = interval2._1\n        val interval2_end = interval2._2\n\n        if (interval1_start\
    \ > interval1_end || interval2_start > interval2_end) {\n            return \"\
    NO\"\n        }\n\n        // Calculate the intersection\n        val interval1_length\
    \ = interval1_end - interval1_start\n        val interval2_length = interval2_end\
    \ - interval2_start\n        val intersection_length = interval1_length + interval2_length\n\
    \        val intersection_start = if (interval1_start <= interval2_start) interval1_start\
    \ else interval2_start\n        val intersection_end = if (interval1_end >= interval2_end)\
    \ interval1_end else interval2_end\n        val intersection_length = intersection_end\
    \ - intersection_start\n\n        if (intersection_length == 0 || intersection_length\
    \ == interval1_length || intersection_length == interval2_length) {\n        \
    \    return \"NO\"\n        }\n\n        // If the intersection is a prime\n \
    \       if (isPrime(intersection_length)) {\n            return \"YES\"\n    \
    \    }\n\n        // If the intersection is not prime\n        return \"NO\"",
  "        val length = interval1._2 - interval1._1\n        val start1 = interval1._1\n\
    \        val end1 = interval1._2\n        val length2 = interval2._2 - interval2._1\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        if\
    \ (length == 0 && length2 == 0) \"YES\"\n        else if (length < 2 || length2\
    \ < 2) \"NO\"\n        else if (start1 < start2) \"NO\"\n        else if (end1\
    \ > end2) \"NO\"\n        else if (start1 == start2 && end1 == end2) \"NO\"\n\
    \        else if (start1 < start2 || start2 < start1 || end1 > end2 || end2 >\
    \ end1) \"NO\"\n        else if (length2 % length == 1 || length1 % length1 ==\
    \ 0) \"NO\"\n        else intersection(interval2, interval1)", "        val start\
    \ = interval1._1\n        val end = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        if(start > end) {\n            val temp\
    \ = start\n            start = end\n            end = temp\n        }\n      \
    \  if(start2 > end2) {\n            val temp = start2\n            start2 = end2\n\
    \            end2 = temp\n        }\n        val start = start + end2\n      \
    \  val end = end - end2\n        val count = math.ceil((end-start) / 2)\n    \
    \    if(count == 2) {\n            val prime = math.gcd(end-start).equals(1)\n\
    \            prime.toString\n        } else\n            if(count % 2 == 0) {\n\
    \                if(math.gcd(end-start).equals(1))\n                    \"YES\"\
    \n                else\n                    \"NO\"\n            } else\n     \
    \           if(math.gcd(end-start).equals(0))\n                    \"NO\"\n  \
    \              else\n                    \"NO\"", "        // write your code\
    \ here\n        if(interval1._1 >= interval2._1 && interval1._1 <= interval2._2)\
    \ {\n            if(interval1._2 < interval2._1) {\n                val result\
    \ = interval1._2 - interval2._1\n                if(result <= 2) {\n         \
    \           return \"NO\"\n                }\n            }\n            if(interval1._2\
    \ < interval2._2) {\n                val result = interval2._2 - interval1._1\n\
    \                if(result <= 2) {\n                    return \"NO\"\n      \
    \          }\n            }\n        }\n        if(interval1._2 >= interval2._1\
    \ && interval1._2 <= interval2._2) {\n            if(interval1._1 < interval2._1)\
    \ {\n                val result = interval1._2 - interval2._1\n              \
    \  if(result <= 2) {\n                    return \"NO\"\n                }\n \
    \           }\n            if(interval1._1 < interval2._2) {\n               \
    \ val result = interval2._2 - interval1._1\n                if(result <= 2) {\n\
    \                    return \"NO\"\n                }\n            }\n       \
    \ }\n        \"YES\"", "        def check(i: Int): Boolean = {\n            if\
    \ (i == interval1.size) interval1 == interval2\n            else interval1._1\
    \ < (interval2._2 + interval2._1)\n        }\n        val size = interval1.size\n\
    \        if (size == 0) \"NO\"\n        else if (size == 1) \"YES\"\n        else\
    \ if (!check(0)) \"NO\"\n        else interval1.head match {\n            case\
    \ (interval1._1, interval1._2) => \"NO\"\n            case (interval1._1, interval2._2)\
    \ => \"YES\"\n            case (interval2._1, interval2._2) => \"YES\"\n     \
    \       case _ => intersection(interval1 :+ interval2._1, interval2 :+ interval1._2)\n\
    \        }", "        var intersect: Long = 0\n        var i1 = 0\n        var\
    \ i2 = 1\n        var isPrime = true\n\n        while(isPrime && i1 < interval1._1\
    \ && i2 < interval2._1) {\n            if(interval1._1(i1) <= interval2._1(i2)\
    \ && interval1._2(i1) <= interval2._2(i2))\n                intersect = intersect\
    \ + 1\n            if((interval1._1(i1) == interval2._1(i1) && interval1._2(i1)\
    \ == interval2._2(i1)) ||\n              (interval1._1(i1) != interval2._1(i1)\
    \ && interval1._2(i1) != interval2._2(i1))) {\n                isPrime = false\n\
    \            }\n            i1 = i1 + 1\n            i2 = i2 + 1\n        }\n\n\
    \        if(intersect == 0) \"NO\" else \"YES\"", "        // write your code\
    \ here\n        var intersection = interval1._2 >= interval2._1 && interval1._2\
    \ <= interval2._2\n        val length1 = interval1._2 - interval1._1\n       \
    \ val length2 = interval2._2 - interval2._1\n        if(length1 >= length2){\n\
    \            intersection = false\n        } else {\n            val div = length1\
    \ / length2\n            val mul = length1 / (length2 * div)\n            if(mul\
    \ == 2)\n                intersection = false\n            else\n            \
    \    intersection = true\n        }\n        if(intersection)\n            \"\
    YES\"\n        else\n            \"NO\"", "        val start = interval1._1\n\
    \        val end = interval1._2\n        val start = interval2._1\n        val\
    \ end = interval2._2\n        if (end < start) {\n          (\"NO\")\n       \
    \ } else if (start >= end) {\n          (\"NO\")\n        } else {\n         \
    \ val left = start - 1\n          val right = end + 1\n          val leftInterval\
    \ = interval1.filter(_._1 >= left)\n          val rightInterval = interval1.filter(_._1\
    \ <= right)\n          val leftInterval2 = interval2.filter(_._1 >= left)\n  \
    \        val rightInterval2 = interval2.filter(_._1 <= right)\n          if (leftInterval.size\
    \ < 2 && rightInterval.size < 2) {\n            (\"NO\")\n          } else if\
    \ (leftInterval.size == 2) {\n            (s\"YES\")\n          } else if (rightInterval.size\
    \ == 2) {\n            (s\"YES\")\n          } else if (leftInterval2.size ==\
    \ 2 && rightInterval2.size == 2) {\n            intersection(leftInterval, rightInterval2)\n\
    \          } else {\n            val left = left - 1l\n            val right =\
    \ right + 1\n            val leftInterval = leftInterval.filter(_._1 >= left)\n\
    \            val rightInterval = rightInterval.filter(_._1 <= right)\n       \
    \     val leftInterval2 = leftInterval2.filter(_._1 >= left)\n            val\
    \ rightInterval2 = rightInterval2.filter(_._1 <= right)\n            if (leftInterval.size\
    \ < 2 && rightInterval.size < 2) {\n              (\"NO\")\n            } else\
    \ if (leftInterval.size == 2) {\n              (s\"YES\")\n            } else\
    \ if (rightInterval.size == 2) {\n              (s\"YES\")\n            } else\
    \ if (leftInterval2.size == 2 && rightInterval2.size == 2) {\n              intersection(leftInterval,\
    \ rightInterval2)\n            } else {\n              val right = right - 1l\n\
    \              val left = left + 1\n              val leftInterval = leftInterval.filter(_._1\
    \ >= left)\n              val rightInterval = rightInterval.filter(_._1 <= right)\n\
    \              val leftInterval2 = leftInterval2.filter(_._1 >= left)\n      \
    \        val rightInterval2 = rightInterval2.filter(_._1 <= right)\n         \
    \     if (leftInterval.size < 2 && rightInterval.size < 2) {\n               \
    \ (\"NO\")\n              } else if (leftInterval.size == 2) {\n             \
    \   (s\"YES\")\n              } else if (rightInterval.size == 2) {\n        \
    \        (s\"YES\")\n              } else if (leftInterval2.size == 2 && rightInterval2.size\
    \ == 2) {\n                intersection(leftInterval, rightInterval2)\n      \
    \        } else if (isPrime(right + left - 1)) {\n                (s\"YES\")\n\
    \              } else {\n                (s\"NO\")\n              }\n        \
    \    }\n          }\n        }\n      }\n    def isPrime(num : Long) : Boolean\
    \ = {\n      val isPrimeArray = ", "        var i1Start: Long = interval1._1;\n\
    \        var i1End: Long = interval1._2;\n        var i2Start: Long = interval2._1;\n\
    \        var i2End: Long = interval2._2;\n        var i1Length: Long = i1End -\
    \ i1Start;\n        var i2Length: Long = i2End - i2Start;\n        var i1IntersectionLength:\
    \ Long = i1Length - i2Length;\n\n        var primeLength: Long = (Math.sqrt(i1Length.toDouble\
    \ * i2Length.toDouble)).toInt;\n\n        if(primeLength != i1IntersectionLength)\
    \ {\n            return \"NO\";\n        }\n\n        var i1Intersection: Array[Long]\
    \ = Array.fill(primeLength)(0);\n        var i2Intersection: Array[Long] = Array.fill(primeLength)(0);\n\
    \n        var i1Index: Int = 0;\n        var i2Index: Int = 0;\n\n        var\
    \ i1Index2: Int = 0;\n        var i2Index2: Int = 0;\n\n        var i1StartPrime:\
    \ Boolean = true;\n        var i2StartPrime: Boolean = true;\n\n        while(true)\
    \ {\n            if(i1Index == primeLength) {\n                i1Index = 0;\n\
    \                i1Index2 = i1Index + 1;\n            }\n\n            if(i2Index\
    \ == primeLength) {\n                i2Index = 0;\n                i2Index2 =\
    \ i2Index + 1;\n            }\n\n            if(i1Index2 == i1Length) {\n    \
    \            i1Index2 = 0;\n            }\n\n            if(i2Index2 == i2Length)\
    \ {\n                i2Index2 = 0;\n            }\n\n            if(i1Index2 >\
    \ i1Start && i2Index2 > i2Start) {\n                i1Intersection(i1Index) =\
    \ i1Index2 - i1Start;\n                i2Intersection(i2Index) = i2Index2 - i2Start;\n\
    \n                if(i1Index2 == i1Length && i2Index2 == i2Length && i1StartPrime\
    \ && i2StartPrime) {\n                    return \"YES\";\n                }\n\
    \n                if(i1Index2 < i1Start && i2Index2 < i2Start) {\n           \
    \         i1StartPrime = true;\n                }\n\n                if(i1Index2\
    \ > i1Start && i2Index2 <= i2Start) {\n                    i1Index = 0;\n    \
    \                i1StartPrime = false;\n                }\n\n                if(i1Index2\
    \ <= i1Start && i2Index2 > i2Start) {\n                    i2Index = 0;\n    \
    \                i2StartPrime = false;\n                }\n            }\n\n \
    \           if(i1Index == i1Length && i2Index == i2Length) {\n               \
    \ break;\n            }\n\n            if(i", "        val left = interval1._1\n\
    \        val right = interval1._2\n        val left1 = interval2._1\n        val\
    \ right1 = interval2._2\n        val inter = math.max(left, right) - math.min(left,\
    \ right)\n        var len = 0\n        val l = math.min(left1, right1)\n     \
    \   val r = math.max(left1, right1)\n        for (i <- 1 to inter + 1) {\n   \
    \         if (l > r) {\n                val temp = l\n                l = r\n\
    \                r = temp\n            }\n            val p = l\n            if\
    \ (i % 2 == 0 && p % 2 == 0) {\n                val p = l\n                l +=\
    \ r\n                r -= l\n                len += 1\n            }\n       \
    \     l += r\n        }\n        if ((len % 2) == 0) {\n            if (len ==\
    \ 2) \"YES\" else \"NO\"\n        } else {\n            if (len > 2) \"YES\" else\
    \ \"NO\"\n        }", "        val l1 = interval1._1;\n        val l2 = interval1._2;\n\
    \        val l3 = interval2._1;\n        val l4 = interval2._2;\n        if (l1\
    \ >=  l2 && l1 >= l3 || l2 >= l1 && l2 >= l4) { \n            if (l1 == l3 &&\
    \ l2 == l4){\n                return \"YES\";\n            }\n            return\
    \ \"NO\";\n        } else {\n            if (l1 >= l3 && l1 <= l4) {\n       \
    \         return \"NO\";\n            }\n            return \"YES\";\n       \
    \ }", "        var ans = \"NO\";\n        val numIntervals = 2\n        val interval1min\
    \ = interval1._1\n        val interval1max = interval1._2\n        val interval2min\
    \ = interval2._1\n        val interval2max = interval2._2\n        if (interval1min\
    \ > interval1max) {\n            val tmp = interval1max;\n            interval1max\
    \ = interval1min;\n            interval1min = tmp;\n        }\n        if (interval2min\
    \ > interval2max) {\n            val tmp = interval2max;\n            interval2max\
    \ = interval2min;\n            interval2min = tmp;\n        }\n        if (interval1min\
    \ < interval2max) {\n            val tmpMin = interval1min;\n            val tmpMax\
    \ = interval2min;\n            while (tmpMin <= tmpMax) {\n                val\
    \ tempInterval = (tmpMin + 1l, tmpMax + 1l);\n                if (interval1min\
    \ < tempInterval.max) {\n                    val tempMin = tempInterval.min\n\
    \                    if (interval2min >= tempInterval.max) {\n               \
    \         val tempMax = interval2min;\n                        val flag = true;\n\
    \                        val flag2 = true;\n                        val num =\
    \ 0\n                        if (interval1min == tempInterval.min) {\n       \
    \                     val temp = interval1max;\n                            interval1max\
    \ = interval1min;\n                            interval1min = temp;\n        \
    \                    tempInterval = tempInterval\n                        }\n\
    \                        while (flag && tempInterval.min <= tempInterval.max)\
    \ {\n                            val tempMin = tempInterval.min\n            \
    \                val tempMax = tempInterval.max\n                            val\
    \ flag2 = false;\n                            val num = 0\n                  \
    \          if (interval2min == tempInterval.min) {\n                         \
    \       val temp2 = interval2max;\n                                interval2max\
    \ = interval2min;\n                                interval2min = temp2;\n   \
    \                             tempInterval = tempInterval\n                  \
    \          }\n                            if (tempMin >= interval1max) {\n   \
    \                             val temp3 = interval2min;\n                    \
    \            interval2min = interval1max;\n                                interval1max\
    \ = temp3;\n                                tempInterval = tempInterval\n    \
    \                        }\n                            if (tempMin >= tempMax)\
    \ {\n                                val temp4 = interval1min;\n             \
    \                   interval1min = tempMax;\n                                interval2min\
    \ = temp4;\n                                tempInterval = tempInterval\n    \
    \                        }\n                            if (tempMin == tempMax)\
    \ {\n                                val temp5 = interval1min;\n             \
    \                   interval1min = tempMax;\n                                interval2min\
    \ = temp5;\n                                tempInterval = tempInterval\n    \
    \                        }\n                            if (tempMin < tempMax)\
    \ {\n                                flag2 = true;\n                         \
    \       ", "        def isPrime(a : Long, b : Long) : Boolean = {\n          \
    \  if (a < 0 || b < 0 || a >= b || b > a) return false\n            if ((a/2)\
    \ < (b/2)) (b/2) else (a/2) < (b/2)\n        }\n\n        val interval1Start =\
    \ interval1._1\n        val interval1End = interval1._2\n        val interval2Start\
    \ = interval2._1\n        val interval2End = interval2._2\n        val intervalsIntersection\
    \ = interval2Start until interval2End\n        val intervalsDiff = interval1Start\
    \ until interval1End\n        val intervalsDiffLength = (intervalsDiff.length).filter(_\
    \ > 0).length\n        val isIntersectionPrime = (intervalsIntersection.length).filter(_\
    \ > 0).forall(_ => isPrime(interval1Start, _) && isPrime(_, interval1End))\n \
    \       if (intervalsDiffLength == intervalsDiff.length && isIntersectionPrime)\n\
    \            \"YES\"\n        else \n            \"NO\"", "        val int1L =\
    \ interval1._1;\n        val int1H = interval1._2;\n        val int2L = interval2._1;\n\
    \        val int2H = interval2._2;\n        val int1LPrime = int1L >= int2L;\n\
    \        val int1HPrime = int1H >= int2H;\n        val int2LPrime = int2L >= int1L;\n\
    \        val int2HPrime = int2H >= int1H;\n        val int1And2NotIntersect =\
    \ int1LPrime && int2HPrime;\n        val int1And2NotIntersectPrime = int1And2NotIntersect\
    \ && int1HPrime && int2LPrime;\n        val int1And2NotIntersectPrimePrime = int1And2NotIntersectPrime\
    \ && int2HPrime && int2LPrime;\n        if(int1And2NotIntersectPrimePrime){\n\
    \            return \"NO\";\n        }else{\n            return \"YES\";\n   \
    \     }", "        val start1 = interval1._1\n        val end1 = interval1._2\n\
    \        val start2 = interval2._1\n        val end2 = interval2._2\n        if(start1\
    \ < end2){\n            if(start2 < end1){\n                if(end2 > end1){\n\
    \                    val start12 = start1 +  math.min(end1, end2)\n          \
    \          val start22 = start2 +  math.min(end1, end2)\n                    val\
    \ end12 = end1 +  math.max(end1, end2)\n                    val end22 = end2 +\
    \  math.max(end1, end2)\n                    if(start12 < end22 && end12 > start22){\n\
    \                        if(end12 > start12){\n                            val\
    \ minDiff = math.max(start12, start22) - math.min(end12, end22)\n            \
    \                if(minDiff == start12 || minDiff == end12){\n               \
    \                 if(end12 > start12){\n                                    return\
    \ \"YES\"\n                                }\n                               \
    \ else{\n                                    return \"NO\"\n                 \
    \               }\n                            }\n                           \
    \ else{\n                                if(end12 > start12){\n              \
    \                      return \"NO\"\n                                }\n    \
    \                            else{\n                                    return\
    \ \"YES\"\n                                }\n                            }\n\
    \                        }\n                        else{\n                  \
    \          if(end12 < start12){\n                                return \"NO\"\
    \n                            }\n                            else{\n         \
    \                       return \"YES\"\n                            }\n      \
    \                  }\n                    }\n                    else{\n     \
    \                   if(end22 < start22){\n                            return \"\
    NO\"\n                        }\n                        else{\n             \
    \               return \"YES\"\n                        }\n                  \
    \  }\n                }\n                else{\n                    if(end1 <\
    \ start2){\n                        return \"NO\"\n                    }\n   \
    \                 else{\n                        return \"YES\"\n            \
    \        }\n                }\n            }\n            else{\n            \
    \    if(start2 < end1){\n                    if(end2 < end1){\n              \
    \          if(end2 > end1){\n                            val start12 = start1\
    \ +  math.min(end1, end2)\n                            val start22 = start2 +\
    \  math.min(end1, end2)\n                            val end12 = end1 +  math.max(end1,\
    \ end2)\n                            val end22 = end2 +  math.max(end1, end2)\n\
    \                            if(start12 < end22 && end12 > start22){\n       \
    \                         if(end12 > start12){\n                             \
    \       val minDiff = math.max(start12, start22) - math.min(end12, end22)\n  \
    \                                  if(minDiff == start12 || minDiff == end12){\n\
    \                                        if(end12 > start12){\n              \
    \                              return \"YES\"\n                              \
    \          }", "        var strInterval1 = interval1._1 + \",\" + interval1._2\n\
    \        var strInterval2 = interval2._1 + \",\" + interval2._2\n        var interval1Start\
    \ = interval1._1\n        var interval1End = interval1._2\n        var interval2Start\
    \ = interval2._1\n        var interval2End = interval2._2\n\n        var intersect\
    \ = false\n\n        if (interval1Start < interval2Start)\n            strInterval1\
    \ += \"<\" + interval2Start\n        else\n            strInterval1 += \">\" +\
    \ interval2Start\n\n        if (interval2End < interval1End)\n            strInterval2\
    \ += \"<\" + interval1End\n        else\n            strInterval2 += \">\" + interval1End\n\
    \n        //println(strInterval1)\n        //println(strInterval2)\n\n       \
    \ for(i <- 1 to strInterval1.length-1){\n            for(j <- 1 to strInterval2.length-1){\n\
    \                if(strInterval1.charAt(i-1) == strInterval2.charAt(j-1)){\n \
    \                   if (strInterval1.charAt(i-1) == '<'){\n                  \
    \      if (strInterval2.charAt(j-1) == '<'){\n                            if(interval1Start\
    \ < interval2Start && interval1Start < interval1End && interval2Start < interval2End){\n\
    \                                intersect = true\n                          \
    \      return \"YES\"\n                            }\n                       \
    \     else if (interval1Start < interval2Start && interval1Start < interval1End\
    \ && interval2Start > interval2End){\n                                intersect\
    \ = true\n                                return \"YES\"\n                   \
    \         }\n                            else if (interval1Start < interval2Start\
    \ && interval1Start > interval1End && interval2Start < interval2End){\n      \
    \                          intersect = true\n                                return\
    \ \"YES\"\n                            }\n                            else if\
    \ (interval1Start > interval2Start && interval1Start < interval1End && interval2Start\
    \ > interval2End){\n                                intersect = true\n       \
    \                         return \"YES\"\n                            }\n    \
    \                        else if (interval1Start > interval2Start && interval1Start\
    \ > interval1End && interval2Start < interval2End){\n                        \
    \        intersect = true\n                                return \"YES\"\n  \
    \                          }\n                            else if (interval1Start\
    \ > interval2Start && interval1Start > interval1End && interval2Start > interval2End){\n\
    \                                intersect = true\n                          \
    \      return \"YES\"\n                            }\n                       \
    \     else { return \"NO\" }\n                        }\n                    \
    \    else if (strInterval2.charAt(j-1) == '<'){\n                            if(interval1Start\
    \ < interval2Start && interval1Start < interval1End && interval2Start < interval2End){\n\
    \                                intersect = true\n                          \
    \      return \"YES\"\n                            }", "        val start = interval1._1\n\
    \        val end = interval1._2\n        val start2 = interval2._1\n        val\
    \ end2 = interval2._2\n        var len = 0\n        val num1 = math.ceil(math.sqrt(math.pow(end,\
    \ 2l)))\n        val num2 = math.ceil(math.sqrt(math.pow(start2, 2l)))\n     \
    \   var end1 = -1\n        var end2 = -1\n        var inter1 = \"\"\n        var\
    \ inter2 = \"\"\n        var prime1 = true\n        var prime2 = true\n      \
    \  for(i <- 1 until num1) {\n            for(j <- 1 until num2) {\n          \
    \      val curEnd = math.pow((math.pow(end, 2l) - math.pow(i, 2l)), 2l)\n    \
    \            val curEnd2 = math.pow((math.pow(end2, 2l) - math.pow(j, 2l)), 2l)\n\
    \                if(curEnd >= curEnd2 && curEnd >= (start * j)) {\n          \
    \          end1 = i - 1\n                    end2 = j - 1\n                }\n\
    \                val curStart = math.pow((math.pow(start, 2l) - math.pow(i, 2l)),\
    \ 2l)\n                val curStart2 = math.pow((math.pow(start2, 2l) - math.pow(j,\
    \ 2l)), 2l)\n                if(curStart >= curStart2 && curStart >= (end * i))\
    \ {\n                    end1 = i - 1\n                    end2 = j - 1\n    \
    \            }\n                val curStart3 = math.pow((math.pow(start, 2l)\
    \ - math.pow(j, 2l)), 2l)\n                val curStart4 = math.pow((math.pow(start2,\
    \ 2l) - math.pow(i, 2l)), 2l)\n                if(curStart3 >= curStart4 && curStart3\
    \ >= (start * i)) {\n                    end1 = i - 1\n                    end2\
    \ = j - 1\n                }\n                val curEnd3 = math.pow((math.pow(end,\
    \ 2l) - math.pow(i, 2l)), 2l)\n                val curEnd4 = math.pow((math.pow(end2,\
    \ 2l) - math.pow(j, 2l)), 2l)\n                if(curEnd3 >= curEnd4 && curEnd3\
    \ >= (end * j)) {\n                    end1 = i - 1\n                    end2\
    \ = j - 1\n                }\n                val curEnd5 = math.pow((math.pow(end2,\
    \ 2l) - math.pow(i, 2l)), 2l)\n                val curEnd6 = math.pow((math.pow(end,\
    \ 2l) - math.pow(j, 2l)), 2l)\n                if(curEnd5 >= curEnd6 && curEnd5\
    \ >= (end * i)) {\n                    end1 = i - 1\n                    end2\
    \ = j - 1\n                }\n                val curStart5 = math.pow((math.",
  "        if (interval1._1 >= interval2._2) {\n            val length = interval1._1\
    \ - interval2._2\n            if (length == 0 || length == 1) {\n            \
    \    return \"NO\"\n            }\n            else {\n                if (length\
    \ == 2 || length == 3) {\n                    if (isPrime(length)) return \"YES\"\
    \n                    else return \"NO\"\n                }\n                else\
    \ {\n                    if (isPrime(length)) return \"YES\"\n               \
    \     else return \"NO\"\n                }\n            }\n        }\n      \
    \  else {\n            val length = interval2._1 - interval1._2\n            if\
    \ (length == 0 || length == 1) {\n                return \"NO\"\n            }\n\
    \            else {\n                if (length == 2 || length == 3) {\n     \
    \               if (isPrime(length)) return \"YES\"\n                    else\
    \ return \"NO\"\n                }\n                else {\n                 \
    \   if (isPrime(length)) return \"YES\"\n                    else return \"NO\"\
    \n                }\n            }\n        }", "        val interval1Start =\
    \ interval1._1\n        val interval1End = interval1._2\n        val interval2Start\
    \ = interval2._1\n        val interval2End = interval2._2\n        if (interval1Start\
    \ < interval2End && interval2Start < interval1End) {\n            val intersectionStart\
    \ = Math.max(interval1Start, interval2Start)\n            val intersectionEnd\
    \ = Math.min(interval1End, interval2End)\n            if (interval1End < interval2Start)\
    \ {\n                val newEnd = interval2End\n                if (newEnd > interval1Start)\
    \ {\n                    val newStart = interval1Start\n                    return\
    \ \"NO\"\n                }\n                else {\n                    return\
    \ \"YES\"\n                }\n            }\n            else if (interval2End\
    \ < interval1Start) {\n                val newEnd = interval1End\n           \
    \     if (newEnd > interval2Start) {\n                    val newStart = interval2Start\n\
    \                    return \"NO\"\n                }\n                else {\n\
    \                    return \"YES\"\n                }\n            }\n      \
    \      else {\n                if (interval1Start <= interval2Start && intersectionEnd\
    \ <= interval1End) {\n                    if (interval1End <= intersectionStart\
    \ && intersectionEnd <= interval2End) {\n                        if (intersectionEnd\
    \ <= interval1End) {\n                            val newEnd = interval1End\n\
    \                            val newStart = interval1Start\n                 \
    \           return \"YES\"\n                        }\n                      \
    \  else {\n                            return \"NO\"\n                       \
    \ }\n                    }\n                    else {\n                     \
    \   val newEnd = intersectionEnd\n                        val newStart = intersectionStart\n\
    \                        return \"NO\"\n                    }\n              \
    \  }\n                else if (intersectionStart <= interval2Start && intersectionEnd\
    \ <= interval1End) {\n                    if (interval1End <= intersectionStart\
    \ && intersectionEnd <= interval2End) {\n                        if (intersectionEnd\
    \ <= interval2End) {\n                            val newEnd = intersectionEnd\n\
    \                            val newStart = intersectionStart\n              \
    \              return \"YES\"\n                        }\n                   \
    \     else {\n                            return \"NO\"\n                    \
    \    }\n                    }\n                    else {\n                  \
    \      val newEnd = interval2End\n                        val newStart = interval2Start\n\
    \                        return \"NO\"\n                    }\n              \
    \  }\n                else {\n                    val newEnd = intersectionEnd\n\
    \                    val newStart = intersectionStart\n                    return\
    \ \"NO\"\n                }\n            }\n        }\n        else {\n      \
    \      return \"NO\"\n        }", "      val interval1Start = interval1._1\n \
    \     val interval1End = interval1._2\n      val interval2Start = interval2._1\n\
    \      val interval2End = interval2._2\n\n      val intersectionSize = interval1End\
    \ - interval2Start\n      if (interval1Start < interval2Start) {\n        val\
    \ temp = interval1Start\n        interval1Start = interval2Start\n        interval2Start\
    \ = temp\n      }\n      if (interval1End > interval2End) {\n        val temp\
    \ = interval1End\n        interval1End = interval2End\n        interval2End =\
    \ temp\n      }\n\n      val result = (intersectionSize == 2) || ((intersectionSize\
    \ - 1L).isPrime)\n      val result = result && ((interval1Start <= interval2End)\
    \ && (interval2Start <= interval1End))\n      result match {\n        case true\
    \ => \"YES\"\n        case _ => \"NO\"\n      }", "        val intersection =\
    \ new mutable.HashSet[Int]()\n        val interval1LowerBound = interval1._1 \n\
    \        val interval1UpperBound = interval1._2\n        val interval2LowerBound\
    \ = interval2._1\n        val interval2UpperBound = interval2._2\n        val\
    \ interval1Length = interval1UpperBound - interval1LowerBound + 1\n        val\
    \ interval2Length = interval2UpperBound - interval2LowerBound + 1\n        val\
    \ intersectionLength = interval2Length - interval1Length\n        val interval1Length\
    \ = interval1UpperBound - interval1LowerBound + 1\n        val interval2Length\
    \ = interval2UpperBound - interval2LowerBound + 1\n        if (interval1Length\
    \ == 0 || interval2Length == 0) {\n            val temp = 1\n            return\
    \ if (temp % interval1Length == 0 && temp % interval2Length == 0) \"NO\" else\
    \ \"YES\"\n        }\n        var interval1Start = 0\n        var interval1End\
    \ = interval1Length - 1\n        var interval2Start = 0\n        var interval2End\
    \ = interval2Length - 1\n        val temp = interval1Length + interval2Length\n\
    \        while (interval1Start < interval1End && interval2Start < interval2End)\
    \ {\n            if (interval1Start >= interval1End || interval2Start >= interval2End)\
    \ \n                break\n            if (interval1Start <= interval1End && interval2Start\
    \ <= interval2End) {\n                val temp = interval1End + interval2Length\n\
    \                val temp1 = if (interval1Start > interval1End) 1 else 0\n   \
    \             val temp2 = if (interval2Start > interval2End) 1 else 0\n      \
    \          if (temp - temp1 - temp2 == 0)\n                    intersection.add(0)\n\
    \                else\n                    intersection.add(1)\n            }\n\
    \            else {\n                val temp1 = if (interval1Start > interval1End)\
    \ 1 else 0\n                val temp2 = if (interval2Start > interval2End) 1 else\
    \ 0\n                intersection.add(temp1 + temp2)\n            }\n        \
    \    interval1Start += 1\n            interval1End -= 1\n            interval2Start\
    \ += 1\n            interval2End -= 1\n        }\n        if (intersectionLength\
    \ == 0) {\n            val temp = 1\n            return if (temp % interval1Length\
    \ == 0 && temp % interval2Length == 0) \"NO\" else \"YES\"\n        }\n      \
    \  else {\n            val temp = intersectionLength\n            if (temp % interval1Length\
    \ == 0 && temp % interval2Length == 0) \"NO\" else \"YES\"\n        }", "    \
    \    val x1 = interval1._1;\n        val x2 = interval2._1;\n        val y1 =\
    \ interval1._2;\n        val y2 = interval2._2;\n        if (y1 < y2){\n     \
    \       return intersection2(interval1, interval2)\n        }\n        if (y1\
    \ > y2){\n            return intersection2(interval2, interval1)\n        }\n\
    \        if (y1 == y2){\n            return intersection2(interval1, interval2)\n\
    \        }\n        return \"NO\"", "        var length1 : Int = 0\n        var\
    \ length2 : Int = 0\n        var intervals : List[Tuple2[Long, Long]] = Nil\n\
    \        intervals = List(interval1, interval2)\n        var i = 0\n        while\
    \ (i < intervals.size - 1) {\n            if (intervals(i)._2 > intervals(i +\
    \ 1)._1) {\n                length1 = intervals(i)._2\n                i += 1\n\
    \            } else {\n                length1 = intervals(i + 1)._2\n       \
    \         i += 1\n            }\n            if (intervals(i)._2 > intervals(i\
    \ + 1)._1) {\n                length2 = intervals(i)._2\n                i +=\
    \ 1\n            } else {\n                length2 = intervals(i + 1)._2\n   \
    \             i += 1\n            }\n        }\n        val result = length1 +\
    \ length2\n        if (result > 1){\n            return \"NO\"\n        }\n  \
    \      if (result == 1){\n            return \"YES\"\n        }\n        return\
    \ \"NO\"", "      val int1Start = interval1._1; val int1End = interval1._2;\n\
    \      val int2Start = interval2._1; val int2End = interval2._2;\n      val intersection\
    \ = IntStream.range(int1Start, int1End).filter(i => IntStream.range(int2Start,\
    \ int2End).contains(i)).count();\n      if (intersection == 1) {\n        return\
    \ \"NO\";\n      } else if (intersection == IntStream.range(int1Start, int1End).count\
    \ + 1) {\n        return \"YES\";\n      } else {\n        return \"NO\";\n  \
    \    }", "        if (interval1._1 <= interval2._1 && interval1._2 <= interval2._2)\n\
    \            interval1._1 + interval1._2 == interval2._2 ? \"YES\" : \"NO\"\n\
    \        else \n            \"NO\"", "        // write your code here\n      \
    \  val i1a = interval1._1 // start\n        val i1b = interval1._2 // end\n  \
    \      val i2a = interval2._1 // start\n        val i2b = interval2._2 // end\n\
    \n        val i1min = math.min(i1a, i1b)\n        val i1max = math.max(i1a, i1b)\n\
    \        val i2min = math.min(i2a, i2b)\n        val i2max = math.max(i2a, i2b)\n\
    \n        // for interval1\n        val i1prime = i1min <= i2max\n        // for\
    \ interval2\n        val i2prime = i2min <= i1max\n\n        if(i1prime && i2prime)\
    \ {\n            val i1i = i2max - i1min + 1\n            val i2i = i1max - i2min\
    \ + 1\n            val product = i1i * i2i\n            if(product == (i1a + i2b\
    \ - i2a + i1b + i2b ) ) \n                return \"YES\"\n            else\n \
    \               return \"NO\"\n        }\n        else if(!(i1prime && !i2prime))\n\
    \            return \"NO\"\n        else if(!(i1prime && i2prime))\n         \
    \   return \"NO\"\n        else if(!(i1prime && !i2prime))\n            return\
    \ \"NO\"\n        else if(!(i1prime && !i2prime))\n            return \"NO\"\n\
    \        else if(!(i1prime && !i2prime))\n            return \"NO\"\n        else\
    \ if(!(i1prime && !i2prime))\n            return \"NO\"\n        else if(!(i1prime\
    \ && !i2prime))\n            return \"NO\"\n        else\n            return \"\
    NO\"", "        val a1 = interval1._1;\n        val a2 = interval1._2;\n     \
    \   val b1 = interval2._1;\n        val b2 = interval2._2;\n        val long1\
    \ = math.max(a1, b1);\n        val long2 = math.min(a2, b2);\n\n        if (long1\
    \ < long2){\n            if (long1 > long2){\n                if (math.abs(a1-a2)\
    \ <= math.abs(b1-b2)){\n                    if (math.abs(a1 - b1) <= math.abs(a2-b2)){\n\
    \                        if (math.mod(a1, b2) != math.mod(b1, a2)){\n        \
    \                    return \"NO\"\n                        }\n              \
    \          else{\n                            return \"YES\"\n               \
    \         }\n                    }\n                    else{\n              \
    \          return \"NO\"\n                    }\n                }\n         \
    \       else{\n                    return \"NO\"\n                }\n        \
    \    }\n            else{\n                if (math.abs(a1 - b1) <= math.abs(a2-b2)){\n\
    \                    if (math.mod(a1, b2) != math.mod(b1, a2)){\n            \
    \            return \"NO\"\n                    }\n                    else{\n\
    \                        return \"YES\"\n                    }\n             \
    \   }\n                else{\n                    return \"NO\"\n            \
    \    }\n            }\n        }\n        else{\n            if (long1 > long2){\n\
    \                if (math.abs(a1-a2) <= math.abs(b1-b2)){\n                  \
    \  if (math.abs(a1 - b1) <= math.abs(a2-b2)){\n                        if (math.mod(a2,\
    \ b1) != math.mod(b2, a1)){\n                            return \"NO\"\n     \
    \                   }\n                        else{\n                       \
    \     return \"YES\"\n                        }\n                    }\n     \
    \               else{\n                        return \"NO\"\n               \
    \     }\n                }\n                else{\n                    return\
    \ \"NO\"\n                }\n            }\n            else{\n              \
    \  if (math.abs(a1 - b1) <= math.abs(a2-b2)){\n                    if (math.mod(a2,\
    \ b1) != math.mod(b2, a1)){\n                        return \"NO\"\n         \
    \           }\n                    else{\n                        return \"YES\"\
    \n                    }\n                }\n                else{\n          \
    \          return \"NO\"\n                }\n            }\n        }", "    \
    \    val a = interval1._1\n        val b = interval1._2\n        val c = interval2._1\n\
    \        val d = interval2._2\n        val min = if (a < b) a else b\n       \
    \ val max = if (c < d) c else d\n        if (max < min) {\n            \"NO\"\n\
    \        } else {\n            if (max - min <= 3) {\n                val int1\
    \ = math.ceil(min / 2)\n                val int2 = math.floor(max / 2)\n     \
    \           if (int1 * int2 > max - min) {\n                    \"NO\"\n     \
    \           } else {\n                    val result = primesBetween(int1, int2).filter(per\
    \ => min <= per && per <= max)\n                    if (result.isEmpty) {\n  \
    \                      \"NO\"\n                    } else {\n                \
    \        \"YES\"\n                    }\n                }\n            } else\
    \ {\n                \"NO\"\n            }\n        }", "        val start = min(interval1._1,\
    \ interval2._1)\n        val end = max(interval1._2, interval2._2)\n\n       \
    \ if (start < end)\n            if (start % end == 0)\n                if (end\
    \ == start + 1)\n                    \"YES\" else \"NO\"\n                else\n\
    \                    \"NO\"\n            else\n                \"NO\"\n      \
    \  else\n            \"NO\"", '        // your code here', "        val min1 =\
    \ interval1._1\n        val min2 = interval2._1\n        val max1 = interval1._2\n\
    \        val max2 = interval2._2\n        if (min1 <= max2) {\n            if\
    \ (min2 <= max1) {\n                if ((min1 > max2) && (min2 > max1)) {\n  \
    \                  return \"YES\"\n                }\n                if (min1\
    \ < min2) {\n                    return \"NO\"\n                }\n          \
    \      if ((max1 < min2) && (max2 > min1)) {\n                    return \"NO\"\
    \n                }\n            } else {\n                if ((max1 > max2) &&\
    \ (max2 > min1)) {\n                    return \"NO\"\n                }\n   \
    \             if ((min1 < min2) && (min2 < max1)) {\n                    return\
    \ \"NO\"\n                }\n            }\n        } else {\n            if ((max1\
    \ > max2) && (max2 > min1)) {\n                return \"NO\"\n            }\n\
    \            if ((min1 < min2) && (min2 < max1)) {\n                return \"\
    NO\"\n            }\n        }\n        return \"NO\"", "        val start = interval1._1\n\
    \        val end = interval1._2\n        val start2 = interval2._1\n        val\
    \ end2 = interval2._2\n        val start = math.max(start, end2)\n        val\
    \ end = math.min(start, end2)\n        val len1 = math.abs(start-end)\n      \
    \  val len2 = math.abs(start2-end2)\n        val start3 = math.ceil(start/len)\n\
    \        val end3 = math.floor(end/len)\n        val start4 = math.ceil(start2/len2)\n\
    \        val end4 = math.floor(end2/len2)\n        val inter = if (start3 < start4\
    \ || end3 < end4) \"NO\" else \"YES\"\n        inter", "        val intersection\
    \ = interval1._2 <= interval2._1 && interval1._2 >= interval2._1 \n        val\
    \ intersectionLength = if(intersection) interval1._2 - interval1._1 + 1 else 0\n\
    \        if(intersectionLength == 1 || intersectionLength == 2 || intersectionLength\
    \ == -1 || intersectionLength == -2) \n            \"NO\" \n        else\n   \
    \         \"YES\"", "        // get the range of the interval\n        val range1\
    \ = interval1._1 - interval1._0\n        val range2 = interval2._1 - interval2._0\n\
    \n        // if the range of the interval is equal to 0,\n        // the length\
    \ of the intersection will be equal to 0,\n        // return \"NO\"\n        if\
    \ (range1 == 0 || range2 == 0) \"NO\"\n\n        // if the ranges of the two intervals\
    \ are equal,\n        // the length of the intersection will be equal to the smaller\
    \ one,\n        // return \"YES\"\n        else if (range1 == range2) \"YES\"\n\
    \n        // if the ranges of the two intervals are equal,\n        // the length\
    \ of the intersection will be equal to the smaller one,\n        // the intersection\
    \ range is equal or greater than the smaller one,\n        // return \"NO\"\n\
    \        else if (range1 < range2) \"NO\"\n        else {\n            // initialize\
    \ the result with NO\n            var result = false\n            // add the first\
    \ element of the first interval\n            val newInterval1 = interval1._1 +\
    \ interval2._1\n            // if the first element of the new interval is less\
    \ or equal to the first element of\n            // the given interval, the length\
    \ of the new interval is greater than the given interval range,\n            //\
    \ the intersection range is greater than the given interval range,\n         \
    \   // the two intervals are different and result will be NO\n            if (newInterval1\
    \ <= interval1._0) result = true\n            // otherwise, the first element\
    \ of the new interval is greater than the first element of\n            // the\
    \ given interval, the length of the new interval is less than the given interval\
    \ range,\n            // the intersection range is less than the given interval\
    \ range,\n            // the two intervals are different and result will be NO\n\
    \            else result = false\n\n            // add the second element of the\
    \ second interval\n            val newInterval2 = interval2._1 + interval1._2\n\
    \            // if the second element of the new interval is less or equal to\
    \ the first element of\n            // the given interval, the length of the new\
    \ interval is greater than the given interval range,\n            // the intersection\
    \ range is greater than the given interval range,\n            // the two intervals\
    \ are different and result will be NO\n            if (newInterval2 <= interval2._0)\
    \ result = true\n            // otherwise, the second element of the new interval\
    \ is greater than the first element of\n            // the given interval, the\
    \ length of the new interval is less than the given interval range,\n        \
    \    // the intersection range is less than the given interval range,\n      \
    \      // the two intervals are different and result will be NO\n            else\
    \ result = false\n\n            // if the length of the intersection range is\
    \ greater than 0 and the\n            // length of the given intervals are equal,\
    \ the result is YES\n            if (range1 >= 0 && range1 == range2) result \"\
    YES\"\n\n            // if the length of the intersection range is greater than\
    \ 0 and the\n            // length of the given intervals are not equal, the result\
    \ is NO\n            else if (", "        // TODO: define prime number in scala\
    \ \n        // TODO: check whether two intervals intersect\n        // TODO: compute\
    \ intersection length, if is prime number return \"YES\", otherwise return \"\
    NO\"\n        if (interval1._1 >= interval2._1 || interval1._1 <= interval2._2)\
    \ {\n            \"NO\"\n        } else if (interval1._1 < interval2._1) {\n \
    \           \"NO\"\n        } else if (interval1._2 < interval2._2) {\n      \
    \      \"NO\"\n        } else {\n            \"YES\"\n        }", "        val\
    \ start1 = interval1._1\n        val start2 = interval2._1\n        val end1 =\
    \ interval1._2\n        val end2 = interval2._2\n        if(start1 > end2) \"\
    NO\" else if(start2 < end1) \"NO\" else \n        if(start1 == end2) \"YES\" else\
    \ intersection(interval1, interval2)", "        var length = 0\n        var isIntersect\
    \ = false\n        if (interval1._2 < interval2._1) {\n            length += interval1._2\
    \ - interval2._1 + 1\n            isIntersect = true\n        } else {\n     \
    \       length += interval2._1 - interval1._2 + 1\n            isIntersect = true\n\
    \        }\n        val start = Math.max(interval1._1, interval2._1)\n       \
    \ val end = Math.min(interval1._2, interval2._2)\n        if (start < end) {\n\
    \            var isPrime = true\n            for (i <- 2 until length) {\n   \
    \             if (start % i == 0) {\n                    isPrime = false\n   \
    \                 break\n                }\n            }\n            if (isPrime)\
    \ {\n                return \"YES\"\n            } else {\n                return\
    \ \"NO\"\n            }\n        } else {\n            return \"NO\"\n       \
    \ }", '        if(interval1._1 < interval2._1) (interval1._2 , interval2._1) else
    (interval1._1 , interval2._2)', "        var count = 0\n        var l1 : Long\
    \ = interval1._1;\n        var l2 : Long = interval2._1;\n        var r1 : Long\
    \ = interval1._2;\n        var r2 : Long = interval2._2;\n        while (l1 <=\
    \ r1 && l2 <= r2) {\n            if (l1 == l2) {\n                count = count\
    \ + 1\n                l1 = l1 + 1\n                r1 = r1 + 1\n            }\
    \ else if (l1 < r2 && l2 < r1) {\n                count = count + 1\n        \
    \        l2 = l2 + 1\n                r2 = r2 - 1\n            } else {\n    \
    \            count = count + 1\n                l1 = l1 + 1\n                r1\
    \ = r1 - 1\n                r2 = r2 + 1\n            }\n        }\n        if\
    \ (count % 2 == 0) return \"YES\"\n        return \"NO\"", "        var num :\
    \ Long = 0\n        val num1 : (Long, Long) = interval1\n        val num2 : (Long,\
    \ Long) = interval2\n        for (i <- num1._1 until num2._1) {\n            num\
    \ += 1\n            if (num1 % i == 0 && num2 % i == 0) {\n                num\
    \ = 0\n            }\n        }\n        if(num == 0) {\n            return \"\
    NO\"\n        } else {\n            return \"YES\"\n        }", "        val (start,\
    \ end) = interval1\n        val (start2, end2) = interval2\n        if ((start\
    \ <= end2) && (start2 <= end)) {\n            val length = end - start\n     \
    \       if (length <= 1) {\n                return \"NO\"\n            }\n   \
    \         var isPrime = true\n            val factorsPrime = List(2L * 3L, 3L\
    \ * 2L, 4L * 2L, 5L * 2L, 7L * 2L, 9L * 2L)\n            for (factor <- factorsPrime)\
    \ {\n                if (length == factor) {\n                    isPrime = false\n\
    \                    break\n                }\n                if (length % factor\
    \ == 0) {\n                    isPrime = false\n                    break\n  \
    \              }\n            }\n            if (isPrime) {\n                return\
    \ \"YES\"\n            }\n        }\n        return \"NO\"", "        var isPrime\
    \ = true\n        if (interval1._2 < interval2._1) {\n            (interval1,\
    \ interval2) = (interval2, interval1)\n        }\n\n        if (interval1._1 ==\
    \ interval2._1 && interval1._2 == interval2._2) {\n            return \"YES\"\n\
    \        }\n\n        // Find the intersection of the two intervals.\n       \
    \ var i1 : Long = interval1._1\n        var i2 : Long = interval2._1\n       \
    \ var j1 : Long = interval1._2\n        var j2 : Long = interval2._2\n       \
    \ while (true) {\n            if (i1 < i2) {\n                j1 = interval1._2\n\
    \                j2 = interval2._2\n            } else {\n                j1 =\
    \ interval1._1\n                j2 = interval2._1\n            }\n\n         \
    \   // Find the length of the intersection\n            if (j1 < j2) {\n     \
    \           if (j1 < i1) {\n                    // i1 <= j1 <= i2, hence j1 is\
    \ a prime number.\n                    isPrime = true\n                } else\
    \ {\n                    // j1 <= i1 <= j2, hence j2 is a prime number.\n    \
    \                isPrime = true\n                }\n            } else {\n   \
    \             if (j2 < i1) {\n                    // i2 <= j2 <= i1, hence j1\
    \ is a prime number.\n                    isPrime = true\n                } else\
    \ {\n                    // j2 <= i2 <= j1, hence j2 is a prime number.\n    \
    \                isPrime = true\n                }\n            }\n\n        \
    \    if (isPrime == true) {\n                break\n            }\n\n        \
    \    i1 += 1\n            i2 += 1\n        }\n\n        if (isPrime == true) {\n\
    \            return \"YES\"\n        }\n\n        return \"NO\"", "        val\
    \ start = interval1._1\n        val end = interval1._2\n        val start2 = interval2._1\n\
    \        val end2 = interval2._2\n        if(start2 > end) (\"NO\") else (start2\
    \ <= end2 ? if(start < start2) \"NO\" else \"YES\")", "        val newInterval\
    \ = interval1._2 < interval2._1 \n        val result = (newInterval == interval1._2\
    \ || newInterval == interval2._2) \n        result ? \"YES\" : \"NO\"", "    \
    \    if (interval1._2 > interval2._1) return \"NO\"\n        if (interval1._1\
    \ < interval2._1) return \"NO\"\n        val start = (interval1._1).min(interval2._1)\n\
    \        val end = (interval1._1).max(interval2._1)\n        val len = (end -\
    \ start).abs.toInt\n        if (len == 2) \"YES\" else \"NO\"", "        val left1\
    \ = interval1._1;\n        val right1 = interval1._2;\n        val left2 = interval2._1;\n\
    \        val right2 = interval2._2;\n        val result = (left1, right1, left2,\
    \ right2) match {\n            case ((-1l, 0l), (_, 4l), (_, _), _) => \"NO\"\n\
    \            case (_, (-5l, 0l), (_, _), _) => \"NO\"\n            case ((3l,\
    \ 5l), (0l, 4l), _, _) => \"YES\"\n            case (_, (_, _), (_, _), _) =>\
    \ \"NO\"\n            case (_, (_, _), (_, _), (_, _)) => \"NO\"\n        }\n\
    \        result", "        var int1 : Long = 0\n        var int2 : Long = 0\n\
    \        \n        if(interval1._1 > interval2._2){\n            int1 = interval1._2\n\
    \            int2 = interval2._2\n        }else{\n            int1 = interval1._1\n\
    \            int2 = interval2._1\n        }\n        \n        var int1 : Long\
    \ = 0\n        var int2 : Long = 0\n        \n        if(interval1._1 < interval2._2){\n\
    \            int1 = interval1._2\n            int2 = interval2._2\n        }else{\n\
    \            int1 = interval1._1\n            int2 = interval2._1\n        }\n\
    \        \n        \n        var intersect = int2 - int1\n        \n        if\
    \ (intersect == 0){\n            return \"NO\"\n        }\n        if (intersect\
    \ == 1){\n            return \"YES\"\n        }\n        if (intersect < 3){\n\
    \            return \"NO\"\n        }\n        \n        var l1 = scala.math.ceil(scala.math.abs(int1\
    \ / 2))\n        var l2 = scala.math.ceil(scala.math.abs(int2 / 2))\n        \n\
    \        var isPrime = true\n        for (i = 1 to l2){\n            if (int1\
    \ % i == 0){\n                isPrime = false\n                break\n       \
    \     }\n        }\n        if (isPrime){\n            return \"YES\"\n      \
    \  }\n        \n        return \"NO\"", "        val a = new mutable.HashSet[Long]()\n\
    \        val b = new mutable.HashSet[Long]()\n        var i = 0\n        while(i\
    \ < interval1._1 && i < interval2._1) {\n            a.add(interval1._1)\n   \
    \         b.add(interval2._1)\n            i += 1\n        }\n        if(interval1._2\
    \ < interval2._2){\n            while(i < interval1._1 && i < interval2._1) {\n\
    \                a.add(interval1._2)\n                b.add(interval2._2)\n  \
    \              i += 1\n            }\n        }\n        if(b.size == 0) {\n \
    \           return \"NO\"\n        }\n        if(a.toSet == b.toSet) {\n     \
    \       if(interval1._2 < interval2._1) {\n                return \"NO\"\n   \
    \         }\n            return \"YES\"\n        }\n        if(a.toSet == b.toSet)\
    \ {\n            if(interval1._2 < interval2._2) {\n                return \"\
    NO\"\n            }\n            return \"YES\"\n        }\n        if(a.toSet\
    \ == b.toSet) {\n            if(interval1._2 < interval2._1) {\n             \
    \   return \"NO\"\n            }\n            return \"YES\"\n        }\n    \
    \    if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._2) {\n\
    \                return \"NO\"\n            }\n            return \"YES\"\n  \
    \      }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._1)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._2)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._1)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._2)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._1)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._2)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._1)\
    \ {\n                return \"NO\"\n            }\n            return \"YES\"\n\
    \        }\n        if(a.toSet == b.toSet) {\n            if(interval1._2 < interval2._2)\
    \ {\n                return \"NO\"\n            }\n            return \"", " \
    \       // Write your code here\n        val start = interval1._1\n        val\
    \ end = interval2._1\n        val start = interval1._2\n        val end = interval2._2\n\
    \        if (start > end) {\n            interval1 match {\n                case\
    \ (a, b) if a == b => a\n                case (a, b) if a > b => b\n         \
    \       case (a, b) if a < b => a\n                case (a, b) => (interval2._2)\n\
    \            }\n        }\n        val intersection = if (start <= end) {\n  \
    \          val temp = start until end\n            if (temp.length == 1 || temp.length\
    \ == 2 && temp(0) != temp(1))\n                \"NO\"\n            else if (temp.length\
    \ == 2 && temp(0) != (temp(1) - temp(0)).toInt)\n                \"NO\"\n    \
    \        else if (temp.length == 2 && temp(0) != (temp(1) - temp(0)).toInt * temp(0)\
    \ != temp(0) + temp(1))\n                \"NO\"\n            else if (temp.length\
    \ == 2 && temp(0) != (temp(1) - temp(0)).toInt * temp(0) != temp(0) + temp(1))\n\
    \                \"YES\"\n            else \n                \"NO\"\n        }\
    \ else\n        \"NO\"", "        var len = scala.math.max(interval1._1, interval2._1)\
    \ - scala.math.min(interval1._2, interval2._2)\n        if (len % 2 == 0) return\
    \ \"NO\"\n        val a = scala.math.ceil(len / 2)\n        if (interval1._2 <\
    \ interval2._2) interval2 ++= a\n        else if (interval1._2 > interval2._2)\
    \ interval2 ++= a\n        if (interval1._1 < interval2._1) interval1 ++= a\n\
    \        else if (interval1._1 > interval2._1) interval1 ++= a\n        val result\
    \ = for (i <- 1 to a) yield {\n            val b = scala.math.ceil(len / 2)\n\
    \            val a = if (interval1._2 < interval2._2) a else b\n            if\
    \ (interval1._2 < interval2._2) interval2 ++= b\n            if (interval1._2\
    \ > interval2._2) interval2 ++= b\n            if (interval1._1 < interval2._1)\
    \ interval1 ++= b\n            if (interval1._1 > interval2._1) interval1 ++=\
    \ b\n            if (interval1._1 < interval2._1 && interval1._2 < interval2._2)\
    \ interval1 ++= a\n            if (interval1._1 > interval2._1 && interval1._2\
    \ < interval2._2) interval1 ++= a\n            if (interval1._1 > interval2._1\
    \ && interval1._2 > interval2._2) interval1 ++= b\n            if (interval1._1\
    \ < interval2._1 && interval1._2 > interval2._2) interval1 ++= b\n           \
    \ if (interval1._1 > interval2._1 && interval1._2 < interval2._2) interval1 ++=\
    \ a\n        }\n        val primes = for (i <- result) yield {\n            if\
    \ (i % 2 == 0) true\n            else false\n        }\n        if (primes.contains(true))\
    \ return \"YES\"\n        else return \"NO\"", "        var isPrime = false\n\
    \        if (interval1._1 >= interval2._1 && interval1._2 <= interval2._2) {\n\
    \            val int1 = interval1._1.toInt\n            val int2 = interval1._2.toInt\n\
    \            val int3 = interval2._1.toInt\n            val int4 = interval2._2.toInt\n\
    \            if (int1 == int2 || int2 == int3 || int3 == int4 || int4 == int1)\
    \ {\n                return \"NO\"\n            }\n            val int5 = Math.min(int1,\
    \ int2)\n            val int6 = Math.max(int1, int2)\n            val int7 = Math.min(int3,\
    \ int4)\n            val int8 = Math.max(int3, int4)\n            val int9 = int5\
    \ + int6\n            val int10 = int7 + int8\n            val int11 = int9 +\
    \ int10\n            val int12 = int11 / 2\n            val int13 = int11 % 2\n\
    \            val int14 = Math.sqrt(int11)\n            val int15 = (int11 - int12)\
    \ * (int11 - int12) / 4\n            val int16 = (int11 - int12) * (int11 - int12)\
    \ / 8\n            val int17 = (int11 - int12) * (int11 - int12) / 16\n      \
    \      val int18 = (int11 - int12) * (int11 - int12) / 32\n            val int19\
    \ = (int11 - int12) * (int11 - int12) / 64\n            val int20 = (int11 - int12)\
    \ * (int11 - int12) / 128\n            val int21 = (int11 - int12) * (int11 -\
    \ int12) / 256\n            val int22 = (int11 - int12) * (int11 - int12) / 512\n\
    \            val int23 = (int11 - int12) * (int11 - int12) / 1024\n          \
    \  val int24 = (int11 - int12) * (int11 - int12) / 2048\n            val int25\
    \ = (int11 - int12) * (int11 - int12) / 4096\n            val int26 = (int11 -\
    \ int12) * (int11 - int12) / 8192\n            val int27 = (int11 - int12) * (int11\
    \ - int12) / 16384\n            val int28 = (int11 - int12) * (int11 - int12)\
    \ / 32768\n            val int29 = (int11 - int12) * (int11 - int12) / 65536\n\
    \            val int30 = (int11 - int12) * (int11 - int12) / 131072\n        \
    \    val ", "        val start = interval1._1\n        val end = interval2._1\n\
    \        if(start <= end){\n            val start = interval1._2\n           \
    \ val end = interval2._2\n            if(start >= end){\n                \"\"\n\
    \            }else if(start <= end){\n                val start = interval1._2\n\
    \                val end = interval2._2\n                if(start <= end){\n \
    \                   val x = math.ceil(math.abs((end - start)))\n             \
    \       if(isPrime(x)){\n                        \"YES\"\n                   \
    \ }else{\n                        \"NO\"\n                    }\n            \
    \    }else{\n                    \"NO\"\n                }\n            }else{\n\
    \                val start = interval1._2\n                val end = interval2._2\n\
    \                if(start >= end){\n                    \"NO\"\n             \
    \   }else{\n                    val start = interval1._2\n                   \
    \ val end = interval2._2\n                    if(start <= end){\n            \
    \            val x = math.ceil(math.abs((end - start)))\n                    \
    \    if(isPrime(x)){\n                            \"YES\"\n                  \
    \      }else{\n                            \"NO\"\n                        }\n\
    \                    }else{\n                        \"NO\"\n                \
    \    }\n                }\n            }\n        }else{\n            \"\"\n \
    \       }", "        val inter = interval1._2 & interval2._2\n        if (inter.isEmpty)\n\
    \            return \"NO\"\n        if (interval1._1 <= interval2._1 && interval2._1\
    \ <= interval1._1)\n            return inter.size == 1 ? \"YES\" : \"NO\"\n  \
    \      if (interval1._1 > interval2._1)\n            return \"NO\"\n        if\
    \ (interval1._1 <= interval2._1 && interval1._1 > interval2._1)\n            return\
    \ \"NO\"\n        if (interval1._2 <= interval2._2 && interval1._2 > interval2._2)\n\
    \            return \"NO\"\n        return \"YES\""]
stop_tokens:
- "\n    }\n"
