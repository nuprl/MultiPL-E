name: HumanEval_111_histogram
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a string representing a space separated lowercase letters, return\
  \ a map\n    // of the letter with the most repetition and containing the corresponding\
  \ count.\n    // If several letters have the same occurrence, return all of them.\n\
  \    // Example:\n    // >>> histogram((\"a b c\"))\n    // (Map[String,Long](\"\
  a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l))\n    // >>> histogram((\"a b b a\"))\n   \
  \ // (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    // >>> histogram((\"a b c\
  \ a b\"))\n    // (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    // >>> histogram((\"\
  b b b b a\"))\n    // (Map[String,Long](\"b\" -> 4l))\n    // >>> histogram((\"\"\
  ))\n    // (Map[String,Long]())\n    def histogram(test : String) : Map[String,Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b\
  \ b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"\
  d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"\
  r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"\
  b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\"\
  \ -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n\
  \    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\
  \n}\n"
completions: ["        val letters = test.split(\" \").toList\n        val histogram\
    \ = new collection.mutable.HashMap[String,Long]\n        for (letter <- letters)\
    \ histogram.put(letter, histogram.getOrElse(letter,0) + 1)\n        histogram.map{case\
    \ (k,v) => (k, v)}.toMap", "        val map = scala.collection.mutable.Map.empty[String,Long]\n\
    \        for (letters <- test.split(\" \")) {\n            val pair = map.getOrElseUpdate(letters,\
    \ 1l)\n            map += letters -> pair + 1l\n        }\n        map.toMap",
  '        test.split(" ").groupBy(_).map{case (k,v) => k -> v.size}.maxBy(_._2).map{case
    (k,v) => k -> v}', "        var histogram = Map[String,Long]()\n        test.split(\"\
    \\\\s\").foreach(letter => histogram(letter.toString -> 0l) += 1 )\n        histogram",
  "        val chars = test.toList\n        val counts = chars.foldLeft(Map[String,Long]())((map,char)\
    \ => {\n            val current = map.getOrElse(char, 0L)\n            map + (char\
    \ -> (current + 1))\n        })\n        counts.toMap", '        test.toList.flatMap(x
    => x.toCharArray).groupBy(x => x).map(x => (x._1,x._2.length)).toMap', "     \
    \   val chars = test.toLowerCase().toCharArray\n        val maxCount = new mutable.HashMap[Char,Long]()\n\
    \        for (c <- chars) {\n            if (maxCount.get(c) == null) maxCount.put(c,\
    \ 1l)\n            else if (maxCount.get(c) >= 1L) maxCount.put(c, maxCount.get(c)+1L)\n\
    \            else maxCount.put(c, maxCount.get(c)-1L)\n        }\n        maxCount.toMap",
  "        var mMap = Map[String,Long]()\n        for (c <- test.split(\" \"))\n \
    \           if (c.nonEmpty) {\n                mMap += (c -> 1)\n            }\n\
    \        val maxCount = mMap.values.max\n        mMap.filter(_._2 == maxCount).sortBy(_._2).map\
    \ { case (c,count) => c -> count }.toMap", "        val m = mutable.Map[String,Long]()\n\
    \        test.toList.map(l => m.updated(l,0L)) // update\n        m.map(m => m._1\
    \ -> m._2) // unzip", "        val freq = new mutable.HashMap[String,Long]\n \
    \       test.split(\" \").foreach(x => {\n            freq.getOrElseUpdate(x,\
    \ 1L)\n        })\n        freq.mapValues(x => freq(x) - 1) // subtract one from\
    \ count if same letter", "        val list = test.split(\" \")\n        var freqs\
    \ = mutable.Map[String,Long]()\n        for (letter <- list) {\n            freqs\
    \ += letter->freqs.getOrElse(letter,0)+1\n        }\n        freqs.toMap", " \
    \       val tokens = test.split(' ')\n        val letters = tokens.toSet\n   \
    \     val counts = mutable.Map.empty[String,Long]\n        for (letter <- letters)\
    \ {\n            counts += letter -> (tokens.count(letter -> _))\n        }\n\
    \        counts", "      var m = Map[String, Long]()\n      test.split(\" \").foreach(letter\
    \ => {\n        val count = m.getOrElse(letter, 0)\n        m.put(letter, count\
    \ + 1);\n      })\n      m", "      var map = Map[String,Long]()\n      var letters\
    \ = test.split(\" \").map(_.toLowerCase)\n      letters.foreach(letter => {\n\
    \        map += (letter -> map.get(letter).getOrElse(0) + 1)\n      })\n     \
    \ map", "        test.split(' ').toList.map(x => (x,test.count(x)) ).groupBy(x\
    \ => (x._1)).mapValues(_.size).map{ case (k, v) => (k.mkString(\"\"), v) }.toMap",
  "        if (test.isEmpty) Map.empty\n        else {\n            val chars = test.toUpperCase().split(\"\
    \ \").map(_.toLower)\n            val counts = chars.foldLeft(Map[String,Long]())((map,\
    \ c) => (c -> (map.getOrElse(c, 0) + 1))) \n            counts.map { case (k,\
    \ v) => k -> (v.get * v._2) }\n        }", "        val words = test.split(\"\
    \ \")\n        var res = new Map[String,Long]()\n        for (word <- words) {\n\
    \            var cnt = 0\n            var maxCnt = -1\n            var maxStr\
    \ = \"\"\n            for (char <- word) {\n                cnt += 1\n       \
    \         if (maxCnt < cnt) maxCnt = cnt\n                if (res.getOrElse(char,0L)\
    \ < cnt) {\n                    res(char) = cnt\n                    maxStr +=\
    \ char\n                }\n            }\n            if (maxCnt > 0) {\n    \
    \            res(maxStr) = maxCnt\n            }\n        }\n        res", '      test.toLowerCase
    splitBy " " grouped (x => x) mapValues (_.toList) mapValues (_.size) toMap', '        test.flatMap
    { x => x.split(" ").map(x => x -> 1) }.groupBy(_._1).mapValues(_.length).map{
    case (k,v) => (k,v.toLong) }.toMap', "       var histo = new mutable.HashMap[String,Long]\n\
    \       var tokens = test.split(\" \").toList\n       var mostCount = math.MaxLong\n\
    \       for (token <- tokens) {\n         val count = histo.count(token)\n   \
    \      if (count > mostCount) {\n           mostCount = count\n           histo\
    \ = histo.remove(token)\n         }\n       }\n       histo.toMap", "        val\
    \ m = test.toLowerCase.toStream.grouped(1).toList.map(c => c.head -> c.size.toLong).reduceLeft((x,y)\
    \ => x).map(_._2)\n        if(m.isEmpty) Map.empty\n        else m", "       \
    \ val histogram = mutable.Map[String,Long]()\n        for (letter <- test.split(\"\
    \ \")) {\n            histogram.put(letter, histogram.getOrElse(letter, 0L) +\
    \ 1)\n        }\n        histogram.toMap", "        val counters = mutable.Map[String,Long]()\n\
    \        test.split(\" \").foreach(c => {\n            val splitted = c.toLowerCase\
    \ :: counters\n            if(counters.contains(splitted.head)) {\n          \
    \      counters(splitted.head) += 1\n            } else {\n                counters(splitted.head)\
    \ = splitted.length\n            }\n        })\n        counters", "        def\
    \ buildTree(s : String) : Map[String,Long] = s match {\n            case \"\"\
    \ => Map()\n            case _ => {\n                val splits = s.split(\" \"\
    )\n                val m = new mutable.LinkedHashMap[String,Long]()\n        \
    \        var count = 0L\n                var max = 0\n                for (i <-\
    \ 0 until splits.length-1) {\n                    val v = splits(i)\n        \
    \            if (m.contains(v)) {\n                        val vv = m(v)\n   \
    \                     val c = vv.get + count\n                        m.updated(v,\
    \ new Long(c))\n                    } else {\n                        m.put(v,\
    \ new Long(count))\n                    }\n                    if (count > max)\
    \ {\n                        max = count\n                    }\n            \
    \        count += 1L\n                }\n                m\n            }\n  \
    \      }\n\n        // Split into lines\n        val splits = test.split(\"\\\
    n\")\n        val lines = splits.map(_.split(\" \")).filter(_.nonEmpty)\n\n  \
    \      // Sort lines by number of occurrences of each letter\n        var map\
    \ = lines.groupBy(_._1).mapValues(_.size)\n\n        // Sort map by largest to\
    \ smallest values\n        map = map.toSeq.sortWith((c1, c2) => c1._2 < c2._2\
    \ ? -1 : c1._1 == c2._1 ? 0 : 1)\n\n        // Build map of letters\n        val\
    \ m = buildTree(splits.last)\n        val result = map.toSeq.map {\n         \
    \   case (k,v) => (k,v / max)\n        }\n        map.clear()\n        result",
  "        // your code here\n        var map = mutable.Map.empty[String,Long]\n \
    \       for (letter <- test.toList) {\n            if (map.contains(letter)) {\n\
    \                map(letter) += 1\n            }\n            else {\n       \
    \         map(letter) = 1\n            }\n        }\n        return map", "  \
    \      test.foldLeft(Map[String, Long]()) {\n            case(acc, letter) =>\
    \ acc.getOrElse(letter, 0l) += 1\n        }", "        val chars = test.toCharArray.distinct.sorted\n\
    \        chars.foldRight(Map[String,Long]())((map,x) => {\n            val count\
    \ = map.getOrElse(x,0L) + 1L\n            map += (x -> count)\n            map\n\
    \        })", "        val words = (test+test).split(\" \") map { s => s.toLowerCase\
    \ }.toList\n        val letters = words.flatMap(_.toCharArray).groupBy(_).toList.sortWith(_._2\
    \ < _._2)\n        val map = new collection.mutable.HashMap[String,Long]()\n \
    \       letters.map {case (letter,list) =>\n            if(map.contains(letter)){\n\
    \                val oldCount = map.get(letter)\n                map.put(letter,\
    \ oldCount+1)\n            } else {\n                map.put(letter, list.length)\n\
    \            }\n        }\n        map.toMap", "        val split = test.split('\
    \ ')\n        val map = mutable.HashMap[String,Long]()\n        split.foreach{\n\
    \          element =>\n            if(map.contains(element)){\n              \
    \  map.update(element,map.get(element)+1)\n            } else {\n            \
    \    map.update(element,1L)\n            }\n        }\n        map.toMap", " \
    \       var counter = mutable.Map.empty[String,Long]\n        for(letter <- test.toUpperCase().split(\"\
    \ \")) {\n            if(counter.contains(letter)) {\n                val c =\
    \ counter(letter) + 1\n                counter(letter) = c\n            } else\
    \ {\n                counter.put(letter, 1)\n            }\n        }\n      \
    \  counter.toMap", "        def getCount(letters: String, count: Map[String, Long],\
    \ count: Long) : Map[String, Long] = {\n            if (letters.isEmpty) {\n \
    \               count\n            } else {\n                val first = letters.head\n\
    \                val rest = letters.tail\n                val newCount = count.get(first)\
    \ + getCount(rest, count, count).getOrElse(count).asInstanceOf[Long]\n       \
    \         (first -> (newCount + count.getOrElse(first, _)))\n            }\n \
    \       }\n        val counts = mutable.Map[String,Long]()\n        test.toLowerCase.split(\"\
    \ \").foreach(x => counts += x -> 1L)\n        getCount(test, counts, 0L)", " \
    \       val letters = test.split(\" \").toList\n        val counts = letters.groupBy(identity).mapValues(_.size).asInstanceOf[Map[String,\
    \ Long]]\n        val maxCount = counts.maxBy(_._2)._1\n        val maxCountLetter\
    \ = maxCount match {\n            case m if m == counts.size => \"\"\n       \
    \     case m if m > counts.size => \"\"\n            case m if m == counts.size\
    \ + 1 => counts.keys.last\n            case m if m == counts.size + 2 => counts.keys.last\n\
    \            case m if m == counts.size + 3 => counts.keys.last\n            case\
    \ m if m == counts.size + 4 => counts.keys.last\n            case m if m == counts.size\
    \ + 5 => counts.keys.last\n            case m if m == counts.size + 6 => counts.keys.last\n\
    \            case m if m == counts.size + 7 => counts.keys.last\n            case\
    \ m if m == counts.size + 8 => counts.keys.last\n            case m if m == counts.size\
    \ + 9 => counts.keys.last\n            case m if m == counts.size + 10 => counts.keys.last\n\
    \            case m if m == counts.size + 11 => counts.keys.last\n           \
    \ case m if m == counts.size + 12 => counts.keys.last\n            case m if m\
    \ == counts.size + 13 => counts.keys.last\n            case m if m == counts.size\
    \ + 14 => counts.keys.last\n            case m if m == counts.size + 15 => counts.keys.last\n\
    \            case m if m == counts.size + 16 => counts.keys.last\n           \
    \ case m if m == counts.size + 17 => counts.keys.last\n            case m if m\
    \ == counts.size + 18 => counts.keys.last\n            case m if m == counts.size\
    \ + 19 => counts.keys.last\n            case m if m == counts.size + 20 => counts.keys.last\n\
    \            case m if m == counts.size + 21 => counts.keys.last\n           \
    \ case m if m == counts.size + 22 => counts.keys.last\n            case m if m\
    \ == counts.size + 23 => counts.keys.last\n            case m if m == counts.size\
    \ + 24 => counts.keys.last\n            case m if m == counts.size + 25 => counts.keys.last\n\
    \            case m if m == counts.size + 26 => counts.keys.last\n           \
    \ case m if m == counts.size + 27 => counts.keys.last\n            case m if m\
    \ == counts.size + 28 => counts.keys.last\n            case m if m == counts.size\
    \ + 29 => counts.keys.last\n            case m if m == counts.size + 30 => counts.keys.last\n\
    \            case m if m == counts.size + 31 => counts.keys.last\n           \
    \ case m if m == counts.size + 32 => counts.keys.last\n            case m if m\
    \ == counts.size + 33 => counts.keys.last\n            case m if m == counts.",
  "        val words = test.split(\"\\\\s+\")\n        val m   = words.toMap\n   \
    \     var result = (0 /: (m.size.toLong)).toMap\n        val it = (0 to m.size.toLong).iterator\n\
    \        var k = 0l\n        while (it.hasNext) {\n            val key = it.next\n\
    \            val value = (m.getOrElse(key,0l))\n            if (value > result(k))\
    \ {\n                result(k) = value\n                k += 1\n            }\n\
    \        }\n        result", "        val splitted = test.split(\" \").toList\n\
    \        val freqs = splitted.foldLeft(Map[String,Long]()){ (a,s) =>\n       \
    \     val spl = s.split(\"[\\\\s]+\")\n            val key = spl(0)\n        \
    \    val count = spl(1)\n            a(key) += count.toLong\n            a\n \
    \       }\n        freqs", "        var map = new TreeMap[String,Long]()\n   \
    \     var array = test.split(\" \")\n        for (i <- 0 until array.length) {\n\
    \            val item = array(i)\n            val count = map.getOrElse(item,0)\n\
    \            map(item) = count + 1\n        }\n        map.toMap", "        val\
    \ counter = mutable.Map[String,Long]()\n        val tokens = test.split(\" \"\
    ).toList\n        tokens foreach { t =>\n            if(counter.contains(t)) {\n\
    \                counter(t) = counter(t) + 1\n            } else {\n         \
    \       counter(t) = 1 // default value\n            }\n        }\n        counter.mapValues\
    \ { v => v }.maxBy(_._1)", "        val m = mutable.HashMap.empty[String,Long]\n\
    \        test.split(\" \").foreach(x => m.update(x,m.getOrElse(x,0) + 1l))\n \
    \       m.toMap", "        val map = mutable.Map.empty[String,Long]\n        test.split(\"\
    \ \").foreach(x => {\n            val n = map.getOrElse(x,0)\n            map\
    \ += (x -> n + 1)\n        })\n        map.toMap", "        val map = mutable.Map[String,Long]()\n\
    \        val counts = test.split(\" \").toList.map(word => word -> test.count(word.toLowerCase\
    \ => 1))\n        counts foreach (x => map += x)\n        map", "        var m\
    \ = Map[String,Long]();\n        var max = 0l;\n        var maxKey = \"\"\n  \
    \      for (word <- test.split(\" \")) {\n            val key = word.toUpperCase\n\
    \            if(m.contains(key)) {\n                m(key) = m(key) + 1l\n   \
    \         } else {\n                m(key) = m.getOrElse(key, 0) + 1l\n      \
    \      }\n            if(m(key) > max) {\n                max = m(key)\n     \
    \           maxKey = key\n            }\n        }\n        Map(maxKey -> max)",
  "        val letters = test.split(\" \").toList\n        val maxValue = letters.count(x\
    \ => x.toChar.toLowerCase == 'a') || letters.count(x => x.toChar.toLowerCase ==\
    \ 'b') || letters.count(x => x.toChar.toLowerCase == 'c') || letters.count(x =>\
    \ x.toChar.toLowerCase == 'd')\n        letters.groupBy(x => x.toChar.toLowerCase\
    \ )\n            .mapValues(x => x.length)\n            .maxBy(x => x._2)\n  \
    \          ._1", '        test.toLowerCase split " " groupBy (_ == test) mapValues
    (_.length)', "        test.split(\" \").toList.groupBy(x => x).toList\n      \
    \    .sortWith((t1, t2) => t1._2 < t2._2 || (t1._2==t2._2 && t1._1 > t2._1))\n\
    \          .map{ case (letter,occurrences) => letter -> occurrences.size }\n \
    \         .groupBy(x => x)\n          .mapValues(_.size)\n          .toMap", '        test.split("
    ").map { a => a -> test.count(a).asInstanceOf[Long]}.toMap', '        test.toList.map(letter
    => letter -> test.count(letter)).toMap.maxBy{case (k,v) => v}', "        var res\
    \ = Map[String,Long]()\n        for (letter <- test.split(\" \")) {\n        \
    \    if (res.contains(letter)) {\n                val curVal = res(letter)\n \
    \               val newVal = curVal + 1\n                res = res.update(letter\
    \ -> (newVal))\n            } else {\n                res = res.update(letter\
    \ -> (1L))\n            }\n        }\n        res", "        val result = mutable.Map.empty[String,Long]\n\
    \        test.toLowerCase split ' ' foreach { c =>\n            val count = test.count(_\
    \ == c)\n            if (result.contains(c)) {\n                result(c) += count\n\
    \            } else {\n                result(c) += count\n            }\n   \
    \     }\n        result.toMap", "        // Split test into array of single letters\n\
    \        var letters = test.split(\" \")\n        // Keep track of letters with\
    \ their counts\n        var lettersWithCount = Map[String,Long]()\n        //\
    \ Loop through letters and count them\n        for (letter <- letters) {\n   \
    \         lettersWithCount += letter -> (lettersWithCount.get(letter) match {\n\
    \                case None => 1\n                case Some(c) => (c + 1) \n  \
    \          })\n        }\n        // Return count of unique letters with their\
    \ counts\n        lettersWithCount.toMap", "        val map = test.split(\" \"\
    ).map(x => x.toLowerCase -> 1l).toMap\n        val maxKey = test.split(\" \").map(x\
    \ => x.toLowerCase).maxBy(_._2)._1\n        val maxValue = test.split(\" \").map(x\
    \ => x.toLowerCase).maxBy(_._2)._2\n        map.filter(_._1 == maxKey).map(_._2)",
  "        val counts = test.groupBy(c => c).toSeq.sortWith(_.count(_ == _) > _.count(_\
    \ == _))\n        val map = counts.toMap.mapValues(_.length)\n        return map",
  "        val counts = test.\n            split(\" \").\n            map(_.toLowerCase).\n\
    \            groupBy(identity).\n            map(x => (x._1, x._2.length)).toMap\n\
    \        val mostFrequent = counts.maxBy(x => x._2)\n        if (counts == mostFrequent)\
    \ mostFrequent else Map[String,Long]()", "        if (test.isEmpty) {\n      \
    \      return Map()\n        }\n        val tokens = test.split(\" \").toList\n\
    \        val letters : Map[String,Long] = tokens.groupBy(t => t).mapValues(_.size)\n\
    \        val maxCount = letters.max\n        val maxCountLetter = letters.maxBy(_._2)._1\n\
    \        (letters ++ Map(maxCountLetter -> maxCount)).filter(_._2 == maxCount).map(_._1)",
  "        val words = test.split(\" \").toList\n        val histogram = new mutable.HashMap[String,Long]()\n\
    \        for(word <- words){ histogram.put(word, 1L) }\n        histogram.toMap",
  "        val histograms = test.split(\" \").map(letter => {\n            (letter,\
    \ test.split(letter).length)\n        }).toMap.groupBy { _._2 }.map { case (k,\
    \ v) => k -> (v.maxBy(_._1)._1 + 1l) }\n        if (histograms.isEmpty) {\n  \
    \          Map[String,Long]()\n        } else {\n            histograms\n    \
    \    }", "        val map = mutable.LinkedHashMap(\"b\" -> 0)\n        test.toCharArray().flatMap\
    \ { c => \n            if (map.contains(c)) map.update(c, map.get(c) + 1l) else\
    \ map.put(c, 1l)\n            c \n        }.toMap", "        var counts = HashMap[String,\
    \ Long]()\n        var res : Map[String,Long] = HashMap[String,Long]()\n     \
    \   for ( elem <- test.split(' ') ) {\n            if ( counts.get(elem) == null\
    \ ) counts += elem -> 1\n            else counts += elem -> counts.get(elem) +\
    \ 1\n        }\n        for ( (key, value) <- counts ) res = res.updated(key,\
    \ value)\n        res", "        val letterCounts = mutable.Map.empty[String,Long]\n\
    \        test.foreach(charToInt _){ count =>\n            val letter = test.charAt(count)\n\
    \            if(letterCounts.contains(letter)) {\n                letterCounts(letter)\
    \ += 1\n            }\n            else {\n                letterCounts(letter)\
    \ = 1\n            }\n        }\n        letterCounts.toMap", "        val letters\
    \ = test.split(\" \").toList\n        val map = new mutable.HashMap[String, Long]()\n\
    \        for (letter <- letters) {\n            if (!map.contains(letter)) {\n\
    \                map.put(letter, 1)\n            } else {\n                map.put(letter,\
    \ map.get(letter) + 1)\n            }\n        }\n        map.toMap", "      \
    \  val map = mutable.Map[String,Long]()\n        test.split(\" \").toList.foreach(s\
    \ => map.update(s, map.getOrElse(s, 0L) + 1))\n        val biggest = map.filter(_._2\
    \ > map.values.max).sortBy(_._2).last\n        val small = map.filter(_._2 ==\
    \ biggest._2).sortBy(_._1).last\n        Map(small._1 -> biggest._2)", "     \
    \ var chars = test.toList\n      var map : Map[String,Long] = Map()\n      chars.foreach(c\
    \ => if (!map.contains(c)) map += c -> 1l)\n      chars.distinct.foreach { c =>\
    \ if (!map.contains(c)) map += c -> 1l}\n      chars.foreach(c => map.get(c.toLowerCase)\
    \ match {\n        case None => map += c -> 1l\n        case Some(v) => (map +\
    \ (c -> map.get(c) + v))\n      })\n      map // the map with the letter with\
    \ the most repetition", "        test.trim().split(\" \").foldLeft(Map[String,Long]()){\n\
    \            (map, letter) => map + (letter -> (map.getOrElse(letter, 0l) + 1l))\n\
    \        }", "        var map = Map[String,Long]()\n        for (letter <- test.split(\"\
    \ \") ){\n            val count = map.getOrElse(letter,0L)\n            map +=\
    \ (letter -> (count + 1))\n        }\n        map", "        val a = test.split(\"\
    \ \").map(x => (x, 1))\n        val grouped = a.groupBy(_._1).mapValues(_.size)\n\
    \        return grouped.mapValues(_.toList).toMap", "        val data = test.split(\"\
    \ \").toList\n        val occurrences = mutable.Map[String,Long]()\n        for\
    \ (dataStr <- data) {\n            if (occurrences.containsKey(dataStr)) {\n \
    \               occurrences(dataStr) += 1\n            } else {\n            \
    \    occurrences(dataStr) =1\n            }\n        }\n        occurrences.toMap",
  "        var map = new HashMap[String,Long]()\n        for (c <- test.toCharArray)\
    \ map += c.toString() -> map.getOrElse(c.toString,0l) + 1l\n        map.toMap",
  "        val result = new mutable.HashMap[String,Long]()\n        for (letter <-\
    \ test.split(\" \"))\n        {\n            if (result.contains(letter)) result(letter)\
    \ += 1\n            else result.put(letter, 1)\n        }\n        result.toMap",
  '        test.split(" ").map(word => word -> test.split(word).length).toMap', " \
    \       var ms = mutable.Map[String,Long]()\n        for(i <- test.split(\" \"\
    )){\n            if(i.length() == 0){continue}\n            if(i.toLowerCase in\
    \ ms){\n                ms(i.toLowerCase) += 1 \n            }\n            else\
    \ {\n                ms(i.toLowerCase) = 1l\n            }\n        }\n      \
    \  ms.toMap", "        val count = mutable.Map[String,Long]()\n        val maxCount\
    \ = mutable.Map[String,Long]()\n        val map = test.split(\" \").map(n => if(count.contains(n))\
    \ count+=(n->count.getOrElse(n,0)+1) else count+=(n->1))\n        val result =\
    \ map.groupBy(_._1).mapValues(_.map(_._2).sum).filter { case (k,v) => v > 1 }.mapValues(_.toLong).toMap\n\
    \        maxCount.zip(result).filter { case (k,v) => v > 1 }.mapValues(_.toLong).map{case\
    \ (k,v) => k+\" \"+ v.toString }", "        if(test.isEmpty || test.indexOf('\
    \ ')==-1) Map()\n        else test.split(' ').groupBy(x=>x).map(x=>x(x._2).map(x=>x._1)).toMap",
  "        if (test.length == 0) {\n            Map()\n        } else {\n        \
    \    var freq = mutable.Map.empty[String,Long]\n            test.split(' ').map(x\
    \ => freq += x -> (freq.getOrElse(x,0L) + 1L)).filter(_._2 > 1).map(_._1).toMap\n\
    \        }", "        var map = Map[String,Long]()\n        var count = new mutable.HashMap[String,Long]()\n\
    \n        for (i <- test.split(\" \")){\n            val t = i.toUpperCase + i\n\
    \            if (map.contains(t)) map.get(t) += 1\n            else  count +=\
    \ (t,1L)\n        }\n        map = map.toMap\n        if (count.size == 0) map\
    \ = Map[String,Long]()\n        map.foreach((k,v) => (k,v.toLong))\n        map",
  "        if(test.isEmpty) Map.empty[String,Long]\n        else test.count(letter\
    \ => test.split(\" \").count(l => l.contains(letter))).mapValues(_.toString).map(x\
    \ => (x._1, x._2.toLong)).toMap", "        val letters = test.split(\" \").toSet\n\
    \        val result = mutable.Map.empty[String, Long]\n        letters.foreach\
    \ {x => \n           if (result.contains(x)) {\n               result(x.toLong)\
    \ += 1\n           } else {\n              result += (x.toLong -> 1L)\n      \
    \     }\n        }\n        result", "        def histogramHelper(test : String,\
    \ seen : mutable.Set[String], results : mutable.Map[String, Long]) = {\n     \
    \       val words = test.split(\" \")\n            val maxCount = 1L\n       \
    \     val maxWord = words(0)\n            for(word <- words) {\n             \
    \   val currentCount = results.remove(word)\n                if(currentCount >\
    \ 0) {\n                    if(currentCount > maxCount) {\n                  \
    \      maxCount = currentCount\n                        maxWord = word\n     \
    \               }\n                    results += ((word) -> currentCount)\n \
    \               }\n                else {\n                    if(!seen.contains(word))\
    \ {\n                        seen += word\n                        histogramHelper(word,\
    \ seen, results)\n                    }\n                }\n            }\n  \
    \          (maxWord, maxCount)\n        }\n        val seen = mutable.Set()\n\
    \        val results = mutable.Map[String, Long]()\n        histogramHelper(test,\
    \ seen, results)", "        test.toList.map(x => (x,1)).reduceByKey(_ + _).map{\n\
    \            case ((x,y),z) => x -> (z.toLong/y.toLong).ceil.toInt\n        }.toMap",
  "        val map = new mutable.HashMap[String,Long]()\n        for(c <- test) {\n\
    \            val count = map.getOrElse(c, 0)\n            map.update(c, (count\
    \ + 1l))\n        }\n        map ", "        // Split on space\n        var counts\
    \ = new mutable.HashMap[String,Long]\n        val splits = test.split(\" \").toList\n\
    \        splits.foreach{ elem =>\n            var elem = elem.toLowerCase\n  \
    \          if (!counts.contains(elem)) {\n                counts += (elem -> 1L)\n\
    \            } else {\n                val old = counts.get (elem)\n         \
    \       counts.put(elem,old + 1L)\n            }\n        }\n        // Return\
    \ map with most repeated element\n        val sorted = counts.toList.sortWith(\
    \ (x,y) => (y._2 > x._2)  || (x._2 == y._2))\n        val maxCount = sorted.head._2\n\
    \        val maxElem = sorted.head._1\n        val retVal = new mutable.HashMap[String,Long]\n\
    \        retVal.put(maxElem,maxCount)\n        return retVal", "        test.toLower.split(\"\
    \\\\s+\").groupBy(_).map { \n        case (k, v) => (k, v.length.toLong) \n  \
    \      }.toMap", "        var freq = Map[String,Long]()\n        test.split(\"\
    \ \").toList.foreach(x => {\n            var temp = freq.getOrElse(x,0)\n    \
    \        freq += (x -> temp)\n        })\n        return freq.toMap", "      \
    \  val histogram = test.split(' ').toList.foldLeft(Map[String,Long]()){\n    \
    \        (m,c) =>\n                val item = m.getOrElseUpdate(c,0L)\n      \
    \          m += c -> (item + 1)\n            }\n            histogram", "    \
    \    val testArray = test.split(\" \").map(_.toLowerCase).toList\n        val\
    \ histogram = testArray.toMap\n        testArray.toMap", "        var map : Map[String,Long]\
    \ = Map()\n        test.split(\" \").foreach{ char =>\n            val count =\
    \ map.get(char).map(x => x += 1).getOrElse(1)\n            map += (char -> (count.toLong\
    \ + 1))\n        }\n        map", "        val counts = test.split(' ').groupBy(s\
    \ => s)\n        val result = counts.reduceLeft(_ + _).map(t => (t._1._1, t._2))\n\
    \        val keyed = new mutable.LinkedHashMap[String,Long]\n        result.foreach(x\
    \ => keyed += x -> 1L)\n        keyed", "        // Split string into a list,\
    \ group letters by their first letter\n        val letters = test.toList.groupBy(_.charAt(0))\n\
    \        // Create a map and add every element in the list as a key and how many\
    \ times it appears in the list as a value\n        letters.map{ case (letter,\
    \ occurrences) => letter -> occurrences }.map(_.toMap)", "        val letters\
    \ = test.split(\" \").toList\n        val lettersWithCount = letters.groupBy(x\
    \ => x).mapValues(_.size).toMap\n        if (lettersWithCount.isEmpty) {\n   \
    \         lettersWithCount\n        } else {\n            lettersWithCount.maxBy(_._2)._1\n\
    \        }", "        val freqs = mutable.Map[String, Long]()\n        var count\
    \ = 0\n        for (c: Char <- test.toCharArray) {\n            if (freqs.contains(c))\n\
    \                freqs(c) += 1\n            else {\n                count += 1\n\
    \                freqs(c) = 1\n            }\n        }\n        freqs.toMap",
  "        val counts = mutable.Map[String,Long]()\n        val tokens = test.split(\"\
    \ \").map(_.toLowerCase )\n        tokens foreach {x =>\n            val v = counts.count(x)\n\
    \            if ( v > counts.count(x)) {\n                counts += x -> 1\n \
    \           } else if ( v == counts.count(x)) {\n                counts(x) = counts(x)\
    \ + 1\n            }\n        }\n        counts.toMap", "        val test = test.split(\"\
    \ \").toMap\n        var m = 0L\n        var max = 0L\n        test.foreach {\n\
    \            pair =>\n            val count = pair._1.count(_ == pair._1)\n  \
    \          val key = pair._1\n            if (count > max) max = count\n     \
    \       if (count > m) {\n                m = count\n            }\n        }\n\
    \        test.filter { case (k, v) => v == max }", "        val pattern = \"[a-z]+\"\
    .r\n        val matcher = pattern.findFirstIn(test)\n        val histogram = new\
    \ mutable.HashMap[String,Long]\n        var currentLetter = \"\"\n        var\
    \ currentCount = 0\n        var repetition = 0\n        var lastChar = \"\"\n\
    \        while (matcher.hasNext) {\n            val next = matcher.next().toString.toLowerCase\n\
    \            val repeat = test.split(next).length\n            if (repeat > currentCount)\
    \ {\n                currentLetter = next\n                currentCount = repeat\n\
    \            }\n            if (lastChar == currentLetter) {\n               \
    \ repetition = repetition + 1\n            } else {\n                if (repetition\
    \ > 0) {\n                    histogram.put(currentLetter, currentCount)\n   \
    \             }\n                repetition = 1\n                currentCount\
    \ = 1\n                lastChar = currentLetter\n            }\n        }\n  \
    \      if (repetition > 0) {\n            histogram.put(lastChar, currentCount)\n\
    \        }\n        histogram.toMap", '        test.split(" ").map(_.toLowerCase).groupBy(identity).map(x
    => (x._2, x._1.size)).toMap', "        test.toList.zipWithIndex.groupBy(identity)\n\
    \           .mapValues(_.size.toLong)\n           .maxBy(_._2)\n           .mapValues(_._1)\n\
    \           .toMap", "        val letters = test.toUpperCase().toList\n      \
    \  val result = new mutable.HashMap[String,Long]\n        for (letter <- letters)\
    \ {\n            if (letter in result.keySet) {\n                result(letter)\
    \ += 1\n            } else {\n                val count = letters.count(_ == letter)\
    \ + 1\n                result.put(letter, count)\n            }\n        }\n \
    \       result", "        val chars = test.split(\" \").toList.sortWith(_ < _)\n\
    \        val count = mutable.HashMap.empty[String,Long]\n        chars foreach\
    \ {c => c match {\n            case a if !count.containsKey(a) => count(c) = 1l\n\
    \            case a if count.contains(a) => count(c) += 1\n            case _\
    \ => null\n        }}\n        count.toMap", "        test.toList match {\n  \
    \          case Nil => Map.empty[String,Long]\n            case x => x.grouped(1).map\
    \ { case (k, v) => (k, v.size) }.toMap\n        }", "        val letters = test.split(\"\
    \ \").toList\n        val map = mutable.Map[String,Long]()\n        letters.foreach\
    \ { letter =>\n            map.put(letter, map.getOrElse(letter, 0L) + 1)\n  \
    \      }\n        letters.map{letter => (letter, map.getOrElse(letter, 0L))}",
  "        val testString = test.split(\" \").toList\n        val testMap = new mutable.HashMap[String,Long]()\n\
    \        testString.foreach(x => {\n            if(testMap.contains(x))\n    \
    \            testMap(x) = testMap(x) + 1\n            else\n                testMap(x)\
    \ = 1\n        })\n        testMap", "        val map = test.chars.groupBy(x =>\
    \ x).mapValues(_.size)\n        val max = map.maxBy(_.value)._1\n        val counts\
    \ = map.map(x => (x._1, x._2)/max)\n        Map(max -> counts.toSeq)", "     \
    \   test.split(\" \").groupBy(s => s).mapValues(_.size).map {\n            case\
    \ (k,v) => k -> v.longValue()\n        }", "        test.split(' ').map { x =>\
    \ x -> test.count(x) }.toMap", "        if (test.length == 0) {\n            Map[String,Long]()\n\
    \        } else {\n            val countMap = test.chars.map(c => c -> 1l).reduceByKey(_\
    \ + _).map(_._2)\n            val result = countMap.foldLeft(Map[String,Long]())\
    \ {\n                case (acc, (count, letter)) => acc + (letter -> (count.toDouble\
    \ / test.length))\n            }\n            result\n        }", '      test.toLowerCase.split().toList.groupBy(_).mapValues(_.size).maxBy(_._2).map(_._1).toMap',
  "        val result = mutable.Map.empty[String,Long]\n        for {\n          \
    \  letter <- test.split(' ').toList\n            count <- result.foldLeft(0)((count,\
    \ letter) => count + 1 if (result.getOrElse(letter, 0L) > count))\n        } yield\
    \ letter -> count", '        test.split(" ").map(word => word -> (test.count(word).reduceLeft{_
    + _}.toLong)).toMap', "        var freq = mutable.Map[String,Long]()\n       \
    \ var map = Map[String,Long]()\n        for(ch <- test.split(\" \")) {\n     \
    \       if(!map.contains(ch)) {\n                freq += ch -> 1\n           \
    \     map += ch -> 1\n            }\n            else {\n                val c\
    \ = map.get(ch)\n                map += ch -> c+1\n            }\n        }\n\
    \        freq.foreach { case (ch, count) =>\n            if(!map.contains(ch))\
    \ {\n                map += ch -> count\n            }\n        }\n        return\
    \ map", "        test.split(\" \").map(word => {\n            val arr = test.split(\"\
    \ \").toArray.filter(word => word != word)\n            val map = arr.map(arr\
    \ => arr -> (arr.toSet.size +1)).toMap\n            map.filter(_._2._2 > 0).map(_._1).toMap\n\
    \        }).reduceLeft(_ ++ _)", "        var counts : Map[String,Long] = new\
    \ mutable.HashMap[String,Long]();\n        var spaceChars = test.toCharArray();\n\
    \        for (i<-0 until spaceChars.length-1) {\n            val letter = Character.toString(spaceChars(i));\n\
    \            if(counts.contains(letter)) {\n                val count = counts(letter);\n\
    \                counts(letter) = count + 1;\n            } else {\n         \
    \       counts(letter) = 1;\n            }\n        }\n        counts;", "   \
    \     val map = Map((\"\") -> 0L)\n        for (letter <- test.toLowerCase().split(\"\
    \ \"))\n            if (map.contains(letter))\n                map(letter) +=\
    \ 1\n            else\n                map(letter)\n        map", "        if(test.isEmpty\
    \ || test.length == 0) return Map()\n        var map : Map[String,Long] = Map()\n\
    \        var counts : Map[String,Long] = Map()\n        for(letter <- test.split('\
    \ ')) {\n            if(counts(letter) == 0) counts(letter) = 1\n            else\
    \ {\n                val count = counts(letter)\n                counts(letter)\
    \ = count + 1\n                if(map.contains(letter)) map = map + (letter ->\
    \ (count + map(letter)))\n                else {\n                    map = map\
    \ + (letter -> count)\n                }\n            }\n        }\n        map",
  "        val map = test.toLowerCase flatMap test.split(\" \").map(x => x -> 1) toMap\n\
    \        val maxKey = map.toSeq.sortBy(_._2).last._1\n        val maxValue = map.get(maxKey)._1\n\
    \        val others = map - maxKey - maxValue\n        others.toMap", "      \
    \  val l = test.toLower.split(\" \")\n        // If there are no words, return\
    \ an empty map.\n        if (l.length == 0) return Map()\n        val map = new\
    \ mutable.HashMap[String,Long]()\n        // Count letters.\n        for (letter\
    \ <- l) {\n            if (map.contains(letter)) {\n                val oldCount\
    \ = map.get(letter)\n                val newCount = oldCount + 1\n           \
    \     map.put(letter,newCount)\n            } else {\n                map.put(letter,1L)\n\
    \            }\n        }\n        // Sort the map by counting letter occurrences.\n\
    \        val sorted = map.toList.sortBy(_._2)(Ordering.Int.reverse)\n        val\
    \ res = if (sorted.size == 1) {\n            // If only one letter, just return\
    \ the map with a single entry.\n            sorted.head\n        } else {\n  \
    \          // If multiple letters, return the letter with the most occurence and\
    \ the count.\n            val maxKey = sorted.last._1\n            val maxCount\
    \ = sorted.last._2\n            Map(maxKey -> maxCount)\n        }\n        return\
    \ res", "        val m = Map()\n        test.split(\" \").map { v => m.updated(v,\
    \ m.getOrElse(v, 0l) + 1) }\n        val m = Map((m.maxBy(_._2)._1, m.mapValues(_._1).sum))",
  "        val counts = mutable.Map[String,Long]()\n        test.toList.filter(_.isLetter).foreach(letter\
    \ => {\n            counts.put(letter, counts.getOrElse(letter, 0L) + 1)\n   \
    \     })\n        counts.toMap", "        def recurse(i : Int) : Map[String,Long]\
    \ = {\n            if (i == test.length) {\n                return Map.empty[String,Long]\n\
    \            }\n            var count : Long = 0\n            var letter : String\
    \ = test.charAt(i)\n            var currentMap : Map[String,Long] = Map.empty[String,Long]\n\
    \            for (x <- test(i+1 until test.length)) {\n                if (x ==\
    \ letter) {\n                    count += 1\n                }\n             \
    \   currentMap += letter -> count\n            }\n            recurse(i + 1)\n\
    \        }\n        recurse(0)", '        test.split(" ").groupBy(x => x).mapValues(_.size).maxBy(_._2)._1',
  "        val chars = test.toList\n        val charMap = chars.groupBy(identity).mapValues(_.size)\n\
    \        charMap.filter(_._2 > 1).mapValues(_._1)", "      val counter = scala.collection.mutable.Map[String,Long]()\n\
    \      var count = 0\n      test.split(' ').foreach( x => {\n        if ( counter.contains(x)\
    \ ) {\n          count = counter(x) + 1\n        } else {\n          counter(x)\
    \ = 1l\n        }\n      })\n      counter.filter( x => x._2 > 1 ).map( x => (x._1,\
    \ x._2) ).sortByKey( ascending )", "        val letters = test.split(' ').toList\n\
    \        val map = new mutable.HashMap[String,Long]()\n        for (letter <-\
    \ letters) {\n            val count = map.getOrElseUpdate(letter,0L)\n       \
    \     map.put(letter,count+(1L))\n        }\n        map.toMap", "        val\
    \ words = test.split(\" \").toList\n        val map = new mutable.HashMap[String,Long]\n\
    \        for (word <- words) {\n            map.put(word, map.getOrElse(word,\
    \ 0)+1)\n        }\n        map.toMap", "        test.toList.foldLeft(Map[String,Long]())((m,\
    \ c) => { \n            c split ' ' match {\n                case Array(l,_) =>\
    \ (l -> 1l) :: m\n                case _ => (c -> 1l) :: m \n            }\n \
    \       })", "        val list = test.split(' ')\n        val map = new collection.mutable.HashMap[String,Long]()\n\
    \        list.foreach {\n            letter =>\n                val count = map.getOrElse(letter,\
    \ 0L)\n                map.put(letter, count + 1L)\n        }\n        map.toMap",
  "        val map = mutable.HashMap.empty[String,Long]\n        test.split().map\
    \ { x =>\n            val l = map.getOrElse(x,0) + 1\n            map.put(x,l)\n\
    \        }\n        map.toMap", "        val s = test.split(' ')\n        val\
    \ counts = new mutable.HashMap[String,Long]()\n        for (x <- s){\n       \
    \     if (counts.containsKey(x)) {\n                counts(x) += 1\n         \
    \   } else {\n                counts.put(x, 1)\n            }\n        }\n   \
    \     counts.toMap", "        val letters = test.split(\" \").toList\n       \
    \ var occurrences = mutable.Map[String,Long]()\n        for (letter <- letters)\n\
    \        {\n            val count = occurrences.get(letter) match {\n        \
    \        case None => 0\n                case Some(count) => count + 1\n     \
    \       }\n            occurrences = occurrences + (letter -> count)\n       \
    \ }\n        occurrences.toMap", "        test.split(\" \").toList.map { letter\
    \ =>\n            letter -> test.split(\" \").toList.count(_ == letter)\n    \
    \    }.foldLeft(Map[String,Long]()){ \n            case(newMap, element) =>\n\
    \                val currentCount = newMap.get(element.key)\n                if\
    \ (currentCount > element.value) { newMap.updated(element.key, element.value)\
    \ }\n                newMap \n        }", "        val map = new mutable.HashMap[String,Long]\n\
    \        var currentCount = 0L\n        test.split(\" \").foreach(\n         \
    \   x => map.getOrElseUpdate(x, currentCount+=1))\n        map map map map", " \
    \       def countMap[A](test : String, start : A) : Map[String, Long] = {\n  \
    \          val countMap = Map[String, Long]()\n            test.split(\" \").foreach(word\
    \ => {\n                if (word == null || word.isEmpty) {\n                \
    \    return\n                }\n                val value = start.get(word.toLowerCase)\n\
    \                if (value == null) {\n                    countMap += (word.toLowerCase\
    \ -> 1L)\n                } else {\n                    countMap += (word.toLowerCase\
    \ -> value.toLong)\n                }\n            })\n            countMap\n\
    \        }\n        val mapBuilder = mutable.Map[String, Long]()\n        var\
    \ maxCount = 0L\n        for (letter <- test.toCharArray) {\n            val count\
    \ = mapBuilder + (letter -> (mapBuilder + (letter -> 1L)).map(x => (x._1 -> x._2)).getOrElse((letter\
    \ -> 1L)))\n            maxCount = math.max(maxCount, count)\n        }\n    \
    \    return maxCount == 0L ? countMap(test, \"\") : (countMap(test, \"\") + (maxCount\
    \ -> maxCount))", "        // Split test in characters to lower case.\n      \
    \  val chars: List[String] = test.toLowerCase.split(\" \").map(_.toLowerCase)\n\
    \        // Create a hash map with the letters as the keys and a count of each\
    \ letter as the value.\n        val letters: Map[String,Long] = chars.groupBy(c\
    \ => c).mapValues(_.size)\n        // Return the map with the letters with the\
    \ highest occurences.\n        letters.maxBy(letterCount => letterCount._2)",
  "        val m = test.split(\" \").map(_.toLower)\n        val ls = test.split(\"\
    \ \").toList.groupBy(x => x).map { case (k,v) => k -> v.size }.toMap\n       \
    \ if (ls.size > 0) ls.max else ls", "        var m = Map[String,Long]()\n    \
    \    test.toList.sliding(2).foreach { x =>\n            val str = x.head\n   \
    \         val count = x.last\n            m.get(str) match {\n               \
    \ case Some(i) => m += (str -> i.toLong)\n                case None => m += (str\
    \ -> count.toLong)\n            }\n        }\n        m match {\n            case\
    \ m if m.isEmpty() => m\n            case _ => m.maxBy(_._2)._1\n        }", " \
    \       val testWord = test.split(\" \").toList\n        val map = testWord.foldLeft(Map[String,Long]())((map,\
    \ word) => map + (word -> (map.getOrElse(word, 0l) + 1)))\n        map += (testWord.last\
    \ -> (testWord.size))\n        map", '        test.split(" ").map(x => (x, test.count(x))).maxBy(_._2)._1',
  "        if (test.isEmpty) Map.empty[String,Long]\n        else {\n            var\
    \ count : Long = 1\n            var letter = test.head\n            test.tail.foreach(\
    \ x => if (letter == x) { count += 1 })\n            Map(letter -> count) \n \
    \       }", "        var hm = scala.collection.mutable.Map[String,Long]()\n  \
    \      var split = test.split(\" \")\n        for ( i <- split.indices if !split.exists(_\
    \ == \"\") ) hm+= split(i) -> 1\n        return hm", "        val tokens = test.split(\"\
    \ \").toArray\n        val freqs = mutable.Map.empty[String,Long]\n        for\
    \ (token <- tokens) {\n            freqs += (token -> freqs.getOrElse(token, 0L))\n\
    \        }\n        freqs.toMap", "        val result = mutable.Map[String,Long]()\n\
    \        test.toLowerCase map {c =>\n            val c = c.toUpper\n         \
    \   val count = result getOrElseUpdate (c, 1L)\n            result + (c -> (count\
    \ + 1))\n        }\n        result.toMap", "        val histogram = mutable.Map[String,Long]()\n\
    \        var counter = 0\n        test.foreach{\n            letter =>\n     \
    \       histogram(letter) = (histogram(letter).getOrElse(counter, 0L)+1L, counter)\n\
    \            counter += 1\n        }\n        histogram.toMap", "        test.split('\
    \ ').groupBy(_.toLower).mapValues(_.length).maxBy(_._2)._1", "        val split\
    \ = test.toList.map (_.toLower)\n        val histogram = split.groupBy(x => x).mapValues(x\
    \ => x.size)\n        histogram.maxBy(_._2)", "        val letters = (test.replace(\"\
    \\\"\",\"\").replace(\"\\\\\",\"\").split(\" \")).toSet\n        letters.map((_,\
    \ 1)).reduceByKey(_ + _).map{ case (k, v) => k -> v.asInstanceOf[Long] }.toMap",
  "        val testSet = test.split(\" \")\n        val mapResult = mutable.Map.empty[String,Long]\n\
    \        testSet.foreach{ word =>\n            if(mapResult.contains(word))\n\
    \                mapResult(word) += 1\n            else\n                mapResult(word)\
    \ = 1\n        }\n        mapResult.map{ case (word, count) =>\n            (word,\
    \ count)\n        }.toMap", "      var counts = mutable.Map[String,Long]();\n\
    \      var currentLetter = test.charAt(0);\n      var currentCount = 0;\n    \
    \  for(i <- 1 to test.length)\n      {\n        if(test.charAt(i) == currentLetter)\n\
    \        {\n          currentCount = currentCount + 1;\n        }\n        else\n\
    \        {\n          counts += ((currentLetter -> currentCount));\n         \
    \ currentCount = 1;\n          currentLetter = test.charAt(i);\n        }\n  \
    \    }\n      counts += ((currentLetter -> currentCount));\n      counts", " \
    \       def histogramHelper(s:String,c:Map[String,Long],t:Long) = {\n        \
    \    val splitted = s.split(\" \").filter(x=>x.length>0).map(_.toLowerCase).toList\n\
    \            if (splitted.isEmpty) c\n            else {\n                val\
    \ count = splitted.foldLeft(0l)((x,y)=>x+(y.toLong))\n                if (count\
    \ > t) histogramHelper(splitted.head,c,count)\n                else histogramHelper(splitted.tail,Map(s->count,splitted.head->t),count)\n\
    \            }\n        }\n        histogramHelper(test,Map(),0)", "        val\
    \ m = test.toList.map(e => e.split(\" \").map(_.toLowerCase).toSet).flatten.toMap\n\
    \        val m2 = m.map(x => (x,1))\n        val m3 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._1\n\
    \        val m4 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._1\n\
    \        val m5 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._1\n\
    \        val m6 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._1._1\n\
    \        val m7 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._1._2\n\
    \        val m8 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._1\n\
    \        val m9 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._2\n\
    \        val m10 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._3\n\
    \        val m11 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._4\n\
    \        val m12 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._5\n\
    \        val m13 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._6\n\
    \        val m14 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._7\n\
    \        val m15 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._8\n\
    \        val m16 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._9\n\
    \        val m17 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(_._2)._2._2._2._10\n\
    \        val m18 = m2.groupBy(_._1).mapValues(_.size.toLong).maxBy(", "      \
    \  val letters = test.split(\" \").toList\n        val map = scala.collection.mutable.Map[String,Long]()\n\
    \        for (letter <- letters) {\n            map.updated(letter, map.getOrElse(letter,\
    \ 0L) + 1L)\n        }\n        map.toMap", "        if (test.length == 0) return\
    \ Map()\n        val counts = mutable.HashMap.empty[String,Long]\n        for\
    \ (word <- test.split(' ')) {\n            val count = counts.getOrElse(word,\
    \ 0L)\n            counts += (word -> count + 1)\n        }\n        counts.toMap",
  "        val map = test.toLowerCase.toList.grouped(1).toList\n        val map =\
    \ map.map(k => (k(0) -> (k.length))).toMap\n        return map", "        val\
    \ letters = new mutable.HashSet[Char]()\n        val letterCounts = new mutable.HashMap[String,Long]()\n\
    \n        for (letter <- test.toLowerCase()) {\n            if (letters.contains(letter))\n\
    \                letterCounts(letter) += 1\n            else\n               \
    \ letters.add(letter)\n        }\n\n        val result = letterCounts.toMap\n\
    \        return result", "        val letters = test.toUpperCase.split(\" \").map(_.toUpperCase).toList\n\
    \        val letterCounts = letters.map(letter => letter -> letters.count(_ ==\
    \ letter)).toMap\n        letterCounts.filter(_._2 > 1).map{ case (k,v) => k ->\
    \ v }.toMap", "        var h : Map[String,Long] = Map()\n        var c : Int =\
    \ 0\n        var rep : Long = 1\n        val testList = test.split(\" \").map(x\
    \ => x.toLowerCase).toList\n        for (x <- testList) {\n            if (h.get(x)\
    \ == null) {\n                h(x) = rep\n            }\n            else {\n\
    \                h(x) = h(x) + rep\n            }\n            if (h(x) > rep)\
    \ {\n                rep = h(x)\n            }\n            c = c + 1\n      \
    \  }\n        return h", '        test.split(" ").map(letter => (letter, test.split(letter).length)).toMap',
  '        test.split(" ").map(s => s -> test.count(_ == s)).groupBy(_._1).mapValues(_.length).toMap',
  "        var map: mutable.Map[String,Long] = mutable.HashMap.empty\n        var\
    \ splitArray = test.split(\" \").toList\n        splitArray.foreach(e => {\n \
    \           var currentLetter = e.head\n            var currentCount = e.length\n\
    \            map.get(currentLetter) match {\n                case None =>\n  \
    \                  map.put(currentLetter,currentCount)\n                case Some(entry)\
    \ => currentCount += entry.getOrElse(0l)\n            }\n        })\n        map.toMap",
  "        val chars = new mutable.HashSet[Char]()\n        var count : Long = 0\n\
    \        test.toList foreach { c => chars += c }\n        chars.toList foreach\
    \ { c => count = chars.count(c ==) ++ count }\n        chars.toList map { c =>\
    \ c -> count } toMap", "       val map = test.grouped(1)\n            .map(s =>\
    \ (s, 1))\n            .toMap\n           .sortWith((s1, s2) => s1._2 > s2._2)\n\
    \           .map(t => (t._1, t._2))\n           .groupBy(_._1)\n           .mapValues(_.size.toLong)\n\
    \           .toMap\n       if(map.isEmpty) map\n       else {\n           val\
    \ keys = map.keySet.toSeq.sortWith((s1, s2) => s1 < s2)\n           map.filter(_._2\
    \ > keys.head)\n           .filter(_._2 == keys.head._2)\n           .map(_._1)\n\
    \           .toMap\n       }", "        val chars = test.toCharArray\n       \
    \ var map = new HashMap[String,Long]()\n        for(i <- 0 until chars.length)\
    \ {\n            val key = chars(i).toString.toLowerCase\n            val count\
    \ = map.get(key) match {\n                case None => 0\n                case\
    \ Some(value) => (value + 1) / 2\n            }\n            map.put(key, count)\n\
    \        }\n        return map", "        val res = test.toCharArray.groupBy(identity).mapValues(_.length)\n\
    \        if(res.size == 0) res.put(\"*\", 1L)\n        else res", "        val\
    \ arr = test.split(\" \").toList\n        val m = mutable.Map.empty[String, Long]\n\
    \        arr.foreach(x => {\n            val count = (m filter { x => (x -> 1)\
    \ }).length\n            m += (x -> (count + 1))\n        })\n        m.map(_._1\
    \ -> _._2)", '        test.toLowerCase.split(" ").map(letter => (letter, 1)).toMap',
  "        def countLetters ( test : String) : Map[String,Long] = test match {\n \
    \               case letter :: \"\" => (letter -> 1L)\n                case letter\
    \ :: tail => {\n                    val countLetters = countLetters(tail)\n  \
    \                  countLetters + (letter -> (countLetters(letter) + 1))\n   \
    \             }\n            }\n        val letterMap : Map[String,Long] = countLetters(test)\n\
    \        letterMap.toMap", "        test.split(\"\\\\s\").foldLeft(Map.empty[String,Long])\
    \ { (m, c) =>\n            val m = m + (c -> (m.getOrElse(c,0L) + 1))\n      \
    \      m\n        }", "        val testString = test.split(\" \").map(_.toLowerCase).toSet\n\
    \        val map = mutable.Map[String,Long]()\n        for (letter <- testString)\n\
    \            map += (letter -> (map.get(letter).getOrElse(0) + 1))\n        map",
  "      var map = new mutable.HashMap[String,Long]()\n      test.split(' ').foreach\
    \ {\n         word => {\n           var count = 1\n           map.get(word) match\
    \ {\n            case None => {\n               map.put(word, count)\n       \
    \     }\n            case Some(count) => {\n               map.put(word, count\
    \ + 1)\n            }\n         }\n       }\n     }\n     map\n  }\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=scala |>\nThis is probably what you're looking for.\
    \ As it says there, it's pretty much the same as your code, but with a slightly\
    \ more functional style.\n<code>\ndef histogram (s: String) = {\n    val m = s.split(\"\
    \ \").toList.groupBy(identity)\n    val maxCount = m.map(_.size).max.toInt\n \
    \   m mapValues ( _ /: maxCount ){\n         case (n, x) => n.ceiling(x).toInt",
  "        def letterCount(test : String) : Map[String,Long] = {\n            test.split(\"\
    \ \").map(_.toLowerCase).groupBy(_).mapValues(_.size).toMap\n        }\n     \
    \   letterCount(test).maxBy(_._2)._1", "        def histogramRec(test : String)\
    \ : Map[String,Long] = {\n            test.toList.foldRight(Map[String,Long]())(\n\
    \                (xs, c) => (xs.get(c.toLowerCase) match {\n                 \
    \   case Some(v) => Some(v + c)\n                    case None => Some(c)\n  \
    \              })\n            ) match {\n                case Some(cs) => cs.foldLeft(Map[String,Long]())(\n\
    \                    (x, c) => (x.get(c.toLowerCase) match {\n               \
    \         case Some(v) => Some(c.toLong + v)\n                        case None\
    \ => Some(c.toLong)\n                    }))\n                case None => Map[String,Long]()\n\
    \            }\n        }\n        histogramRec(test)", '        test.toLower.toList.distinct.map(x
    => (x,test.count(x)))', "        var result = Map[String,Long]();\n        var\
    \ splits = test.split(\" \")\n        splits.foreach(x => {\n            if (result.containsKey(x)){\n\
    \                result(x) = result(x) + 1l\n            }else {\n           \
    \     result(x) = 1l\n            }\n        })\n        return result", '        test.toLowerCase.split("
    ").groupBy(identity).mapValues(_.length).toMap', '        test.toLowerCase split
    " " map (word => (word, 1 +: word.split("\\s".toList).map(_.toLowerCase).countBy
    { _ => 1 }.values.toList))', "        val map = mutable.HashMap.empty[String,Long]\n\
    \        test.split(' ').foreach(item => map += (item -> 1))\n        map.toMap",
  "        val pattern = \"\\\\W+\"\n        val matcher = pattern.r.findFirstIn(test)\n\
    \        val matches = pattern.r.findAllIn(test)\n        val chars = test.split(pattern)\n\
    \        val m = mutable.Map.empty[String,Long]\n        for (i <- 0 until matches.size)\
    \ {\n            val key = matches.apply(i).replaceAll(pattern,\"\")\n       \
    \     val charCount = chars.distinct.count(_.equals(key))\n            m.update(key,charCount)\n\
    \        }\n        m.toMap", "        var counts = mutable.HashMap[String,Long]();\n\
    \        var count = 1;\n        var currentLetter = \"\";\n        var currentCount\
    \ = 0;\n        for (x <- test.split(\" \")) {\n            if (x.equals(currentLetter))\
    \ {\n                count+=1;\n            } else {\n                count =\
    \ 1;\n                currentCount = 1;\n                currentLetter = x;\n\
    \            }\n            counts += (x -> count);\n        }\n        return\
    \ counts;", '        test.map(_.toLowerCase => test.count(_ == _.toLowerCase)).maxBy(_._2)._1',
  "        val result = mutable.Map.empty[String,Long]\n        for (x <- test.split(\"\
    \ \")) {\n            val count = result.getOrElse(x,0L)\n            result(x)\
    \ = count + 1\n        }\n        result.toMap", "        def count[A](s : Seq[A])\
    \ : Map[A,Long] = {\n            s.foldLeft(Map[A,Long]())((h,e) => h += (e ->\
    \ 1L))\n        }\n        def merge[A](s : Map[A,Long], m : Map[A,Long]) : Map[A,Long]\
    \ = {\n            val m1 = s.toMap\n            val m2 = m.toMap\n          \
    \  val m3 = m2.filterKeys { case (k,v) => m1.contains(k) && m1.getOrElse(k,0L)\
    \ > v }\n            m3.mapValues(v => v + m1.getOrElse(k,0L))\n        }\n  \
    \      val m = test.split(\" \").foldLeft(Map[String,Long]())((m,s) => merge[String](count[String](m.toSeq\
    \ ++ Seq(s)) ,m))\n        m.toMap", "        val histogram = mutable.Map[String,Long]()\n\
    \        test.split(\" \").foreach { letter =>\n            val count = histogram.getOrElseUpdate(letter,0)\
    \ + 1\n            histogram += (letter -> count)\n        }\n        histogram.toMap",
  '        test.split(" ").toList.groupBy(x => x).map(x => (x._1, x._2.size)).toMap',
  "        // split string into array of strings delimited by ' '\n        var chars\
    \ = test.split(\" \")\n        // init empty map\n        var histogram = new\
    \ mutable.HashMap[String,Long]()\n\n        for (i <- 0 until chars.length) {\n\
    \            // for each char, increment the count and add it to the histogram\n\
    \            histogram(chars(i)) += 1\n        }\n\n        // return the map\
    \ of chars with their count\n        histogram", "        val splitted = test.split(\"\
    \ \").toList\n        splitted.groupBy(x => x).map(x => (x._1,x._2.length)).toMap",
  "        val testSet = test.split(\" \").toSet\n        var maxCount = 0L\n    \
    \    var maxLetter = \"\"\n        val countMap = new mutable.HashMap[String,Long]\n\
    \        test.split(\" \").foreach {\n            if (testSet.contains(it)) {\n\
    \                countMap(it) += 1L\n            }\n        }\n        val mapCount\
    \ = countMap.sortWith((x,y) => y._2 > x._2)\n        mapCount.foreach { case (letter,\
    \ count) =>\n            if (count > maxCount) {\n                maxCount = count\n\
    \                maxLetter = letter\n            }\n        }\n        (maxLetter\
    \ -> maxCount)", "      val freqs = test.split(\" \").map(c => c -> 1).foldLeft(Map.empty[String,Long]){\n\
    \        case (map, c) =>\n          val count = map.getOrElse(c, 0)\n       \
    \   map + (c -> (count + 1))\n      }\n\n      freqs.map{ case (letter, count)\
    \ => letter -> count }.filter(_._2 > 1).toMap", "        // Convert input to list\
    \ for easy manipulation\n        var words = test.toLowerCase().split(\" \").toList\n\
    \n        // Initialize a map to store counts\n        var counts = Map[String,Long]()\n\
    \n        // Initialize a map to store max counts\n        var maxCounts = Map[String,Long]()\n\
    \n        // Use a loop to iterate through the input words\n        for (word\
    \ <- words) {\n            // Check if the word has already been seen\n      \
    \      if (counts.contains(word)) {\n                // Increment the count\n\
    \                counts(word) = counts(word) + 1\n                // If the count\
    \ is greater than the current max count so far, update it\n                if\
    \ (counts(word) > maxCounts(word))\n                    maxCounts(word) = counts(word)\n\
    \            } else {\n                // Otherwise, initialize a new count\n\
    \                counts(word) = 1\n                // If this is the first time\
    \ we've seen this word, update max counts\n                if (counts.contains(word))\n\
    \                    maxCounts(word) = counts(word)\n            }\n        }\n\
    \n        // Return the final map with all counts\n        return maxCounts",
  "      var counts : mutable.Map[String,Long] = Map.empty\n      var letters : List[String]\
    \ = test.split(\" \").map(_.toLowerCase).toList\n      val letterMap : Map[String,Long]\
    \ = letters.map(letter => (letter, 1l)).groupBy(_._1).mapValues(_.size).mapValues(_.max)\n\
    \      for (letter <- letters) counts += letter -> letterMap(letter)\n      counts",
  "        val chars = test.split(\" \").toSeq\n        val charCount = chars.map(c\
    \ => (c, 1))\n        val freq = charCount.groupBy(c => c._1).map(c => (c._1,\
    \ c._2.length)).toMap\n        freq.foreach { case (c, freq) =>\n            val\
    \ count = freq.max\n            charCount += (c->count)\n        }\n        charCount.toMap",
  "        val letters = test.toLowerCase.split(\" \").toList\n        val histogram\
    \ = mutable.HashMap[String, Long]()\n\n        for (letter <- letters) {\n   \
    \         histogram(letter) += letter.length.toLong\n        }\n        histogram.toMap",
  "        // TODO: complete this method\n        val map = new mutable.HashMap[String,Long]()\n\
    \        val words = test.split(' ')\n        for( x <- words) {\n           \
    \ if(map.get(x) eq null)\n                map += x -> 1\n            else\n  \
    \              map += x -> map.get(x) + 1\n        }\n        return map", " \
    \       val counts = mutable.Map[String,Long]()\n        val list = test.split(\"\
    \ \").toList\n        for (word <- list) {\n            if (counts.contains(word))\
    \ {\n                counts(word) = counts(word) + 1\n            } else {\n \
    \               counts.put(word, 1L)\n            }\n        }\n        counts.toMap",
  "        val words = test.split(\" \").map(_.trim).filter(_.nonEmpty)\n        val\
    \ map = Map[String,Long]()\n        for(w <- words) {\n            val c = map.get(w)\n\
    \            val n = if (c == None) 1L else c.getOrElse(0L)\n            map +=\
    \ (w -> n+1)\n        }\n        map", "        val test = test.toLowerCase \n\
    \        val map = mutable.HashMap[String,Long]()\n        test.split (\"\\\\\
    s+\").foreach{x=>map.update(x.toLowerCase , 1L) }\n        val sortedMap = (map\
    \ sortWith ((Map(_,x) => x)>(_,x=>x)))\n        val sorted = sortedMap.toSeq.sortWith((Map(_,x)\
    \ => x)>(_,x=>x))\n        val result = sorted.takeWhile(Map(_,x) => x<sortedMap.getOrElse(_,0l)).filterKeys(_>1).filterKeys(_<sortedMap.get(_,_)).map{case\
    \ (k,v)=> k -> v.toLong}\n        result + Map(\"Other\" -> map.getOrElse(\"other\"\
    ,0l))", "        def countLetters(letters:List[String],count:Int) : Map[String,Long]\
    \ = {\n            letters match {\n                case Nil => (Map[String,Long](),0)\n\
    \                case head :: tail => {\n                    val m = countLetters(tail,1)\n\
    \                    val count = m.getOrElse(head,0) + 1l\n                  \
    \  (m + (head -> (count)),count)\n                }\n            }\n        }\n\
    \        val letters = test.split(\"\\\\s+\").map(_.toLowerCase).toList\n    \
    \    val maxLetter = letters.maxBy(_.length)\n        val map = countLetters(letters,letters.length)\n\
    \        map + (maxLetter -> map.get(maxLetter).getOrElse(0l))", "      val map\
    \ = scala.collection.mutable.Map.empty[String,Long]\n      test.split(\" \").foreach\
    \ {\n        str =>\n          val count = getCount(str)\n          if(map.contains(str))\n\
    \            map(str) += count\n          else\n            map += (str -> count)\n\
    \      }\n      map.toMap", "        // Parse string into an array of letters\n\
    \        val letters = test.split(\" \").toList.map(_.toLowerCase)\n        val\
    \ counts = letters.foldLeft(Map[String,Long]())((counts, letter) => \n       \
    \     val count = counts.getOrElse(letter,0) + 1\n            counts.updated(letter,\
    \ count)\n        )\n        counts.toMap", '        test.toList.map(x => (x,
    test.count(x => x == x)).toMap).maxBy(_._2)._1', "        val counts = mutable.Map.empty[String,Long]\n\
    \        test.split(\" \").foreach(letter => counts +=+= (letter -> (counts(letter)\
    \ + 1l)))\n        counts", "        var histogram = Map[String,Long]()\n    \
    \    for (nd <- test.toList) {\n            var count = histogram.getOrElse(nd.toLowerCase(),0L)\n\
    \            histogram.updated(nd.toLowerCase(),count+1)\n        }\n        histogram.toMap",
  "        test.split(' ').foldLeft(Map[String,Long]())((h,c) => (h.getOrElse(c,0L)+1L,h))",
  "        var map = scala.collection.mutable.Map.empty[String, Long]\n        var\
    \ counts = scala.collection.mutable.Map.empty[String, Long]\n        test.toList.foreach(\
    \ x => {\n            map += (x->map.getOrElse(x, 0l)+1l)\n            counts\
    \ += (x->map.getOrElse(x, 0l))\n        })\n        map += (\"empty\" -> 0l)\n\
    \        map = map.toMap\n        counts = counts.toMap\n        map + (\"empty\"\
    \ -> 0l)\n        map ++= counts\n        map", '        test.split(" ").groupBy(x
    => x).maxBy(_._2.length).map(_._1)', "        test.toList.foldLeft(Map.empty[String,\
    \ Long]) { (count, word) => word match {\n            case \"\" => count\n   \
    \         case letter => letter match {\n                case letter if (letter\
    \ in count.keySet) => count.update(letter, count.getOrElse(letter) + 1)\n    \
    \            case letter => count + (letter -> (count.getOrElse(letter) + 1))\n\
    \            }\n        }}", "        val letters = test.split(\" \").toSet\n\
    \        val letterOccurrences = letters.foldLeft(Map[String,Long]()){\n     \
    \       (m,c) => m.updated(c, m.getOrElse(c, 0L) + 1)\n        }\n        letterOccurrences.filter(_._2\
    \ > 1).map(x => (x._1, x._2)).toMap"]
stop_tokens:
- "\n    }\n"
