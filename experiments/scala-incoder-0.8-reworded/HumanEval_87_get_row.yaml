name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ["        if (lst.isEmpty) List(Tuple2(0, 0)) :: Nil else {\n       \
    \     var i = 0\n            val xList = lst.map( row => {\n                val\
    \ len = row.length\n                val row = row.drop(i).dropRight(len)\n   \
    \             i <- row.lastIndex\n                row.headOption.map( _ + i ).toList.sortBy(_\
    \ * -1) // sorted by columns in descending order\n            } )\n          \
    \  xList.map { row => row.map { col => (col, x) } }.sortBy(_._1) // sorted by\
    \ rows in ascending order\n        }", "        var row: List[Tuple2[Long, Long]]\
    \ = Nil\n        for (row <- lst) {\n            val sortedRow = row.sortBy(f\
    \ => -f.get)\n            var col: List[Tuple2[Long, Long]] = Nil\n          \
    \  for (col <- sortedRow) {\n                if ((col.get) == x) return (col,\
    \ row)\n            }\n        }\n        return Nil", "        val rows = lst.map\
    \ {\n            list => list.zipWithIndex.sortBy(_._1).map(_._2).toList\n   \
    \     }\n        val cols = (lst zip rows map {\n            list => list.zipWithIndex.sortBy(_._2).map(_._1).toList\n\
    \        }).flatten\n        val rowInd = rows.indexWhere(row => row(0).contains(x))\n\
    \        val colInd = cols.indexWhere(col => col(0).contains(x))\n        if (rowInd\
    \ == -1 || colInd == -1) {\n            Nil\n        } else {\n            rows(rowInd).sortBy(-colInd).reverse.map((x,\
    \ y)) => (x, y)\n        }", "        // Use map function\n        // Iterate\
    \ over every row of lst.\n        lst.map((row => \n            // Iterate over\
    \ every item of current row\n            row.map(x => \n                // If\
    \ the current item matches x\n                if (x == x) {\n                \
    \    // Return the index\n                    Tuple2[Long, Long](row.indexOf(x),\
    \ row.indexOf(x)) \n                }\n                // If current item doesn't\
    \ match x\n                else None\n            )\n        ))\n        // Sort\
    \ the rows by the first element\n        .sortWith((left, right) => left._1 <\
    \ right._1)\n        // Sort the rows by the second element\n        .sortWith((left,\
    \ right) => left._2 < right._2)\n        // Return the tuple\n        .sortWith((left,\
    \ right) => left._1 < right._1)", "        if (lst.isEmpty) List(Tuple2(x, x))\
    \ else lst.headOption match {\n            case None => lst.tail.tailOption match\
    \ {\n                case None => lst.tail.tail.tailOption match {\n         \
    \           case None => lst.tail.tail.tail.tailOption match {\n             \
    \           case None => lst.tail.tail.tail.tail.tailOption match {\n        \
    \                    case None => lst.tail.tail.tail.tail.tail.tailOption match\
    \ {\n                                case None => lst.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                    case None => lst.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                        case None => lst.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                            case None => lst.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                    case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                        case None =>\
    \ lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n      \
    \                                                      case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                case\
    \ None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n\
    \                                                                    case None\
    \ => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n\
    \                                                                        case\
    \ None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \          case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \              case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \                  case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match ", "        lst.map( x => ((x.indexOf(x) + 1), x) )\n            .sortWith(\
    \ (x, y) => if (x(0).compareTo(x(1))) > 0) (-1) else 1)\n            .sortWith(\
    \ (x, y) => if (y(0).compareTo(y(1))) > 0) (-1) else 1)\n            .filter(\
    \ x => x(0) == x(x(1).indexOf(x(x(1)).toLong)) )\n            .sortWith( (x, y)\
    \ => if (x(0).compareTo(x(1))) > 0) (-1) else 1)", "        if(lst.isEmpty){\n\
    \            List[Tuple2[Long, Long]]()\n        } else {\n            // First\
    \ sort the list initially by row\n            lst.sortWith((x, y) => x.zip(y).zipped.map{case\
    \ (x, y) => x}.compare < 0)\n            // Then, sort the inner list initially\
    \ by column\n            lst.map(_.reverse).sortWith((x, y) => y.zip(x.zipped).map{case\
    \ (x, y) => x}.compare < 0)\n            // Now, you can do the search\n     \
    \       val result = lst.map{\n                case list => {\n              \
    \      val tuple = (list.indexWhere(x => x == x))\n                    (tuple.index\
    \ + 1, tuple.last)\n                }\n            }.filter(_._2 >= 0).map{\n\
    \                case (row, column) => Tuple2(row, column)\n            }\n  \
    \          result.sortWith(t => t._1._1 < t._1._2 || (t._1._1 == t._1._2 && t._2._1\
    \ < t._2._2))\n        }", "        if(lst.isEmpty) List()\n        val m = lst(0).size\n\
    \        val n = lst(0).map(_.size).sum\n        val r = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for(i <- 0 to n-1)\n        {\n            val cur = lst.map(x\
    \ => x(i)).toList\n            val cur2 = cur.sortBy(x => x(i)).reverse\n    \
    \        val cur3 = cur2.sortBy(x => x(i)).reverse\n            r += (Tuple2(cur(0),\
    \ cur3(0)))\n        }\n        r.toList", "        val mn = ListBuffer.empty[Tuple2[Long,\
    \ Long]]\n        var m = 0\n        var i = 0\n        var j = lst.length - 1\n\
    \        var r = 0\n        var c = 0\n        // For each row (r), find the first\
    \ element (in the sorted order) greater than x, \n        // and move to the left.\n\
    \        while ((i <= j) && (mn < x)) {\n            m += 1\n            if (r\
    \ == lst.length - 1) {\n                mn += Tuple2[Long, Long](m, lst(m)(lst.length\
    \ - 1))\n                return mn.toList\n            }\n            i +=1\n\
    \            r += 1\n        }\n        // For each row (r), find the first element\
    \ (in the sorted order) less than x, \n        // and move to the right.\n   \
    \     while ((i <= j) && (mn > x)) {\n            m += 1\n            i += 1\n\
    \            if (r == lst.length - 1) {\n                mn += Tuple2[Long, Long](m,\
    \ lst(m)(lst.length - 1))\n                return mn.toList\n            }\n \
    \           r += 1\n        }\n        // For each row (r), find the first element\
    \ (in the sorted order) greater than x, \n        // and move to the left. Then\
    \ move to the right.\n        while ((i <= j) && (mn > x)) {\n            m +=\
    \ 1\n            if (r == lst.length - 1) {\n                mn += Tuple2[Long,\
    \ Long](m, lst(m)(lst.length - 1))\n                return mn.toList\n       \
    \     }\n            i +=1\n            r += 1\n        }\n        // For each\
    \ row (r), find the first element (in the sorted order) less than x, \n      \
    \  // and move to the right. Then move to the left.\n        while ((i <= j) &&\
    \ (mn < x)) {\n            m += 1\n            j +=1\n            if (r == lst.length\
    \ - 1) {\n                mn += Tuple2[Long, Long](m, lst(m)(lst.length - 1))\n\
    \                return mn.toList\n            }\n            r += 1\n       \
    \ }\n        // For each row (r), find the first element (in the sorted order)\
    \ greater than x, \n        // and move to the left. Then move to the right.\n\
    \        while ((i <= j) && (mn < x)) {\n            m += 1\n            i +=1\n\
    \            c += 1\n            if (r == lst.length - 1) {\n                mn\
    \ += Tuple2[Long, Long](m, lst(m)(lst.length - 1))\n                return mn.toList\n\
    \            }\n            r += 1\n        }", '        lst.zipWithIndex.sortBy(_._1).reverse.filter(e
    => e._2 == x).map(_._1)', "        val r = new HashMap[Long, List[Long]]()\n \
    \       val r2 = new HashMap[Long, List[Long]]()\n        for(e <- lst.take(lst.length\
    \ - 1)){\n            val n = new HashMap[Long, List[Long]]()\n            for(i\
    \ <- e.drop(1)){\n                val ni = new HashMap[Long, List[Long]]()\n \
    \               n.put(i.asInstanceOf[Long], ni)\n            }\n            val\
    \ temp = new HashMap[Long, List[Long]]()\n            for(i <- e.drop(1)){\n \
    \               temp.put(i.asInstanceOf[Long], List(n.keySet().toList))\n    \
    \        }\n            r2.put(e.head, temp)\n        }\n        val l = new ListBuffer[(Long,\
    \ Long)]()\n        for(e <- r2.keySet()){\n            l.append((e._1, x))\n\
    \        }\n        l.sortWith((x, y) => x._1 <=> y._1)\n        l.sortWith((x,\
    \ y) => y._1 <=> x._1)\n        val r3 = (l(0)).asInstanceOf[Tuple2[Long, Long]]\n\
    \        return List(r3)", "        lst.map(row => row.zipWithIndex.filter(e =>\
    \ e._2 == x).sortWith(a => a._1 > a._2).map(e => Tuple2(e._2 + 1, e._1))).sortWith(a\
    \ => a._1 < a._2).map(e => e.toList)}\n    // You are given a 2 dimensional data,\
    \ as a nested lists,\n    // which is similar to matrix, however, unlike matrices,\n\
    \    // each row may contain a different number of columns.\n    // Given lst,\
    \ and integer y, find integers y in the\n    // list of nested lists,\n    //\
    \ and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
    \ initially by columns in ascending order.\n    // Also, sort coordinates of the\
    \ row by columns in descending order.\n    // Examples:\n    // >>> getCol((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (2l))\n    // (List[Tuple2[Long,\
    \ Long]]((0l, 0l), (2l, 1l), (2l, 2l), (0l, 3l), (0l, 4l)))\n    // >>> getCol((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (6l))\n    // (List[Tuple2[Long,\
    \ Long]]((0l, 0l), (2l, 2l)))\n    // >>> getCol((List[List[Long]]()), (2l))\n\
    \    // (List[Tuple2[Long, Long]]())\n    def getCol(lst : List[List[Long]], y\
    \ : Long) : List[Tuple2[Long, Long]] = {\n        lst.map(row => row.zipWithIndex.filter(e\
    \ => e._1 == ", "        def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long,\
    \ Long]] = {\n            val lst_copy = lst.sortWith(_(_).lt(x))\n          \
    \  val x_copy = x.toLong\n            var result = lst_copy.map {\n          \
    \      case row if (row.contains(x_copy)) => (0l, row.indexOf(x_copy))\n     \
    \           case row => row.zipWithIndex.map {\n                    case (elm,\
    \ idx) => (0l, elm._1 - idx)\n                }\n            }.toList\n      \
    \      val tempCol = result.sortWith(_._1 < _._1).map(x => x._1).reverse\n   \
    \         result = result.sortWith(_._1 < _._1).map(x => (x._1, x._2 + tempCol.indexOf(_._2)\
    \ - tempCol.indexOf(_._1))).toList\n            result\n        }\n        getRow(lst,\
    \ x)", "        val size = lst(0).length\n        var found = false\n        val\
    \ rows = lst.map(row => {\n            var column = 0\n            while (!found\
    \ && column < row.length) column += 1;\n            val tuple = column.zip(row.zipWithIndex).find(_._2\
    \ == x).map(_._1)\n            if (tuple.isEmpty) ()\n            else tuple.toList\n\
    \        }).toList\n        rows.sortWith((a, b) => {\n            if (a.toLong\
    \ > b.toLong) return true\n            else return false\n        }).sortWith((a,\
    \ b) => {\n            if (a.toLong < b.toLong) return true\n            else\
    \ return false\n        })", "        val rowSize = lst.head.size\n        val\
    \ colSize = lst.last.head\n        val rows = lst\n        .map { row =>\n   \
    \         val r = row\n            .zipWithIndex.map {\n                case (val,\
    \ index) => (index, val)\n            }\n            .sortBy(x => (x._1, x._2))\n\
    \            .map(x => (x._2, x._1))\n            .toArray\n            .sortBy(x\
    \ => (-x._1, -x._2))\n            .map(x => (x._2, x._1))\n            .map(x\
    \ => Tuple2((x._1 * rowSize + x._2, x._1 * rowSize + x._1)))\n        }\n    \
    \    val result = rows.find(x => x._1 == x).map { x =>\n            val r = x._2\n\
    \            .zipWithIndex.map {\n                case (val, index) => (index,\
    \ val)\n            }\n            .sortBy(x => (x._1, x._2))\n            .map(x\
    \ => (x._2, x._1))\n            .toArray\n            .sortBy(x => (-x._1, -x._2))\n\
    \            .map(x => (x._2, x._1))\n            .map(x => Tuple2((x._1 * rowSize\
    \ + x._2, x._1 * colSize + x._1)))\n        }\n        result.toList", "     \
    \   var row1 = new mutable.ArrayBuffer[Tuple2[Long, Long]]();\n        var row2\
    \ = new mutable.ArrayBuffer[Tuple2[Long, Long]]();\n        var row3 = new mutable.ArrayBuffer[Tuple2[Long,\
    \ Long]]();\n        var currentRow = List[Tuple2[Long, Long]]()\n        var\
    \ counter1 = 0, counter2 = 0, counter3 = 0;\n        for(i <- 0 until lst.length){\n\
    \            for(j <- 0 until lst(i).length){\n                if (lst(i)(j) ==\
    \ x){\n                    currentRow += new Tuple2[Long, Long](i, j);\n     \
    \               counter1 += 1;\n                }\n                if (lst(i)(j)\
    \ == x){\n                    row1 += new Tuple2[Long, Long](i, j);\n        \
    \            counter2 += 1;\n                }\n                if (lst(i)(j)\
    \ == x){\n                    row2 += new Tuple2[Long, Long](i, j);\n        \
    \            counter3 += 1;\n                }\n            }\n        }\n   \
    \     if (counter1 > counter2 && counter1 > counter3){\n            row1 += new\
    \ Tuple2[Long, Long](0, 0);\n            row2 += new Tuple2[Long, Long](0, 0);\n\
    \            row3 += new Tuple2[Long, Long](0, 0);\n        }\n        if (counter2\
    \ > counter1){\n            row2 += new Tuple2[Long, Long](0, 0);\n          \
    \  row3 += new Tuple2[Long, Long](0, 0);\n        }\n        if (counter3 > counter1){\n\
    \            row3 += new Tuple2[Long, Long](0, 0);\n        }\n        var tempRow\
    \ = row1 ++ row2 ++ row3\n        tempRow.sortBy(_._1)\n        tempRow.sortBy(_._2).reverse\n\
    \        var result = tempRow.toList\n        result.sortBy(_._1)\n        result.sortBy(_._2).reverse\n\
    \        result", "        // TODO: Your code goes here\n        if (lst.isEmpty)\
    \ return List((0l, 0l))\n        val mn = lst.head\n        val mx = lst.last\n\
    \        val m = mx.length\n        val n = mn.length\n        val r = List((0l,\
    \ 0l))\n        for (i <- 0 until n) {\n            if (mx(i) < mn || mn == mx)\
    \ {\n                r(i) = List((i, 0l))\n            }\n        }\n        for\
    \ ((i, j) <- r.zipWithIndex) {\n            val d = x\n            if (j < n)\
    \ d = mx(j)\n            if (d > mx(i)) d = mx(i)\n            if (d >= mn) r(i)\
    \ = List((i, 0l))\n        }\n        return r.map(x => (x._1, x._2))", "    \
    \    val m = lst.head\n        val n = lst.last\n        val r = m.indexOf(x)\n\
    \        val c = n.indexOf(x)\n        val row = r.toInt\n        val col = c.toInt\n\
    \        val lst2 = lst.reverse.take(row+1).reverse.drop(1)\n        val lst3\
    \ = lst2.take(col+1).reverse.drop(1)\n        (for (i <- 0 until row) yield (lst3(i),\
    \ lst(i))).sortBy(_._1)", "        val res = mutable.ListBuffer[Tuple2[Long, Long]]()\n\
    \        val lst1 = lst.flatten\n        val lst2 = lst1.filter( i => i != x)\n\
    \        val res1 = lst2.foldLeft((x,x))((b, c) => (b,c))\n        res ++= res1\n\
    \        res.sortBy(t => t._1)", "        val rows = lst.map(_.map(x => x.toLong))\n\
    \        val cols = rows.head.tail\n        val lst2 = lst.map(_.tail).map(_.map(_.toLong)).flatMap(_\
    \ ++ List(x.toLong))\n        val lst3 = lst2.sortBy(_).reverse.sortBy(_)\n  \
    \      lst3.map(x => Tuple2(x._1, x._2))", '      lst.zipWithIndex.sortBy(_._1).map(t
    => (t._2, t._1)).filter(t => t._2 == x).map(t => (t._2, t._2-1)).toList', "  \
    \      val rows = lst.map(_.zipWithIndex).sortBy(_._1).map(x => x._2)\n      \
    \  val cols = rows.map(_.zipWithIndex).sortBy(_._1).map(x => x._2)\n        val\
    \ r = rows.map(x => (x, x.indexOf(x)))\n        val c = cols.map(x => (x, x.lastIndexOf(x)))\n\
    \        r.zip(c.filter(_._2 == x)).filter(_._2 != 0).toList", "        val rs\
    \ = lst.map(row => row.map(_ - 1)).toSeq.sortWith((x, y) => y < x).zipWithIndex.filter(_._2\
    \ > 0).map(_._1).reverse.sortWith((x, y) => y < x).zipWithIndex.filter(_._2 >\
    \ 0).map(_._2).reverse.map(row => Tuple2(x = x, y = row))\n        val r0 = rs.find(row\
    \ => row.x == x).map { x => Tuple2(x, x.y) }.getOrElse(Tuple2(x = x, y = 0))\n\
    \        val r1 = rs.filter(row => row.y == 0).sortWith((x, y) => y < x).zipWithIndex.filter(_._2\
    \ > 0).map(_._1).reverse.map(row => Tuple2(x = x, y = row))\n        r0 :: r1",
  "        if (lst.isEmpty) List(Tuple2(x, x)).sortBy(t => t._1) // empty row is treated\
    \ as (row, row)\n        else {\n            val lists = lst\n            val\
    \ result = (0, 0) // we keep results for last row\n            val listIt = lists.iterator\
    \ // we need list iterator, so we can remove items when we get to last element\n\
    \            val rowIt = lists.map(_.head).iterator // we need row iterator, so\
    \ we can remove items when we get to first element\n            val removed =\
    \ if (listIt.isEmpty || rowIt.isEmpty || rowIt.next > listIt.next) {\n       \
    \         listIt.next\n            } else rowIt.next // remove element that we\
    \ don't need\n\n            while (removed > 0) {\n                val l1 = listIt.next()\n\
    \                val r1 = rowIt.next()\n                val l2 = listIt.next()\n\
    \                val r2 = rowIt.next()\n\n                val isRow = l1.head\
    \ < r2\n                val isCol = l2.head < r1\n\n                // if we are\
    \ not in order, then sort it\n                if (!isRow && !isCol) {\n      \
    \              val isReversed = r1 < l1\n                    if (isReversed) {\n\
    \                        (l1, r2).sortWith(_ > _)\n                    } else\
    \ {\n                        (l2, r1).sortWith(_ > _)\n                    }\n\
    \                }\n                // if we are in order already, then skip\n\
    \                else if ((!isRow && isCol) || (isRow && !isCol)) {\n        \
    \            listIt.remove()\n                    rowIt.remove()\n           \
    \         removed--\n                } else {\n                    val isReversed\
    \ = r1 < l1\n                    if (isReversed) {\n                        (l1,\
    \ r1).sortWith(_ > _)\n                    } else {\n                        (l1,\
    \ r2++).sortWith(_ > _)\n                    }\n                }\n          \
    \  }\n\n            val resultTuple = if (lists.isEmpty) List((x, y))\n      \
    \      else lists.map(_.head).map(t => Tuple2(t, y)).sortBy(t => t._2)\n     \
    \       result.zip(resultTuple).map(x => Tuple2(x.get._1, x.get._2))\n       \
    \ }", "        var row = 0\n        var col = 0\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for( row <- 0 until lst.length ) {\n            if( lst(row).size\
    \ < x ) break\n            val temp = row :: lst(row)\n            lst(row) =\
    \ (lst(row).drop(x).reverse)\n            lst(row) = (temp.head :: lst(row))\n\
    \        }\n        for( row <- 0 until lst.length ) {\n            val temp =\
    \ row :: lst(row)\n            if( temp.size < x ) break\n            lst(row)\
    \ = (temp.tail.reverse)\n        }\n        for( row <- 0 until lst.length ) {\n\
    \            if( lst(row).size < x ) break\n            result ::= row -> lst(row)\n\
    \        }\n        for( row <- 0 until lst.length ) {\n            if( lst(row).size\
    \ < x ) break\n            result ::= row -> lst(row).reverse\n        }\n   \
    \     result ::= row -> lst(row)\n        result ::= row -> lst(row).reverse\n\
    \        result", "        val rows = lst\n        val result = new ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        val temp = new ArrayBuffer[Tuple2[Long, Long]]()\n       \
    \ val temp2 = new ArrayBuffer[Tuple2[Long, Long]]()\n\n        var cols = 0\n\n\
    \        for (i <- 0 until rows.length) {\n            val rowLen = rows(i).length\n\
    \            cols = rowLen\n\n            val rowIndex = 0\n            while\
    \ (cols > 0 && rowIndex < rows.length) {\n                val val = rows(rowIndex)(0)\n\
    \                val columnIndex = 0\n                while (columnIndex < cols\
    \ && rowIndex < rows.length) {\n                    val cmp = rows(rowIndex)(columnIndex)\n\
    \                    if (val < cmp) {\n                        rowIndex += 1\n\
    \                        val temp2 = temp.clear()\n                        temp2\
    \ += ((rowIndex, val), (rowIndex, cmp))\n                        temp += temp2\n\
    \                    } else if (val == cmp) {\n                        val temp2\
    \ = temp2.clear()\n                        temp2 += ((rowIndex, val), (rowIndex,\
    \ cmp))\n                        temp += temp2\n                    } else {\n\
    \                        val temp2 = temp.clear()\n                        temp2\
    \ += ((rowIndex, val), (rowIndex, cmp))\n                        temp += temp2\n\
    \                        break\n                    }\n                    columnIndex\
    \ += 1\n                }\n            }\n\n            temp2 += ((rowIndex, x),\
    \ (rowIndex, x))\n            temp += temp2\n        }\n        result.addAll(temp.sortBy(_._1))\n\
    \        result.addAll(temp.sortBy(_._2))\n        result.sortBy(_._2)\n     \
    \   result", "        val sorted = (lst\n            .sorted\n            .map(_.zipWithIndex)\n\
    \            .filter(x => x._1._2 == x)\n            .map(x => (x._1._1, x._1._2))\n\
    \            .sortBy(x => x._1)\n            .sortBy(x => -x._2))\n        val\
    \ result = new ListBuffer[Tuple2[Long, Long]]()\n        for {\n            r\
    \ <- sorted\n        } yield {\n            val rows = sorted\n              \
    \  .filter(r => r._1 == r)\n                .map(x => (x._1._2, x._1._1))\n  \
    \              .toList\n            val columns = rows.map(_.swap)\n         \
    \   (rows.head -> columns.head)\n        }", "        var cols: MutableList[Int]\
    \ = mutable.MutableList(0)\n        var coords: List[Tuple2[Long, Long]] = mutable.MutableList().toList\n\
    \        var rows: MutableList[Tuple2[Long, Long]] = mutable.MutableList().toList\n\
    \        lst.foreach {row =>\n            row.foreach {col =>\n              \
    \  if (col == x) return (coords = coords :+ (row, col))\n                if (col\
    \ >= cols.last) cols :+= col + 1\n            }\n            rows += ((row, cols))\n\
    \        }\n        coords.sortBy(_._1)\n        coords.sortBy(_._2, ascending\
    \ = false)\n        coords.reverse", "        // Your code goes here\n       \
    \ if(lst.isEmpty) {\n            throw new RuntimeException(\"The list must be\
    \ not be empty.\")\n        }\n        if(!lst.isInstanceOf[List]) {\n       \
    \     throw new RuntimeException(\"The list must be a list of lists.\")\n    \
    \    }\n        if(!lst.isInstanceOf[List[Any]]) {\n            throw new RuntimeException(\"\
    The list must be a list of lists of type Any\")\n        }\n        if(lst.length\
    \ != lst(0).length) {\n            throw new RuntimeException(\"The number of\
    \ columns in the list must be the same as the first row.\")\n        }\n     \
    \   if(!lst(0).isInstanceOf[List]) {\n            throw new RuntimeException(\"\
    The first row must be a list of lists.\")\n        }\n        if(lst.length ==\
    \ 1) {\n            val lst1 = lst(0)\n            val lst2 = lst(1)\n       \
    \     val lst3 = lst2\n            var flag = true\n            var lst4 : List[Long]\
    \ = lst3\n            while(lst4.nonEmpty) {\n                val lst5 = lst4(0)\
    \ :: lst4\n                lst4 = lst4.remove(0)\n                lst4 = lst5\n\
    \            }\n            var flag2 = true\n            var lst5 : List[Long]\
    \ = lst4\n            while(lst5.nonEmpty) {\n                val lst6 = lst5(0)\n\
    \                lst5 = lst5.remove(0)\n                lst5 = lst6\n        \
    \    }\n            var flag3 = true\n            var lst7 : List[Long] = lst5\n\
    \            while(lst7.nonEmpty) {\n                val lst8 = lst7(0)\n    \
    \            lst7 = lst7.remove(0)\n                lst7 = lst8\n            }\n\
    \            if(flag) {\n                var lst9 : List[Tuple2[Long, Long]] =\
    \ lst7\n                while(lst9.nonEmpty) {\n                    val lst10\
    \ = lst9(0)\n                    lst9 = lst9.remove(0)\n                    lst9\
    \ = lst10\n                }\n                return lst9\n            }\n   \
    \         if(flag2) {\n                var lst11 : List[Tuple2[Long, Long]] =\
    \ lst7\n                while(lst11.nonEmpty) {\n                    val lst12\
    \ = lst11(0)\n                    lst11 = lst11.remove(0)\n                  \
    \  lst11 = lst12\n                }\n                return lst11\n          \
    \  }\n            if(flag3) {\n                var lst13 : List[Tuple2[Long, Long]]\
    \ = lst7\n                while(lst13.nonEmpty) {\n                    val lst14\
    \ = lst13(0)\n                    lst13 = lst13.remove(0)\n                  \
    \  lst13 = lst14\n                }\n                return lst13\n          \
    \  }\n        }\n        var flag4 = true\n        var lst15 : List[List[Long]]\
    \ = lst\n        while(lst15.nonEmpty) {\n            val lst16 = lst15(0)\n \
    \           lst15 = lst15.remove(0)\n            ", "        val result: List[Tuple2[Long,\
    \ Long]] = Nil\n        if(lst.isEmpty) result\n        else {\n            var\
    \ rows: List[List[Long]] = Nil\n            for(i <- 0 until lst.size){\n    \
    \            rows = lst.map(x => (x, lst(i))).filter(x => x._1 == x).sortBy(x\
    \ => x._2)\n                for((_, row) <- rows.reverse) result = (x -> (row.toLong,\
    \ i)) :: result\n            }\n        }\n        result.sortBy(x => x._1)",
  "        def getCoordinates(row: List[Long], x : Long, result : List[Tuple2[Long,\
    \ Long]]): List[Tuple2[Long, Long]] =\n            if(row.isEmpty) List()\n  \
    \          else if(row == List(x)) List((x, x)) // coordinate (x, x) is the current\
    \ coordinate - we add the coordinate (x, x) to result to maintain the correct\
    \ order of coordinates\n            else if(x <  row(0)) getCoordinates(row.tail,\
    \ x, result :+ ((x, x), row.head))\n            else getCoordinates(row.tail,\
    \ x, result :+ ((row.head, x), row.head))\n        getCoordinates(lst, x, Nil).sortBy(x\
    \ => (x._1, -x._2))", "        if (lst.isEmpty) Nil\n        else {\n        \
    \    val lst1 = lst.sortBy(_.head)\n            val x = lst1.indexOf(lst1.find(_\
    \ == x)) match {\n                case -1 => Nil\n                case _ => Nil\n\
    \            }\n            if (x == lst1.size - 1) {\n                lst1.map\
    \ {\n                    i => (i - lst1.size + 1, i)\n                }\n    \
    \        } else (lst1.map {\n                i => (i - x, i)\n            }).reverse.sortBy(_._1).reverse.map(t\
    \ => (t._1, t._2))\n        }", "        val numOfCols = lst(0).size\n       \
    \ val numOfRows = lst.size\n        val coords: List[List[Tuple2[Long, Long]]]\
    \ = lst.map(list => list.map(x => (x, x)))\n        val rows = coords.map(list\
    \ => list.map(x => x.get._1)).toList\n        val cols = coords.map(list => list.map(x\
    \ => x.get._2)).toList\n        val orderedRows = rows.sortWith((a, b) => b <\
    \ a) // sort rows first by descending values\n        val orderedCols = cols.sortWith((a,\
    \ b) => a > b) // sort columns first by ascending values\n        orderedRows.flatMap\
    \ { row =>\n            orderedCols.map(col => Tuple2(row.toLong, col.toLong))\n\
    \        }", "        def getColumn(lst : List[List[Long]], x : List[Long]) :\
    \ List[Long] = {\n            val ls : List[Long] = x match {\n              \
    \  case Nil => lst.map(_.head).flatten.toList\n                case _   => x\n\
    \            }\n            val rs : List[Long] = lst.map(_.tail).flatten.toList\n\
    \            val cols : List[Long] = ls.zip(rs)\n            val res : List[Long]\
    \ = cols.filter(v => v != x)\n            val m   : List[Long] = lst match {\n\
    \                case Nil => cols\n                case _   => lst.map(_.head).zipWithIndex.filter(v\
    \ => v._2 == x.toInt).map(v => v._1).toList\n            }\n            val bc\
    \ : List[Long] = m.map(v => if (v < x.toLong) v else x.toLong - v).takeWhile(v\
    \ => v < x.toLong).map(v => v.toLong).takeWhile(v.lt(x.toLong)).map(v => v.substract(x))\
    \ + List(x.toLong)\n            bc.distinct\n        }\n\n        val row = lst.map(_.map(_.toLong))\n\
    \        val columns = getColumn(row, List(x))\n        val res : List[Tuple2[Long,\
    \ Long]] = columns.zip(row).map(v => (v._1, v._2.map(_.toLong)))\n        res.sortWith((v1,v2)=>{\n\
    \            val c1 = v1._1.toInt\n            val c2 = v2._1.toInt\n        \
    \    if (c1 < c2) -1 else if (c1 > c2) 1 else 0\n        })", "        val tuples\
    \ = lst.map {\n            case x :: y :: tail => x :: y :: tail\n        }\n\
    \        tuples.sortBy {\n            case x :: y :: tail => (tail.map(i => i.toLong).max\
    \ / x.toLong, tail.map(i => i.toLong).min / x.toLong)\n        }\n           \
    \ .sortBy {\n            case x :: y :: tail => (tail.map(i => i.toLong).max /\
    \ x.toLong, tail.map(i => i.toLong).min / x.toLong)\n        }\n            .filter(t\
    \ => t._2.min <= x.toLong && t._2.max >= x.toLong)\n            .map(t => Tuple2(t._1,\
    \ t._2.max - t._1))", "        val rows = lst.map(l => l.map(x -> x).map((x, _)).toList)\n\
    \        val cols = rows.map(_.sorted.reverse).map(_.head).map(x => x.filter(_._1\
    \ == x).toList)\n        (0 until rows.size).map(i => ((0 until rows(i).size).map(j\
    \ => (i, j)).toList.sortBy(_._1), rows.map(_.drop(i).sorted.reverse).map(_.head).map(x\
    \ => (x, (0 until cols(i).size).map(j => (i, j)).toList.sortBy(_._2))))).toList",
  "        val rows = lst.map(_.length).max\n        val columns = lst.head.length\n\
    \        val newRows = rows + (if (rows == 0) 1 else 0)\n        val newCols =\
    \ columns + (if (columns == 0) 1 else 0)\n        val newList = new mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for(i <- 0 until newRows) {\n            for(j <- 0 until\
    \ newCols) {\n                newList += ((i * newCols) + j, (lst(i)(j + x) match\
    \ {\n                    case \"None\" => 0l\n                    case \"Some\"\
    \ => x\n                    case x => x\n                    }))\n           \
    \ }\n        }\n        newList.sortBy(_._1).reverse.sortBy(_._2).reverse.map(x\
    \ => Tuple2(x._1, x._2))", "        lst.map{l =>\n            val ys = l.toArray\n\
    \            val rowIndex = ys.indexOf(x)\n            if(rowIndex > -1) (ys.take(rowIndex),\
    \ ys.drop(rowIndex))\n            else (List(x), ys)\n        }", "        val\
    \ ret: List[Tuple2[Long, Long]] =\n            if (lst.isEmpty) Nil\n        \
    \    else lst.headOption.map { case List(xx, yy, zz, ..., yx, yz) =>\n       \
    \         val row = x - (xx + yy + zz + ... + yx + yz)\n                val col\
    \ = yz.max(yx.toLong).toLong - yy.max(yx.toLong).toLong\n                (row,\
    \ col)\n            }.toList.sortBy(_._1).reverse\n        ret", "        if(lst.isEmpty)\
    \ {\n            return Nil\n        }\n        var temp = [Long]()\n        var\
    \ newLst: List[List[Long]] = (lst.map(l => l.map(l => l.toLong))) match {\n  \
    \          case lst : List[List[Long]] => lst\n            case lst : List[Long]\
    \ => lst.map(l=>List(l))\n            case lst => Nil\n        }\n        var\
    \ result: MutableList[Tuple2[Long, Long]] = MutableList(Tuple2(0, 0))\n\n    \
    \    for(row <- newLst) {\n            val y = row.indexOf(x)\n            if(y\
    \ != -1) {\n                val rowCol = row.filter(_ != x)\n                val\
    \ colRow = row.filter(_ == x)\n                val temp = rowCol.zip(colRow).sortBy(x\
    \ => -x._1).map(x => (x._1, x._2))\n                temp = temp sortBy(x => -x._1).map(x\
    \ => (x._1, x._2))\n                result ++= temp\n            }\n        }\n\
    \n        return result.sortBy(x => -x._1).map(x => (x._1, x._2)).toList", " \
    \       val numRow = lst(0).size\n        val numCol = lst(1).size\n        val\
    \ lst2 = lst.map(x => x.map(i => (i, 0l)))\n        lst2.sortBy(x => x._1, Ordering[Long].reverse)\n\
    \            .sortBy(x => x._2, Ordering[Long].reverse)\n            .filter(x\
    \ => x._2 % numCol == 0)\n            .filter(x => x._2 % numRow == 0)\n     \
    \       .filter(x => x._2 % x == 0)\n            .filter(x => x._1 % x == 0)\n\
    \            .map(x => (x._1 / numRow, x._2 / numCol))\n            .map(x =>\
    \ (x._1, x._2))", "        lst.foldLeft(List[Tuple2[Long, Long]]()) {\n      \
    \      case ((row: List[Long], c: List[Long], l: List[Long]), (index: Int, xs:\
    \ Int, y: Long)) =>\n                val i = index\n                val xInc =\
    \ xs match {\n                    case 0 => l\n                    case xs =>\
    \ l :+ x\n                }\n                val yInc = y match {\n          \
    \          case y if y < xs => l.reverse\n                    case y if y > xs\
    \ => l\n                    case y => l :+ y\n                }\n            \
    \    row.foldLeft(List[Tuple2[Long, Long]]()) {\n                    case ((row:\
    \ List[Long], c: List[Long], l: List[Long]), (index: Int, xs: Int, y: Long)) =>\n\
    \                        val j = index\n                        val xDec = xs\
    \ match {\n                            case 0 => l\n                         \
    \   case xs => l :+ x\n                        }\n                        val\
    \ yDec = y match {\n                            case y if y < xs => l.reverse\n\
    \                            case y if y > xs => l\n                         \
    \   case y => l :+ y\n                        }\n                        c.foldLeft(List[Tuple2[Long,\
    \ Long]]()) {\n                            case ((row: List[Long], c: List[Long],\
    \ l: List[Long]), (index: Int, xs: Int, y: Long)) =>\n                       \
    \         val k = index\n                                val xInc0 = xInc\n  \
    \                              val xInc1 = xInc0 match {\n                   \
    \                 case l => l\n                                    case _ => l\
    \ :+ xInc0(0)\n                                }\n                           \
    \     val yInc0 = yInc\n                                val yInc1 = yInc0 match\
    \ {\n                                    case l => l\n                       \
    \             case _ => l :+ yInc0(0)\n                                }\n   \
    \                             val xDec0 = xDec\n                             \
    \   val xDec1 = xDec0 match {\n                                    case l => l\n\
    \                                    case _ => l :+ xDec0(0)\n               \
    \                 }\n                                val yDec0 = yDec\n      \
    \                          val yDec1 = yDec0 match {\n                       \
    \             case l => l\n                                    case _ => l :+\
    \ yDec0(0)\n                                }\n                              \
    \  row.foldLeft(List[Tuple2[Long, Long]]()) {\n                              \
    \      case ((row: List[Long], c: List[Long], l: List[Long]), (index: Int, xs:\
    \ Int, y: Long)) =>\n                                        val m = index\n \
    \                                       val xInc2 = xInc1\n                  \
    \                      val xInc3 = xInc", "        if (lst.isEmpty) Nil\n    \
    \    else {\n            val n = lst.size\n            val m = lst.head._2.size\n\
    \            val lst1 = lst.map(_.zipWithIndex).filter(_._2 % n == 0)\n      \
    \      val rows = lst1.map(x => (x._2, x._1.toLong / n))\n            val rows1\
    \ = rows.filter(x => x._1 == x)\n            val rows2 = rows.filter(x => x._1\
    \ == x + 1)\n            val result = rows1.zip(rows2)\n                .reduceLeft((x,\
    \ y) => x zip y).filter(_._1 == x)\n                .reverse.sortWith(_._1 > _._1)\n\
    \                .map(t => (t._2, t._1))\n        }", "        val pairs = lst.map((_:\
    \ Iterable[Long]).toSet).flatMap(_.filter((x: Long) => x.mod(2) != 0)).distinct\n\
    \        val xInRow = pairs.filter((y: Long) => x.mod(y) == 0)\n        val xInColumn\
    \ = pairs.filter((y: Long) => x.mod(y) != 0)\n        val maxRow = xInRow.max(_.toLong)\n\
    \        val maxColumn = xInColumn.max(_.toLong)\n        if (maxRow.toLong ==\
    \ 0) List[Tuple2[Long, Long]]() else lst.filter((x: List[Long]) => x(0) == maxRow).sortBy(x\
    \ => x(0)).map(x => (x(1), x(maxColumn.toLong - 1))).filter(x => x(0) == x).toList",
  '        lst.map(l => if (l.size < x) Nil else ((l.size - 1).toLong, l(x)));', " \
    \       // Create empty matrix for x\n        var matrix = List.fill(x)((List[Long]()))\n\
    \n        // Get first row\n        var firstRow = lst.head\n\n        // For\
    \ each row from lst\n        lst match {\n            case x :: y =>\n       \
    \         // For each item in the row\n                y match {\n           \
    \         case x :: _ => // If it is x, add it to the row\n                  \
    \      matrix += ((x, firstRow.head))\n\n                    case _ => // Otherwise,\
    \ add it into the matrix\n                        matrix += ((firstRow.head, firstRow.last))\n\
    \                }\n\n            // If there are no more rows\n            case\
    \ Nil =>\n                matrix += ((firstRow.head, firstRow.last))\n\n     \
    \   }\n\n        // Return list of tuples\n        matrix.sortBy(_._1).reverse.sortBy(_._2).reverse",
  "        var coord : List[(Long, Long)] = Nil\n        val r : List[Long] = lst.map(x\
    \ => x.map(_+1).sortBy(-_)).flatten\n        var i = 0\n        while (i < r.length)\
    \ {\n            coord = coord :+ (r(i), i)\n            i += 1\n        }\n \
    \       coord.sortBy(-_._1).map(x => (x._1, x._2)).filter(_._1 == x).map(_._2)",
  "        val lstM: MutableList[List[Long]] = lst.map(_.toList)\n        val r: List[Tuple2[Long,\
    \ Long]] = lstM.map(x => Tuple2(x, x))\n        r.sortWith(_._1 < _._1)", "  \
    \      val m = lst.size // rows\n        val n = lst(0).size // columns\n    \
    \    val r = new Array[Tuple2[Long, Long]](m)\n        var i = 0\n        while\
    \ (i < m) {\n            var j = 0\n            while (j < n) {\n            \
    \    if (lst(i).contains(x)) r(i) = Tuple2(i, j);\n                j++\n     \
    \       }\n            i++\n        }\n        r.sortWith((x, y) => x._1 < y._1)\n\
    \        r.reverse.sortWith((x, y) => y._1 < x._1)\n        r", "        val rows\
    \ = lst.map(_.toList)\n        val cols = lst(0).map(_.toList)\n        val result\
    \ = new mutable.ListBuffer[Tuple2[Long, Long]]()\n        var currX = x\n    \
    \    var currY = 0\n        while(!rows.isEmpty && rows.head != List.empty) {\n\
    \            if(rows.head.length == cols.length) {\n                var rowIndex\
    \ = rows.head(0)\n                var colIndex = cols.head\n                while\
    \ (colIndex != 0) {\n                    if (rowIndex == currX) {\n          \
    \              result.+=(Tuple2(rowIndex, colIndex))\n                    }\n\
    \                    rowIndex += 1\n                    colIndex -= 1\n      \
    \          }\n            }\n            rows.head = (rows.head - 1)\n       \
    \     cols.head = (cols.head - 1)\n            currX -= 1\n            currY +=\
    \ 1\n        }\n        return result.toList.reverse.sortBy(_._1).reverse.sortBy(_._2).reverse",
  "        def sortFunc(x : (Long, Long)) : Boolean = x._1 < x._2\n        val rowList\
    \ = lst.toList\n        val columnList = lst.toList.map(_.toList).toList\n   \
    \     columnList.sortBy(sortFunc).reverse.sortBy(sortFunc)\n        rowList.map(x\
    \ => (x.zipWithIndex.map(x => (x._2, x._1 + 1)))).filter(_._1 == x).map(x => x._2.reverse).map(x\
    \ => (x._1, x._2)).toList", "        var row: List[Tuple2[Long, Long]] = None\n\
    \        var maxRow = 0\n        var maxCol = 0\n        lst.foreach {\n     \
    \       lst => {\n                lst.foreach {\n                    row => {\n\
    \                        if (row.contains(x))\n                            return\n\
    \                        if (maxRow < row.last._1)\n                         \
    \   maxRow = row.last._1\n                        if (maxCol < row.last._2)\n\
    \                            maxCol = row.last._2\n                    }\n   \
    \             }\n            }\n        }\n        if (maxRow == 0)\n        \
    \    List[Tuple2[Long, Long]]()\n        else\n            (0 until maxRow).map\
    \ {\n                i => ((i + 1) * maxCol + x, (i + 1) * maxCol + x + maxRow)\n\
    \            }", "        val (sortedRows, sortedCols) = lst.sortBy { a => (a(0).compareTo(x))\
    \ }\n        val listOfTuples = sortedRows.map { row =>\n            val (_, _,\
    \ rowWithX) = getRowWithX(row, x)\n            (rowWithX._1, rowWithX._2)\n  \
    \      }\n        listOfTuples.sortBy(_._1)", "        val (maxRow, maxCol) =\
    \ lst.foldLeft((0, 0)) {\n            case((maxRow, _), list) => list.foldRight((maxRow,\
    \ list.size))(max => max max max max max max) //max of list\n        }\n     \
    \   //print (maxRow, maxCol)\n        val rows = lst.map(row => (row.size, row)).sortBy(_._1).reverse\n\
    \        val cols = rows.map(row => (row._2, row)).sortBy(_._2).reverse\n    \
    \    //print (rows, cols)\n        cols.map(col => (col._1, col._2)).map(coord\
    \ => (coord, coord._2, row._1, row._2)).sortWith(compareRowCol)", "        val\
    \ lst1 = lst.sortWith( (p1, p2) => p1.headOption.exists( _ == x) && p2.headOption.exists(\
    \ _ == x) )\n        val lst2 = lst1.sortWith( (p1, p2) => p1.lastOption.exists(\
    \ _ == x) && p2.lastOption.exists( _ == x) )\n        lst2.map( (p) => (p.headOption.getOrElse(x),\
    \ p.lastOption.getOrElse(x)) )", "        val mn = lst.head\n        val mx =\
    \ lst.last\n        val n = mx.length\n        val m = mn.length\n        var\
    \ r = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ res = new mutable.ArrayBuffer[Tuple2[Long, Long]]()\n        res.appendAll((new\
    \ Tuple2[Long, Long](xl, xl)).map(tup2 => new Tuple2[Long, Long](tup2._1, 0l)))\n\
    \        for(i <- 0 until n){\n            for(j <- 0 until m){\n            \
    \    if((lst(i)(j) >=mx) && (lst(i)(j) < mn)){\n                    r = j\n  \
    \                  k = i\n                }\n            }\n            if(r !=\
    \ 0){\n                for(k <- 0 until m){\n                    if(lst(k)(m)\
    \ != mn){\n                        res = res.appendAll((new Tuple2[Long, Long](lst(k)(m),\
    \ lst(k)(m))).map(tup2 => new Tuple2[Long, Long](tup2._2, tup2._2 + 1)))\n   \
    \                 }\n                }\n            }\n        }\n        return\
    \ res.sortBy(tup2 => tup2._1).reverse.sortBy(tup2 => tup2._2).reverse", "    \
    \    val pairs = lst.map(row => row.zipWithIndex)\n        val rows = pairs.groupBy(_._1).filter(_._2\
    \ != 0).map(_._2).sortBy(_._1).map(_._2)\n        val cols = pairs.groupBy(_._2).filter(_._2\
    \ != 0).map(_._2).sortBy(_._1).map(_._2)\n        val index = {\n            var\
    \ i = -1\n            val m = x\n            val n = rows.tail\n            val\
    \ o = cols.tail\n            while(i < n) {\n                i += 1\n        \
    \        val r = rows(i)\n                val c = o(i)\n                if(r <\
    \ m) {\n                    val temp = i\n                    i = m\n        \
    \            m = temp\n                }\n                if(r > m) {\n      \
    \              val temp = i\n                    i = n\n                    n\
    \ = temp\n                }\n                if(c < o(m)) {\n                \
    \    val temp = m\n                    m = c\n                    c = temp\n \
    \               }\n                if(c > o(n)) {\n                    val temp\
    \ = n\n                    n = c\n                    c = temp\n             \
    \   }\n            }\n            i = 0\n        }\n        if(index < 0) {\n\
    \            List(Tuple2[Long, Long](x, x)).sortBy(_._1).map(_._2)\n        }\
    \ else {\n            val row = rows.map(_._1).sortBy(_._1).map(_._2)\n      \
    \      val col = cols.map(_._1).sortBy(_._1).map(_._2)\n            List(Tuple2[Long,\
    \ Long](row(i), col(i))).sortBy(_._1).map(_._2)\n        }", "        require(lst.nonEmpty,\
    \ \"lst(%d) should not be empty\" % lst)\n        var rowIndex = lst.indexWhere\
    \ (_ == x)\n        var rowValue = lst (rowIndex)\n        if (rowIndex == 0)\
    \ {\n            rowIndex += lst.size\n        }\n        rowIndex = rowIndex\
    \ - 1\n        var columnIndex = lst.lastIndexWhere (_ == x)\n        var columnValue\
    \ = lst (columnIndex)\n        if (columnIndex == rowIndex + 1) {\n          \
    \  columnIndex = 0\n            columnIndex += 1\n        }\n        require(columnIndex\
    \ >= 0, \"rowIndex(%d) should be greater than 0(columnIndex)\" % rowIndex)\n \
    \       require(columnIndex <= rowIndex, \"columnIndex(%d) should be less than\
    \ or equal torowIndex(%d)\" % (columnIndex, rowIndex))\n        val coordinate\
    \ = Tuple2(rowValue, columnValue)\n        require(coordinate != None, \"coordinate\
    \ should not be null\")\n        require(coordinate != Tuple2(x, x), \"coordinate\
    \ should not be equal to x\")\n        val coordinates = coordinate.fold(List())((a,\
    \ _) => a :+ Tuple2(a.product, a.product))\n        val rows = coordinates.indexWhere\
    \ (_._1 < coordinate.product)\n        val columns = coordinates.lastIndexWhere\
    \ (_._1 < coordinate.product)\n        require(rows != None, \"rows should not\
    \ be null\")\n        require(columns != None, \"columns should not be null\"\
    )\n        val coordinatesAndRowsAndColumns = coordinates.zip (coordinates.drop(rows\
    \ + 1)) zip (coordinates.drop(1) zip (coordinates.drop(columns) + 1))\n      \
    \  coordinatesAndRowsAndColumns.sortBy { _._1 }.sortBy { _._2 }.map { case (coordinate,\
    \ _) => coordinate }", "        // create map of maps\n        val map = new mutable.HashMap[Long,\
    \ mutable.HashMap[Long, Long]]()\n        for (i <- 0 until lst.size) {\n    \
    \        val row = new mutable.HashMap[Long, Long]()\n            for (j <- 0\
    \ until lst(i).size) {\n                if (lst(i)(j) != x) {\n              \
    \      row.put(lst(i)(j), 0l)\n                } else {\n                    row.put(lst(i)(j),\
    \ 1l)\n                }\n            }\n            map.put(i, row)\n       \
    \ }\n        val row = new mutable.HashMap[Long, Long]()\n        // create map\
    \ of lists sorted by rows\n        val rowList = new mutable.LinkedList[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until map.size) {\n            rowList.push(map.get(i).mapValues\
    \ { case (k,v) => v })\n        }\n        rowList.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        rowList.map(_.mapValues(_.asInstanceOf[Long]).toList).flatMap(x => x).map(x\
    \ => x._1 -> x._2)", "        if (lst.isEmpty) List()\n        else (lst.map(i\
    \ => ((i(0), i((lst.head._2).size))))).sortBy(i => i.productIterator.toList.sortBy(j\
    \ => j))", "        // Use index to find the position of the item in nested list\
    \ using recursion method\n        def getIndex(row : List[Long], index : Int,\
    \ subIndex : Int) : Int = {\n            // If index >= length of row, return\
    \ -1\n            if(index < row.length)\n                return index\n     \
    \       // If subIndex >= length of column, return -1\n            if(subIndex\
    \ >= row.length)\n                return -1\n            // If the sublist is\
    \ empty, return the index value\n            if(row.length == 0)\n           \
    \     return index\n            val currentIndex = getIndex(row, index - 1, subIndex\
    \ + 1)\n            if(currentIndex != -1)\n                return currentIndex\n\
    \            // If the sublist is not empty\n            // Recursive call\n \
    \           val currentSubIndex = getIndex(row, index, subIndex + 1)\n       \
    \     // If sublist is not empty\n            if(currentSubIndex != -1)\n    \
    \            return currentSubIndex\n            // If the sublist is empty, return\
    \ the index value\n            return index\n        }\n\n        def getColumn(column\
    \ : List[Long], index : Int, subIndex : Int) : Int = {\n            // If index\
    \ >= length of column, return -1\n            if(index < column.length)\n    \
    \            return index\n            // If subindex >= length of row, return\
    \ -1\n            if(subIndex >= column.length)\n                return -1\n \
    \           // If the sublist is empty, return the index value\n            if(column.length\
    \ == 0)\n                return index\n            val currentIndex = getColumn(column,\
    \ subIndex + 1, index + 1)\n            if(currentIndex != -1)\n             \
    \   return currentIndex\n            // If the sublist is not empty\n        \
    \    // Recursive call\n            val currentSubIndex = getColumn(column, subIndex\
    \ + 1, index + 1)\n            // If sublist is not empty\n            if(currentSubIndex\
    \ != -1)\n                return currentSubIndex\n            // If the sublist\
    \ is empty, return the index value\n            return index\n        }\n\n  \
    \      // Sort the row by rows in ascending order initially and in the descending\
    \ order after each row is sorted\n        // Sorting can be done in three ways\
    \ - 1) using scala.util.Sorting 2) using scala.collection.immutable.TreeSet 3)\
    \ using scala.collection.immutable.TreeMap\n        val rowSorted = lst.sortWith(a\
    \ => a.zipWithIndex.toSeq.sortWith(_.first < _.first).map(_._2))\n        // Sort\
    \ each row by columns in descending order\n        rowSorted.map(row =>\n    \
    \        row.sortWith(a => getColumn(row, a.index, a.subIndex)))\n\n        //\
    \ Get the row that contains the specific value\n        rowSorted.filter(row =>\
    \ row.contains(x)).map(row => row.map { case (index, subIndex) => Tuple2(index,\
    \ subIndex) }).toList", "        if (lst.isEmpty) List()\n        else {\n   \
    \         val rowsList = lst(0).toList\n            val colsList = lst.flatMap(_.length)\n\
    \            val rowIndex = rowsList.indexOf(x)\n            val colIndex = colsList.indexOf(x)\n\
    \            val rowTuples = rowsList.filter(_ != x).map { case x => (x, x-1).toLong\
    \ }.toList\n            val colTuples = colsList.filter(_ != x).map { case x =>\
    \ (x, x-1).toLong }.toList\n            (rowTuples ++ colTuples).sortBy(_._1)\n\
    \                .sortBy(-_._2)\n        }", "        def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n                val xs = lst.map {\
    \ e => e.filter(_ == x) }\n                val xs2 = xs.map{ e => e.sortWith(_\
    \ < _) }\n                val x2s = xs.map{ e => e.sortWith(_ < _.reverse) }\n\
    \                val x2s2 = x2s.map{ e => e.sortWith(_ < _.reverse) }\n      \
    \          val rs = xs.flatMap(x2 => x2s.map(y => (y, x2)))\n                val\
    \ rs2 = xs.flatMap(x2 => x2s2.map(y => (y, x2)))\n                val rs3 = xs.flatMap(x2\
    \ => x2s2.flatMap(y => rs))\n                val rs31 = rs3.reduce((x, y) => if\
    \ (x._2 > y._2) x else y)\n                val rs41 = rs31.map(x2 => (x2._1, x2._2))\n\
    \                val rs51 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val r53 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs56 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs7 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs71 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs3r1 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs4r1 = rs3r1.map(x2 => (x2._1, x2._2))\n               \
    \ val rs5r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n            \
    \    val rs56r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n        \
    \        val rs7r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n     \
    \           val rs7r5r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs7r5r5r1 = rs3r1.reduce((", "        def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            def getRow(lst : List[List[Long]],\
    \ x : Long, acc : List[Tuple2[Long, Long]]): List[Tuple2[Long, Long]] =\n    \
    \        {\n                if (lst.isEmpty) return acc\n                val i\
    \ = lst.head\n                val j  = lst.tail.head\n                getRow(lst.tail,\
    \ x, acc.reverse :+ Tuple2(i, j))\n            }\n            getRow(lst, x, Nil)\n\
    \        }\n        getRow(lst, x, Nil).sortBy(_._1)", "        // sort all coordinates\
    \ by rows\n        lst.sortWith(_._1 <=> _._1)\n        // sort each row by columns\
    \ in descending order\n        lst.flatMap {\n            row =>\n           \
    \     row.sortWith(_._2 <=> -_._2)\n        }.filter { row =>\n            row._1\
    \ == x\n        }.map{\n            row =>\n                (row._1, row._2)\n\
    \        }.toList", "        lst.sortBy {\n            case row => row.toList\n\
    \        }.sortWith(_._2 < _._2) {\n            case (row, _) => row.toList\n\
    \        }.filter {\n            case (row, _) => row.contains(x)\n        }.map\
    \ {\n            case (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n\
    \        }.sortWith(_._2 < _._2) {\n            case (row, _) => row.toList\n\
    \        }.map {\n            case (row, idx) => ((idx % row.size, idx / row.size),\
    \ row.toList)\n        }.sortWith(_._2 < _._2) {\n            case (row, _) =>\
    \ row.toList\n        }.map {\n            case (row, idx) => ((idx % row.size,\
    \ idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2) {\n          \
    \  case (row, _) => row.toList\n        }.map {\n            case (row, idx) =>\
    \ ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2)\
    \ {\n            case (row, _) => row.toList\n        }.map {\n            case\
    \ (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2\
    \ < _._2) {\n            case (row, _) => row.toList\n        }.map {\n      \
    \      case (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n   \
    \     }.sortWith(_._2 < _._2) {\n            case (row, _) => row.toList\n   \
    \     }.map {\n            case (row, idx) => ((idx % row.size, idx / row.size),\
    \ row.toList)\n        }.sortWith(_._2 < _._2) {\n            case (row, _) =>\
    \ row.toList\n        }.map {\n            case (row, idx) => ((idx % row.size,\
    \ idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2) {\n          \
    \  case (row, _) => row.toList\n        }.map {\n            case (row, idx) =>\
    \ ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2)\
    \ {\n            case (row, _) => row.toList\n        }.map {\n            case\
    \ (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2\
    \ < _._2) {\n            case (row, _) => row.toList\n        }.map {\n      \
    \      case (row, idx) => ((idx % row.", "        val rowMap : scala.collection.mutable.Map[Long,\
    \ List[Tuple2[Long, Long]]] = scala.collection.mutable.Map()\n        def getRowHelper(row\
    \ : List[Long], col : Long, rowMap : scala.collection.mutable.Map[Long, List[Tuple2[Long,\
    \ Long]]]) = {\n            if (row == Nil) {\n                rowMap.put(col,\
    \ Nil)\n                return\n            }\n            var i = 1\n       \
    \     var rowList : List[Tuple2[Long, Long]] = Nil\n            while (i <= row.size)\
    \ {\n                rowList = rowMap.get(row(i))\n                if (rowList\
    \ == null) {\n                    rowList = scala.collection.mutable.ListBuffer.empty\n\
    \                    rowMap += (row(i) -> rowList)\n                }\n      \
    \          rowList += ((col, i))\n                i += 1\n            }\n    \
    \    }\n        val size = lst.size\n        for (i <- 0 until size) {\n     \
    \       var rowList = rowMap.get(i).orElse(Nil)\n            var i = 1\n     \
    \       var col = 0\n            while (i <= row.size) {\n                getRowHelper(row,\
    \ col, rowMap)\n                i += 1\n                col += 1\n           \
    \ }\n        }\n        return rowMap.toList.sortBy(_._1).reverse.map(_.swap)",
  "        if(lst.size() == 0) return List((x, x))\n        val rows = lst.map(row\
    \ => (row.size, row.max)).toSeq\n        val cols = rows.map(_.swap).getOrElse((0l,\
    \ 0l))\n        val coords = lst.flatMap(row => (row.map(elem => elem + coords._2).toSeq)).distinct\n\
    \        val sortedCoords = coords.sortBy(r => (r._1, r._2)).reverse.map(c =>\
    \ ((coords.indexWhere(i => i._1 == c._1) // first occurence\n            ) ->\
    \ (coords.indexWhere(i => i._2 == c._2) // second occurence\n            )))\n\
    \        val sortedRows = rows.sortBy(r => (r._1 - coords._2).toLong)\n      \
    \  val result = sortedCoords.flatMap(c => (sortedRows.map(row => ((coords.indexWhere(i\
    \ => i._1 == c._1) // first occurence\n            ) -> (coords.indexWhere(i =>\
    \ i._2 == c._2) // second occurence\n            ) -> (coords.indexWhere(i =>\
    \ i._1 == c._1) // first occurence\n            ) -> (coords.indexWhere(i => i._2\
    \ == c._2) // second occurence\n            ) -> (coords.indexWhere(i => i._1\
    \ == c._1) // first occurence\n            ) -> (coords.indexWhere(i => i._2 ==\
    \ c._2) // second occurence\n            ) -> (coords.indexWhere(i => i._1 ==\
    \ c._1) // first occurence\n            ) -> (coords.indexWhere(i => i._2 == c._2)\
    \ // second occurence\n            ) -> (coords.indexWhere(i => i._1 == c._1)\
    \ // first occurence\n            ) -> (coords.indexWhere(i => i._2 == c._2) //\
    \ second occurence\n            ) -> (coords.indexWhere(i => i._1 == c._1) //\
    \ first occurence\n            ) -> (coords.indexWhere(i => i._2 == c._2) // second\
    \ occurence\n            ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n\
    \            ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n\
    \            )))", "        val l = lst.filter(_ contains x).map(_)\n        val\
    \ r = lst.filter(_ contains x).map(_.reverse).sortWith((x, y) => y.getOrElse(0)\
    \ - x.getOrElse(0))\n        val tuples = r.foldLeft((List.empty[Tuple2[Long,\
    \ Long]], 0l)) {\n            case ((list, cur), row) => list :+ Tuple2(cur, row(0))\n\
    \        }\n        tuples.sortWith(_._2._1 < _._1._1)", "        // find first\
    \ element of lst\n        val indexOfFirst = lst.indexOfFirst {\n            _\
    \ != Nil\n        }\n        if (indexOfFirst == -1) {\n            // No element\
    \ found\n            List()\n        } else {\n            // Recursively invoke\
    \ itself for remaining elements\n            val lstElements = lst.drop(indexOfFirst).reverse\n\
    \            val currentRow = lstElements.head\n            val currentRowIndex\
    \ = currentRow.indexOf(x)\n            if (currentRowIndex >= 0) {\n         \
    \       val currentRowElements = currentRow.drop(currentRowIndex)\n          \
    \      val currentRowElementsIndex = currentRowElements.indexOf(x)\n         \
    \       if (currentRowElementsIndex >= 0) {\n                    val currentRowElementsElement\
    \ = currentRowElements.at(currentRowElementsIndex)\n                    (currentRowIndex.toLong,\
    \ currentRowElementsElement.toLong)\n                } else {\n              \
    \      Nil\n                }\n            } else {\n                Nil\n   \
    \         }\n        }", "        val m = lst.size\n        val n = lst(0).size\n\
    \        if (lst.isEmpty) {\n            List[Tuple2[Long, Long]]()\n        }\
    \ else {\n            var maxRow = lst(0).head\n            var maxCol = lst(0).tail\n\
    \            var row = lst(0).head\n            var col = lst(0).tail\n      \
    \      val tuples = List[Tuple2[Long, Long]]()\n            while (row <= m) {\n\
    \                col = col - maxCol\n                maxCol = maxCol + x\n   \
    \             if (maxCol < 0) {\n                    maxCol = 0\n            \
    \    }\n                if (row > m) {\n                    maxRow = lst(row).head\n\
    \                    maxCol = lst(row).tail\n                    row = row + 1\n\
    \                }\n                if (maxRow < 0) {\n                    maxRow\
    \ = 0\n                }\n                val tuple = (maxRow, maxCol)\n     \
    \           tuples ::= tuple\n            }\n            tuples\n        }", " \
    \       if(lst.isEmpty) List()\n        else if(lst.length == 1) x -> lst(0)(0)\n\
    \        else if(lst.length == 2) x -> lst(0)(0) -> (lst(1)(0) -> lst(0)(1))\n\
    \        else if(lst.length == 3) x -> lst(0)(0) -> (lst(1)(0) -> (lst(1)(1) ->\
    \ lst(0)(1))) -> (lst(2)(0) -> (lst(2)(1) -> lst(0)(1)))\n        else {\n   \
    \         val x1: List[Long] = getRow(lst(1), x)\n            val x2: List[Long]\
    \ = getRow(lst(2), x)\n            x1 ::: x2 ::: x1 ::: x2\n        }", "    \
    \    val rows = lst.flatMap(_.toList)\n        val rows = rows.sortWith(_.first\
    \ < _.first)\n        val cols = rows.map(_.toList)\n        val cols = cols.sortWith(_.last\
    \ > _.last)\n        val pairs = rows.zipWithIndex.map {\n            case (row,\
    \ idx) => (idx, cols.map(idx => if (row == x) (idx + 1) else idx))\n        }\n\
    \        pairs.sortBy(_._1).map {\n            case (idx, cols) => (idx, cols.reverse)\n\
    \        }", "        val r = lst.flatMap(x => x).map(i => (i, 0))\n        val\
    \ c = lst.flatMap(x => x.reverse).map(i => (0, i))\n        (r.reverse, c.reverse).sortBy(_._1).map(x\
    \ => (x._2, x._1)).filter(_._1 == x).map(_._2)", "        def getTuple(lst: List[List[Long]],\
    \ index: Int, value: Long): List[Tuple2[Long, Long]] = { \n            if (index\
    \ == lst.size) {\n                tupleList[index]\n            } else if (lst(index).nonEmpty)\
    \ {\n                val res = getTuple(lst, (index + 1) % lst.size, lst(index).head).map(x\
    \ -> Tuple2(value, x))\n                tupleList ++ res\n            } else {\n\
    \                getTuple(lst, (index + 1) % lst.size, value)\n            }\n\
    \        }\n        val tupleList: List[Tuple2[Long, Long]] = List(Tuple2(0, x))\n\
    \        getTuple(lst, 0, x)", "        var newRow = List[Tuple2[Long, Long]]()\n\
    \        var newCol = List[Long]()\n        for (i <- 0 until lst.size) {\n  \
    \          for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    newRow += Tuple2((i, j))\n                }\n    \
    \            if (newRow.isEmpty && newCol.isEmpty && lst(i).length == 1) {\n \
    \                   newRow += Tuple2((i, lst(i)(0)))\n                }\n    \
    \        }\n        }\n        if (newRow.isEmpty) {\n            newRow += Tuple2((0,\
    \ 0l))\n        }\n        if (newCol.isEmpty) {\n            newCol += 0l\n \
    \       }\n        if (newCol.head == newCol.last) {\n            newCol = List.fill(newCol.head)((newCol.head\
    \ - 1l) until newCol.last)\n        }\n        newCol.sortWith((a, b) => b - a).reverse\n\
    \        newCol.sortWith((a, b) => a - b)\n        newCol.sortWith((a, b) => b\
    \ - a)\n        newCol.sortWith((a, b) => b - a)\n        for (i <- 0 until newCol.length)\
    \ {\n            newCol(i) match {\n                case 0l =>\n             \
    \       break\n                case n =>\n                }\n                newCol(i)\
    \ match {\n                    case nl =>\n                        newCol(i) match\
    \ {\n                            case 0l =>\n                                break\n\
    \                            case nl =>\n                        }\n         \
    \               newCol(i) match {\n                            case nl =>\n  \
    \                              newCol(i) match {\n                           \
    \         case nl =>\n                                    }\n                \
    \                    newCol(i) match {\n                                     \
    \   case nl =>\n                                    }\n                      \
    \              newCol(i) match {\n                                        case\
    \ nl =>\n                                    }\n                             \
    \       newCol(i) match {\n                                        case nl =>\n\
    \                                    }\n                                    newCol(i)\
    \ match {\n                                        case nl =>\n              \
    \                      }\n                                    newCol(i) match\
    \ {\n                                        case nl =>\n                    \
    \                }\n                                    newCol(i) match {\n  \
    \                                      case nl =>\n                          \
    \          }\n                                    newCol(i) match {\n        \
    \                                case nl =>\n                                \
    \    }\n                                    newCol(i) match {\n              \
    \                          case nl =>\n                                    }\n\
    \                                    newCol(i) match {\n                     \
    \                   case nl =>\n                                    }\n      \
    \                              newCol(i) match {\n                           \
    \             case nl =>\n                                    }\n            \
    \                        newCol(i) match {\n                                 \
    \       case nl =>\n                                    }\n                  \
    \                  newCol(i) match {", "      val tuples = lst.map(_.map(_ + x).map(Tuple2.apply))\n\
    \      tuples.groupBy(_._1).sortBy(_._2).map(p => (p._1, p._2.map(_._2)))", " \
    \       var i = 0\n        var j = 0\n        var row = List[Tuple2[Long, Long]]()\n\
    \        while (i < lst.size) {\n            val tmpRow = lst(i).take(x).toList\n\
    \            if (tmpRow.size < x) {\n                tmpRow :: lst(i).drop(x).toList\n\
    \            } else {\n                tmpRow.toList match {\n               \
    \     case h :: t => row ::= (h -> j)\n                    case _ => row ::= (j\
    \ -> j)\n                }\n            }\n            i += 1\n            j +=\
    \ 1\n            if (j == lst(i).size) {\n                j += 1\n           \
    \ }\n        }\n        row.sortBy(_._1).sortBy(_._2)", "        val (maxRow,\
    \ maxCol) = lst.foldLeft((0, 0))({ (acc, el) => if (el.length > acc._1) el.length\
    \ else acc })\n        val (row, col) = lst.foldLeft((0, 0))({ (acc, el) => if\
    \ (el.length == acc._1) (el(0).toInt, el(1).toInt) else acc })\n        if (row._2\
    \ == maxRow && col._2 == maxCol) {\n            var rowTmp = row._1\n        \
    \    var colTmp = col._1\n            var tmpRow = row._2\n            var tmpCol\
    \ = col._2\n            var i = col._2\n            var j = 0\n            while\
    \ (i < maxCol) {\n                var nextCol = i + 1\n                while (j\
    \ < maxCol) {\n                    val (rowNew, colNew) = if (tmpRow == rowTmp\
    \ && tmpCol == colTmp) {\n                        (tmpRow, tmpCol)\n         \
    \           } else if (tmpRow > rowTmp) {\n                        (tmpRow, tmpCol)\n\
    \                    } else {\n                        (tmpRow, tmpCol)\n    \
    \                }\n                    tmpRow = rowNew\n                    tmpCol\
    \ = colNew\n                    rowTmp = rowNew\n                    colTmp =\
    \ colNew\n                    j++\n                }\n                i += 1\n\
    \                tmpCol++\n            }\n            return List(Tuple2(rowTmp.toInt,\
    \ colTmp.toInt))\n        } else {\n            return List()\n        }", " \
    \       val rows = lst.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n        val\
    \ columns =\n            lst.zipWithIndex.map(_.map(x => x match {\n         \
    \       case None => 0\n                case Some(x) => x\n            }))\n \
    \               .zipWithIndex.map(_.map(_._2))\n                .sortBy(_._1).reverse\n\
    \                .map(_._2)\n        val outputRows = rows.zipWithIndex.filter(i\
    \ => i._1 == x).map(i => (i._2, i._1))\n        val outputColumns = columns.zipWithIndex.map(i\
    \ => i._1 -> i._2).sortBy(_._1).reverse.map(_._2)\n        List(outputRows, outputColumns)",
  "        val list = lst.toList\n        list.sortBy(a => a(0))\n        list.sortBy(a\
    \ => a(1)).reverse\n        val xIndex = list.indexWhere(a => a(0) == x)\n   \
    \     val result = list.get(xIndex).toList\n        result.sortBy(a => a(1)).reverse\n\
    \        result.reverse", "        var result : List[Tuple2[Long, Long]] = Nil\n\
    \        var row = 0\n        var col = 0\n        var num = 0\n        lst.foreach\
    \ { i =>\n            if ((i = 0) && (num < x)) row += 1\n            else if\
    \ ((i = 0) && (num >= x)) {\n                num -= x\n                col +=\
    \ 1\n                result ::= (Tuple2(row, col))\n                row = 0\n\
    \                col = 0\n            }\n            num += 1\n        }\n   \
    \     result", "        val m = lst.size\n        val n = lst(0).size\n      \
    \  var tuples: List[Tuple2[Long, Long]] = Nil\n\n        for (row <- 0 until m)\
    \ {\n            var row_tuples: List[Tuple2[Long, Long]] = Nil\n            for\
    \ (column <- 0 until n) {\n                if(lst(row)(x) == column) {\n     \
    \               row_tuples = row_tuples :+ (row, column)\n                }\n\
    \            }\n            tuples = tuples ++ row_tuples\n        }\n       \
    \ val tupleSort = tuples.sortBy(x => x._1)\n        val tupleSortReverse = tupleSort.sortBy(x\
    \ => x._1).reverse\n        tupleSortReverse.foreach(x => tupleSort(x))\n    \
    \    tupleSortReverse", "        // Get row from matrix data\n        val rows\
    \ = lst.map(x => x)\n        // Get row from matrix data\n        val rowIndex\
    \ = rows.indexOf(x)\n        val row = rows(rowIndex)\n        // Get column from\
    \ matrix data\n        val columns = row.map( x => x % x).getOrElse(0)\n     \
    \   val columnIndex = columns.indexOf(x)\n        val rowValues = rows(rowIndex).map(\
    \ x => x % x).getOrElse(0)\n        val tuples = for (i <- 0 until rowIndex; x\
    \ <- rowValues(i)) yield ((rowIndex - i - 1, columnIndex - x), x)\n        //\
    \ Sort tuples by rows in ascending order - row 0 is first row\n        tuples.sortBy(x\
    \ => x._1).reverse", "        def toTuple(row: List[Long]) : List[Tuple2[Long,\
    \ Long]] = {\n            val tup: List[(Long, Long)] = row.zipWithIndex.sortBy(_._1).map{x\
    \ => (x._2, x._1)}\n            val tup2 = tup.sortBy(_._1).reverse\n        \
    \    (tup2.map(x => (x._2, x._1)).filter(x => x == (x._2, x)).map(x => (x._1,\
    \ x._2))).toList\n        }\n        if(lst.isEmpty) List(Tuple2[Long, Long](x,\
    \ x))\n        else if(lst.isEmpty) List(Tuple2[Long, Long]())\n        else getRow(lst.head,\
    \ x)", "        val lst0 = lst.flatten\n        val lst1 = lst0.slice(lst0.length\
    \ - x, lst0.length)\n        val lst2 = lst1.flatten\n        val lst3 = lst2.slice(lst2.length\
    \ - x, lst2.length)\n        lst3.map(x => (x - x, x)).sortBy(_._1).reverse.sortBy(_._2).map(x\
    \ => (x._1, x._2))", "        val m = lst.size\n        val n = lst(0).size\n\
    \        val y = m.toInt\n        val z = (lst.toList flatMap { case Nil => Nil\
    \ } sorted)\n        val z = z.zipWithIndex.filter(x => x._2 % y == 0).sortBy(x\
    \ => x._2).reverse\n        val x = z(0)._2\n        val z = z.filter(_._2 % x\
    \ != 0).sortBy(_._2).reverse\n        z.map(_._1).zipWithIndex.map {\n       \
    \     case (i, j) => (i -> j -> lst(i)(j))\n        }", "        val numRows =\
    \ lst.length\n        val numCols = lst(0).length\n        val coord = mutable.ArrayBuffer.empty[Tuple2[Long,\
    \ Long]]\n        coord.append(Tuple2(0, 0))\n        val colIndx = 0\n      \
    \  for (i <- 0 to numRows - 1) {\n            val rowIndx = 0\n            while\
    \ (rowIndx < numCols && colIndx < lst(i).length) {\n                if (lst(i)(colIndx)\
    \ == x)\n                    coord.append(Tuple2(i, lst(i)(rowIndx)))\n      \
    \          rowIndx += 1\n                colIndx += 1\n            }\n       \
    \ }\n        coord.sortBy(_._1).reverse.sortBy(_._2).reverse", "        // Your\
    \ code goes here!\n        val retVal = mutable.ListBuffer[Tuple2[Long, Long]]()\n\
    \        val mapIn = mutable.Map[Long, List[Long]]()\n        for (innerList <-\
    \ lst) {\n            var currentRow = mapIn.getOrElseUpdate(innerList.head,\n\
    \                List[Long]()) match {\n                case Nil => List[Long]()\n\
    \                case head::tail => head::tail\n            }\n            currentRow\
    \ ::= innerList.tail\n            mapIn += (innerList.head -> currentRow)\n  \
    \      }\n        val sortedMap = mapIn.toSeq.sortBy(_._1) ++ mapIn.toSeq.sortBy(_._2)\n\
    \        val searchVal = sortedMap.toList(x).last\n        sortedMap.toList.map\
    \ { case (k, v) => k.toString -> (v.toList zip sortedMap.toList.filter(_._1 ==\
    \ k).map { case (k, v) => v.toList }).filter(_._1 == searchVal).sortBy(_._1).toList\
    \ }", "        val rows = lst.map(_(0))\n        val cols = lst.length\n     \
    \   val result = new mutable.LinkedHashMap[Long, Long]()\n        val index =\
    \ 0\n        while (index < rows.length) {\n            val row = (index / cols).toLong\n\
    \            val col = (index % cols).toLong\n            val value = row(col)\
    \ - x\n            if (result.containsKey(row))\n                result(row) =\
    \ result.getOrElse(row, 0l) + value\n            else\n                result.put(row,\
    \ value)\n            index = index + 1\n        }\n        result.values.toList.sortWith((a,\
    \ b) => b.compareTo(a))\n            .sortWith((a, b) => a.compareTo(b))\n   \
    \         .map(v => ((v - 0).toLong, v.toLong))\n            .sortWith((a, b)\
    \ => b.compareTo(a))\n            .map(v => ((v + 1).toLong, v.toLong))", "  \
    \      val result = new mutable.HashMap[Long, mutable.HashMap[Long, Long]]()\n\
    \        lst match {\n            case Nil => Nil\n            case head :: tail\
    \ => {\n                head match {\n                    case Nil => Nil\n  \
    \                  case head :: tail1 => {\n                        tail match\
    \ {\n                            case Nil => Nil\n                           \
    \ case tail1 :: tail2 => {\n                                tail1 match {\n  \
    \                                  case Nil => Nil\n                         \
    \           case tail1 :: tail2 => {\n                                       \
    \ tail2 match {\n                                            case Nil => Nil\n\
    \                                            case tail2 :: tail3 => {\n      \
    \                                          tail3 match {\n                   \
    \                                 case Nil => Nil\n                          \
    \                          case tail3 :: tail4 => {\n                        \
    \                                tail4 match {\n                             \
    \                               case Nil => Nil\n                            \
    \                                case tail4 :: tail5 => {\n                  \
    \                                              tail5 match {\n               \
    \                                                     case Nil => Nil\n      \
    \                                                              case tail5 :: tail6\
    \ => {\n                                                                     \
    \   tail6 match {\n                                                          \
    \                  case Nil => Nil\n                                         \
    \                                   case tail6 :: tail7 => {\n               \
    \                                                                 tail7 match\
    \ {\n                                                                        \
    \            case Nil => Nil\n                                               \
    \                                     case tail7 :: tail8 => {\n             \
    \                                                                           tail8\
    \ match {\n                                                                  \
    \                          case Nil => Nil\n                                 \
    \                                                           case tail8 :: tail9\
    \ => {\n                                                                     \
    \                           tail9 match {\n                                  \
    \                                                                  case Nil =>\
    \ Nil\n                                                                      \
    \                              case tail9 :: tail10 => {\n                   \
    \                                                                            \
    \         tail10 match {\n                                                   \
    \                                                         case Nil => Nil\n  \
    \                                                                            \
    \                              case tail10 :: tail11 => {\n                  \
    \                                                                            \
    \                  tail11 match {\n                                          \
    \                                                                          case\
    \ Nil => Nil\n                                                               \
    \                                                     case tail11 :: tail12 =>\
    \ {\n                                                                        \
    \                                                tail12 match {\n            \
    \                                                                            \
    \                                    case Nil => Nil\n                       \
    \                                                                            \
    \                         case tail12 :: tail13 => {\n                       \
    \                                                                            \
    \                             tail13 match {\n                               \
    \                                                                            \
    \                         case Nil => Nil\n                                  \
    \                                                                            \
    \                      case tail13 :: tail14 => {\n                          \
    \                                                                            \
    \                                  tail14 match {\n                          \
    \                                                                            \
    \                                      case Nil => Nil\n                     \
    \                                                                            \
    \                                           case tail14 :: tail15 => {\n     \
    \                                                                            \
    \                                                               tail15 match {\n\
    \                                                                            \
    \                                                                        case\
    \ Nil => Nil\n                                                               \
    \                                                                            \
    \         case tail15 :: tail16 => {\n                                       \
    \                                                                            \
    \                                     tail16 match {\n                       \
    \                                                                            \
    \                                                         case Nil => Nil\n  \
    \                                                                            \
    \                                                                            \
    \  case tail16 :: tail17 => {\n                                              \
    \                                                                            \
    \                                      tail17 match {\n                      \
    \                                                                            \
    \                                                                  case Nil =>\
    \ Nil\n                                                                      \
    \                                                                            \
    \                  case tail17 :: ", "        def swap(lst: List[Long], i: Int,\
    \ j: Int): List[Long] = {\n            var tmp: List[Long] = null\n          \
    \  var index = 0\n            while (index < lst.size) {\n                if (j\
    \ >= lst(index).size) {\n                    if (index >= lst.size) {\n      \
    \                  tmp :: lst\n                    } else {\n                \
    \        tmp = swap(lst, index, j + 1)\n                    }\n              \
    \      break\n                }\n                if (j == lst(index).size) {\n\
    \                    tmp :+ lst(index)\n                    index += 1\n     \
    \           } else {\n                    index += 1\n                }\n    \
    \        }\n            return tmp\n        }\n\n        def getRows(lst: List[List[Long]],\
    \ x: Long): List[Tuple2[Long, Long]] = {\n            def getCols(lst: List[Long]):\
    \ List[Long] = {\n                var col: List[Long] = null\n               \
    \ var index = 0\n                while (index < lst.size) {\n                \
    \    if (x >= lst(index).size) {\n                        if (index >= lst.size)\
    \ {\n                            col :: lst\n                        } else {\n\
    \                            col = swap(lst, index, 0)\n                     \
    \   }\n                        break\n                    }\n                \
    \    if (x == lst(index).size) {\n                        col :+ lst(index)\n\
    \                        index += 1\n                    } else {\n          \
    \              index += 1\n                    }\n                }\n        \
    \        return col\n            }\n\n            def getRowsReversed(lst: List[List[Long]],\
    \ x: Long): List[Tuple2[Long, Long]] = {\n                var row: List[Long]\
    \ = null\n                var index = 0\n                while (index < lst.size)\
    \ {\n                    if (x >= lst(index).size) {\n                       \
    \ if (index >= lst.size) {\n                            row :: lst\n         \
    \               } else {\n                            row = swap(lst, index, 0)\n\
    \                        }\n                        break\n                  \
    \  }\n                    if (x == lst(index).size) {\n                      \
    \  row :+ lst(index)\n                        index += 1\n                   \
    \ } else {\n                        index += 1\n                    }\n      \
    \          }\n                return row\n            }\n\n            var row:\
    \ List[Long] = null\n            var col: List[Long] = null\n            var index\
    \ = 0\n            while (index < lst.size) {\n                if (col == null)\
    \ {\n                    col = getCols(lst(index))\n                }\n      \
    \          if (row == null) {\n                    row = getRowsReversed(lst,\
    \ lst(index).apply(col))\n                }\n                if (x == lst(index).size)\
    \ {\n                    row.zip(col) map (_._1) :+ Tuple2(x, Tuple2(x, Tuple2(0,\
    \ Tuple2(x - 1, x - 1))))\n                } else {\n                    row.zip(col)\
    \ map (_._1) :+ Tuple2(x, Tuple2(lst(index).apply(col), x - 1))\n            \
    \    }\n                index++\n            }\n            return row.toList\n\
    \        }\n\n        lst.toList.flatMap {\n            _.getRows(x).map(_", " \
    \       var lst1 = lst\n        var lst2 = lst\n        val length = lst1.size\n\
    \        if(length <= 0)\n            return lst2\n        val colList = lst1.head.drop(x)\n\
    \        val rowList = lst1.drop(1).takeWhile(_ != colList)\n        val row2col\
    \ = lst2.zipWithIndex.map(x => (x._2._1, x._2._2 + x)).toMap\n        val result\
    \ = rowList.map(x => (row2col(x), x))\n        result.sortBy(x => x._1)\n    \
    \    result.sortBy(x => x._2, Ordering[Long].reverse)\n        result.map(x =>\
    \ (x._1._1, x._1._2)).toList", "        if(lst.isEmpty) List(Tuple2(0, 0))\n \
    \       else if((lst(0).isEmpty) && (lst(1).isEmpty)) {\n            val tmp :\
    \ List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple => Tuple2(tuple._1,\
    \ x).zip(tuple._2))\n        }\n        else if((lst(0).isEmpty) && (lst(1).isEmpty\
    \ == false)) {\n            val tmp : List[Tuple2[Long, Long]] = lst\n       \
    \     tmp.map(tuple => Tuple2(tuple._2, x).zip(tuple._1))\n        }\n       \
    \ else if((lst(0).isEmpty == false) && (lst(1).isEmpty)) {\n            val tmp\
    \ : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple => Tuple2(tuple._1,\
    \ x).zip(tuple._2).reverse)\n        }\n        else if((lst(0).isEmpty == false)\
    \ && (lst(1).isEmpty == false)) {\n            val tmp : List[Tuple2[Long, Long]]\
    \ = lst\n            tmp.map(tuple => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false) && (lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse.sortBy(_._4).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse.sortBy(_._4).reverse",
  "        if(lst.isEmpty) Nil\n        else {\n            val m = lst.head\n   \
    \         val r = m.zipWithIndex.filter(x => x % m.size == 0).sortBy(_._1).reverse\n\
    \            val c = lst.last.zipWithIndex.filter(x => x % m.size == 0).sortBy(_._2).reverse\n\
    \            r.zipWithIndex.map(x => (x._2, x._1)).sortBy(_._1).reverse.flatMap\
    \ {\n                case (i, j) =>\n                    (j.map(_ - i).map(i =>\
    \ Tuple2(i, j))).toList\n            }\n        }", "        val rows = lst.map(_.length)\n\
    \        assert(rows.length == 1, \"Only 1 row allowed\")\n        val cols =\
    \ lst(0).map(_.length)\n        assert(cols.length == 1, \"Only 1 column allowed\"\
    )\n        val coords = lst.map(a => (a(0), a(1)))\n        assert(coords.length\
    \ == lst.size, \"List size mismatch\")\n        val xInd = coords.indexOf(x)\n\
    \        assert(xInd != -1, \"Could not find \" + x + \" in coords\")\n      \
    \  coords.map(a=>a._2.map(a._1).toSeq).sortBy(a=>a._1).reverse.sortBy(a=>a._2).reverse.map\
    \ {\n            case ((a, b), (c, d)) => Tuple2(a, b)\n        }", "        val\
    \ size = lst.size\n        val r = lst.filter(l=> l.contains(x)).sortWith((a:\
    \ List, b: List) => a._1 > b._1).map(l => (l.indexOf(x),l.indexOf(x) + 1))\n \
    \       if(size > 0) {\n          val c = lst.filter(l=> l.contains(x)).sortWith((a:\
    \ List, b: List) => a._1 > b._1).map(l => (l.indexOf(x),l.indexOf(x) + 1))\n \
    \         val nr = c.groupBy(a => a._1).mapValues(_.map(_._2)).sortWith((a: List,\
    \ b: List) => b._2 > a._2).map(_._1)\n          val nrf = nr.filter(_ < size)\n\
    \          nrf.map(_ => r.map(_._1)).flatMap(x => x).sortWith((a: List, b: List)\
    \ => a._1 > b._1).map(_ => (x(0),x._2 - 1))\n        } else {\n          List[Tuple2[Long,Long]]()\n\
    \        }", "        val rows = lst.map(_.reverse)\n        val cols = lst.map(_.size)\n\
    \        val rowIndexes = rows.map(_(0)).toIndexedSeq\n        val colIndexes\
    \ = cols.toIndexedSeq\n        val rows = rowIndexes.zip(colIndexes).toList\n\
    \        val cols = colIndexes.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n \
    \       val colIndexes = cols.toIndexedSeq\n        val result = colIndexes.zip(rowIndexes).toList.flatMap\
    \ {\n            row =>\n                row.map{\n                    case (row,\
    \ col) => Tuple2((row + x, col + x))\n                }\n        }\n        result.sortBy(_._1).reverse.map(_._2)",
  "        val mapRow = mutable.Map[Long, List[Long]]()\n        val mapCol = mutable.Map[Long,\
    \ List[Long]]()\n        \n        lst.map(row => {\n            val mapRowValues\
    \ = row.map(elem => mapRow.getOrElseUpdate(elem, List.empty[Long]))\n        \
    \    val mapColValues = row.map(elem => mapCol.getOrElseUpdate(elem, List.empty[Long]))\n\
    \            mapCol.updated(0, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \            mapRow.updated(0, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \            mapCol.updated(row.zipWithIndex.filter(_._1 == x).map(_._2).reverse,\
    \ row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n            mapRow.updated(row.zipWithIndex.filter(_._1\
    \ == x).map(_._2).reverse, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \        })", "        var inRow = lst\n        for (i <- 0 to lst.length - 1)\
    \ {\n            lst(i) = lst(i).sortWith((x, y) => x < y)\n        }\n      \
    \  for (i <- 0 to lst(0).length - 1) {\n            inRow = inRow.sortWith((x,\
    \ y) => y < x)\n        }\n        inRow = inRow.sortWith((x, y) => y > x)\n \
    \       lst = inRow\n        for (i<- 0 to lst(0).length - 1) {\n            if\
    \ (lst(0)(i) == x) {\n                lst(0) = lst(0)\n                break\n\
    \            }\n        }\n        val res = for (i <- 0 until lst.size - 1) yield\
    \ {\n            val xy = lst(i).zipWithIndex.filter(_._1 == i)\n            (xy(0)._2,\
    \ xy(0)._1)\n        }\n        res.sortWith((x, y) => x._1 < y._1)", "      \
    \  val rows = lst.map(l=> l.toMap)\n        val rowsSorted = rows sortBy (_.keys.toList.sorted)\n\
    \        val columns = rowsSorted map _.keys.toList\n        val columnsSorted\
    \ = columns sortBy (_ < x)\n        val tuples = rowsSorted map {\n          \
    \  case(row: List[Long], rowMap) =>\n                val key = rowMap.get(columnsSorted.head).map(x\
    \ => Tuple2(x, x)).map(_.swap)\n                val result = columns.map(x =>\
    \ Tuple2(row.head, key))\n                result\n        }\n        tuples.toList",
  "        val numCols = lst.map(_.length).reduce(_ + _)\n        val numRows = lst.length\n\
    \        val lstRows = lst.map(_.zipWithIndex.sortBy(_._1))\n        val lstCols\
    \ = lstRows.map(_.map(x => (x, (_: Int))).sortBy(_._1).reverse)\n        val lstTuples\
    \ = lstRows.flatMap(row => lstCols.map(col => (col._1, row._2 + col._1)))\n  \
    \      lstTuples.map(t => (t._1, t._2 - numCols)).sortBy(_._1).reverse", "   \
    \     if (lst.isEmpty) {\n            throw new Exception(\"Can't find row with\
    \ 0 element\")\n        } else if (lst(0).isEmpty) {\n            throw new Exception(\"\
    Can't find row with 0 element in this row\")\n        } else if (lst.size != 1)\
    \ {\n            throw new Exception(\"Not a matrix\")\n        } else {\n   \
    \         // Sort coordinates initially by rows in ascending order.\n        \
    \    val sortedCoordinate = lst.sortWith(x => x.head) \n            // Also, sort\
    \ coordinates of the row by columns in descending order.\n            val sortedCoordinateWithDesc\
    \ = sortedCoordinate.sortWith(x => x.last)\n            val x = x % sortedCoordinateWithDesc.last.last\n\
    \            val coordinateWithDesc = sortedCoordinateWithDesc.find(x => x.last.last\
    \ == x).sortWith(x => x.last.last)\n            // Get coordinate of (x, x)\n\
    \            val coordinate = coordinateWithDesc.find(x => x.last == x).sortWith(x\
    \ => x.last.last)\n            return coordinateWithDesc.map(x => coordinate.map(y\
    \ => (x, y))).toList\n        }", "        // Sorting coordinates by rows in ascending\
    \ order\n        lst.sortWith((a,b) => a.toLong > b.toLong)\n\n        // Sorting\
    \ coordinates by columns in descending order\n        lst.sortWith((a,b) => b.toLong\
    \ > a.toLong)\n\n        // Creating a 2-dim mutable array and filling it with\
    \ coordinates - (row, columns) in the form of tuples\n        var lst2d = Array.ofDim[Tuple2[Long,\
    \ Long]](lst.size)\n        // Getting all elements that exist in the inner list\
    \ for each row and store them in the array\n        lst.map {\n            row\
    \ =>\n                row.foreach { elem =>\n                    lst2d(elem.toInt)\
    \ = (elem.toLong, elem.toLong)\n                }\n        }\n\n        // Returning\
    \ the coordinates which match the x value\n        lst.find(elem => elem.toLong\
    \ == x).toList.sortWith((a,b) => a.toLong > b.toLong).sortWith((a,b) => b.toLong\
    \ > a.toLong).map(xy => (xy.toInt, xy.toInt))", "        val rows = lst.map(row\
    \ => row.map(x => x -> row).zipWithIndex)\n        val sortedRows = rows.sortBy(row\
    \ => row._1)\n        val sortedCols = rows.map(row => row._2).sortBy(col => -col(0))\n\
    \        val resultRows = sortedCols.map(col => (col(0), col(1)))\n        val\
    \ result = (resultRows ::: sortedRows.map(row => (row(0), row(1)) :: Nil))\n \
    \       result.sortBy(row => (row._1))", "        // We need to sort the rows,\
    \ then sort the columns in descending order using scala.math.Ordering\n      \
    \  // Scala.math.Ordering.Int.reverse() will sort a list in ascending order\n\
    \        val rowOrdering = Ordering[List[Long]].reverse\n        val rowOrderingByCol\
    \ = Ordering[List[Long]].on(_.reverse)\n\n        // Sorting the first row in\
    \ the nested list rowOrder \n        // The row list should be sorted in ascending\
    \ order by rows \n        // So for each row in the nested list lst(outer list)\
    \ we will sort using rowOrder\n        val rows = lst.sort(rowOrdering) \n   \
    \     // Sorting the first element of each row in the nested list rowOrder\n \
    \       // The list should be sorted in ascending order by columns\n        //\
    \ So for each row in the nested list lst(outer list) we will sort using rowOrderByCol\n\
    \        val rowsWithCols = lst.map(row => row.sort(rowOrderingByCol))\n     \
    \   // Mapping each row in the nested list lst(outer list) to a list of its column\n\
    \        // We sort the columns using the columnOrder\n        val rows = rowsWithCols.map(row\
    \ => row.sortBy(_._1))\n        // Return the rows that match the given x\n  \
    \      val matchingRows = rows.filter(row => row._1 == x)\n        // Return the\
    \ matching row in the nested list rowOrder\n        val matchingRowWithCols =\
    \ rows.find(row => row._1 == x)\n        // Return the matching row in the nested\
    \ list rowOrderByCol\n        val matchingRowWithColsWithCol = rows.find(row =>\
    \ row._1 == x).map(row => row.sortBy(_._1))\n        \n        // Return empty\
    \ list if the given x is not in the list\n        matchingRowWithColsWithCol match\
    \ {\n          case None => matchingRowWithCols\n          case Some(row) => row\n\
    \        }", "        if(lst.isEmpty) List()\n        else lst\n             \
    \   .zipWithIndex\n                .sortBy{case (it, index) => it._2}\n      \
    \          .sortBy{case (it, index) => it._2}.filter(_._1==x).map(_._2).toList",
  "        val rowList = lst.map(row => (row.indexOf(x), row)).toList\n        rowList.sortBy(row\
    \ => (row.indexOf(x), row)).flatMap(row => (row.sortBy(col => (-col, col)))).map(row\
    \ => (row.head._1, row.head._2))", "        require(lst.length > 0, \"Empty List\"\
    )\n        val len = lst(0).length\n        val rows = new collection.mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            val row = lst.apply(i).zipWithIndex.sortBy(_._1).sortBy(_._2).reverse\n\
    \            rows ++= row.takeWhile(_._1 == x).map(t => (t._2, t._1 + 1))\n  \
    \      }\n        rows.toList", "        // Solution 1 - Using Scala 2.8\n   \
    \     // Solution 2 - Using Scala 2.7\n        // Solution 3 - Using Scala 2.8\n\
    \        // Solution 4 - Using Scala 2.7\n        // Solution 5 - Using Scala\
    \ 2.8\n        require(!lst.isEmpty)\n        val rows = lst.size\n        val\
    \ cols = lst(0).size\n        val ans = mutable.ListBuffer[Tuple2[Long, Long]]()\n\
    \        (0 until rows).foreach(row => {\n            (0 until cols).foreach(col\
    \ => {\n                val value = lst(row)(col)\n                ans += (Tuple2(row,\
    \ col) -> value)\n            })\n        })\n        ans.sortBy(t => t._1)",
  "        val map = new mutable.HashMap[Long, List[Long]]()\n        val map2 = new\
    \ mutable.HashMap[Long, List[Long]]()\n        var index = 0\n        var result:\
    \ List[Tuple2[Long, Long]] = List()\n        // first sort\n        for(i <- 0\
    \ until lst(0).size){\n            if(map.containsKey(lst(0(i)))){\n         \
    \       map.get(lst(0(i)))(i) = lst(0(i))\n            }else{\n              \
    \  map.put(lst(0(i)), lst(0(i)))\n            }\n        }\n        // second\
    \ sort\n        for(i <- 0 until lst(0).size){\n            if(map2.containsKey(lst(0(i)))){\n\
    \                map2.get(lst(0(i)))(i) = lst(1).size - i\n            }else{\n\
    \                map2.put(lst(0(i)), lst(1).size - i)\n            }\n       \
    \ }\n        // first sort\n        for(i <- 0 until map.keySet().toArray.sortWith(_\
    \ < _)){\n            result += ((map.get(i).toList, map2.get(i).toList))\n  \
    \      }\n        return result", "        var r : List[Tuple2[Long, Long]] =\
    \ List(Tuple2(x, 0l))\n        for (i <- 0 until lst.size) {\n            val\
    \ curr = lst(i)\n            var y = curr(0)\n            var x = 0\n        \
    \    var count = 0\n            if (curr == List(x)) {\n                count\
    \ += 1\n            }\n            if (count == 0) {\n                y = curr(1)\n\
    \                count = 0\n            }\n            for (j <- 0 until curr)\
    \ {\n                if (curr(j) == y) {\n                    x = j\n        \
    \            count = 1\n                }\n            }\n            val tuple\
    \ = Tuple2(x, y)\n            if (count > 0) {\n                r = r ++ List(tuple)\n\
    \            }\n        }\n        r.sortBy(_._1)\n        r.sortBy(_._2)\n  \
    \      r", "        def getRowHelper(row: List[Long], x : Long) : List[Tuple2[Long,\
    \ Long]] = {\n            if (row.size >= x) return (row.toList, (row.toList.length,\
    \ 0l))\n            val newRow = row.drop(x - row.size)\n            val getRowHelperResult\
    \ = getRowHelper(newRow, x)\n            row.drop(x - newRow.size) match {\n \
    \               case Nil => (getRowHelperResult._1, getRowHelperResult._2)\n \
    \               case x :: xs =>\n                    if (x == row.last) getRowHelperResult\
    \ :: xs\n                    else getRowHelperResult :: getRowHelper(x, row.last)\
    \ :: getRowHelper(row.drop(1), xs)\n            }\n        }\n        getRowHelper(lst,\
    \ x)", "        var result : List[Tuple2[Long, Long]] = List()\n        val rowIndex\
    \ = mutable.ListBuffer.empty[Long]\n        for (row <- lst) {\n            for\
    \ (i <- 0 until row.size) {\n                if (row(i) == x) {\n            \
    \        rowIndex += i\n                }\n            }\n        }\n        val\
    \ columnIndex = mutable.ListBuffer.empty[Long]\n        for (i <- 0 until rowIndex.size)\
    \ {\n            if (rowIndex(i) >= rowIndex.size) {\n                columnIndex\
    \ += rowIndex.size - i\n            } else {\n                columnIndex += rowIndex(i)\n\
    \            }\n        }\n        for (i <- 0 until columnIndex.size) {\n   \
    \         if (columnIndex(i) >= columnIndex.size) {\n                columnIndex\
    \ += columnIndex.size - i\n            } else {\n                columnIndex +=\
    \ columnIndex(i)\n            }\n        }\n        for (i <- 0 until columnIndex.size)\
    \ {\n            if (columnIndex(i) >= columnIndex.size) {\n                columnIndex\
    \ += columnIndex.size - i\n            } else {\n                columnIndex +=\
    \ columnIndex(i)\n            }\n        }\n        val columnIndex = columnIndex.toList.sortWith(_\
    \ > _)\n        val rowIndex = rowIndex.toList.sortWith(_ < _)\n        var row\
    \ = 0\n        var column = 0\n        for (i <- 0 until rowIndex.size) {\n  \
    \          row += 1\n            column += 1\n            for (j <- 0 until columnIndex.size)\
    \ {\n                if (i == columnIndex(j)) {\n                    result +=\
    \ ((row.toLong, column.toLong))\n                }\n            }\n        }\n\
    \        result.sortWith(_._1 < _._1)", "        val result = new mutable.LinkedHashSet[Tuple2[Long,\
    \ Long]]()\n        val index = new mutable.HashMap[Long, Long]()\n\n        lst.foreach{row\
    \ =>\n            row.foreach{col =>\n                if(index.getOrElse(col,\
    \ -1) < x) {\n                    index += (col -> x)\n                    result\
    \ += Tuple2(col, x)\n                }\n            }\n        }\n\n        val\
    \ sortedIndices = index.toSeq.sortWith(_._1 < _._1)\n        val sortedResults\
    \ = result.sortWith(_._2 < _._2)\n        val tuples = sortedResults.map(e =>\
    \ Tuple2(sortedIndices(e._2).toInt, e._1)).toList\n        tuples.sortWith(_._1\
    \ < _._1)", "        def row(lst : List[List[Long]], r : Long, c : Long) : List[Long]\
    \ = {\n            if (lst.isEmpty) Nil\n            else if (r == x) lst(r -\
    \ 1).map(_ + c) //ascending\n            else row(lst.take(r - 1), r, c + 1) //descending\n\
    \        }\n        row(lst, 0, 0).sortWith(\n            (x1: Long, y1: Long)\
    \ => x1 < y1,\n            (x1: Long, y1: Long) => x1 > y1).map(\n           \
    \ (x1: Long, y1: Long) => Tuple2(y1 - x1, x1)).toList", "        val rows = lst.map(l\
    \ => l.map(x => Tuple2(x, x)))\n        val cols = rows.flatMap(_.map(l => l.map(_\
    \ -> 0)))\n        val sortedRows = rows.sortBy(r => -r.map(_.asInstanceOf[Long]).max)\n\
    \        val sortedCols = cols.sortBy(c => -c.map(_.asInstanceOf[Long]).max)\n\
    \        val res = sortedRows.flatMap(row => sortedCols.map(col => Tuple2(row(0),\
    \ col(0))))\n        return res", "        val map = mutable.Map[Long, Long]()\n\
    \        val rows = lst.flatMap(row => row.map(i => map.putIfAbsent(i, i + x)))\n\
    \        val columns = rows.flatMap(col => col.map(i => map.putIfAbsent(i, i +\
    \ 1)))\n        rows.flatMap(row => row.zipWithIndex)\n            .sortBy(_._1)\n\
    \            .sortBy(_._2)\n            .map(x => (x._1, x._2))", "        lst.sortWith((x,\
    \ y) => x.head < y.head).\n          flatMap((_, i) =>\n            lst\n    \
    \          .take(i)\n              .sortWith((x, y) => x.head > y.head).\n   \
    \           flatMap((_, j) =>\n                lst\n                  .take(j)\n\
    \                  .sortWith((x, y) => x.head < y.head)))\n          .filter((i,\
    \ j) => j == x).\n          map((_, x) => Tuple2(i, x)).toList", "        require(lst.length\
    \ == 1)\n        require(lst(0).length == lst(1).length)\n        val m = lst(0).length\n\
    \        val n = lst(1).length\n        val coords = scala.collection.mutable.ListBuffer.empty[Tuple2[Long,\
    \ Long]]\n        coords.+=((0l, 0l))\n        coords.+=((0l, x)).sortBy(_._1)\n\
    \        coords.+=((xl.toLong, 0l)).sortBy(_._2)\n        coords.+=((xl.toLong,\
    \ xl))\n        coords.+=((xl.toLong, n))\n        coords.+=((n, 0l)).sortBy(_._1)\n\
    \        coords.+=((n, xl))\n        coords.+=((n, n))\n        coords.toList.sortBy(_._1)",
  "        val r = lst.sortWith((r1, r2) => r1.zip(r2).map(_._1).sum < r2.zip(r1).map(_._1).sum)\n\
    \        val m = r.map(_.zip(r).map(x => (x, 0l)).toSet).map { x => x.last.zip(x.last.map(y\
    \ => (y, 0l)).toSet) }\n        val w = r.map(_.zip(m).map(x => x.last.zip(x.last.map(y\
    \ => (y, y._2._1 - x._1)).toSet)).flatten)\n        val l = r.map(_.zip(w).map(x\
    \ => x.last.zip(x.last.map(y => (y, y._2._1 - x._1)).toSet)).flatten)\n      \
    \  l :+ w.map(x => x.last.zip(x.last.map(y => (y, y._2 + x._1)).toSet)).flatten",
  "        // (0, 0) (1, 4) (1, 0) (2, 5) (2, 0)\n        val ls = lst.map(l => l.map(l\
    \ => (l, 0l)).toList.toSeq)\n            .sortWith(_.first < _.second)\n     \
    \       .sortWith(_.first > _.second)\n            .map(l => (l, 0l))\n      \
    \  val tuples = ls.zip(ls.tail).flatMap{ case (l, l2) =>\n            val l =\
    \ l.map(x => (x, l2.head))\n            l.sortWith(_.first < _.second).sortWith(_.first\
    \ > _.second)\n        }\n        tuples.map(t => t._1 -> t._2)", "        def\
    \ findRow(row: List[Long], x: Long) : List[Long] = {\n            val r = row.indexOf(x)\n\
    \            if (r == -1) {\n                row.push(x)\n                row\n\
    \            } else {\n                if (row.last.compareTo(x) < 0) {\n    \
    \                findRow(row.dropRight(1), x)\n                } else {\n    \
    \                findRow(row.drop(1), x)\n                }\n            }\n \
    \       }\n        val rows: List[List[Long]] = lst.map(findRow(_, x)).toList\n\
    \        val newRows = rows.map((row, index) =>\n            (rows(index), row.map((_,\
    \ row.lastIndexOf(x))).reduceLeft{(x, y) => y.compareTo(x)}\n            )\n \
    \       ).sortWith((x, y) => -x._2._2).sortBy(_._1).reverse.map(x => (x._1, x._2))\n\
    \        newRows.toList", "        val m = lst.size\n        var tst = ListBuffer.empty[Tuple2[Long,\
    \ Long]]()\n        var i = 0\n        var col = 0\n        while(i < m) {\n \
    \           while (col < x.toLong) {\n                tst += List(Tuple2(i, col))\n\
    \                col += 1\n            }\n            i += 1\n            col\
    \ = 0\n        }\n        tst.sortWith((x, y) => x._1 < y._1)\n        tst.sortWith((x,\
    \ y) => x._2 < y._2)\n        tst.toList.filter(_._1 == x).filter(_._2 == x).toList",
  "        var rowMap : Map[Long, List[Long]] = Map()\n        var row = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        var idx = 0\n        for (x <- lst) {\n            if (rowMap.getOrElse(x,\
    \ List.empty).contains(idx)) {\n                row += ((idx, rowMap(x, idx)))\n\
    \            }\n            rowMap += (x -> rowMap.getOrElse(x, List.empty).::(idx))\n\
    \            idx += 1\n        }\n        row.toList.reverse.sortBy(_._1).toList",
  "        lst.foldLeft[List[Tuple2[Long, Long]]](List[Tuple2[Long, Long]]())((x,\
    \ y) => y match {\n            case Nil => x :: Nil\n            case head ::\
    \ tail => getRow(tail, x.head + x.last) :: (head :: Nil)\n        })", "     \
    \   val indexToFindInList = lst.indexOf(x)\n        if (indexToFindInList < 0)\
    \ List() else (0 until lst(indexToFindInList).size).map(i => (i, lst.map(x =>\
    \ x(i)).toList)).sortWith(_.swap).reverse.map(x => (x._1, x._2))", "        //\
    \ First sort the coordinates of all rows by rows in ascending order\n        var\
    \ rows: List[List[Long]] = lst.reverse.foldRight(List[List[Long]]()){ (acc, current)\
    \ =>\n            val row: List[Long] = current.reverse\n            (acc.sortWith((x,\
    \ y) => x < y) || acc.reverse, row.sortWith((x, y) => y < x))\n        }._1.sortWith((x,\
    \ y) => x < y)\n        // Then sort the coordinates of each row by columns in\
    \ descending order\n        rows = rows.map(_.sortWith((x, y) => y < x))\n   \
    \     val result: List[Tuple2[Long, Long]] = rows.map(row =>\n            val\
    \ tuple = row.zipWithIndex.filter(x => x._1 == x).sortBy(x => x._2).reverse\n\
    \            (tuple._1, tuple._2)\n        ).takeWhile(x => x._2 == x).map(x =>\
    \ (x._1, x._2 + x))\n        result.reverse", "        // TODO: Write your code\
    \ here\n        var result: List[Tuple2[Long, Long]] = List()\n        for (i\
    \ <- 0 until lst.size) {\n            for (j <- 0 until lst(i).size) {\n     \
    \           if ((i == 0) && (lst(j).contains(x))) {\n                    result\
    \ = result :+ ((i.toLong, j.toLong))\n                }\n                if (j\
    \ == lst(i).size - 1) {\n                    result = result :+ ((i.toLong, j.toLong))\n\
    \                }\n                if (i == lst.size - 1) {\n               \
    \     if (lst(j).contains(x)) {\n                        result = result :+ ((i.toLong,\
    \ j.toLong))\n                    }\n                }\n            }\n      \
    \  }\n        result.sortWith((a, b) => (a._1 < b._1))\n        result.sortWith((a,\
    \ b) => (b._1 > a._1))\n        return result", "        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n",
  "        val lst1 = lst.toList\n        val lst2 = lst1.map(_ match {\n        \
    \    case head :: tail => head\n            case Nil => x\n        }).toList\n\
    \        val lst3 = lst2.sortWith(_.compareTo(_) < 0)\n        val lst4 = lst3.sortWith(_.compareTo(_)\
    \ > 0)\n        val lst5 = lst4.zipWithIndex.sortWith(_.last.compareTo(_._1) >\
    \ 0)\n        val lst6 = lst5.map(_._2)\n        val lst7 = lst6.map((_, x)).toList\n\
    \        lst7.reverse", "        val rows = lst.map(row => row.map(_.toLong))\n\
    \        val rows = rows.sortBy(_.map(_._1))\n        val rows = rows.sortBy(_.map(_._2),\
    \ Ordering.Int.reverse)\n        val rows = rows.filter(row => row._1 == x)\n\
    \        val rows = rows.map(row => Tuple2(row._1, row._2))\n        val rows\
    \ = rows.sortBy(row => (row._2, row._1), Ordering.Long.reverse)\n        val rows\
    \ = rows.map(row => (row._1, row._2))\n        rows.toList", "        if (lst.isEmpty)\
    \ List(Tuple2(0,0))\n        else {\n            val m = lst(0)\n            val\
    \ i = Int((x.toLong - m.toLong)/m.toLong)\n            val y = m.toLong + i *\
    \ m.toLong\n            val m2 = lst(1)\n            val i2 = Int((y.toLong -\
    \ m2.toLong)/m2.toLong)\n            val y2 = m2.toLong + i2 * m2.toLong\n   \
    \         val m3 = lst(2)\n            val i3 = Int((y2.toLong - m3.toLong)/m3.toLong)\n\
    \            val y2 = m3.toLong + i3 * m3.toLong\n            (for {\n       \
    \         i <- 0L until i\n                j <- 0L until i2\n                k\
    \ <- 0L until i3\n            } yield Tuple2(i*m.toLong + j,m2.toLong + k*m2.toLong\
    \ + y)).sortBy(_._1).reverse\n        }", "        var lst2 : List[List[Long]]\
    \ = lst.reverse\n        for (rowCols <- lst2)\n            for (col <- rowCols.reverse)\n\
    \                if (x == col) yield (row, col)", "        // sort lst by rows\
    \ by descending order\n        lst.sortBy( (x) => -x(1) )\n\n        // sort each\
    \ row by columns in descending order\n        // returns List[List[Tuple2[Long,\
    \ Long]]]\n        def sortRow(xs : List[List[Long]]) : List[List[Tuple2[Long,\
    \ Long]]] = {\n            xs.map( _.sortBy( (x) => -x(2) ) ).flatten\n      \
    \  }\n\n        // returns List[Tuple2[Long, Long]]\n        def getCoord(xs :\
    \ List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {\n            xs.find(\
    \ _.exists( (x) => x == x(x) ) ).getOrElse( List[Tuple2[Long, Long]]() )\n   \
    \     }\n\n        // if lst is empty, return empty list\n        if(lst.isEmpty)\
    \ List[Tuple2[Long, Long]]()\n\n        // if x is in the lst, return the list\
    \ of coordinates of x, otherwise return empty list\n        lst.flatMap( getCoord\
    \ ).find( x => x == x ).getOrElse( List[Tuple2[Long, Long]]() )", "        //\
    \ Sort the list by row number\n        lst.sortWith(_.compareTo(_, Ordering[Long]()))\n\
    \n        val listOfTupleOfLongs = lst.map {\n            x =>\n             \
    \   val (row, col) = x\n                (row.toLong, col.toLong)\n        }\n\
    \        listOfTupleOfLongs.sortWith(_.compareTo(_, Ordering[Long](Ordering[Long]())))\n\
    \n        listOfTupleOfLongs.sliding(2).map {\n            x =>\n            \
    \    (x._1, x._2)\n        }.filter(_._1 == x).sortWith(_.compareTo(_, Ordering[Long](Ordering[Long]())))",
  "        val rows = lst.map(_.length)\n        val columns = rows.max\n        val\
    \ maxTuples = columns.toLong / 2\n        val maxTuplesSize = maxTuples * 2\n\n\
    \        val lstOfListOfLongs = lst.map(_.map(_ => x.toLong))\n        val lstOfListOfTuples\
    \ = lstOfListOfLongs.map(_.toList)\n\n        val lstOfListOfTuplesAndTuples =\
    \ lstOfListOfTuples.zip(lstOfListOfTuples.dropRight(maxTuplesSize))\n\n      \
    \  val lstOfListOfTuplesAndTuplesSorted = lstOfListOfTuplesAndTuples.sortBy(_._1)\n\
    \n        val lstOfListOfTuplesAndTuplesSortedByRow = lstOfListOfTuplesAndTuplesSorted.sortBy(_._2)\n\
    \n        val lstOfListOfTuplesAndTuplesSortedByColumn = lstOfListOfTuplesAndTuplesSortedByRow.sortBy(_._1)\n\
    \n        val tuples = lstOfListOfTuplesAndTuplesSortedByColumn.map(_._2).toList\n\
    \        val tuplesWithOutDuplicates = tuples\n        tuplesWithOutDuplicates.distinct.sortWith(_\
    \ < _)", "        def swap(x: Long, y: Long, list: List[List[Long]]) : List[List[Long]]\
    \ = list match {\n            case Nil => list\n            case _ =>\n      \
    \          val temp = list(x)(y)\n                list(x)(y) = list(x)(y)\n  \
    \              list(x)(y) = temp\n                list\n        }\n        val\
    \ sortedLst = lst.sortBy(x => x(0))\n        val rowNr = sortedLst.map(x => x(0)).indexOf(x)\n\
    \        val colNr = sortedLst.map(x => x(1)).indexOf(x)\n        val res = sortedLst\
    \ match {\n            case Nil => Nil\n            case _ => swap(0, rowNr, sortedLst).map(x\
    \ => swap(1, colNr, x)).sorted\n        }\n        val reRow = res.map(_(0)).sorted\n\
    \        val reCol = res.map(_(1)).sorted\n        val finalRe = reRow ++ reCol\n\
    \        reRow", "        val n = lst.length\n        var i = 0\n        var j\
    \ = 0\n        var k = lst(0)(0).toLong\n        var temp = 0l\n        var ans\
    \ = List[Tuple2[Long, Long]]()\n\n        while (i < n) {\n            var minIndex\
    \ = 0\n            var minRow = lst(i)\n            var minCol = lst(0)(0)\n \
    \           var minVal = lst(0)(0)\n            var maxIndex = 0\n           \
    \ var maxRow = lst(n - 1)\n            var maxCol = lst(n - 1)(0)\n          \
    \  var maxVal = lst(n - 1)(0)\n\n            for (k <- 0 until n) {\n        \
    \        if (lst(k)(0).toLong < minVal) {\n                    minIndex = k\n\
    \                    minRow = lst(k)\n                    minCol = lst(0)(0)\n\
    \                    minVal = lst(0)(0)\n                }\n                else\
    \ if (lst(k)(0).toLong > maxVal) {\n                    maxIndex = k\n       \
    \             maxRow = lst(k)\n                    maxCol = lst(0)(0)\n      \
    \              maxVal = lst(0)(0)\n                }\n            }\n\n      \
    \      for (j <- 0 until n) {\n                if (lst(j)(0).toLong < minVal)\
    \ {\n                    minIndex = j\n                    minRow = lst(j)\n \
    \                   minCol = lst(0)(0)\n                    minVal = lst(0)(0)\n\
    \                }\n                else if (lst(j)(0).toLong > maxVal) {\n  \
    \                  maxIndex = j\n                    maxRow = lst(j)\n       \
    \             maxCol = lst(0)(0)\n                    maxVal = lst(0)(0)\n   \
    \             }\n            }\n\n            if (minIndex == maxIndex) {\n  \
    \              var tmpCol = lst(0)(0)\n                var tmpVal = lst(0)(0)\n\
    \                for (k <- 0 until n) {\n                    if (lst(k)(0).toLong\
    \ < minVal) {\n                        minIndex = k\n                        minRow\
    \ = lst(k)\n                        minCol = lst(0)(0)\n                     \
    \   minVal = lst(0)(0)\n                    }\n                    else if (lst(k)(0).toLong\
    \ > maxVal) {\n                        maxIndex = k\n                        maxRow\
    \ = lst(k)\n                        maxCol = lst(0)(0)\n                     \
    \   maxVal = lst(0)(0)\n                    }\n                }\n\n         \
    \       for (j <- 0 until n) {\n                    if (lst(j)(0).toLong < minVal)\
    \ {\n                        minIndex = j\n                        minRow = lst(j)\n\
    \                        minCol = lst(0)(0)\n                        minVal =\
    \ lst(0)(0)\n                    }\n                    else if (lst(j)(0).toLong\
    \ > maxVal) {\n                        maxIndex = j\n                        maxRow\
    \ = lst(j)\n                        maxCol = lst(0)(0)\n                     \
    \   maxVal = lst", "        def toTuple(t: List[Long]) : Tuple2[Long, Long] =\
    \ {\n            val r = t.sorted\n            val c = t.reverse.sorted\n    \
    \        (c.get(0), r.get(r.length - 1))\n        }\n\n        def getRows(t:\
    \ List[Long], rows: List[Long], cols: List[Long]): List[Tuple2[Long, Long]] =\
    \ {\n            if (t.isEmpty) List(Tuple2(rows(0), cols(0)))\n            else\
    \ {\n                val r : List[Long] = t.get\n                val c : List[Long]\
    \ = t.reverse\n                if (c.length >= rows.length) getRows(t.tail, rows.::(rows),\
    \ cols.::(cols))\n                else if (r.length >= cols.length) getRows(t,\
    \ rows, cols.::(cols))\n                else getRows(t.tail, rows.::(rows), cols.::(cols))\n\
    \            }\n        }\n\n        def getCols(t: List[Long], rows: List[Long],\
    \ cols: List[Long]): List[Tuple2[Long, Long]] = {\n            if (t.isEmpty)\
    \ List(Tuple2(cols(0), rows(0)))\n            else {\n                val r :\
    \ List[Long] = t.get\n                val c : List[Long] = t.reverse\n       \
    \         if (r.length >= cols.length) getCols(t.tail, rows.::(rows), cols.::(cols))\n\
    \                else if (c.length >= rows.length) getCols(t, rows, cols.::(cols))\n\
    \                else getCols(t.tail, rows.::(rows), cols.::(cols))\n        \
    \    }\n        }\n\n        val rows = lst.flatMap { x => x.toList }\n      \
    \  val cols = lst.flatMap { x => x.reverse }\n        getRows(rows, rows, cols).flatMap\
    \ { x => toTuple(x) }", "        // Solution below is O(n^2). Solution below is\
    \ O(n) by first sorting by columns in descending order\n        val lst2 = lst.reverse\n\
    \        val lst3 = lst2.groupBy(x => x)\n        val lst4 = lst3.toList\n   \
    \     val lst5 = lst4.sortWith((a, b) => b._2 > a._2)\n        val lst6 = lst5.map(x\
    \ => Tuple2(x._1, x)).map(x => (x._1, x._2)).sortBy(x => x._1)\n        lst6.take(x)",
  "        var rows : List[Tuple2[Long, Long]] = List()\n        var cols : List[Long]\
    \ = List()\n        var result : List[Tuple2[Long, Long]] = List()\n        var\
    \ currentRow : List[Long] = List()\n        var currentCol : List[Long] = List()\n\
    \        var flag : Boolean = false\n\n        if (lst.isEmpty) {\n          \
    \  rows = (List(xl.toLong, 0l))\n        } else {\n            rows.head = (xl.toLong,\
    \ 0l)\n        }\n\n        for(i <- 0 until lst.size) {\n            currentRow.clear()\n\
    \            currentCol.clear()\n\n            if (lst(i).size == 0) {\n     \
    \           rows += (lst(i).head.toLong, 0l)\n                currentRow += 0l\n\
    \                cols += 0l\n            } else if (lst(i).head.toLong != 0) {\n\
    \                rows += (lst(i).head.toLong, 0l)\n                currentRow\
    \ += 0l\n                cols += 0l\n                result += getRow(lst(i).tail,\
    \ x)\n            } else {\n                currentCol = lst(i).tail.distinct\n\
    \n                if (lst(i).head.contains(x)) {\n                    flag = true\n\
    \                } else {\n                    for (j <- 0 until currentCol.size)\
    \ {\n                        if (currentCol(j) != 0l && currentCol(j) != (currentCol(j)\
    \ - 1)) {\n                            flag = true\n                         \
    \   currentCol(j) = currentCol(j) - 1\n                            currentCol(j)\
    \ = (currentCol(j) + 1).toLong\n                            break\n          \
    \              }\n                    }\n                }\n\n               \
    \ if (flag) {\n                    currentRow += currentCol.tail.distinct\n  \
    \                  cols += currentCol.tail.distinct\n                    if (!rows.contains((currentRow,\
    \ cols))) {\n                        rows += (currentRow, cols)\n            \
    \        }\n                }\n            }\n        }\n\n        return result",
  "        val lstNew = lst.sortWith(_._2 < _._2)\n        val xRow = lstNew.indexOf(x)\n\
    \        val xCol = lst(newCols(lstNew, xRow))\n        val row = lst(newRows(lstNew,\
    \ xRow))\n        val lst2 = lstNew.map(_._1).zipWithIndex.sortBy(x => x).map{\n\
    \            case (x, i) => Tuple2(xRow - i, xCol - i)\n        }\n        row\
    \ :: lst2", "        val res = new mutable.LinkedList[Tuple2[Long, Long]]()\n\
    \        val m = lst.size\n        for(i <- 0 until m) {\n            if(lst(i).size\
    \ == 0) {\n                if(!res.contains(Tuple2(i, x))) res.add(Tuple2(i, x))\n\
    \                else\n                    res.remove(Tuple2(i, x))\n        \
    \    }\n            else {\n                val rows = lst(i)\n              \
    \  val cols = rows.tail\n                val maxR = rows.max\n               \
    \ val maxC = cols.max\n                val r = if (maxR > x) maxR else x\n   \
    \             val c = if (maxC > x) maxC else x\n                for(j <- 0 until\
    \ cols.size) {\n                    if(!res.contains(Tuple2(i, j))) res.add(Tuple2(i,\
    \ j))\n                    else if(!res.contains(Tuple2(i + m, j + m))) res.add(Tuple2(i\
    \ + m, j + m))\n                    else if(!res.contains(Tuple2(i, j + m))) res.add(Tuple2(i,\
    \ j + m))\n                }\n            }\n        }\n        res", "      \
    \  lst match {\n            case Nil => ((0 to x.toInt).map(x => (x, 0l)), Nil)\n\
    \            case _ => lst.sortWith(_.length).flatMap { row =>\n             \
    \   (0 to x.toInt).map { i =>\n                    (i to (row.length - 1).toInt).map(j\
    \ => (j, row.map(x => x.toLong).sum))\n                }\n            }\n    \
    \    }", "        val coordinates = lst.map(row => row.map(_ -> 0l).toList).flatten.toList\n\
    \        val coordinatePairs = coordinates.map(c => c.zipWithIndex).toList.sortBy(_._1).map(x\
    \ => (x._2, x._1)).map(x => x._2)\n        val coordinatePairsReverse = coordinatePairs.reverse\n\
    \        val coordinatePairsByRow = coordinatePairs.map(x => (x._1, x._2)).groupBy(x\
    \ => x._1)\n        val coordinatePairsByRowReverse = coordinatePairsByRow.reverse\n\
    \        val rowCoordinate : Map[Long, Long] = coordinatePairsByRowReverse.filter(_._1\
    \ == x).toList.maxBy(_._2)._2._2._1.toLong\n        val columnCoordinate : Long\
    \ = coordinatePairsReverse.filter(_._2 == rowCoordinate).toList.maxBy(_._1)._1\n\
    \        val coordinates : List[Tuple2[Long, Long]] = coordinatePairsByRowReverse.filter(_._1\
    \ == rowCoordinate).sortBy(_._1).map(x => (x._2, x._1))\n        val coordinatesReverse:\
    \ List[Tuple2[Long, Long]] = coordinates.map(x => (x._2, x._1))\n        val coordinatesReverseByRow\
    \ : List[Tuple2[Long, Long]] = coordinatesReverse.groupBy(_._1).filter(_._1 ==\
    \ rowCoordinate)\n        val coordinatesReverseByRowReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRow.reverse\n        val coordinatesReverseByRowReverseByColumn\
    \ : List[Tuple2[Long, Long]] = coordinatesReverseByRowReverse.groupBy(_._2)\n\
    \        val coordinatesReverseByRowReverseByColumnReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumn.reverse\n        val coordinatesReverseByRowReverseByColumnReverseByRow\
    \ : List[Tuple2[Long, Long]] = coordinatesReverseByRowReverseByColumnReverse.groupBy(_._1)\n\
    \        val coordinatesReverseByRowReverseByColumnReverseByRowReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumnReverseByRow.reverse\n      \
    \  val coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumn : List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumnReverseByRowReverse.groupBy(_._2)\n\
    \        val coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumnReverse:\
    \ List[Tuple2[Long, Long]] = coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumnReverse.sortBy(_._1).map(x\
    \ => (x._2, x._1))\n        val coordinatesReverseByRowReverse", "        val\
    \ m = lst.head\n        val n = lst.tail.length\n        val l = lst.map(c =>\
    \ getColumn(c.map(m %/% x), n))\n        l.toList.sortWith(_._1 > _._1).map(x\
    \ => (x._1, x._2))", "        if (lst == Nil) Nil\n        else {\n          \
    \  val m = lst.head\n            val m = m.reverse.take(x)\n            lst.tail.foldLeft(List[Tuple2[Long,\
    \ Long]](Nil)) { (x, y) =>\n                val ym = y.reverse.take(x)\n     \
    \           if (ym == Nil) x :: x\n                else {\n                  \
    \  val c = ym.size\n                    x :: Tuple2(ym.head.head + x * (c - 1l),\
    \ ym.head.tail + (c - 1l))\n                }\n            }\n        }", "  \
    \      // Your code here\n        val row = lst\n        val len = row.size\n\
    \        var row = lst\n        var column = row\n        var ans = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until len) {\n            if (row(i).contains(x))\
    \ {\n                ans = ans ::: (Tuple2(x-row(i), i))\n                row\
    \ = row.drop(i)\n                column = column.drop(i)\n                break\n\
    \            }\n        }\n        if (row.nonEmpty) {\n            ans = ans\
    \ ::: (getRow(row, x))\n        }\n        if (column.nonEmpty) {\n          \
    \  ans = ans ::: (getRow(column, x))\n        }\n        return ans", "      \
    \  if(lst.size==0) return List[Tuple2[Long, Long]]()\n        val rowLst = lst.sortWith(_\
    \ > _)\n        val columnLst = rowLst.sortWith(_ < _.reverse)\n        val l1\
    \ = columnLst.size\n        val l2 = rowLst.size\n        val rows = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for(i <- 0 to (l1-1)) {\n            for(j <- 0 to (l2-1))\
    \ {\n                val res = rowLst(i)(j) == x\n                if(res){\n \
    \                   rows ++= List(Tuple2(i+1, j+1))\n                }\n     \
    \       }\n        }\n        rows.toList.sortBy(_._1).reverse", "        val\
    \ rows = lst.map(row => Tuple2(row(0), row.length)) // Rows starting with index\
    \ 0 are sorted by columns\n        val columnSort = rows.sortBy(r => (-r._1, r._2))\
    \ // Sorts columns in descending order\n        val sortRowSort = columnSort.sortBy(r\
    \ => (-r._2, r._1)) // Sorts rows by columns in descending order\n        val\
    \ result = sortRowSort.filter(r => r._1 == x) // Filters rows that contain given\
    \ number\n        result.map(p => p._2 -> p._1).sortBy(r => (-r._1, r._2)) //\
    \ Sorts coordinates by rows in ascending order and by columns in descending order",
  "        val lst2 = lst.sortBy(l => l)\n        val lst3 = lst2.sortBy(l => l)\n\
    \        val lst4 = lst3.sortBy(l => l)\n        val lst5 = lst4.sortBy(l => l)\n\
    \        lst5.find(l => l._2 == x).toList", "        val (rs, cs, rt) = (lst.map(a\
    \ => a.indexOf(x)), lst.map(_.indexOf(x)), lst.indexOf(x))\n        val rts =\
    \ if (rt == 0) 0 else 1\n        val rtc = if (rts == 0) 0 else rts.toInt\n  \
    \      val rtl = if (rtc == 0) 0 else rtc.toInt\n        val rtd = if (rtl ==\
    \ 0) 0 else rtl.toInt\n        val rc = if (rs == 0) 0 else rs.toInt\n       \
    \ val rl = if (rc == 0) 0 else rc.toInt\n        val rr = if (rl == 0) 0 else\
    \ rl.toInt\n        (0 until rl).map((i, x) => Tuple2(x * i.toInt, x * i.toInt\
    \ + rtd.toInt))", '        lst.sortBy(_.toLong).map(row => (row.indexOf(x), row.lastIndexOf(x))
    )', "      lst.map(l => l.map(i => Tuple2(x, i)))\n          .sortWith(_.first\
    \ < _.first)\n          .sortBy(_.first < _.first.reverse)", "        def sortCoords(lst:\
    \ List[List[Long]], startIndex: Int = 0) : List[List[Long]] = {\n            val\
    \ rowIndex = startIndex\n            val listIndex = startIndex\n            val\
    \ rows = lst.size\n            val cols = lst(rowIndex).size\n            val\
    \ coords = List[List[Long]](List(startIndex))\n            for {\n           \
    \     row <- 0 until rows\n                col <- 0 until cols\n            }\
    \ yield {\n                if (row == rowIndex)\n                    coords =\
    \ lst(rowIndex)\n                else if (col == listIndex)\n                \
    \    coords = lst(row)\n                else\n                    coords = sortCoords(lst,\
    \ rowIndex)\n                coords.map(_ -> col)\n            }\n        }\n\
    \        if (lst.isEmpty)\n            List[Tuple2[Long, Long]]()\n        else\n\
    \            sortCoords(lst).map(_ -> x)", "        var row = (0.to(lst.size).reverse.map(i\
    \ => (i, 0)))\n        val lst2 = lst.map(xs => xs.filter(x=> x == x))\n     \
    \   lst2.foreach { x => row = row.map{ x => (x._1, x._2 - 1) }}\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._1 < y._2) // sort by first col\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._2 < y._1) // sort by second col\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._2 < y._2) // sort by first col\n        row", "    \
    \    val result: List[Tuple2[Long, Long]] = new ListBuffer[Tuple2[Long, Long]]\n\
    \        val matrix: mutable.Map[Long, Long] = mutable.Map()\n\n        for (i\
    \ <- 0 until lst.size) {\n            for (j <- 0 until lst(i).size) {\n     \
    \           if (lst(i)(j) == x) {\n                    matrix(i) = matrix(i) +\
    \ 1\n                    result.add(Tuple2(i, matrix(i)))\n                }\n\
    \            }\n        }\n\n        val maxCol = matrix.values.toList.max\n \
    \       val result = result.sortBy(_._1).reverse.sortBy(_._2).reverse\n      \
    \  result.map { case (x, y) => (x - maxCol, y) }", "        def getFirstIndex(lst\
    \ : List[Long], x : Long) : Long = {\n            val index = lst.indexWhere(_\
    \ == x)\n            if(index == -1l) return -1l\n            lst(index).toLong\n\
    \        }\n\n        def getLastIndex(lst : List[Long], x : Long) : Long = {\n\
    \            val index = lst.indexWhere(_ == x)\n            if(index == -1l)\
    \ return -1l\n            lst(index - 1l).toLong\n        }\n\n        // Find\
    \ row index\n        val firstIndex = getFirstIndex(lst(x), x)\n        val lastIndex\
    \ = getLastIndex(lst(x), x)\n        val rowTuple = new scala.collection.mutable.LinkedList[Tuple2[Long,\
    \ Long]]\n        while(firstIndex != -1l && lastIndex != -1l) {\n           \
    \ rowTuple.add(new scala.Tuple2[Long, Long](firstIndex, lastIndex))\n        \
    \    firstIndex = getFirstIndex(lst(firstIndex), firstIndex)\n            lastIndex\
    \ = getLastIndex(lst(lastIndex), lastIndex)\n        }\n        if(firstIndex\
    \ == -1l || lastIndex == -1l) rowTuple.clear()\n        rowTuple.toList.reverse.sortWith(_._1\
    \ < _._1).map { case (row, col) => new scala.Tuple2[Long, Long](row, col) }",
  "        val rows = lst.map(lst => (lst, lst.indexOf(x)))\n        rows.sortBy(_._1.indexOf(x)).map(_._1)\
    \ :+ rows.map(_.indexOf(x)).max", "        // Code here\n        if(lst.isEmpty){\n\
    \            return Nil\n        }\n        val lstOfLists = lst.map(_.toList)\n\
    \        val lstOfTuples = lstOfLists.map(xlst => xlst.map(x => Tuple2(x, xlst(0))))\n\
    \        val lstOfTuplesAndOrderedList = lstOfTuples.map(x => x._1 -> x._2).sortBy(x\
    \ => x._1).reverse.sortBy(x => x._2).reverse\n        lstOfTuplesAndOrderedList.filter(x\
    \ => x._1 == x).map(x => Tuple2(x._2, x._1))", "        val res = new collection.mutable.ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.size) {\n            val xs = lst(i)\n\
    \            val y = xs(x).toLong\n            if (y > 0)\n                res.push(Tuple2(i,\
    \ y))\n        }\n        res.sortBy(r => (r.t._1, r.t._2))\n        res.sortWith((a,\
    \ b) => b._1 < a._1)\n        res.reverse", "        val rowNum = lst.foldLeft[List[Long]](List[Long]()){\
    \ (res, elem) =>\n            if (elem.isEmpty) res else res.head :: elem.head\n\
    \        }\n        val colNum = lst.get(rowNum.last).foldLeft[List[Long]](List[Long]()){\
    \ (res, elem) =>\n            if (elem.isEmpty) res else elem ::: res.last\n \
    \       }\n        lst.map{row =>\n            val sortedRow = row.sortWith((x,\
    \ y) => y < x)\n            (sortedRow.take(colNum.last), sortedRow.drop(colNum.last).take(rowNum.last))\n\
    \        }", "        val m = new mutable.LinkedHashMap[Long, Long]\n        lst.map{row\
    \ =>\n            var n = 0\n            for(i <- 0 until row.length){\n     \
    \           val e = m.getOrElseUpdate(row(i), 0l)\n                m.put(row(i),\
    \ e+1l)\n                n += e\n            }\n        }\n        val res = m.toList.sortBy(_._1).sortByDescending(_._2)\n\
    \        if(res.size == 0) res\n        else{\n            val r = res(0)\n  \
    \          val c = res(res.length-1)\n            val xx = r._2\n            val\
    \ yy = r._1\n            val newX = xx + x\n            val newY = yy + x\n  \
    \          if((newY < yy) || (newX < xx))\n                getRow(lst, newY)\n\
    \            else res\n        }", "        val rows = lst.flatten.zipWithIndex\n\
    \        val rows = rows.filter(r => r._1 == x).sortBy(_._1).reverse\n       \
    \ val cols = rows.map(_.toList).flatten.zipWithIndex\n        val cols = cols.filter(r\
    \ => r._1 == x).sortBy(_._1).reverse\n        rows.map(row => (row._2, row._1)).sortBy(_._1).reverse.zip(cols.map(col\
    \ => (col._2, col._1))).map(t => (t._2, t._1))", "        val lst_row_indexed\
    \ = lst.map(i => i.zipWithIndex.toList)\n        val lst_column_indexed = lst_row_indexed.map(i\
    \ => i.map(j => j._2))\n        val rows = lst_row_indexed.map(i => i._2)\n  \
    \      val columns = lst_column_indexed.map(i => i._2)\n        val x_index =\
    \ columns.indexOf(x)\n        if (x_index == -1) {\n            List[Tuple2[Long,\
    \ Long]]()\n        } else {\n            val row = rows.find(_.toLong == x_index)\n\
    \            val row_tuple = List(Tuple2(row._1, row._2))\n            row_tuple.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        }", "        val lst0 = lst.head\n        val lst1 = lst.tail\n     \
    \   val lst2 = lst0.map( x => x :: lst1 )\n        val lst3 = lst2.sortWith( x\
    \ => x.reverse )\n        lst3.map( x => (x.head, x.last) )", "        if (lst.isEmpty)\
    \ Nil\n        else {\n            val lst1 = lst.flatten\n            if (lst1.isEmpty)\
    \ Nil\n            else lst1.map(row => (row, x)).sortBy(_._1).reverse.sortBy(_._2)\n\
    \        }", "        // Write your code here\n        if (lst.isEmpty) {\n  \
    \          List[Tuple2[Long, Long]]()\n        } else {\n            val mn =\
    \ lst.head\n            val mx = lst.last\n            val r = x / (mx - mn)\n\
    \            val l = (mx + mn) / (mx - mn)\n            val i = (r - mn / l).ceil.toInt\n\
    \            val j = (r + mn / l).floor.toInt\n            val r2 = (i - 1) *\
    \ l + j\n            val r3 = r2 - l\n            val r4 = r3 + l\n          \
    \  val coords = lst.drop(r3).take(r4)\n            coords.sortWith((a: Tuple2[Long,\
    \ Long], b: Tuple2[Long, Long]) => b._2.compareTo(a._2))\n            coords.sortWith((a:\
    \ Tuple2[Long, Long], b: Tuple2[Long, Long]) => a._1.compareTo(b._1))\n      \
    \      coords.map(c => (c._1.toLong * l.toLong + c._2.toLong))\n        }", " \
    \       val result = lst.foldLeft((List(), List()))(\n            (acc, e) =>\
    \ {\n                val rowNum = e.sum\n                val colNum = e.length\n\
    \                val temp: List[Long] = List(xl.toLong)\n                for (i\
    \ <- 0 until rowNum) temp = acc :+ xl % rowNum\n                for (i <- 0 until\
    \ colNum) temp = acc :+ xl(i) % colNum\n                (temp, List(acc))\n  \
    \          }\n        )\n\n        // Get rows in ascending order\n        val\
    \ rows = result._1.sortBy(x => x).reverse\n\n        // Get columns in descending\
    \ order\n        val cols = result._2.sortBy(x => -x)\n\n        result._2 zip\
    \ result._1", "        val rows = lst.map { row => row.map(_.toLong) }\n     \
    \   val result = rows.foldLeft(List[Tuple2[Long, Long]]())((acc, row) => {\n \
    \           val columns = row.map(_.toLong)\n            val indexOfX = columns.indexOf(x)\n\
    \            if (indexOfX == -1) {\n                acc :+ Tuple2(row, 0)\n  \
    \          } else {\n                val rowWithX = row :+ Tuple2(row(indexOfX),\
    \ row(indexOfX+1))\n                acc :+ Tuple2(rowWithX, 0)\n            }\n\
    \        })\n        result.sortBy(x => (x._1)).sortBy(x => (x._2, -1)).map {\
    \ x => (x._1, x._2) }", "        var coors: List[Tuple2[Long, Long]] = List()\n\
    \        var xcoor: List[Long] = List()\n        var ycoor: List[Long] = List()\n\
    \        var row: List[Long] = List()\n        var counts: Map[Long, Long] = HashMap()\n\
    \        var maxcount = -1\n        var maxrow = 0\n        var maxcol = -1\n\
    \        var i = 0\n        for (r <- 0 until lst.length) {\n            var j\
    \ = 0\n            for (c <- 0 until lst(r).length) {\n                var x =\
    \ lst(r).(c).toLong\n                if (counts.exists(x)) {\n               \
    \     var count = counts(x)\n                    counts.remove(x)\n          \
    \          counts(x) // Update the counts map\n                    if (count >\
    \ maxcount) {\n                        maxcount = count\n                    \
    \    maxrow = r\n                        maxcol = c\n                    }\n \
    \               } else {\n                    counts(x) = 1 + counts.getOrElse(x,\
    \ 0l) // Initialize to 0 if not present (first occurance)\n                }\n\
    \            }\n        }\n        for (xi <- 0 until counts.keys) {\n       \
    \     coors = coors :+ ((maxrow + 0l, maxcol + xi))\n        }\n        coors\
    \ = coors.sortBy(_._1)\n        coors = coors.sortBy(_._2)\n        for (r <-\
    \ 0 until lst.length) {\n            row = row :+ lst(r).indexOf(maxcol.toLong)\n\
    \        }\n        row = row.sortBy(_ - maxcol.toLong)\n        row = row.sortBy(_\
    \ - maxrow.toLong)\n        return coors.map(t => (t._1, t._2))", "        val\
    \ n = lst(0).length\n        val m = (lst(0).length + 1) * lst(1).length\n   \
    \     val m1 = m + 2 * x\n        if (n == 0) List((0l, 0l))\n        else if\
    \ (m1 == m) List(Tuple2(0l, 0l))\n        else List(Tuple2(0l, 0l))", "      \
    \  val n = lst.size\n        val rows = lst.map(_.toArray.toList).map(_.toLong)\n\
    \        val cols = lst(0).toArray.toList\n        val m = rows.size\n       \
    \ val result: List[Tuple2[Long, Long]] = new ArrayList[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until n) {\n            var row: Long = 0\n            var\
    \ col: Long = 0\n            var j = i\n            while(j >= 0 && rows(j) >=\
    \ x) {\n                row += rows(j--)\n                col += 1\n         \
    \   }\n            result.add(new Tuple2[Long, Long](row, col))\n        }\n \
    \       result.sortBy(t => (t._1.toLong, t._2.toLong)).reverse", "        val\
    \ m = lst.size // rows\n        val n = lst(0).size // cols\n        val list\
    \ = lst.map(row => {\n            val tuple = row.toSeq.sortWith(_.toLong > x)\n\
    \            (tuple(0).toLong, tuple(1).toLong)\n        }).toList\n        val\
    \ reversedList = list.reverse\n        val reversedListMap = reversedList.map(_.toSeq.toMap).sortedWith(_.keys.toList\
    \ > _.keys.toList.reverse).getOrElse(Map.empty)\n        val reversedListMap =\
    \ reversedListMap.map(key => {\n            val tuple = reversedListMap(key).toSeq.sortWith(_.keys.toList\
    \ > _.keys.toList.reverse)\n            (tuple(0).toLong, tuple(1).toLong)\n \
    \       }).toList\n        val reversedListMap = reversedListMap.toMap\n     \
    \   val listMap = (list.map(_.toSeq.toMap).sortedWith(_.keys.toList > _.keys.toList.reverse).getOrElse(Map.empty))\
    \ ++ reversedListMap\n        listMap.toList.sortWith(_.keys.toList > _.keys.toList.reverse).map(_.toSeq.toMap).sortedWith(_.keys.toList\
    \ > _.keys.toList.reverse).flatMap(_.values).map(Tuple2(_._1, _._2))", "     \
    \   // Your code here\n        // Solution here\n        // Solution here\n  \
    \      // Solution here\n        // Solution here", "        val result = new\
    \ scala.collection.mutable.ArrayListBuffer[Tuple2[Long, Long]]()\n        for\
    \ (row <- lst.sortWith((l, r) => l < r)) {\n            val rowList = row.toList\n\
    \            val rowListLength = row.size\n            for (col <- 0 until row.size)\
    \ {\n                if (rowList(col) == x) {\n                    result += Tuple2(rowListLength\
    \ - col, row)\n                }\n            }\n        }\n        result +=\
    \ Tuple2(result.size - 1, lst(result.size - 1))\n        result.sortWith((x, y)\
    \ => x._1 < y._1)", "        var ret: List[Tuple2[Long, Long]] = Nil\n       \
    \ var i: Long = 0\n        lst.sortWith(_ < _)\n        lst.map(row => {\n   \
    \         while (i < row.length) {\n                if ((row(i) == x)) {\n   \
    \                 ret :+= Tuple2(i, x)\n                }\n                i +=\
    \ 1\n            }\n        })\n        lst.sortWith(_.head > _.head)\n      \
    \  lst.sortWith(_ < _.head)\n        lst.map(row => {\n            row.tail.sortWith(_\
    \ < _)\n            row.tail.map(col => {\n                if (col(i) == x) {\n\
    \                    ret :+= Tuple2(i, x)\n                }\n            })\n\
    \        })\n        lst.sortWith(_.head > _.head)\n        lst.sortWith(_ < _.head)\n\
    \        return ret", "        // TODO: Write your code here\n        ", '        lst.map(r
    => (r.indexOf(x), r.lastIndexOf(x))).sorted.zipWithIndex.sortBy(_._1).map(_._2).zip(lst.map(_.head).map(_
    => (0, 0)))', "        val rowIndex = lst.zipWithIndex.map { case (e, idx) =>\
    \ (idx, e._1) }.toList\n        val index = rowIndex.indexOf(x)\n        val columnIndex\
    \ = rowIndex.filter(_.1==index).map { case (e, idx) => (idx, e._2) }.toList.reverse\n\
    \        columnIndex.map { case (e, idx) => (e, idx) }.toList", "        require(lst.length\
    \ > 0)\n        require(lst(0).length == lst.length)\n        val sorted = lst.sorted\
    \ (_(0))\n        val rows = (0 until sorted.length).map(_ => (sorted(_).reverse,\
    \ sorted.drop(_).last)).toList\n        rows.sortWith(_._1 > _._1).sortWith(_._1\
    \ < _._1)", "        val r = lst.sortBy(r => r(0).toInt, Ordering.Int)\n     \
    \   val c = r.sortBy(c => c(0).toInt, Ordering.Int)\n        val ret = c.takeWhile(_(0)\
    \ == x).flatMap { c =>\n            (0 until r(0).size).map(i => Tuple2(c(i),\
    \ r(0).apply(i)(c)))\n        }.toList\n        ret.reverse.sortBy(r => -r._1).toList",
  "        var tuples: List[Tuple2[Long, Long]] = Nil\n        var count = 1\n   \
    \     var row: List[Tuple2[Long, Long]] = Nil\n        for(elem <- lst){\n   \
    \         for(elem <- elem){\n                if(elem == x){\n               \
    \     tuples = elem\n                    break\n                }\n          \
    \  }\n        }\n        while(count <= lst.length){\n            row = Nil\n\
    \            for(elem <- lst){\n                for(elem <- elem){\n         \
    \           if(elem == x){\n                        row = elem\n             \
    \           break\n                    }\n                }\n            }\n \
    \           if(row.length > 0){\n                tuples = row :: tuples\n    \
    \        }\n            count +=1\n        }\n        return tuples", "      \
    \  var result : List[Tuple2[Long, Long]] = List()\n        var lstSize : Int =\
    \ lst.size\n        lst.foreach(row => {\n            row.foreach(col => {\n \
    \               if(col == x) {\n                    result = List((row.toLong,\
    \ col.toLong))\n                }\n            })\n        })\n        if(result\
    \ == List()) {\n            return List()\n        }\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        result.foreach(row => {\n            row.foreach(col\
    \ => {\n                if(row.toLong > col.toLong) {\n                    result.updated(row.toLong\
    \ - 1, Tuple2(row.toLong, col.toLong))\n                }\n            })\n  \
    \      })\n        if(result == List()) {\n            return List()\n       \
    \ }\n        result.sortBy(row => row._1).reverse\n        result.sortBy(row =>\
    \ row._2).reverse\n        return result", "        val map0 = mutable.HashMap[(Long,\
    \ Long), List[Long]]()\n        val map1 = mutable.HashMap[(Long, Long), List[Long]]()\n\
    \        lst.zipWithIndex.foreach {\n            case(v, i) =>\n             \
    \   if (i <= 0) return\n                if (map0.contains(v)) map0(v).append(i)\n\
    \                else {\n                    val list0 = mutable.ListBuffer[Long]()\n\
    \                    list0 += i\n                    map0.put(v,list0)\n     \
    \           }\n                if (map1.contains(v)) {\n                    val\
    \ list1 = mutable.ListBuffer[Long]()\n                    list1 += map1(v).last\n\
    \                    map1.put(v,list1)\n                } else {\n           \
    \         map1.put(v,List(i))\n                }\n        }\n        val result\
    \ = map1.get(x)\n        val map2 = mutable.HashMap[(Long, Long), List[Long]]()\n\
    \        val map3 = mutable.HashMap[(Long, Long), List[Long]]()\n        val result\
    \ = map2.get(x)\n        if (result != null) map3(result) else map3(x)", "   \
    \     val lstRev = lst.reverse\n        val lstRow = lstRev.map{x => (x, lstRev.indexOf(x))}\n\
    \        val lstCol = lstRev.map{x => (lstRev.indexOf(x), x)}\n        val lstRowRev\
    \ = lstRow.reverse\n        val lstColRev = lstCol.reverse\n        lstRowRev.map(x\
    \ => (lstColRev.indexOf(x._1), x._1)).filter{x => x == x}", "      val rows =\
    \ lst.toList.sortBy(_(0))\n      val cols = lst(0).toList.sortBy(_ - 1)\n    \
    \  val rowAndCols = rows.map(row => (row, cols)).toList\n      val rowAndColsSorted\
    \ = rowAndCols.sortBy(_._1)\n      rowAndColsSorted.map(_._2)", "        var rows\
    \ : List[Tuple2[Long, Long]] = Nil\n        var cols : List[Long] = Nil\n    \
    \    var xRow = 0\n        var xCol = 0\n        var i = 0\n        var j = 0\n\
    \        var col = 0\n        while (i < lst.size) {\n            if (lst(i) ==\
    \ x.toLong) {\n                rows += ((xRow, xCol))\n                cols +=\
    \ lst(j)\n                ++i\n                ++j\n            } else {\n   \
    \             ++xCol\n            }\n        }\n        rows.sortWith(_.swap)\n\
    \        cols.sortWith(_.swap)\n        val sortedRows = rows.toList\n       \
    \ val sortedCols = cols.toList\n        if (sortedCols.last < sortedRows.last)\
    \ {\n            sortedRows.reverse\n        } else {\n            sortedCols.reverse\n\
    \        }\n        sortedRows.map { case (row, col) => (row, col) }", "     \
    \   // Create mutable list of coordinates - initially empty.\n        var rows\
    \ = mutable.LinkedHashSet[Tuple2[Long, Long]]()\n        // Create mutable list\
    \ of columns - initially empty.\n        var columns = mutable.LinkedHashSet[Long]()\n\
    \        // Traverse nested list lst,\n        // each element contains sublist,\n\
    \        // each sublist contains one row.\n        lst.foreach(rows ++= {\n \
    \           (rows ++= (0 until lst.size)).map(_ => lst.map(_.toLong).toSet).flatten\n\
    \        })\n        val rowCoordinates = rows.toSeq.sortBy(row => {\n       \
    \     columns.addAll(row)\n            columns.size\n        }).map(row => row.toSeq.sortBy(column\
    \ => columns.lastIndexOf(_))).toList\n        val rowAndColumnCoordinates = rowCoordinates.map(coordinate\
    \ => (coordinate._1, coordinate._2))\n        val xAndYs = rowAndColumnCoordinates.filter(coordinate\
    \ => coordinate._1 == x).unzip._2\n        xAndYs.sortBy(coordinate => coordinate._1)",
  "        if (lst.isEmpty)\n            Nil\n        else\n            lst.sortWith(compareRows)\n\
    \                .toList.flatMap {\n                case row :: Nil => row.zipWithIndex.map\
    \ { case (item, index) => Tuple2(index.toLong, item) }\n                case row\
    \ => row.zipWithIndex.map { case (item, index) => Tuple2(index.toLong, item) }.filter(x\
    \ => x._1 >=x).map(x => (x._1, x._2 - x))\n            }\n            .toList\n\
    \            .sortWith(compareRows)\n            .map(x => Tuple2(x, x))\n   \
    \         .toList", "        def getRowHelper(lst: List[List[Long]], x : Long,\
    \ result : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] = {\n        \
    \    if (lst.isEmpty) {\n                result :+ Tuple2(x, 0)\n            }\
    \ else {\n                getRowHelper(\n                    if (lst(0) contains\
    \ x) (lst.tail, x, lst)\n                    else (lst.tail, x, lst),\n      \
    \              x,\n                    result :+ Tuple2(x, 0))\n            }\n\
    \        }\n        getRowHelper(lst, x, Nil)", "        val newList = mutable.ArrayBuffer.empty[(Long,\
    \ Long)]\n        for (row <- lst) {\n            for (cell <- row) {\n      \
    \          if (cell == x) {\n                    newList += ((row, cell))\n  \
    \              }\n            }\n        }\n        newList.sortBy(_._1).reverse.sortBy(_._2).reverse",
  "        if (lst == Nil || lst.length == 0) return Nil\n        val lst0 = lst(0)\n\
    \        var result = Nil\n        var i = 1\n        for (x <- lst0 reversed)\
    \ {\n            var found = true\n            if (i >= lst.length) break\n  \
    \          for (y <- lst(i)) {\n                if (y == x) found = false\n  \
    \          }\n            if (found) result = result :+ (i, x)\n            i\
    \ += 1\n        }\n        result", "        if(lst.isEmpty) return List()\n \
    \       def isRow(xs: List[Long], x: Long) : Boolean = xs == List(x, x) && xs.headOption.exists(x\
    \ => x == x) || x == xs.head\n\n        val coords: List[Tuple2[Long, Long]] =\
    \ lst.sortWith(x => x.zipWithIndex).map{case (row, x) => row.map{ case (x, y)\
    \ => (y, x) }}.sortWith(x => x._2).map{case (row, _) => row.map{ case (x, y) =>\
    \ (y, x) }}.sortWith(x => (x._1 < x._2))\n        val indexes = coords.map {case\
    \ (row, col) => (row, col)}\n\n        val rowIndex = indexes.headOption.filter{case\
    \ (row, col) => isRow(row, x)}\n        val coord = coords.find(row => row._1\
    \ == rowIndex.get._1).map{case (row, col) => row.map{case (x, y) => (y, x)}}.getOrElse(IndexedSeq())\n\
    \        coord", "        val xList = lst.filter(_ contains x).sortBy(_.toLong).reverse\n\
    \        val yList = xList.map(_._2).sortBy(_.toLong).reverse\n        xList.zipAll(yList).sortBy(_._1).map(_._2)",
  "        if (lst.isEmpty) return Nil\n        val m = lst.map(_.length)\n      \
    \  var maxRow = x.toLong\n        for (i <- 0 to m-1) {\n            if (lst(i).indexOf(x)\
    \ >= 0) {\n                maxRow = lst(i).indexOf(x)\n            } else {\n\
    \                break\n            }\n        }\n        if (lst(0).isEmpty)\
    \ {\n            return Nil\n        }\n        if (maxRow == 0) {\n         \
    \   return lst(1).map(i => (0, i)).sorted\n        }\n        return lst(maxRow).map(i\
    \ => (maxRow, i)).sorted // reverse the sorted rows", "        def sortRow(row:\
    \ List[Long], rowSize: List[Long], result: List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            val row = row.sortWith(_ < _)\n            val rowSize\
    \ = rowSize.sortWith(_ < _)\n            val index = row.zipWithIndex.filter(_._1\
    \ == x).map(x => x._2).map(i => rowSize(i))\n            val size = rowSize.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val resultSize = result.map(_._1).zipWithIndex.filter(_._1\
    \ == x).map(x => x._2)\n            val resultIndex = result.map(_._2).zipWithIndex.filter(_._1\
    \ == x).map(x => x._2)\n            val size = size.map(x => x._1).zip(x._2)\n\
    \            val index = index.map(x => x._1).zip(x._2)\n            val newSize\
    \ = rowSize.zipWithIndex.filter(_._2 == x).map(x => x._2).map(i => row(i))\n \
    \           val newIndex = row.zipWithIndex.filter(_._1 == x).map(x => x._2).map(i\
    \ => rowSize(i))\n            val newSizeIndex = size.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newIndexIndex = index.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => rowSize(i))\n            val newIndexSize = rowSize.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeIndex = newSize.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newIndexSizeIndex = newIndex.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeSizeIndex\
    \ = newSize.zipWithIndex.filter(_._2 == x).map(x => x._2).map(i => row(i))\n \
    \           val newIndexSizeSizeIndex = newIndex.zipWithIndex.filter(_._2 == x).map(x\
    \ => x._2).map(i => row(i))\n            val newIndexSizeSizeSizeIndex = newIndex.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeSizeSizeIndex\
    \ = newSize.zipWithIndex.filter(_._2 == x).map(x => ", "        val size = lst(0).size\n\
    \        if (size == 0) {\n            List()\n        } else {\n            val\
    \ newLst: List[List[Long]] = lst.map(l => l.map(n => (n, n+x))).toList\n     \
    \       val lstSize = newLst(0).size\n            val rowList: List[List[Long]]\
    \ = newLst.map(l => l.sortWith(_ > _))\n            val newRowList: List[List[Long]]\
    \ = rowList.map(l => l.sortWith(_ < _))\n            getRow(newRowList, x)\n \
    \       }", "        val lstCopy = lst\n        def inOrderHelper(lst: List[Long],\
    \ x: Long, acc: List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] =\n     \
    \       lst match {\n                case Nil => acc\n                case List(rl,\
    \ rc, rc0) =>\n                    val ll = inOrderHelper(rl, x, Tuple2.tuple2(ll,\
    \ rc))\n                    if (ll == Nil) {\n                        inOrderHelper(rc,\
    \ x, Tuple2.tuple2(rl, rc))\n                    } else {\n                  \
    \      inOrderHelper(rl, x, Tuple2.tuple2(rl, rc))\n                    }\n  \
    \              case List(rl, rc, rc0) =>\n                    if (rc < rc0) {\n\
    \                        inOrderHelper(rl, x, Tuple2.tuple2(rl, rc))\n       \
    \             } else if (rc > rc0) {\n                        inOrderHelper(rc,\
    \ x, Tuple2.tuple2(rl, rc))\n                    } else {\n                  \
    \      inOrderHelper(rl, x, Tuple2.tuple2(rl, rc))\n                    }\n  \
    \          }\n\n        inOrderHelper(lstCopy, x, Tuple2.tuple2(x, 0l))"]
stop_tokens:
- "\n    }\n"
