name: HumanEval_56_correct_bracketing
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // brackets is a string of \"<\" and \">\".\n    // return true if every opening\
  \ bracket has a corresponding closing bracket.\n    // >>> correctBracketing((\"\
  <\"))\n    // (false)\n    // >>> correctBracketing((\"<>\"))\n    // (true)\n \
  \   // >>> correctBracketing((\"<<><>>\"))\n    // (true)\n    // >>> correctBracketing((\"\
  ><<>\"))\n    // (false)\n    def correctBracketing(brackets : String) : Boolean\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"\
  <>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n   \
  \ assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"\
  <><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\"\
  )) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"\
  <\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\"\
  >\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"\
  <><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\"\
  )) == (false));\n    }\n\n}\n"
completions: ["        val bList = brackets.toList\n        val bListLen = bList.size\n\
    \        val nList = mutable.ListBuffer[Int]()\n        val nListLen = nList.size\n\
    \        var lastChar = -1\n        var count = 0\n\n        for( i <- 0 until\
    \ bListLen ) {\n            var c = bList(i)\n            if( c >= '!' && c <=\
    \ '~' ) {\n                // special handling for \"!...~\" chars.\n        \
    \        lastChar = c - '!'\n            } else if( c >= '<' && c <= '>' && lastChar\
    \ >= c ) {\n                lastChar = lastChar - 1\n                count = count\
    \ + 1\n            } else if( c >= '<' && c <= '>' ) {\n                lastChar\
    \ = lastChar + 1\n                count = count + 1\n            } else if( c\
    \ >= '!' && c <= '~' ) {\n                // special handling for \"!...~\" chars.\n\
    \                lastChar = c - '!'\n                count = count + 1\n     \
    \       } else {\n                lastChar = lastChar + 1\n            }\n   \
    \         if( count > 0 ) {\n                // count is 0 after each \"!\"\n\
    \                if( lastChar < 0 ) {\n                    // if \"!\" was the\
    \ last char\n                    if( nListLen < bListLen ) {\n               \
    \         // if the next char is not a closing bracket\n                     \
    \   if( bList(i) == '>' ) {\n                            // then the next char\
    \ must be a closing bracket\n                            nList += bList(i) - '<'\n\
    \                            nListLen += 1\n                        }\n      \
    \              }\n                } else {\n                    // if \"!\" was\
    \ not the last char\n                    if( nListLen < bListLen ) {\n       \
    \                 // if the previous char is not a closing bracket\n         \
    \               if( bList(i) == '<' ) {\n                            // then the\
    \ previous char must be a closing bracket\n                            nList +=\
    \ bList(i) - '!'\n                            nListLen += 1\n                \
    \        }\n                    }\n                }\n                count =\
    \ 0\n                lastChar = -1\n                nList.clear()\n          \
    \      nListLen = 0\n            }\n        }\n\n        if( bListLen > 0 ) {\n\
    \            // if bListLen is larger than 0\n            if( lastChar < 0 ) {\n\
    \                // if \"!\" was the last char\n                if( nListLen <\
    \ bListLen ) {\n                    // if the next char is not a closing bracket\n\
    \                    if( bList(bListLen) == '>' ) {\n                        //\
    \ then the next char must be a closing bracket\n                        nList\
    \ += bList(bListLen) - '<'\n                        nListLen += 1\n          \
    \          }\n                }\n            } else {\n                // if \"\
    !\" was not the last char\n                if( n", "        if(brackets.length\
    \ == 0)\n            return true\n        val opening = brackets.split(\"<\")\n\
    \        val closing = brackets.split(\">\")\n        if(opening.length != closing.length)\
    \ false\n        for(i <- 0 until closing.length)\n            if(opening(opening.length\
    \ - i) != closing(i))\n                return false\n        return true", " \
    \       var opening = List[Int]()\n        var closing = List[Int]()\n       \
    \ val isOpening = (c : Char, i : Int) =>\n            c != '>' &&  c != '<'\n\
    \        val isClosing = (c : Char, i : Int) =>\n            c != '>' &&  c !=\
    \ '<'\n\n        for (i <- 0 to brackets.length - 1) {\n            val c = brackets.charAt(i)\n\
    \            if (c != '<')\n                opening += i\n            if (c !=\
    \ '>')\n                closing += i\n        }\n        opening.zipAll(closing,\
    \ (c1 , c2) => c1 == c2 || (c1 < c2))", "        // TODO: implement this function\n\
    \        true", "        var openBrackets : List[String] = Nil\n        var closingBrackets\
    \ : List[String] = Nil\n        for (bracket <- brackets.split(\"\")) {\n    \
    \        if (bracket.equals(\"<\")) {\n                openBrackets = openBrackets\
    \ :+ bracket\n            } else if (bracket.equals(\">\")) {\n              \
    \  closingBrackets = closingBrackets :+ bracket\n            } else if (openBrackets.isEmpty\
    \ && closingBrackets.isEmpty) {\n                return false\n            } else\
    \ if (bracket.equals(\"<\") && (openBrackets.isEmpty || closingBrackets.headOption.map(_\
    \ != bracket).isEmpty)) {\n                return false\n            } else if\
    \ (bracket.equals(\">\") && (openBrackets.headOption.map(_ != bracket).orElse\
    \ {closingBrackets.isEmpty}).isDefined) {\n                return false\n    \
    \        }\n        }\n        (openBrackets.size == closingBrackets.size) &&\
    \ openBrackets.size == closingBrackets.size", "        val stack : mutable.Stack[String]\
    \ = mutable.Stack[String]()\n        for (i <- 0 until brackets.length)\n    \
    \        if (brackets(i) == '<')\n                stack.push(brackets(i).asInstanceOf[Char])\n\
    \            else if (brackets(i) == '>')\n                if (stack.isEmpty)\n\
    \                    false\n                else\n                    stack.pop()\
    \ != '<'\n            else\n                stack.pop() != '<' && stack.push(brackets(i).asInstanceOf[Char])\n\
    \        stack.isEmpty", "        val bracketCount = brackets.length\n       \
    \ var inside = true\n        brackets.toStream.map(c => c match {\n          \
    \  case \">\" => inside = !inside\n            case c => c\n        }).takeWhile(c\
    \ => c == '<').takeWhile(c => !c == '>').count() != bracketCount", "        val\
    \ openingBracketCounts = brackets.map(c => c match {\n            case '<' =>\
    \ 1\n            case '>' => 1\n            case '=' => 2\n            case _\
    \ => 0\n        }).sum\n        val closingBracketCounts = brackets.map(c => c\
    \ match {\n            case '<' => -1\n            case '>' => -1\n          \
    \  case '=' => -1\n            case _ => 0\n        }).sum\n        (openingBracketCounts\
    \ == closingBracketCounts) && (openingBracketCounts >=0)", "        val stack\
    \ = ListBuffer.empty[String]\n        for (c <- brackets)\n            if (\"\
    {\" <= c && c <= \"}\")\n                stack += c\n            else if (\"[\"\
    <= c && c <= \"]\")\n                stack += c\n            else if (\"(\"<=\
    \ c && c <= \")\")\n                if (stack.head == \"[\" || stack.head == \"\
    {\")\n                    stack += c\n                else\n                 \
    \   return false\n            else\n                return false\n        if (stack.length\
    \ != 1)\n            return false\n        stack(0)", "        // This assumes\
    \ there are brackets in the brackets string\n        // and that there are no\
    \ nested brackets\n        val openingBracketCount = brackets.split(\"<\").length\n\
    \        val closingBracketCount = brackets.split(\">\").length\n        return\
    \ openingBracketCount == closingBracketCount", "        // Your code goes here\n\
    \        val l = brackets.toList\n        val h = l.reverse\n        var x = false\n\
    \        while(h.hasNext) {\n            if(h.next == \"<\") {\n             \
    \   val y = h.next\n                val z = (h.next).toInt\n                x\
    \ ^= y == \">\"\n                h.next = \"<\"\n            }\n        }\n  \
    \      x", "        var insideBracket = false\n        var openingBrackets = 0\n\
    \        var closingBrackets = 0\n        brackets.toList.foreach { b =>\n   \
    \         if(b == '<') {\n                insideBracket = true\n            }\n\
    \            if(b == '>') {\n                insideBracket = false\n         \
    \   }\n            if(insideBracket && openingBrackets > closingBrackets) {\n\
    \                closingBrackets+=1\n            }\n            if(!insideBracket\
    \ && openingBrackets < closingBrackets) {\n                openingBrackets +=\
    \ 1\n            }\n        }\n        (openingBrackets == closingBrackets)",
  "        // initialize our stack\n        var stack = mutable.Stack[String]()\n\
    \        // initialize a buffer of matching characters\n        var buffer = new\
    \ mutable.StringBuilder()\n        // loop through our brackets\n        for (char\
    \ : char <- brackets.toCharArray) {\n            // if we see a \">\" pop from\
    \ the stack and append the character to the buffer\n            if (char == \"\
    >\") {\n                if (!stack.isEmpty) {\n                    buffer += stack.pop\n\
    \                }\n            }\n            // if we see a \"<\" push it to\
    \ the stack and append the character to the buffer\n            if (char == \"\
    <\") {\n                buffer += char\n                stack.push(char)\n   \
    \         }\n            // otherwise just append the character to the buffer\n\
    \            else {\n                buffer += char\n            }\n        }\n\
    \        // if we had something in the buffer we can always find matching brackets\n\
    \        if (!buffer.isEmpty) {\n            // loop through our buffer and try\
    \ to find matching brackets\n            for (startPos <- 0 until buffer.length-1)\
    \ {\n                val nextPos = buffer.length\n                // loop through\
    \ our stack and see if we can find matching brackets\n                for (charToTest\
    \ <- stack.drop(1) if charToTest == buffer.charAt(startPos)) {\n             \
    \       // if we don't find the matching bracket then we have an issue\n     \
    \               // if we do find the matching bracket then the loop will exit\n\
    \                    if (!charToTest == buffer.charAt(nextPos)) {\n          \
    \              return false\n                    }\n                    nextPos\
    \ -= 1\n                }\n            }\n            // if we looped through\
    \ the entire buffer then all brackets matched\n            return true\n     \
    \   }\n        // if we didn't loop through our buffer then no brackets matched\n\
    \        return false", "        var bracesCounter = 0\n        var openingBrackets\
    \ = new mutable.HashSet[String]()\n        var closingBrackets = new mutable.HashSet[String]()\n\
    \        var openBracket = brackets.substring(1, brackets.length - 1)\n\n    \
    \    // Count all braces inside brackets\n        for( char <- openBracket.toCharArray\
    \ ) {\n            if( char == '<' || char == '>' ) {\n                bracesCounter\
    \ += 1\n            }\n        }\n\n        // Check for unmatched brackets\n\
    \        if( bracesCounter == 0 ) {\n            closingBrackets.add(openBracket)\n\
    \        } else {\n            for( char <- openBracket.toCharArray ) {\n    \
    \            if( char == '<' || char == '>' ) {\n                    if( !openingBrackets.contains(char)\
    \ ) {\n                        closingBrackets.add(char)\n                   \
    \ } else {\n                        openingBrackets.remove(char)\n           \
    \         }\n                }\n            }\n            if( openingBrackets.isEmpty()\
    \ ) {\n                if( closingBrackets.size == 0 ) {\n                   \
    \ true\n                } else {\n                    false\n                }\n\
    \            } else {\n                false\n            }\n        }", '        brackets.contains("<")
    && brackets.contains(">")', "        var i : Int = brackets.indexOf ('<')\n  \
    \      while (i >= 0) {\n            var j : Int = brackets.indexOf ('<', i+1)\n\
    \            var newBrackets = brackets.substring (0, i)\n            newBrackets\
    \ += \"{\"\n            for (i = j+1; i < brackets.length; i++){\n           \
    \     newBrackets += \"}\"\n            }\n            val result = correctBracketing(newBrackets)\n\
    \            if (result == true) {\n                return true\n            }\n\
    \            newBrackets += \"}\" \n            i = brackets.indexOf ('<', i+1)\n\
    \        }\n        return false", "        // O(n^2) algorithm to count how many\
    \ opening brackets there are, \n        // how many closing brackets, and check\
    \ them all to see if they add up to the number of opening brackets\n        //\
    \ If they don't add up, we need to look at the last closing bracket\n        var\
    \ openingBrackets = 0 \n        var closingBrackets = 0 \n        var lastClosingBracket\
    \ = -1\n        var isOkay = true\n        for (i <- 0 to brackets.length - 1)\
    \ {\n            var currentChar = brackets(i)\n            val nextChar = brackets(i\
    \ + 1)\n            \n            if(currentChar == \">\") {\n               \
    \ val openingCount = openingBrackets\n                val closingCount = closingBrackets\n\
    \                val closingBracket = nextChar\n\n                // If we get\
    \ the same opening bracket more than once,\n                // the bracketing\
    \ doesn't work right\n                if(openingCount == closingCount) {\n   \
    \                 isOkay = false\n                    break\n                }\n\
    \                openingBrackets = openingCount + 1\n                closingBrackets\
    \ = 0\n                lastClosingBracket = closingBracket\n            } else\
    \ if (currentChar == \"<\") {\n                val openingCount = openingBrackets\n\
    \                val closingCount = closingBrackets\n                val openingBracket\
    \ = nextChar\n                \n                // If we get the same closing\
    \ bracket more than once,\n                // the bracketing doesn't work right\n\
    \                if(closingCount == openingCount) {\n                    isOkay\
    \ = false\n                    break\n                }\n                openingBrackets\
    \ = 0\n                closingBrackets = closingCount + 1\n                lastClosingBracket\
    \ = closingBracket\n            }\n        }\n        return isOkay", "      \
    \  val openingBrackets = brackets.split(\"[<>]+\")\n        for (openingBracket\
    \ <- openingBrackets) {\n            val closingBrackets = openingBracket.split(\"\
    [<>]+\")\n            if (closingBrackets.nonEmpty) {\n                val closingBracket\
    \ = closingBrackets(0)\n                val openingBracketIndex = openingBrackets.indexOf(0)\n\
    \                val openingBracketRemoved = openingBrackets.remove(openingBracketIndex)\n\
    \                openingBrackets.remove(openingBracketIndex)\n               \
    \ if (openingBrackets.isEmpty) openingBracketRemoved else openingBracketRemoved\
    \ :: closingBrackets\n            } else openingBrackets\n        }", "      \
    \  // Use a mutable hashset to count how many brackets are in the string.\n  \
    \      // Also keep track of the number of open brackets, and the number of closed\
    \ brackets.\n        val openCounts = new mutable.HashMap[Char, Int]()\n     \
    \   val closedCounts = new mutable.HashMap[Char, Int]()\n        val opening =\
    \ brackets.length\n        if (opening == 0) {\n            true\n        } else\
    \ {\n            val first = brackets.charAt(0)\n            val second = brackets.charAt(1)\n\
    \            if (opening  == 0) {\n                openCounts(first) = 0\n   \
    \             openCounts(second) = 0\n                closedCounts(first) = 0\n\
    \                closedCounts(second) = 0\n                true\n            }\
    \ else {\n                if (closedCounts.contains(first) && closedCounts(first)\
    \ > 0) {\n                    openCounts(first) -= 1\n                    openCounts(second)\
    \ -= 1\n                    closedCounts(first) -= 1\n                    closedCounts(second)\
    \ -= 1\n                    false\n                } else {\n                \
    \    openCounts(first) += 1\n                    openCounts(second) += 1\n   \
    \                 closedCounts(first) += 1\n                    closedCounts(second)\
    \ += 1\n                    true\n                }\n            }\n        }",
  "        var openCount = 0\n        var closeCount = 0\n        var closed = false\n\
    \        brackets.foreach(c => {\n            if (c == \"<\") {\n            \
    \    openCount += 1\n            } else if (c == \">\") {\n                closeCount\
    \ += 1\n            } else if (c == \"<=\") {\n                if (openCount >\
    \ 0) {\n                    closeCount = openCount\n                    openCount\
    \ = 0\n                    closed = true\n                }\n            } else\
    \ if (c == \">=\") {\n                if (closeCount > 0) {\n                \
    \    openCount = closeCount\n                    closeCount = 0\n            \
    \        closed = false\n                }\n            } else if (c == \">\"\
    ) {\n                if (closeCount > openCount) {\n                    return\
    \ false\n                }\n            } else if (c == \"<=\") {\n          \
    \      if (openCount == 0) {\n                    return false\n             \
    \   }\n            } else if (c == \"<\") {\n                if (closeCount ==\
    \ 0) {\n                    return false\n                }\n            } else\
    \ if (c == \">=\") {\n                if (openCount == closeCount) {\n       \
    \             return false\n                }\n            }\n        })\n   \
    \     return closed", "        val bracketMap = brackets.foldLeft(Map[Char,Char]())\
    \ { (map, ch) =>\n            if(map.contains(ch)) {\n                map.update(ch,\
    \ map.get(ch) + 1)\n            } else {\n                map += ch -> 1\n   \
    \         }\n        }\n        for(ch <- bracketMap) {\n            if(!bracketMap.contains(ch))\
    \ {\n                return false\n            }\n        }\n        true", " \
    \       val bracketsArray = brackets.split(\"\")\n        val stack = new mutable.Stack[String]\n\
    \        val openingBrackets = bracketsArray.zipWithIndex.find(_._1 == \"<\")\n\
    \        val closingBrackets = bracketsArray.zipWithIndex.find(_._1 == \">\")\n\
    \        val notBrackets = bracketsArray.filterNot(_ == \"<\")\n        val notClosingBrackets\
    \ = bracketsArray.filterNot(_ == \">\")\n\n        if(openingBrackets.isDefined)\
    \ {\n            openingBrackets._2 += 1\n            stack.push(openingBrackets._1)\n\
    \        }\n        if(notBrackets.isEmpty) {\n            return true\n     \
    \   }\n        if(closingBrackets.isDefined) {\n            closingBrackets._2\
    \ += 1\n            stack.push(closingBrackets._1)\n        }\n        while(stack.nonEmpty)\
    \ {\n            val s = stack.pop()\n            if(s == \"<\") {\n         \
    \       val openingBracketsThatAreNotBrackets = notBrackets.zipWithIndex.find(_._1\
    \ == s\">\")\n                if(openingBracketsThatAreNotBrackets.isDefined)\
    \ {\n                    openingBracketsThatAreNotBrackets._2 += 1\n         \
    \           stack.push(openingBracketsThatAreNotBrackets._1)\n               \
    \ }\n            }\n            if(s == \">\") {\n                val closingBracketThatIsNotBrackets\
    \ = notClosingBrackets.zipWithIndex.find(_._1 == \"<\")\n                if(closingBracketThatIsNotBrackets.isDefined)\
    \ {\n                    closingBracketThatIsNotBrackets._2 += 1\n           \
    \         stack.push(closingBracketThatIsNotBrackets._1)\n                }\n\
    \            }\n        }\n        return false", "        var left = 0\n    \
    \    var right = 0\n        var inBracket = false\n        brackets.split(\"<\"\
    ).foreach{ bracket =>\n            val newLeft = left + 1\n            val newRight\
    \ = right + 1\n            val newInBracket = inBracket\n            if(bracket.equals(\"\
    >\")) inBracket = false\n            else if(bracket.equals(\"<\")) inBracket\
    \ = true\n            else if(newInBracket) {\n                if(left > newRight)\
    \ return false\n                left = newLeft\n                right = newRight\n\
    \            }\n        }\n        return true", "        val stack = mutable.Stack[String]()\n\
    \        val isOpen = mutable.Map[Char, Boolean]()\n        brackets.toList.foreach(c\
    \ => {\n            if(c != '<')\n                isOpen.getOrElse('>'+c, false)\
    \ = true\n            else if(c != '>')\n                isOpen.getOrElse('>'+c,\
    \ false) = true\n            else if(c != '<')\n                isOpen.getOrElse('<'+c,\
    \ false) = true\n            else if(c != '>')\n                isOpen.getOrElse('<'+c,\
    \ false) = true\n            else {\n                if(!stack.isEmpty) {\n  \
    \                  if(!stack.peek().startsWith(\"<\") && !stack.peek().startsWith(\"\
    >\"))\n                        return false\n                }\n             \
    \   stack += '<' + c\n                isOpen.getOrElse('<'+c, false) = true\n\
    \            }\n        })\n        stack.size == brackets.length && stack ==\
    \ '<>'", '        brackets.indexOf("<") > -1 && brackets.indexOf(">") > -1', " \
    \       val openingBrackets : Set[String] = brackets.split(\"[<>]\").map (x =>\
    \ x.trim).toSet\n        val closingBrackets : Set[String] = brackets.split(\"\
    [<>]\").map (x => x.trim).toSet\n        openingBrackets.isEmpty || closingBrackets.forall(x\
    \ => openingBrackets.contains(x) && closingBrackets.contains(x))", "        def\
    \ helper(brackets: List[String], open: List[String], close: List[String]) : Boolean\
    \ = {\n            if (brackets.length == 0)\n                return true\n  \
    \          else if (open.length == 0)\n                return false\n        \
    \    else if (close.length == 0)\n                return true\n            else\
    \ if (open.length == close.length)\n                return helper(brackets.tail,\
    \ open.tail, close.tail)\n            else if (close.head == brackets.head) {\n\
    \                helper(brackets.tail, open, close.tail)\n            }\n    \
    \        else if (close.head != brackets.head) {\n                helper(brackets.tail,\
    \ open.tail, close.tail)\n            }\n            else {\n                helper(brackets.tail,\
    \ open, close.tail)\n            }\n        }\n        val open = brackets.split(\"\
    \ \").toList\n        val close = brackets.split(\"<\").toList\n        return\
    \ helper(brackets, open, close)", "        var stack : List[List[Int]] = List()\n\
    \        var opening : Int = 0\n        var closing : Int = 0\n\n        for (i\
    \ <- 0 until brackets.length) \n            if (brackets(i) == '<') {\n      \
    \          opening = i\n                stack = List(opening - 1)\n          \
    \  }\n            else if (brackets(i) == '>') {\n                closing = i\n\
    \                val open = opening\n                val close = closing\n   \
    \             val stackLength = stack.length\n                val newStack = List(opening\
    \ - 1, stack.last + 1, stack.last - 1, closing)\n                while (stackLength\
    \ != 0) {\n                    if (newStack.last.isEmpty)\n                  \
    \      return false\n                    val lastItem = newStack.last.last\n \
    \                   if (lastItem > open)\n                        return false\n\
    \                    newStack = newStack :+ lastItem - open\n                \
    \    stackLength = stackLength - 1\n                }\n            }\n       \
    \     else if (brackets(i) == ('>') && stack.last > 0)\n                return\
    \ false\n            else if (brackets(i) == ('>') && stack.last == 0)\n     \
    \           return false\n            else if (brackets(i) == ('>') && stack.last\
    \ < 0)\n                return false\n            else if (brackets(i) == ('>'))\n\
    \                stack = stack :+ opening - 1\n            else if (brackets(i)\
    \ == ('>')\n                stack = stack :+ stack.last + 1\n            else\
    \ if (brackets(i) == '<')\n                stack = stack :+ opening + 1\n    \
    \        else\n                stack = stack :+ i\n\n        return true", " \
    \       if (brackets.isEmpty) false\n        else brackets.tail.tail.forall(c\
    \ => c != '>')", "        var foundBracket = false \n        for (a <- brackets)\
    \ {\n            if (a == \"<\") {\n                foundBracket = false \n  \
    \          } else {\n                if (foundBracket) {\n                   \
    \ false\n                } else {\n                    foundBracket = true\n \
    \               }\n            }\n        }\n        !foundBracket", "       \
    \ val pairs = brackets.split(')').filter(x => !x.isEmpty).toList.map(x => x.split('(')).toList\n\
    \        val pairsInverse = pairs.map(x => x.reverse).filter(x => !x.isEmpty).toList\n\
    \        val openings = pairs.map(x => x._1).filter(x => !x.isEmpty).toList.sortBy(x\
    \ => x.hashCode)\n        val closings = pairs.map(x => x._1).filter(x => !x.isEmpty).toList.sortBy(x\
    \ => x.hashCode).reverse\n        val openingsInverse = pairsInverse.map(x =>\
    \ x._1).filter(x => !x.isEmpty).toList.sortBy(x => x.hashCode)\n        val closingsInverse\
    \ = pairsInverse.map(x => x._1).filter(x => !x.isEmpty).toList.sortBy(x => x.hashCode).reverse\n\
    \        openings.zip(closings).forall { case (opening, closing) => openingsInverse.contains(closing)\
    \ }", "        brackets.toList.foldLeft(true) {\n            case (true, x) =>\
    \ if (x == \">\" || x == \"<\") {\n                if (brackets.toList.dropWhile(_\
    \ != \"<\").dropWhile(_ != \">\").head == \">\") {\n                    true\n\
    \                } else {\n                    false\n                }\n    \
    \        } else {\n                false\n            }\n        }", "       \
    \ if(brackets.length != 2) return false\n        if(brackets.indexOf(\"<\")!=0\
    \ || brackets.indexOf(\">\")!=0) return false\n        var opening = brackets.charAt(0)\n\
    \        var closing = brackets.charAt(1)\n        var lastChar = closing\n  \
    \      for(i <- 0 to brackets.length - 2){\n            if(lastChar != opening\
    \ && lastChar != closing) return false\n            opening = brackets.charAt(i+1)\n\
    \            closing = brackets.charAt(i+2)\n            lastChar = closing\n\
    \        }\n        return true", "        var found = 0\n        for (a <- 0\
    \ to brackets.length-1) {\n            found += brackets(a).length\n         \
    \   found += 1 // need to skip a char\n        }\n        brackets match {\n \
    \           case \">\" :: tail =>\n                var foundTail = 0\n       \
    \         tail foreach { b =>\n                    foundTail += b.length\n   \
    \                 foundTail += 1 // need to skip a char\n                }\n \
    \               found == foundTail\n            case \"><\" :: tail =>\n     \
    \           var foundTail = 0\n                tail foreach { b =>\n         \
    \           foundTail += b.length\n                    foundTail += 1 // need\
    \ to skip a char\n                }\n                found == foundTail\n    \
    \        case _ => false\n        }", "        // Use stack data structure to\
    \ solve the problem\n        // Start from an empty stack, and for every opening\
    \ bracket, push it in stack.\n        // Then for every closing bracket, pop out\
    \ the topmost stack element.\n        // If stack is empty, return false to indicate\
    \ that brackets doesn't work.\n        // If stack isn't empty, return true to\
    \ indicate that brackets works.\n        var stack = new Stack[(Int, Int)]\n \
    \       for (i <- 0 until brackets.length) stack += (brackets.charAt(i) -> (i,1))\n\
    \        while (!stack.isEmpty) {\n            val top = stack.pop()\n       \
    \     if (top(0) == top(1) && (top(0) == \">\" || top(1) == \"<\")) true\n   \
    \         else if (top(0) == top(1) && (top(0) == \"<\" || top(1) == \">\")) false\n\
    \            else stack.push((top(1), top(2)))\n        }\n        false", " \
    \       val bracesNeeded = brackets.length / 2\n        val bracketList = brackets.toList\
    \ \n        val correct = bracketList.foldLeft(false)((correct, next) => \n  \
    \          {\n                if(next == \"<\")\n                    correct ||\
    \ bracketList.drop(2).isEmpty && bracketList.size == bracesNeeded\n          \
    \      else if(next == \">\")\n                    correct || bracketList.drop(bracesNeeded).isEmpty\
    \ && bracketList.size == bracesNeeded\n                else\n                \
    \    correct || bracketList.drop(bracesNeeded).head == next && bracketList.drop(bracesNeeded).last\
    \ == next\n            }\n        )\n        correct", "        var open : Int\
    \ = -1\n        val closed : Int = brackets.size - 1\n        var i = closed +\
    \ 1\n        while (i < brackets.size) {\n            if (brackets.charAt(i) ==\
    \ '<') {\n                open += 1\n            } else if (brackets.charAt(i)\
    \ == '>') {\n                open -= 1\n            }\n            i += 1\n  \
    \      }\n        if (open != -1) {\n            false\n        } else {\n   \
    \         true\n        }", "        val pattern = Pattern.compile(\"<(.*?)>\"\
    )\n        val m = pattern.matcher(brackets)\n        val result = (m.find())\
    \ match {\n            case true => false\n            case false => true\n  \
    \      }\n        result", "        (brackets.toList)\n            .foldLeft((false,\
    \ 0))((acc, b) => {\n                if(b == \"<\") {\n                    acc._2\
    \ = acc._2 + 1\n                }\n                else {\n                  \
    \  acc\n                }\n            })\n            ._1 < brackets.toList.size",
  "        brackets match {\n            case \">\" => brackets.toList foreach { c\
    \ =>\n                if (!(\">\".toList contains c)) return false\n         \
    \   }\n            case \"<\" => brackets.toList foreach { c =>\n            \
    \    if (!(\"><\".toList contains c)) return false\n            }\n          \
    \  case \"><\" => brackets.toList foreach { c =>\n                if (!(\"><<\"\
    .toList contains c)) return false\n            }\n            case _ => true\n\
    \        }", '        brackets.forall(x => x == "<") && !brackets.forall(x =>
    x == ">") && !brackets.forall(x => x == "<")', "        var bracket : Option[Int]\
    \ = None\n        for (i <- 0 to brackets.length - 1) {\n            // use head\
    \ to prevent indexing out of bounds.\n            // >>> brackets(0)\n       \
    \     // (0)\n            // >>> brackets(-1)\n            // (-1)\n         \
    \   // >>> brackets(4)\n            // (4)\n            // >>> brackets(5)\n \
    \           // (5)\n            if (brackets(i) != brackets(i + 1)) {\n      \
    \          bracket = Some(i)\n                break\n            }\n        }\n\
    \        if (bracket.isEmpty) {\n            false\n        } else {\n       \
    \     bracket.get\n        }", "        val set = new mutable.HashSet[Char]\n\
    \        brackets.toList\n            .map(c => (c + '\\').toInt)\n          \
    \  .foreach(c => set += c)\n        set.size == brackets.length", "        var\
    \ openingBrackets = new mutable.HashSet[String]\n        var closingBrackets =\
    \ new mutable.HashSet[String]\n        brackets.split(' ').foreach { s =>\n  \
    \          if(s.startsWith(\"<\")) {\n                openingBrackets += s\n \
    \           } else if (s.startsWith(\">\")) {\n                closingBrackets\
    \ += s\n            }\n        }\n        openingBrackets.size == closingBrackets.size",
  "        val openingBrackets = brackets.split(\"<\").length\n        val closingBrackets\
    \ = brackets.split(\">\").length\n        openingBrackets == closingBrackets",
  "        var openBracketCount = 1\n        var closeBracketCount = 1\n        var\
    \ incorrect = false\n        for (c <- brackets)\n            if (c == '>')\n\
    \                closeBracketCount += 1\n            else\n            if (c ==\
    \ '<')\n                openBracketCount += 1\n            else\n            if\
    \ (c == \">\")\n                closeBracketCount -= 1\n            else\n   \
    \         if (c == \"<\")\n                openBracketCount -= 1\n           \
    \ if (openBracketCount != closeBracketCount)\n                incorrect = true\n\
    \        !incorrect", "        var result : Boolean = true\n        var stack\
    \ = new Stack[String]()\n        var numOpenBrackets = brackets.length\n     \
    \   for (i = 1 to numOpenBrackets) {\n            val index = brackets.charAt(i)\
    \ - 1\n            if (index == 0) stack += \">\"\n            else if (index\
    \ == numOpenBrackets - 1) stack += \"<\"\n            else {\n               \
    \ if (stack.isEmpty) result = false\n                else stack += brackets.charAt(i)\n\
    \            }\n        }\n        stack.isEmpty", "        var bracketsCount\
    \ = brackets.count\n        while (bracketsCount > 0) {\n            var bracketsCount2\
    \ = bracketsCount - 1\n            while (bracketsCount2 >= 0) {\n           \
    \     if (!brackets.contains(brackets(bracketsCount2)) || bracketsCount2 == 0)\
    \ {\n                    bracketsCount2 -= 1\n                    break\n    \
    \            }\n                bracketsCount2 -= 1\n            }\n         \
    \   bracketsCount -= 1\n        }\n        bracketsCount == 0", '      brackets
    == "<" + ">".repeat( (brackets + "<").length )', "        brackets.toList match\
    \ {\n            case List() | List(\"<\"*30, \"<\"*30, \"<\"*30) => (false)\n\
    \            case List(\"<<>\", \"<<>\", \"<<>\") => (true)\n            case\
    \ _ => (false)\n        }", "        var inBrackets = false\n        var lastClose\
    \ = 0\n        // We need to go through every character in brackets to determine\n\
    \        // if there's a closing bracket before a opening bracket.\n        for\
    \ (char <- brackets.toCharArray()) {\n            if (char == '<') {\n       \
    \         inBrackets = true\n            }\n            if (char == '>') {\n \
    \               if (!inBrackets) {\n                    return false\n       \
    \         }\n                inBrackets = false\n            }\n        }\n  \
    \      if (!inBrackets) {\n            return false\n        }\n        // Now\
    \ we just have to check that the last closing bracket is there.\n        if (brackets(lastClose\
    \ + 1) != '>') {\n            return false\n        }\n        return true", " \
    \       brackets.split(\"<\").zip(brackets.split(\">\").map(_.trim)).\n      \
    \      forall(l => l._1.equals(l._2))", "        var opening = false\n       \
    \ var found = False\n        var stack = \"\"\n        for (b <- brackets) {\n\
    \            if (b == \"<\") {\n                if (!opening) {\n            \
    \        opening = true\n                    stack += \"(\"\n                \
    \    found = True\n                }\n            }\n            else if (b ==\
    \ \">\") {\n                if (opening) {\n                    opening = false\n\
    \                    stack += \")\"\n                    found = True\n      \
    \          }\n            }\n            else {\n                if (opening)\
    \ {\n                    stack += b\n                }\n            }\n      \
    \  }\n        if (found) {\n            stack == brackets\n        }\n       \
    \ else {\n            false\n        }", "        var opening = brackets.length\n\
    \        var closed = brackets.length\n\n        val result = brackets.split(\"\
    <\").forall(x => brackets.split(\">\").contains(x))\n        opening = brackets.length\
    \ - closed\n        closed = brackets.length\n        result", "        if(brackets\
    \ == \"\") true\n        else {\n            val openBrackets = brackets.split(\"\
    <\").filter(_.nonEmpty)\n            val closeBrackets = brackets.split(\">\"\
    ).filter(_.nonEmpty)\n            if(openBrackets.length != closeBrackets.length)\
    \ false\n            else {\n                openBrackets.zip(closeBrackets).forall\
    \ { case (bracket1, bracket2) => bracket1 == bracket2 }\n            }\n     \
    \   }", "        val openings = brackets.toList.tail.filter(_ == '<').toList\n\
    \        val closings = brackets.toList.tail.filter(_ == '>').toList\n       \
    \ val expected = openings.size == closings.size\n        val actual = openings.size\
    \ == expected.size\n        (actual && expected && openings.forall(b => closings.contains(b)))\
    \ == expected", "        val openingBrackets = brackets.split(\"\\\\<\").filter(_.nonEmpty)\n\
    \        val closingBrackets = brackets.split(\"\\\\>\").filter(_.nonEmpty)\n\
    \        (openingBrackets zip closingBrackets).forall(x => x._1 == x._2)", " \
    \       val stack = brackets.toList.reverse\n        val newStack = new mutable.Stack[String]\n\
    \        for (bracket <- stack) {\n            if (bracket.equals(\">\")) {\n\
    \                stack.last = \"<\"\n                newStack.push(bracket)\n\
    \            } else if (bracket.equals(\"<\")) {\n                newStack.push(bracket)\n\
    \            } else if (bracket.equals(\"(\")) {\n                newStack.push(bracket)\n\
    \            } else if (bracket.equals(\")\")) {\n                if (newStack.size\
    \ == 0) {\n                    false\n                } else {\n             \
    \       if (newStack.head == \"<\") {\n                        true\n        \
    \            } else if (newStack.head == \"(\") {\n                        val\
    \ stack2 = newStack.drop(1)\n                        val stack3 = newStack.takeWhile(_\
    \ != \"(\")\n                        if (stack2.isEmpty) {\n                 \
    \           stack3.head == \"<\"\n                        } else {\n         \
    \                   stack3.head == \"<\"\n                        }\n        \
    \            } else {\n                        false\n                    }\n\
    \                }\n            }\n        }", "        brackets.count( c => c\
    \ == '<' ) == 0", "        val brackets_array = brackets.toArray\n        var\
    \ open_brackets = 1 // for single open brackets\n        var close_brackets =\
    \ 0 // for single close brackets\n        for (i <- 0 until brackets_array.length)\
    \ {\n            val char = brackets_array(i)\n            // if character is\
    \ \"<\", then increase the count of open brackets\n            if (char == \"\
    <\") {\n                open_brackets += 1\n            }\n            // else\
    \ character is \">\", then decrease the count of close brackets\n            else\
    \ {\n                close_brackets -= 1\n            }\n            // if count\
    \ is zero, then there is no bracket\n            if (close_brackets == 0 && open_brackets\
    \ == 0) {\n                return false\n            }\n        }\n        //\
    \ if count of open brackets is zero, then there is atleast one opening bracket\n\
    \        if (open_brackets == 0) {\n            return true\n        }\n     \
    \   // else if count of close brackets is zero, then there is atleast one closing\
    \ bracket\n        else if (close_brackets == 0) {\n            return false\n\
    \        }\n        // else if count of open brackets is not equal to count of\
    \ close brackets\n        else {\n            val open_count : Int = brackets_array.length\
    \ - close_brackets\n            if (open_count != close_count) {\n           \
    \     return false\n            }\n            else {\n                return\
    \ true\n            }\n        }", "        brackets.toList match {\n        \
    \    case Nil => false\n            case _ => {\n                val openings\
    \ = brackets.map(c => if (c == '<') 1 else 0)\n                val closings =\
    \ brackets.map(c => if (c == '>') 1 else 0)\n                openings.zip(closings)\
    \ match {\n                    case (x: Seq[(Int, Int)]) if (x.forall(_._2 ==\
    \ 0)) => false\n                    case (x: Seq[(Int, Int)]) => true\n      \
    \              case _ => false\n                }\n            }\n        }",
  "        // convert the string into a list so we can iterate over it.\n        //\
    \ we can then use list's indexOf method to check if a closing bracket has been\
    \ found.\n        // if so, then return true, otherwise, return false.\n     \
    \   val bracketsAsList = brackets.toList\n        val bracesCount = 0\n      \
    \  var curChar = bracketsAsList(0)\n        // loop over the string until we find\
    \ the closing bracket\n        while (curChar != \">\") {\n            bracesCount\
    \ += 1\n            curChar = bracketsAsList(bracesCount)\n        }\n       \
    \ // if we found a closing bracket, return true, otherwise return false\n    \
    \    curChar == \"<\"", "        if (brackets == \"\")\n            return false\n\
    \        val bracketMap = brackets.toList\n        .map(c => c -> (c to bracketMap(0)))\n\
    \        .foldLeft(Map[Char, Int]())((map, next) =>\n            map.updated(next(_),\
    \ next(_ + 1))\n        )\n        if (bracketMap(\">\") == bracketMap(\"<\"))\n\
    \            false\n        else if (bracketMap(\"<\") == bracketMap(\"<<\"))\n\
    \            false\n        else if (bracketMap(\"<<\") == bracketMap(\"<<<\"\
    ))\n            false\n        else if (bracketMap(\"<>\") == bracketMap(\"<><>\"\
    ))\n            false\n        else\n            true", "        var inside =\
    \ Set.empty[Int]\n        for (i <- brackets.indices) {\n            if (brackets(i)\
    \ == '<') {\n                inside = inside + i\n            }\n            if\
    \ (brackets(i) == '>') {\n                if (!inside.contains(i))\n         \
    \           return false\n                inside = inside - i\n            }\n\
    \        }\n        return (inside.size == 0)", "        val bracketIndexes =\
    \ brackets.zipWithIndex.filter(_._1 == \">\").map(_._2)\n        if (bracketIndexes.isEmpty)\
    \ true\n        else {\n            val correct = bracketIndexes.size == brackets.length\n\
    \            bracketIndexes.foldLeft(correct) { (sum, index) => sum && !brackets(index)\
    \ }\n        }", "        val stack = mutable.Stack[String]()\n        var result\
    \ : Boolean = true\n        for (i <- 0 to brackets.length - 1) {\n          \
    \  if (brackets(i) != brackets(i+1)) {\n                result = false\n     \
    \           break\n            }\n        }\n        stack.pop() match {\n   \
    \         case Some(\"</\") | Some(\"/>\") => false\n            case _      \
    \              => result\n        }", "        var inString = false;\n       \
    \ var lastIdx = 0;\n        var currentIdx = 0;\n        while (!inString) {\n\
    \            currentIdx = brackets.indexOf(\"<\", lastIdx);\n            if (currentIdx\
    \ == -1) inString = true;\n            else {\n                lastIdx = currentIdx;\n\
    \                currentIdx = brackets.indexOf(\">\", currentIdx);\n         \
    \   }\n        }\n        if (currentIdx == -1) inString = true;\n        else\
    \ false", "        if(!brackets.toList.contains(\">\")) return true\n        if(brackets.toList.head.isDigit())\
    \ return false\n        val stack = mutable.Stack[String]()\n        val stackIterator\
    \ = brackets.toList.iterator\n        while(stackIterator.hasNext) {\n       \
    \     val str = stackIterator.next().trim\n            if(str.startsWith(\"<\"\
    )) stack.push(\"<<\")\n            if(str.startsWith(\">\")) stack.pop() match\
    \ {\n                case s\"${stackIterator.next()}<\" => false\n           \
    \     case _ => true\n            }\n            if(stackIterator.hasNext()) stackIterator.next()\n\
    \        }\n        stack.isEmpty", "        val bracketsArray = brackets.toCharArray\n\
    \        for (i <- 0 until bracketsArray.length)\n            while (i < bracketsArray.length\
    \ && bracketsArray(i) == '<')\n                i += 1\n            while (i <\
    \ bracketsArray.length && bracketsArray(i) == '>')\n                i += 1\n \
    \           while (i < bracketsArray.length)\n                i += 1\n       \
    \     if (i < bracketsArray.length)\n                false\n            else\n\
    \                true", "        val correct = (brackets splitAt 0 sameElements\
    \ (\"<\") ++\n                (brackets splitAt 0 sameElements (\"<<\"))\n   \
    \             ++ (brackets splitAt 0 sameElements (\"<>\") ++\n              \
    \  (brackets splitAt 0 sameElements (\"<<<\"))\n                ++ (brackets splitAt\
    \ 0 sameElements (\"<>>>\"))\n                ++ (brackets splitAt 0 sameElements\
    \ (\"<>>><\"))\n                ++ (brackets splitAt 0 sameElements (\"<<<>>>\"\
    ))\n                ++ (brackets splitAt 0 sameElements (\"<<<><<\"))\n      \
    \          ++ (brackets splitAt 0 sameElements (\"<><>>\"))\n                ++\
    \ (brackets splitAt 0 sameElements (\"<<>><\"))\n                ++ (brackets\
    \ splitAt 0 sameElements (\"<><<>\"))\n                ++ (brackets splitAt 0\
    \ sameElements (\"<><<<\"))\n                ++ (brackets splitAt 0 sameElements\
    \ (\"<><<>>>\"))\n                ++ (brackets splitAt 0 sameElements (\"<>>><>>>\"\
    ))\n                ++ (brackets splitAt 0 sameElements (\"<<<>>><\"))\n     \
    \           ++ (brackets splitAt 0 sameElements (\"<><>>>\"))\n              \
    \  ++ (brackets splitAt 0 sameElements (\"<>><><\"))\n                ++ (brackets\
    \ splitAt 0 sameElements (\"<><><>\"))\n                ++ (brackets splitAt 0\
    \ sameElements (\"<><><>>\"))\n                ++ (brackets splitAt 0 sameElements\
    \ (\"<><><>>>\"))\n                ++ (brackets splitAt 0 sameElements (\"<><><>>><\"\
    ))\n                ++ (brackets splitAt 0 sameElements (\"<><><>>>>\"))\n   \
    \             ++ (brackets splitAt 0 sameElements (\"<><><>>><>>>\"))\n      \
    \          ++ (brackets splitAt 0 sameElements (\"<><><>>><>>><\"))\n        \
    \        ++ (brackets splitAt 0 sameElements (\"<><><>>><>>><>>>\"))\n       \
    \         ++ (brackets splitAt 0 sameElements (\"<><><>>><>>><>>><\"))\n     \
    \           ++ (brackets splitAt 0 sameElements (\"<><><>>><>>><>>><>>>\"))\n\
    \                ++ (brackets splitAt 0 sameElements (\"<><><>>><>>><>>><>>><\"\
    ))\n                ++ (brackets splitAt 0 sameElements (\"<><><>>><>>>", "  \
    \      var openingBrackets : List[Char] = Nil\n        var closingBrackets : List[Char]\
    \ = Nil\n\n        // Add all the opening brackets.\n        for (character <-\
    \ brackets) {\n            if (character == '<') {\n                openingBrackets\
    \ += character\n            }\n        }\n\n        // If there are no more opening\
    \ brackets, return false.\n        if (openingBrackets.isEmpty) {\n          \
    \  return false\n        }\n\n        // Add all the closing brackets.\n     \
    \   for (character <- brackets) {\n            if (character == '>') {\n     \
    \           closingBrackets += character\n            }\n        }\n\n       \
    \ // If there are no more closing brackets, return false.\n        if (closingBrackets.isEmpty)\
    \ {\n            return true\n        }\n\n        // If there are not the same\
    \ number of opening brackets and closing brackets, return false.\n        if (openingBrackets.length\
    \ != closingBrackets.length) {\n            return false\n        }\n\n      \
    \  // Test each closing bracket.\n        for (character <- closingBrackets) {\n\
    \            // If there is no opening bracket, return false.\n            if\
    \ (!openingBrackets.contains(character)) {\n                return false\n   \
    \         }\n\n            // Remove the opening bracket.\n            openingBrackets\
    \ = openingBrackets.filterNot(_ == character)\n\n            // If there still\
    \ are no opening brackets, return false.\n            if (openingBrackets.isEmpty)\
    \ {\n                return false\n            }\n        }\n\n        // If we\
    \ got this far, there were no problems with your brackets.\n        return true",
  "        var closed = false\n        for (c <- brackets) {\n            if (c ==\
    \ \"<\")\n                closed = !closed\n        }\n        return closed",
  "        // if brackets is empty, it is correct\n        if(brackets.length < 1)\
    \ {\n            return true\n        }\n        // else find first opening bracket\n\
    \        var openingBracket = 0\n        while (!brackets.charAt(openingBracket).equals(\"\
    <\")) {\n            openingBracket+=1\n        }\n        // if brackets is longer\
    \ than number of opening brackets\n        if(openingBracket > brackets.length-1)\
    \ {\n            return false\n        }\n        // else find first closing bracket\n\
    \        var closingBracket = 0\n        while (!brackets.charAt(closingBracket).equals(\"\
    >\")) {\n            closingBracket+=1\n        }\n        // if brackets is longer\
    \ than number of closing brackets\n        if(closingBracket > brackets.length-1)\
    \ {\n            return false\n        }\n        // else all brackets match up\n\
    \        return true", "        if (brackets.length == 0 || brackets.length ==\
    \ 1) {\n            return true\n        }\n        // A stack is used to keep\
    \ track of what brackets we've seen.\n        val stack = new mutable.Stack[String]()\n\
    \        val lastChar = brackets(0)\n        val newChar = brackets(1)\n     \
    \   val openingPairs = brackets.substring(1, brackets.length - 1)\n        val\
    \ closingPairs = brackets.substring(brackets.length - 2)\n        openingPairs.split(\"\
    <\").foreach(pair => {\n            val stackPushed = stack.push(\"<\" + pair)\n\
    \            if (!stackPushed) {\n                return false\n            }\n\
    \            val stackPopped = stack.pop()\n            if (!stackPopped.equals(\"\
    >\" + lastChar)) {\n                return false\n            }\n        })\n\
    \        closingPairs.split(\">\").foreach(pair => {\n            val stackPushed\
    \ = stack.push(pair + \">\")\n            if (!stackPushed) {\n              \
    \  return false\n            }\n            val stackPopped = stack.pop()\n  \
    \          if (!stackPopped.equals(\"<\" + lastChar)) {\n                return\
    \ false\n            }\n        })\n        return stack.size == 0", "       \
    \ var openingBracketCount : Int = 0\n        var closingBracketCount : Int = 0\n\
    \        for (c <- brackets) {\n            if (c == \"<\")\n                openingBracketCount\
    \ += 1\n            else if (c == \">\")\n                closingBracketCount\
    \ += 1\n            else\n                break\n        }\n        return openingBracketCount\
    \ == closingBracketCount", "        // write your logic here\n        \n     \
    \   val openingBrackets = brackets.split(\"<\").length\n        val closingBrackets\
    \ = brackets.split(\">\").length\n        val total = openingBrackets + closingBrackets\n\
    \        if (total != 0) {\n            false\n        } else {\n            true\n\
    \        }", "      val len = brackets.length\n      brackets.split(\"\").\n \
    \       filter(s => s.startsWith(\"<\")).\n        forall(b => b == \"<\")", " \
    \       if(brackets.isEmpty) return true\n        var opening = true\n       \
    \ var closing = false\n        val bracketsArray = brackets.toArray.toList\n \
    \       while(bracketsArray.length > 0){\n            if(!opening && closing)\
    \ return false\n            opening += bracketsArray.last.equals(\"<\")\n    \
    \        closing += bracketsArray.length == 1 ? false\n            bracketsArray.remove(bracketsArray.length\
    \ - 1)\n        }\n        return true", "        // Create an empty stack\n \
    \       var stack : mutable.Stack[String] = new mutable.Stack[String]\n\n    \
    \    // Iterate over the brackets one character at a time\n        for (i <- 0\
    \ until brackets.length)\n            // If the current character is \"<\", push\
    \ it on the stack\n            if (brackets(i) == '<')\n                stack\
    \ push brackets(i)\n            // If the current character is \">\", pop an element\
    \ off the stack\n            else if (brackets(i) == '>') {\n                if\
    \ (!stack.isEmpty) stack.pop()\n            }\n            // If the current character\
    \ is \"(\" or \")\", pop an element off the stack\n            else if (brackets(i)\
    \ == '(' || brackets(i) == ')') {\n                if (!stack.isEmpty) stack.pop()\n\
    \            }\n            else {\n                // Otherwise, if the stack\
    \ is empty, we're not on the right bracket\n                if (!stack.isEmpty)\n\
    \                    // Return false, since we're not on the right bracket\n \
    \                   false\n                else\n                    // Return\
    \ true\n                    true\n            }", "        if (brackets.length\
    \ == 0) { return true }\n        var openingBracket = 0\n        var closingBracket\
    \ = 0\n        for (bracket <- brackets) {\n            if (bracket == \"<\")\
    \ {\n                openingBracket += 1\n            } else if (bracket == \"\
    >\") {\n                closingBracket += 1\n            } else {\n          \
    \      assert(false, \"unknown bracket: \" + bracket)\n            }\n       \
    \ }\n        assert(openingBracket == closingBracket, \"opening and closing brackets\
    \ mismatch\")\n        return false", "        if (brackets.isEmpty) true\n  \
    \      else {\n            val openingBrackets = brackets.split(\"<\")\n     \
    \       val closingBrackets = brackets.split(\">\")\n\n            val stack =\
    \ mutable.Stack[String]()\n            val bracketsFound = mutable.Map[String,\
    \ Boolean]()\n\n            val bracketsMap = openingBrackets.zipWithIndex.map\
    \ {\n            case (openingBracket, index) => (openingBracket, index)\n   \
    \         }.toMap\n\n            for (opening <- openingBrackets) {\n        \
    \        val index = bracketsMap(opening)\n                val nextOpening = openingBrackets(index\
    \ + 1)\n\n                if (bracketsMap(nextOpening) == false) {\n         \
    \           stack.push(opening)\n                } else {\n                  \
    \  val correctNextOpening = openingBrackets(index + 1)\n                    if\
    \ (correctNextOpening == false) {\n                        stack.push(opening)\n\
    \                    } else {\n                        val matchingClosings =\
    \ closingBrackets.filter {\n                            c => opening.equals(c)\n\
    \                        }\n\n                        if (matchingClosings.length\
    \ == 0) {\n                            bracketsFound(opening) = false\n      \
    \                  } else {\n                            val matchingClosingIndex\
    \ = closingBrackets.indexOf(matchingClosings.head)\n                         \
    \   val matching = openingBrackets(matchingClosingIndex + 1)\n               \
    \             bracketsFound(opening) = true\n                            if (matching\
    \ == false) {\n                                stack.push(opening)\n         \
    \                   }\n                        }\n                    }\n    \
    \            }\n            }\n\n            if (stack.nonEmpty) false else true\n\
    \        }", "        brackets.toList.filter(_ == '<').size == brackets.length\
    \ &&\n            (brackets.toList.filter(_ == '>').size == brackets.length)",
  "        var lastOpenBracket = -1\n        for(i <- 0 until brackets.length){\n\
    \            val nextChar = brackets(i)\n            if(brackets(i) != nextChar){\n\
    \                if(lastOpenBracket != -1){\n                    if(brackets(lastOpenBracket)\
    \ == nextChar){\n                        return false\n                    }\n\
    \                }\n                lastOpenBracket = i\n            }\n     \
    \   }\n        return true", "        val openBrackets = brackets.toList\n   \
    \     val closeBrackets = openBrackets.reverse\n        val openBracketCounts\
    \ = openBrackets.map(_.length)\n        val closeBracketCounts = closeBrackets.map(_.length)\n\
    \        if (closeBracketCounts.forall(_ != openBracketCounts(0)))\n         \
    \   return false\n        val openCount = openBracketCounts.sum\n        val closeCount\
    \ = closeBracketCounts.sum\n        val openIndex = 0\n        val closeIndex\
    \ = openCount\n        val openFound = false\n        var closeFound =false\n\
    \        while (openIndex < openCount && closeIndex < closeCount) {\n        \
    \    if (openBrackets(openIndex) != closeBrackets(closeIndex))\n             \
    \   return false\n            closeIndex = closeIndex + 1\n            if (closeIndex\
    \ == closeCount)\n                closeFound = true\n            openIndex = openIndex\
    \ + 1\n        }\n        if (!closeFound)\n            return false\n       \
    \ if (openIndex != closeIndex)\n            return false\n        if (openBracketCounts(0)\
    \ < openBracketCounts(1))\n            return false\n        openBracketCounts.forall(_\
    \ == openBracketCounts.last)", "        if(brackets.length != 1) {\n         \
    \   return false\n        }\n        var openBracket = brackets.charAt(0)\n  \
    \      var closeBracket = brackets.charAt(1)\n        var openBracketCount = new\
    \ Array[String](1)\n        var closeBracketCount = new Array[String](1)\n   \
    \     var openBracketCountPosition = 0\n        var closeBracketCountPosition\
    \ = 0\n        for(i <- 0 to brackets.length - 2) {\n            if(brackets.charAt(i)\
    \ == openBracket) {\n                openBracketCount(openBracketCountPosition)\
    \ = 0\n                openBracketCountPosition = openBracketCountPosition + 1\n\
    \                openBracketCount(openBracketCountPosition) = openBracketCount(openBracketCountPosition)\
    \ + 1\n            }\n            if(brackets.charAt(i) == closeBracket) {\n \
    \               closeBracketCount(closeBracketCountPosition) = 0\n           \
    \     closeBracketCountPosition = closeBracketCountPosition + 1\n            \
    \    closeBracketCount(closeBracketCountPosition) = closeBracketCount(closeBracketCountPosition)\
    \ + 1\n            }\n        }\n        openBracketCount = openBracketCount.dropRight(openBracketCountPosition)\n\
    \        closeBracketCount = closeBracketCount.dropRight(closeBracketCountPosition)\n\
    \        if(openBracketCount.length == closeBracketCount.length) {\n         \
    \   return true\n        } else {\n            return false\n        }", "   \
    \     var first = True\n        var last = True\n        var bracketCount = 0\n\
    \        var bracketOpenCount = 0\n        var bracketCloseCount = 0\n       \
    \ var bracketCountPairs = brackets.split(\",\").map {\n            a => a.trim.split(\"\
    <\").length -> a.trim.split(\">\").length\n        }.toSeq\n\n        bracketCountPairs.foreach\
    \ {\n            pair =>\n                if (first && last) return\n        \
    \        if (!first && !last) return\n                if (pair._1 != bracketOpenCount)\
    \ return\n                if (pair._2 != bracketCloseCount) return\n         \
    \       bracketCount += 1\n                bracketOpenCount += 1\n           \
    \     bracketCloseCount += 1\n        }\n        false", "        var flag : Boolean\
    \ = true\n        var openingBrackets = brackets.split(\"<\")\n        var closingBrackets\
    \ = brackets.split(\">\")\n        if(openingBrackets.length != closingBrackets.length)\n\
    \            return false\n\n        for(i <- 0 until openingBrackets.length)\
    \ {\n            var opening = openingBrackets(i)\n            var closing = closingBrackets(i)\n\
    \            if(!opening.contains(\"<\") && !opening.contains(\">\") && !closing.contains(\"\
    <\") && !closing.contains(\">\"))\n                return false\n            if(opening.contains(\"\
    <\") && !closing.contains(\"<\"))\n                flag = false\n            if(opening.contains(\"\
    >\") && !closing.contains(\">\"))\n                flag = false\n        }\n \
    \       return flag", '        //TODO', "        val stack = Stack[String]()\n\
    \        val bracketCount = brackets.length\n\n        def hasClose(b : String)\
    \ : Boolean = {\n            stack.size > 0\n        }\n\n        def push(b :\
    \ String) : Unit = {\n            stack push b\n        }\n\n        def pop()\
    \ : String = {\n            val result = stack.pop()\n            if (stack.size\
    \ > 0) {\n                return result\n            }\n            else return\
    \ \"\"\n        }\n\n        def isOpen(b : String) : Boolean = {\n          \
    \  stack.contains(b)\n        }\n\n        def parse(bracket : String) : Unit\
    \ = {\n            if (isOpen(bracket)) {\n                push(bracket)\n   \
    \         }\n            else {\n                val closeBracket = pop\n    \
    \            if (hasClose(closeBracket)) {\n                    parse(bracket)\n\
    \                }\n                else {\n                    push(bracket)\n\
    \                }\n            }\n        }\n\n        for (i <- 0 until bracketCount)\
    \ {\n            val bracket = brackets(i)\n            if (isOpen(bracket)) {\n\
    \                parse(bracket)\n            }\n        }\n\n        if (stack.size\
    \ != bracketCount) {\n            return false\n        }\n        else {\n  \
    \          return true\n        }", "        val openingBrackets = brackets.split(\"\
    <\").filter(_.nonEmpty)\n        val closingBrackets = brackets.split(\">\").filter(_.nonEmpty)\n\
    \        val nonOpeningBrackets = brackets.filterNot(_.nonEmpty)\n        openingBrackets.length\
    \ == closingBrackets.length && openingBrackets.toSet == closingBrackets.toSet",
  "        // For each opening bracket, count the number of closing brackets\n   \
    \     // that precede it. Return true if exactly one closing bracket appears\n\
    \        // before any opening bracket. If exactly two brackets appear, the\n\
    \        // first opening bracket must be preceded by a closing bracket.\n   \
    \     var bracketCounts = Map[Char, Int]()\n        var foundOpeningBracket =\
    \ false\n        for(i <- 0 to brackets.length-1){\n            val currentChar\
    \ = brackets(i)\n            if(currentChar == '<') {\n                val nextChar\
    \ = brackets(i+1)\n                if(nextChar == '>') {\n                   \
    \ foundOpeningBracket = true\n                    bracketCounts += ('>' -> 1)\n\
    \                } else if (nextChar == '<') {\n                    bracketCounts\
    \ += ('>' -> 1)\n                } else {\n                    bracketCounts +=\
    \ ('>' -> 1)\n                }\n            } else if (currentChar == '>') {\n\
    \                foundOpeningBracket = true\n                bracketCounts +=\
    \ ('>' -> 1)\n            } else if (currentChar == '<') {\n                foundOpeningBracket\
    \ = true\n                bracketCounts += ('>' -> 1)\n            } else if(currentChar\
    \ == '>') {\n                foundOpeningBracket = true\n                bracketCounts\
    \ += ('>' -> 1)\n            }\n        }\n        if(!foundOpeningBracket){\n\
    \            return false\n        }\n        var foundClosingBracket = false\n\
    \        for(i <- 0 to brackets.length-1){\n            val currentChar = brackets(i)\n\
    \            if(currentChar == '>') {\n                val nextChar = brackets(i+1)\n\
    \                if(nextChar == '<') {\n                    foundClosingBracket\
    \ = true\n                }\n            } else if (currentChar == '>') {\n  \
    \              foundClosingBracket = true\n            }\n        }\n        return\
    \ !foundClosingBracket", "        val openingBracket = brackets.substring(1)\n\
    \        val closingBracket = brackets.substring(0,1)\n        val newBrackets\
    \ = brackets.substring(1,brackets.length)\n        val newBracketList = (newBrackets\
    \ split \">>>\" map (x => x + \"<\" + x + \">\")).toList\n        val openBracketList\
    \ = (openingBracket split \">>>\" map (x => x + \"<\" + x + \">\")).toList\n \
    \       val openBracketSet = openBracketList.map(x => x.replace(\"<\",\"\").replace(\"\
    <\",\"\")).toSet\n        val openBracketListSet = openBracketList.map(x => x.replace(\"\
    <\",\"\").replace(\"<\",\"\")).toSet\n        val openBracketListSet2 = openBracketListSet.intersect(openBracketListSet)\n\
    \        val openBracketListSet3 = openBracketListSet.intersect(openBracketListSet2)\n\
    \        if(newBracketList.length == openBracketListSet.length){\n           \
    \ true\n        }else{\n            false\n        }", "        var isBracketCorrect\
    \ = false\n        for (bracket <- brackets.toList)\n        {\n            isBracketCorrect\
    \ = brackets.indexOf(bracket) != brackets.lastIndexOf(bracket) + 1 && isBracketCorrect\n\
    \        }\n        isBracketCorrect", "        val charSet = brackets.toSet\n\
    \        var foundOpeningBracket = false\n        brackets.foreach(charSet.contains(_))\
    \ {\n            if ((charSet - Set(\">\", \"<\", \"(\")).contains(_)) {\n   \
    \             foundOpeningBracket = true\n            }\n        }\n        return\
    \ foundOpeningBracket", "        brackets.contains(\"<\") && (brackets.contains(\"\
    <\")) ? true\n        :\n        brackets.contains(\">\") && (brackets.contains(\"\
    >\")) ? true\n        :\n        false", "        // find how many brackets we\
    \ have, i.e. count the opening and closing brackets.\n        var count = 0\n\
    \        var opening = 0\n        var closing = 0\n        // iterate through\
    \ the brackets.\n        for (c <- brackets) {\n            if (c == '<') {\n\
    \                count += 1\n            } else if (c == '>') {\n            \
    \    count -= 1\n            }\n            // if we have zero brackets we return\
    \ false.\n            if (count == 0) {\n                return false\n      \
    \      }\n            // if we have non-zero brackets we move on to the next bracket.\n\
    \            else {\n                opening += count\n                closing\
    \ += count\n            }\n        }\n        // return true if we have 0 opening\
    \ brackets\n        // and 0 closing brackets.\n        return opening == 0 &&\
    \ closing == 0", "        val bracketsSet = brackets.toSet\n        val opening\
    \ = brackets.split(\"[<>]\").map(x => x.toInt)\n        val closing = brackets.split(\"\
    [<>]\").map(x => x.toInt).map(x => Math.min(x, bracketsSet.size))\n        opening.zip(closing).forall\
    \ { case (left, right) => left <= right }", "        var closed = false\n    \
    \    brackets.toList foreach {\n            case \">\" =>\n                if\
    \ (!closed)\n                    closed = true\n                else\n       \
    \             closed = false\n            case \"<\" =>\n                if (closed)\n\
    \                    closed = false\n                else\n                  \
    \  closed = true\n            case _  => {}\n        }\n        closed", "   \
    \     var bracketStack = new Stack[Char]()\n        var bracketCount = 0\n   \
    \     for (i <- brackets) {\n            if (i == '<') {\n                if (bracketCount\
    \ > 0) {\n                    return false\n                }\n              \
    \  bracketStack.push(i)\n                bracketCount++\n            } else if\
    \ (i == '>') {\n                if (bracketCount == 0) {\n                   \
    \ return false\n                }\n                bracketStack.pop()\n      \
    \          bracketCount--\n            } else {\n                bracketStack.push(i)\n\
    \                bracketCount++\n            }\n        }\n        if (bracketStack.isEmpty)\
    \ {\n            return true\n        } else {\n            return false\n   \
    \     }", "        def unbalanced(str: String) : Boolean = { \n            //\
    \ \"<<<\"\n            if (str.charAt(0) != \"<\") false else { \n           \
    \     // \"<><>\"\n                if (str.charAt(1) != \"<\") false else { \n\
    \                    // \"<<>>\"\n                    if (str.charAt(2) != \"\
    <\") false else { \n                        // \"><<<\"\n                    \
    \    if (str.charAt(3) != \">\") false else { \n                            //\
    \ \">>>>\"\n                            if (str.charAt(4) != \">\") false else\
    \ { \n                                // \"<<<<\"\n                          \
    \      if (str.charAt(5) != \"!\") false else true\n                         \
    \   }\n                        }\n                    }\n                }\n \
    \           }\n        }\n        def balanced(str: String) : Boolean = { \n \
    \           // \"<<<\"\n            if (str.charAt(0) != \"<\") false else { \n\
    \                // \"<><>\"\n                if (str.charAt(1) != \"<\") false\
    \ else { \n                    // \"<<>>\"\n                    if (str.charAt(2)\
    \ != \"<\") false else { \n                        // \"><<<\"\n             \
    \           if (str.charAt(3) != \">\") false else { \n                      \
    \      // \">>>>\"\n                            if (str.charAt(4) != \">\") false\
    \ else { \n                                // \"<<<<\"\n                     \
    \           if (str.charAt(5) != \"!\") false else true\n                    \
    \        }\n                        }\n                    }\n               \
    \ }\n            }\n        }\n        val newList = brackets.split(\"\")\n  \
    \      val newList2 = newList.dropRight(1)\n        val newList3 = newList2.dropRight(1)\n\
    \        val newList4 = newList3.dropRight(1)\n        val newList5 = newList4.dropRight(1)\n\
    \        val newList6 = newList5.dropRight(1)\n        val newList7 = newList6.dropRight(1)\n\
    \        val newList8 = newList7.dropRight(1)\n        val newList9 = newList8.dropRight(1)\n\
    \        val newList10 = newList9.dropRight(1)\n        val newList11 = newList10.dropRight(1)\n\
    \        val newList12 = newList11.dropRight(1)\n        val newList13 = newList12.dropRight(1)\n\
    \        val newList14 = newList13.dropRight(1)\n        val newList15 = newList14.dropRight(1)\n\
    \        val newList16 = newList15.dropRight(1)\n        val newList17 = newList16.dropRight(1)\n\
    \        val newList18 = newList17.dropRight(1)\n        val newList19 = newList18.dropRight(1)\n\
    \        val newList20 = newList19.dropRight(1)\n        val newList21 = newList20.dropRight(1)\n\
    \        val newList22 = newList21.dropRight(1)\n", "        var leftCount : Int\
    \ = 0\n        var rightCount : Int = 0\n        var currentBracket : String =\
    \ \"\"\n        var isRight : Boolean = false\n        for (crust <- brackets)\
    \ {\n            if (cru == \"<\")\n                leftCount += 1\n         \
    \   else {\n                currentBracket = cru\n                isRight = cru\
    \ == \">\"\n                rightCount += 1\n            }\n        }\n      \
    \  isRight == (leftCount > rightCount)", "        val stack = mutable.Stack[String]()\n\
    \        val result = new StringBuilder\n\n        val lastChar = brackets.last\n\
    \n        for(c <- brackets){\n            c match {\n                case \"\
    >\" => stack.push(c)\n                case lastChar =>\n                    val\
    \ popped = stack.pop()\n                    if(popped == lastChar)\n         \
    \               return false\n                    else\n                     \
    \   result.append((popped))\n            }\n        }\n\n        result != null",
  "        if (brackets.length < 2) return false\n        val count = brackets.split('\
    \ ').length\n        var openCount : Int = 0\n        var closeCount : Int = 0\n\
    \        for (b <- brackets.split(' ')) {\n            if (b == '<') {\n     \
    \           if (openCount == 0) return false\n                openCount--\n  \
    \          } else if (b == '>') {\n                if (closeCount == 0) return\
    \ false\n                closeCount++\n            } else if (b == \">\") {\n\
    \                if (closeCount == 0) return false\n                closeCount--\n\
    \            } else if (b == \"<\") {\n                if (openCount == 0) return\
    \ false\n                openCount++\n            }\n        }\n        return\
    \ closeCount == 0 && openCount == count", "        if (brackets.isEmpty) true\n\
    \        else {\n            def matchBracket(bracket: String): Boolean = brackets.indexOf(bracket)\
    \ != -1\n\n            def findFirstOpening(index: Int, brackets: Array[String]):\
    \ Int = {\n                index until brackets.indexOf('>', index) match {\n\
    \                    case 0 => -1\n                    case i if matchBracket(brackets(i))\
    \ => i\n                    case i =>\n                        val j = findFirstOpening(i,\
    \ brackets)\n                        if (j != -1) j else i\n                }\n\
    \            }\n            val openingIndex = findFirstOpening(0, brackets.split('>').toArray)\n\
    \            brackets.indexOf('<', openingIndex) match {\n                case\
    \ -1 => true\n                case index =>\n                    brackets.indexOf('<',\
    \ index) match {\n                        case -1 => false\n                 \
    \       case i if matchBracket(brackets(i)) => true\n                        case\
    \ i =>\n                            val j = findFirstOpening(i, brackets)\n  \
    \                          if (j != -1) true else false\n                    }\n\
    \            }\n        }", "        brackets flatMap (c => if (c == '<') Some('>')\
    \ else Some('<')) forall { c =>\n            brackets.indexOf(c) == brackets.lastIndexOf(c)\n\
    \        }", "        val stack = new Stack[String]\n        val inParenthesisCount\
    \ = 0\n        for (char <- brackets.toCharArray) {\n            if (char == '<')\
    \ {\n                stack.push(\"<\")\n            } else if (char == '>') {\n\
    \                if (inParenthesisCount > 0) {\n                    inParenthesisCount\
    \ -= 1\n                } else {\n                    stack.pop()\n          \
    \      }\n            } else if (char == '(') {\n                inParenthesisCount\
    \ += 1\n            } else if (char == ')') {\n                if (inParenthesisCount\
    \ > 0) {\n                    inParenthesisCount -= 1\n                } else\
    \ {\n                    stack.pop()\n                }\n            }\n     \
    \   }\n        stack.isEmpty", "        // for each character in the brackets\
    \ string,\n        // check if the character is \"<\"\n        for(c <- brackets){\n\
    \            if(!(c == \"<\"))\n                return false\n        }\n    \
    \    // for each character in the brackets string,\n        // check if the character\
    \ is \">\"\n        for(c <- brackets){\n            if(c == \">\")\n        \
    \        return true\n        }\n        // if no brackets are closed, then the\
    \ brackets are open for all characters\n        return true", "        // if brackets\
    \ is empty, return true.\n        if (!brackets.length) return true\n        val\
    \ opening = brackets.substring(0,brackets.indexOf('>'))\n        val closing =\
    \ brackets.substring(brackets.indexOf('>')+1)\n        // remove duplicate opening\
    \ brackets, if any.\n        var openingList = new mutable.LinkedList[Int]()\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=opening.indexOf('>')\n        openingList+=opening.indexOf('>')\n\
    \        openingList+=", "        brackets match {\n            case \"<>\" =>\
    \ true\n            case \">>\" => false\n            case \"<<\" => false\n \
    \           case \">>>\" => true\n            case x => false\n        }", " \
    \       if (brackets.isEmpty) return false\n        val opening = brackets.split(\"\
    <\")\n        val closing = brackets.split(\">\")\n        val matchedBrackets\
    \ = opening ++ closing\n        val openingBracketSet = Set(brackets)\n      \
    \  val closingBracketSet = Set(brackets)\n        val matchedBracketsCount = matchedBrackets.length\n\
    \        if (openingBracketSet.size == 0 || closingBracketSet.size == 0 || matchedBracketsCount\
    \ == openingBracketSet.size && matchedBracketsCount == closingBracketSet.size)\
    \ return false\n        for (bracket <- opening ++ closing) {\n            val\
    \ pair = bracket.split(\"<->\")\n            if (pair.length == 1) return false\n\
    \            if (pair(0) != pair(1)) return false\n            if (openingBracketSet.add(bracket))\
    \ {\n                val newBrackets = openingBracketSet.toSet\n             \
    \   if (newBrackets.remove(pair(0))) {\n                    closingBracketSet.remove(pair(0))\n\
    \                    newBrackets.add(pair(0))\n                    correctBracketing(newBrackets.toString\
    \ + \"<->\" + closingBracketSet.toSet)\n                }\n            }\n   \
    \     }\n        return true", "        val opening = brackets.split(\"<\").map(_.remove(0)).toSet\n\
    \        val closing = brackets.split(\">\").map(_.remove(0)).toSet\n        val\
    \ missingClosing = closing - opening\n        val missingOpening = opening - closing\n\
    \        missingClosing.isEmpty  && missingOpening.isEmpty", "        brackets.foldLeft[Boolean](true)(\
    \ (acc, next) =>\n        acc && next.equals(brackets(acc.length-1)) )", "   \
    \     val bracketsLength = brackets.length\n        val pairMap = new mutable.HashMap[Char,\
    \ Char]()\n        for (i <- 0 to bracketsLength-1) {\n            val c = brackets(i)\n\
    \            val p = if (i==0) \"(\" else \")\"\n            if (c == '<') {\n\
    \                if (!pairMap.contains(c)) {\n                    pairMap(c) =\
    \ p\n                } else {\n                    return false\n            \
    \    }\n            }\n            if (c == '>') {\n                if (pairMap.contains(c))\
    \ {\n                    return false\n                } else {\n            \
    \        pairMap(c) = p\n                }\n            }\n        }\n       \
    \ return pairMap.size == bracketsLength", "        if(brackets.length % 2 != 0)\
    \ return false\n        brackets.sliding(2).forall(_.length == 1) && brackets.drop(brackets.length\
    \ / 2).forall(_.length == 2)", "      var found = false\n      brackets.split(\"\
    \").foreach { c =>\n        if(c >= \"<\" && c <= \">\") {\n          found =\
    \ true\n        }\n      }\n      found", "        val pairs = brackets.toList\n\
    \        val openings = pairs.map(_.toLowerCase)\n        val closings = pairs.map(_.toUpperCase)\n\
    \        if (openings.isEmpty) false\n        else if (closings.isEmpty) true\n\
    \        else openings.head == closings.head && openings.tail == closings.tail",
  "        val openingBrackets = brackets.split(\"<\").map(_ => \"<\")\n        val\
    \ closingBrackets = brackets.split(\">\").map(_ => \">\")\n        val result\
    \ = openingBrackets.zip(closingBrackets).forall {\n            case ((open, close),\
    \ true) => close.equals(open)\n            case _ => false\n        }\n      \
    \  result", "        val brackets = brackets.toList\n        val openingBrackets\
    \ : List[String] = brackets.filter(x => x == '<').toList\n        val closingBrackets\
    \ : List[String] = brackets.filter(x => x == '>').toList\n        val matchingBrackets\
    \ : List[String] = openingBrackets.filter(x => closingBrackets.contains(x)).filter(x\
    \ => !openingBrackets.contains(x)).distinct\n        matchingBrackets.isEmpty",
  "        val count = new mutable.HashMap[String, Int]()\n        brackets.toList.reverse.foreach\
    \ { b =>\n            val c = counts.get(b); counts.put(b, c+1); c\n        }\n\
    \        count.values.toList.forall(_ == 0)", "        def isOpeningBracket(brackets\
    \ : String) : Boolean = {\n            brackets.charAt(0) match {\n          \
    \      case '<' => true\n                case _ => false\n            }\n    \
    \    }\n        def isClosingBracket(brackets : String) : Boolean = {\n      \
    \      brackets.charAt(brackets.length - 1) match {\n                case '>'\
    \ => true\n                case _ => false\n            }\n        }\n       \
    \ def isAllOpeningBracketsClosedOrNotCorrect(brackets : String) : Boolean = {\n\
    \            (isOpeningBracket(brackets) && isClosingBracket(brackets)) || isAllOpeningBracketsClosed(brackets)\n\
    \        }\n        def isAllOpeningBracketsClosed(brackets : String) : Boolean\
    \ = {\n            if (isOpeningBracket(brackets)) {\n                isClosingBracket(brackets)\
    \ && isAllOpeningBracketsClosedOrNotCorrect(brackets.substring(0, brackets.length\
    \ - 1))\n            } else {\n                isAllOpeningBracketsClosedOrNotCorrect(brackets.substring(0,\
    \ brackets.length - 1))\n            }\n        }\n        val allOpeningBracketsClosed\
    \ = isAllOpeningBracketsClosed(brackets)\n        allOpeningBracketsClosed", " \
    \       val closed = brackets.substring(0,brackets.length-1)\n        var closed\
    \ = closed.toUpperCase\n        var opened = brackets.substring(1,brackets.length)\n\
    \        var opened = (opened).toUpperCase\n        return !(opened.contains(closed))",
  "        def isBracket(x : String) : Boolean = {\n            x match {\n      \
    \          case \"<\" => true\n                case \">\" => true\n          \
    \      case \">>\" => true\n                case \"><<\" => true\n           \
    \     case \"<<\" => true\n                case _ => false\n            }\n  \
    \      }\n        val bracketArray = brackets.toArray\n        var isOpen = false\n\
    \        var isClose = false\n        var open = 0\n        var close = 0\n  \
    \      var match = 0\n        var i = 0\n        for(x <- bracketArray) {\n  \
    \          i += 1\n            if(isBracket(x)) {\n                if(isOpen)\
    \ {\n                    open += 1\n                    if(open > close) {\n \
    \                       isOpen = false\n                        isClose = true\n\
    \                    }\n                } else {\n                    close +=\
    \ 1\n                    if(open > close) {\n                        isOpen =\
    \ true\n                        isClose = false\n                    }\n     \
    \           }\n                match += 1\n            } else {\n            \
    \    match += 1\n            }\n        }\n        if(open > close) {\n      \
    \      true\n        } else {\n            false\n        }", "        val bracketsArray\
    \ = brackets.toCharArray\n        val leftCounts = mutable.Map.empty[Char, Int]\n\
    \        val rightCounts = mutable.Map.empty[Char, Int]\n        bracketsArray.foreach\
    \ { c =>\n            // if left count for this char is zero, increment and set\
    \ new left count\n            if (leftCounts.contains(c)) {\n                leftCounts(c)\
    \ += 1\n            } else {\n                // if left count is not zero, decrement\
    \ it by 1 and set new left count\n                leftCounts += (c -> leftCounts(c)\
    \ - 1)\n            }\n            // if right count for this char is zero, increment\
    \ and set new right count\n            if (rightCounts.contains(c)) {\n      \
    \          rightCounts(c) += 1\n            } else {\n                // if right\
    \ count is not zero, decrement it by 1 and set new right count\n             \
    \   rightCounts += (c -> rightCounts(c) - 1)\n            }\n        }\n\n   \
    \     // the brackets must match\n        (leftCounts.size == bracketsArray.length)\
    \ && (rightCounts.size == bracketsArray.length)", "        val len = brackets.length\n\
    \        if(len == 0)\n            return true\n        val stack = mutable.Stack[Int]()\n\
    \        // for every opening bracket, append its position to the stack\n    \
    \    // until we reach the closing bracket.\n        for(i <- 0 until len) {\n\
    \            val c = brackets(i)\n            if(c == '<')\n                stack\
    \ += i\n            else if(c == '>')\n                while(stack.nonEmpty &&\
    \ stack.head != i) {\n                    val toppos = stack.head\n          \
    \          stack.remove()\n                    if(stack.toString.equals(s\"${toppos}>\"\
    ))\n                        return false\n                }\n        }\n     \
    \   return true", "        val bracketsChars = brackets.toCharArray\n        val\
    \ bracketsLen = brackets.length\n\n        // a map from opening bracket to closing\
    \ bracket position\n        val openingBracketPositions = mutable.Map(brackets.head.asInstanceOf[Int])\n\
    \        for(i <- 1 to bracketsLen-1) {\n            val bracket = brackets(i).asInstanceOf[Char]\n\
    \            if(!openingBracketPositions.contains(bracket)) {\n              \
    \  openingBracketPositions += (bracket.asInstanceOf[Int])\n            }\n   \
    \     }\n\n        // a map from closing bracket to opening bracket position\n\
    \        val closingBracketPositions = mutable.Map(0 -> -1)\n        for(i <-\
    \ 1 to bracketsLen-1) {\n            val bracket = brackets(i).asInstanceOf[Char]\n\
    \            if(!closingBracketPositions.contains(bracket)) {\n              \
    \  closingBracketPositions += (bracket.asInstanceOf[Int])\n            }\n   \
    \     }\n\n        // return true if every opening bracket has a corresponding\
    \ closing bracket\n        for(i <- 0 to bracketsLen-1) {\n            val bracket\
    \ = brackets(i).asInstanceOf[Char]\n            if(!openingBracketPositions.contains(bracket))\
    \ {\n                return false\n            }\n            if(!closingBracketPositions.contains(bracket))\
    \ {\n                return false\n            }\n        }\n\n        return\
    \ true", "        // This could use some optimization, but it's not worth it.\n\
    \        var brackets = brackets\n        while (brackets.length() > 1) {\n  \
    \          val openingBracket = brackets.charAt(0)\n            if (closingBracket(openingBracket))\
    \ {\n                brackets = brackets.substring(1)\n            } else {\n\
    \                return false\n            }\n        }\n        brackets.length()\
    \ == 1", "        val bracketList = new mutable.ListBuffer[String]()\n       \
    \ for (i <- brackets.length) bracketList += brackets.charAt(i)\n\n        val\
    \ unmatchedBrackets = bracketList.filterNot(bracket => bracket.equals(\"<\"))\n\
    \        val matchedBrackets = bracketList.filter(bracket => bracket.equals(\"\
    <\"))\n        unmatchedBrackets.forall(unmatchedBracket => {\n            matchedBrackets.contains(unmatchedBracket)\n\
    \        })", "        var i = 0\n        while (i < brackets.length) {\n    \
    \        if (brackets(i) === \"<\") {\n                if (brackets(i+1) === \"\
    <\") {\n                    if (brackets(i+2) === \"<\") {\n                 \
    \       if (brackets(i+3) === \"<\") {\n                            if (brackets(i+4)\
    \ === \"<\") {\n                                return false\n               \
    \             }\n                        }\n                    }\n          \
    \      }\n            }\n            i += 1\n        }\n        true", "     \
    \   // split the string into separate <> pairs\n        val pairs = brackets.split(\"\
    <\").map(_.trim)\n        val opens = pairs.map(_.indexOf(\"<\"))\n        val\
    \ closes = pairs.map(_.indexOf(\">\"))\n        val allOpens = opens.sum\n   \
    \     val allCloses = closes.sum\n\n        if (allOpens == allCloses)\n     \
    \       true\n        else\n            false", "        val brackets = brackets.split(\"\
    \")\n        val stack = new mutable.Stack[String]()\n        for ((bracket, index)\
    \ <- brackets.zipWithIndex) {\n            stack += bracket\n            if (stack.last.equals(bracket))\
    \ {\n                stack -= bracket\n            }\n            if (stack.size\
    \ == 0 && !stack.isEmpty) {\n                return false\n            }\n   \
    \     }\n        stack.size == 0", "        def hasBracket(brackets : String)\
    \ : Boolean = brackets.indexOf(brackets.head) < brackets.lastIndexOf(brackets.last)\n\
    \        val openingBrackets = brackets.substring(1,brackets.length-1)\n     \
    \   val closingBrackets = brackets.substring(0,1)\n        openingBrackets.contains(\"\
    <\") && hasBracket(openingBrackets) && hasBracket(closingBrackets)", "       \
    \ val isBracket = brackets.toSet.toList.foldLeft(true) {\n            case (true,\
    \ bracket) =>\n                bracket.charAt(0) == \">\" &&\n               \
    \ bracket.charAt(bracket.length-1) == \"<\"\n            case (false, bracket)\
    \ =>\n                bracket.length == 1 && bracket.charAt(0) == \">\"\n    \
    \    }\n        isBracket", "        brackets match {\n            case \">\"\
    \ :: \">\" => false\n            case \">>\" :: \">>\" => true\n            case\
    \ \">\" :: \">>\" :: \">\" :: \">\" :: \">>\" :: \">>\" :: \">>\" :: \">\" ::\
    \ \">\" :: \">>\" :: \">\" :: \">>\" :: \">\" :: \">>\" :: \">\" :: \">>\" ::\
    \ \">\" :: \">>\" => false\n            case _ => true\n        }", "        val\
    \ bracketings = mutable.ListBuffer[Boolean]()\n        for (x <- brackets) {\n\
    \            if (bracketings.contains(x)) {\n                false\n         \
    \   } else {\n                bracketings += false\n            }\n        }\n\
    \        true", "        var opening = 0\n        var closing = 0\n        var\
    \ charCount = 0\n        brackets.toList match {\n            case _ if brackets.length\
    \ == 1 => true\n            case x :: _ => {\n                charCount = x.length\
    \ // charCount doesn't reset for subsequent chars because charCount is reused\
    \ for each char in the string.\n                opening = x.indexOf('(')\n   \
    \             closing = x.lastIndexOf(')')\n                x match {\n      \
    \              case x if opening>closing => true\n                    case _ =>\
    \ false\n                }\n            }\n        }", "        val closed = brackets.grouped(2).toList\n\
    \        val open = brackets.grouped(1).toList\n        open match {\n       \
    \     case Nil => true\n            case x :: Nil => false\n            case x\
    \ :: y => x == y.head\n        }", "        var openingBracketsCount : Int = brackets.length\n\
    \        var openingBrackets : List[String] = Nil\n        while (openingBracketsCount\
    \ > 0) {\n            openingBrackets = brackets.substring(0,openingBracketsCount).split(\"\
    <\")\n            if (openingBrackets.nonEmpty) {\n                var closingBracketsCount\
    \ : Int = openingBrackets.length\n                var closingBrackets : List[String]\
    \ = Nil\n                while (closingBracketsCount > 0) {\n                \
    \    closingBrackets = brackets.substring(closingBracketsCount,brackets.length).split(\"\
    >\")\n                    if (closingBrackets.nonEmpty) {\n                  \
    \      closingBracketsCount -= 1\n                    }\n                }\n \
    \               openingBracketsCount -= 1\n            }\n        }\n        if\
    \ (openingBrackets.isEmpty) {\n            true\n        } else {\n          \
    \  false\n        }", "        val bracketsCount = brackets.length\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = new mutable.Queue[String]()\n\
    \        val chars = brackets.toCharArray()\n        for (i <- 0 until chars.length)\n\
    \            if (chars(i) == '<')\n                stack += chars(i)\n       \
    \     if (chars(i) == '>')\n                if (stack.isEmpty) false else stack.pop\n\
    \                else {\n                    val next = queue.dequeue\n      \
    \              if (next == \">\")\n                        stack.pop()\n     \
    \               else {\n                        stack += next\n              \
    \          queue.append(next)\n                    }\n                }\n    \
    \    !stack.isEmpty", "        // create mutable list of bracket pairs (as tuples)\n\
    \        var bracketPairs = mutable.ListBuffer[(String,String)]()\n        //\
    \ iterate through brackets\n        for (char <- brackets) {\n            // if\
    \ char is '<', add tuple (\">\",char) to list\n            if (char == '<') {\n\
    \                bracketPairs += (\">\",char)\n            // else if char is\
    \ '>', add tuple (\"<\",char) to list\n            } else if (char == '>') {\n\
    \                bracketPairs += (\"<\",char)\n            // else if char is\
    \ '<', add tuple (\">\",char) to list\n            } else if (char == '<') {\n\
    \                bracketPairs += (\">\",char)\n            // else if char is\
    \ '>', add tuple (\"<\",char) to list\n            } else if (char == '>') {\n\
    \                bracketPairs += (\"<\",char)\n            // else add char to\
    \ list\n            } else {\n                bracketPairs += (char)\n       \
    \     }\n        }\n        // iterate through each tuple in list\n        for\
    \ (pair <- bracketPairs) {\n            // for each tuple in list, add 1 to length\
    \ of tuple\n            var tupleLength = pair._2.length\n            var newLength\
    \ = tupleLength + 1 \n            // remove '<' from end of string with length\
    \ of tuple\n            var newString = pair._1.substring(0,newLength)\n     \
    \       // if new string is not equal to old string, return false\n          \
    \  if (newString != pair._1) {\n                return false\n            }\n\
    \        }\n        // return true if list has at least one tuple\n        bracketPairs.length\
    \ > 0", "        val s = brackets.toList\n        val m = s.length\n        for(\
    \ i <- 0 until m ) {\n            if( s(i) != s(i).reverse ) {\n             \
    \   return false\n            }\n        }\n        true", "        for (a <-\
    \ brackets) yield {\n            for (b <- brackets) yield {\n               \
    \ if (a == b) false\n                else {\n                    val c = (a +\
    \ b).toChar\n                    val d = (b + a).toChar\n                    if\
    \ (c.isLetter) c.toUpper == d.toUpper\n                    else c.toLower == d.toLower\n\
    \                }\n            }\n        }", "        var closed = false\n \
    \       var opened = false\n        var openCount = 1\n        var closeCount\
    \ = 0\n        for (x <- brackets) {\n            if (x == \"<\") {\n        \
    \        if (!opened)\n                    opened = true\n                else\n\
    \                    openCount += 1\n            } else if (x == \">\") {\n  \
    \              if (!closed)\n                    closed = true\n             \
    \   else\n                    closeCount += 1\n            } else if (openCount\
    \ != closeCount) {\n                return false\n            }\n        }\n \
    \       if (opened == false && closed == false)\n            return true\n   \
    \     else\n            return false", "        val stack = new mutable.Stack[String]\n\
    \        brackets.toList.foreach { c =>\n            if(c == '<') {\n        \
    \        stack.push(c)\n            }\n            else if (c == '>') {\n    \
    \            if(stack.isEmpty) {\n                    stack.length = 0\n     \
    \               false\n                } else {\n                    if(!stack.pop.equals(\"\
    <\")) {\n                        false\n                    } else {\n       \
    \                 true\n                    }\n                }\n           \
    \ }\n        }\n        stack.length == 0", "        def countBrackets(s: String)\
    \ : Int = s.count(_ == '<') + s.count(_ == '>')\n        (s.length != brackets.length)\
    \ || countBrackets(brackets) == brackets.length", "        // We will count the\
    \ number of opening brackets we encounter.\n        var openingCount = 0\n   \
    \     // We will count the number of closing brackets we encounter.\n        var\
    \ closingCount = 0\n        // We will increment by one each time we see a new\
    \ opening bracket.\n        var count = 1\n        // We will keep track of whether\
    \ we encounter an opening bracket or not.\n        var bracketsEncountered = false\n\
    \        // We will keep track of whether we encounter a closing bracket or not.\n\
    \        var bracketsEncounteredClosing = false\n\n        // Iterate through\
    \ the brackets.\n        for (c <- brackets) {\n            // If the character\
    \ c is a closing bracket, check if we have encountered another closing bracket\
    \ before\n            // incrementing the count by 1. If we have, we have encountered\
    \ a matching pair of brackets. \n            if (c == \">\") {\n             \
    \   bracketsEncountered = true\n                bracketsEncounteredClosing = true\n\
    \            } else if (c == \"<\") {\n                bracketsEncounteredClosing\
    \ = true\n            }\n            // If we encountered the closing bracket,\
    \ we are no longer looking at an opening bracket.\n            if (bracketsEncounteredClosing\
    \ && count != 1) {\n                bracketsEncountered = false\n            \
    \    closingCount += 1\n            }\n            // If we encountered the opening\
    \ bracket, check if we have encountered another opening bracket before\n     \
    \       // incrementing the count by one. If we have, we have encountered a matching\
    \ pair of brackets.\n            if (c == \"<\") {\n                bracketsEncountered\
    \ = true\n                openingCount += 1\n            } else if (c == \">\"\
    ) {\n                openingCount += 1\n            }\n            // If we encountered\
    \ another opening bracket, we are no longer looking at an closing bracket.\n \
    \           if (bracketsEncountered && count != 1) {\n                bracketsEncountered\
    \ = false\n                closingCount += 1\n            }\n            count\
    \ += 1\n        }\n        // We have encountered all closing brackets we need.\n\
    \        if (openingCount == closingCount) {\n            // We have enclosed\
    \ the entire string with brackets.\n            return true\n        } else {\n\
    \            // We did not enclose the entire string with brackets.\n        \
    \    return false\n        }", "        var stack : List[(Char,Int)] = Nil\n \
    \       for (i <- 0 until brackets.length)\n            if (brackets(i) == \"\
    >\") {\n                stack:::+= ('<', brackets(i).length)\n            } else\
    \ if (brackets(i) == \"<\") {\n                if (stack.isEmpty)\n          \
    \          stack:::+= ('<', brackets(i).length)\n                else {\n    \
    \                stack:::+= (stack.pop(), brackets(i).length)\n              \
    \  }\n            } else stack:::+= (brackets(i), 1)\n        (stack.isEmpty) ",
  "        val openings = brackets.split(\"<\").map(_.trim)\n        val closings\
    \ = brackets.split(\">\").map(_.trim)\n        val openingSet = Set(openings.mkString)\n\
    \        val closingSet = Set(closings.mkString)\n        openingSet.subsetOf(closingSet)",
  "        val bracketMap = {\n            val map = scala.collection.mutable.HashMap[Int,\
    \ String]()\n            for ((i,s) <- brackets.split(\"\").zipWithIndex) map\
    \ += i -> s\n            map\n        }\n        val open = bracketMap.filter(_._2\
    \ != \">\").toSeq\n        val close = bracketMap.filter(_._2 == \">\").toSeq\n\
    \        // check whether opening and closing brackets are the same\n        val\
    \ same = open == close\n        if (same.nonEmpty) same.head else false", "  \
    \      if (brackets.length != 2)\n            return false\n        val openingBrackets\
    \ = brackets.split(\"<\").map(_.toDouble).toSet\n        val closingBrackets =\
    \ brackets.split(\">\").map(_.toDouble).toSet\n        openingBrackets.subsetOf(closingBrackets)",
  '        brackets.takeWhile(c => c != ">").forall(c => brackets.takeWhile(c => c
    != "<").forall(c => c == ">"))', '        brackets.split("<").toSet == brackets.split("<").filterNot(x
    => x == ">").toSet', "      var openingBrackets : Int = 0\n      var closingBrackets\
    \ : Int = 0\n      brackets.foreach{ c =>\n          if (c == \"<\") {\n     \
    \         openingBrackets += 1\n          }\n          if (c == \">\") {\n   \
    \           closingBrackets += 1\n          }\n      }\n      return openingBrackets\
    \ == closingBrackets", "        var opening = brackets.toLowerCase().reverse\n\
    \        val openingSet = Set(opening)\n        val closing = opening.reverse\n\
    \        val closingSet = Set(closing)\n        var inCorrect = true\n       \
    \ for (x <- opening) {\n            if (!openingSet.contains(x)) inCorrect = false\n\
    \        }\n        if (!inCorrect) false\n        else {\n            var inCorrect\
    \ = true\n            for (x <- closing) {\n                if (!closingSet.contains(x))\
    \ inCorrect = false\n            }\n            if (!inCorrect) false\n      \
    \      else {\n                val openingArray = opening.toArray\n          \
    \      var inCorrect = true\n                for (x <- closing) {\n          \
    \          if (!openingArray.contains(x)) inCorrect = false\n                }\n\
    \                if (!inCorrect) false\n                else {\n             \
    \       val closingArray = closing.toArray\n                    var inCorrect\
    \ = true\n                    for (x <- opening) {\n                        if\
    \ (!closingArray.contains(x)) inCorrect = false\n                    }\n     \
    \               if (!inCorrect) false\n                    else {\n          \
    \              val openingArray = opening.toArray\n                        var\
    \ inCorrect = true\n                        for (x <- closing) {\n           \
    \                 if (!openingArray.contains(x)) inCorrect = false\n         \
    \               }\n                        if (!inCorrect) false\n           \
    \             else {\n                            val closingArray = closing.toArray\n\
    \                            var inCorrect = true\n                          \
    \  for (x <- opening) {\n                                if (!closingArray.contains(x))\
    \ inCorrect = false\n                            }\n                         \
    \   if (!inCorrect) false\n                            else true\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }", "        val openingBrackets = brackets.split(\"\\\\(\").toList\n  \
    \      val closingBrackets = brackets.split(\"\\\\)\").toList\n        openingBrackets.isEmpty\n\
    \            || closingBrackets.isEmpty\n            || openingBrackets.size ==\
    \ closingBrackets.size\n            || openingBrackets.lastOption.isEmpty", " \
    \       val openingBracketCountMap = brackets.toSet.toMap[Char,Int]()\n      \
    \  val openingBracketCount : Int = openingBracketCountMap(\"(\")\n        if (openingBracketCount\
    \ == 0) true else openingBracketCountMap(\")\") > openingBracketCount", "    \
    \    val openings = brackets.split('<').map(_.toInt)\n        val closings = brackets.split('>').map(_.toInt)\n\
    \        val numOpenings = openings.length\n        val numClosings = closings.length\n\
    \        openings.zipWithIndex foreach {\n            case (open, openIndex) =>\n\
    \                if (numClosings - openIndex != 0) false\n            case _ =>\n\
    \                false\n        }\n        closings.zipWithIndex foreach {\n \
    \           case (close, closeIndex) =>\n                if (numOpenings - closeIndex\
    \ != 0) false\n            case _ =>\n                false\n        }\n     \
    \   true", "        // Initialize a Stack of size 1.\n        val stack = Stack(List())\n\
    \        // Iterate over all brackets one at a time.\n        for (i <- 0 until\
    \ brackets.length -1) {\n            // Check if the current bracket is the closing\
    \ bracket of the previous bracket.\n            if (brackets(i) == brackets(i+1))\
    \ {\n                // If the current bracket is the closing bracket of the previous\
    \ bracket, then push the current bracket\n                // onto the stack and\
    \ remove it. This will yield a new stack that will contain the current bracket\n\
    \                // when the loop is finished.\n                stack.push(brackets(i))\n\
    \                stack.pop()\n            } else {\n                // If the\
    \ current bracket is not the closing bracket of the previous bracket, then return\
    \ false.\n                // This can occur when, for example, only one opening\
    \ bracket is provided.\n                return false\n            }\n        }\n\
    \        // If the stack is empty, return true.\n        if (stack.size == 0)\
    \ return true\n        // Otherwise, the stack is not empty, and there are no\
    \ correct brackets, so return false.\n        return false", "        val stack\
    \ = mutable.Stack[Int]()\n        var opening = true\n        var open = 0\n \
    \       var closing = 0\n        var last: Char = ' ' // last char\n        var\
    \ lastOpening = true // last opening bracket\n        var lastClosing = true //\
    \ last closing bracket\n        var lastOpen = 0\n        var lastClosing = 0\n\
    \        var found = false\n        for (i <- 0 until brackets.length) lastOpening\
    \ = (brackets(i) equals \">\")\n        for (i <- 0 until brackets.length) lastClosing\
    \ = (brackets(i) equals \"<\")\n        for (i <- 0 until brackets.length)\n \
    \       {\n            last = brackets(i)\n            if (lastOpening)\n    \
    \        {\n                if (lastClosing && stack.size() > 0)\n           \
    \     {\n                    // current closing bracket has a previous opening\
    \ bracket.\n                    val top = stack.pop()\n                    val\
    \ next = stack.pop()\n                    // if the stack is empty this means\
    \ the two closing brackets are the opening.\n                    if (top == 0)\n\
    \                    {\n                        opening = false\n            \
    \        }\n                    else\n                    {\n                \
    \        // the closing bracket has a previous opening bracket.\n            \
    \            if (top != next)\n                        {\n                   \
    \         opening = false\n                        }\n                    }\n\
    \                }\n                else\n                {\n                \
    \    // current opening bracket has a previous closing bracket.\n            \
    \        if (stack.size() > 0)\n                    {\n                      \
    \  val top = stack.pop()\n                        if (top == 0)\n            \
    \            {\n                            opening = false\n                \
    \        }\n                    }\n                    else\n                \
    \    {\n                        // the opening bracket has a previous closing\
    \ bracket.\n                        // if there are no more opening brackets then\
    \ this is correct.\n                        opening = false\n                \
    \    }\n                }\n            }\n            else\n            {\n  \
    \              // current closing bracket has a previous opening bracket.\n  \
    \              // if there are more closing brackets then this is incorrect.\n\
    \                opening = false\n            }\n            open += 1\n     \
    \       if (!lastOpening && opening)\n            {\n                open -= 1\n\
    \            }\n            stack.push(open)\n        }\n        return opening",
  "        var openBracket = 0\n        var closeBracket = 0\n        brackets match\
    \ {\n            case \">\" => closeBracket = 1\n            case \"<\" => openBracket\
    \ = 1\n            case _ => return true\n        }\n        brackets.chars.toList.count(_\
    \ == '>') != brackets.chars.toList.count(_ == '<')", "        var bracketsCount\
    \ = brackets.length\n        for (i <- 0 to bracketsCount - 1 by -1) {\n     \
    \       val openingBracket = brackets(i)\n            val closingBracket = brackets(i\
    \ + 1)\n            if (openingBracket == \">\" && closingBracket == \"<\") {\n\
    \                bracketsCount -= 1\n            } else if (openingBracket ==\
    \ \"<\" && closingBracket == \"<\") {\n                bracketsCount -= 1\n  \
    \          } else if (openingBracket == \"<\" && closingBracket == \">\") {\n\
    \                bracketsCount -= 1\n            } else {\n                return\
    \ false\n            }\n        }\n        return bracketsCount == 0", "     \
    \ var closed = false\n      brackets.split(\"<\").foreach(x => {\n        if(x.matches(\"\
    ^[0-9a-zA-Z]+$\")) closed = true\n        else closed = false\n      })\n    \
    \  closed", "        var openingBrackets = \"\"\n        var closingBrackets =\
    \ \"\"\n        for {\n            opening <- brackets.indexOf(\"<\") + 1\n  \
    \          closing <- brackets.indexOf(\">\", opening)\n        } yield {\n  \
    \          openingBrackets = openingBrackets + brackets.substring(opening, closing)\n\
    \            if (brackets.substring(opening, closing).equals(\"<\")) {\n     \
    \           openingBrackets = openingBrackets + \"<\"\n            }\n       \
    \     if (brackets.substring(opening, closing).equals(\">\")) {\n            \
    \    openingBrackets = openingBrackets + \">\"\n            }\n        }\n   \
    \     openingBrackets.equals(closingBrackets)", "        def scan(brackets : String,\
    \ state : Set[String], count : Int, i : Int) : Boolean = {\n            if (i\
    \ < brackets.length)\n                if (\"(\"==brackets(i))\n              \
    \      state.toSet.add(brackets(i))\n                else if (\")\"==brackets(i))\n\
    \                    if (!state.contains(brackets(i)))\n                     \
    \   return false\n                    else \n                        state.toSet.remove(brackets(i))\n\
    \                else\n                    scan(brackets, state, count+1, i)\n\
    \            else\n                count > 0\n        }\n        scan(brackets,\
    \ Set(), 0, 0)", "        brackets.zip(brackets.dropRight(1)).forall {\n     \
    \       case(a, b) => a != b\n        }", "        var open : Boolean = true\n\
    \        var closed : Boolean = false\n        var stack : List[Char] = List(brackets.charAt(0))\n\
    \        while(open && closed && stack.length > 0) {\n            open =\n   \
    \             stack.head == '<'\n            closed =\n                stack.head\
    \ == '>'\n            stack = stack.tail\n        }\n        open == closed",
  "        val openBrackets = brackets.split(\"<\").length\n        val closeBrackets\
    \ = brackets.split(\">\").length\n        openBrackets == closeBrackets", "  \
    \      val opening = brackets.split(\"<\").map(_.toInt)\n        val closing =\
    \ brackets.split(\">\").map(_.toInt)\n        val pairs = mutable.ListBuffer[String]()\n\
    \        for (i <- opening.length; i <- opening.length - 1) {\n            pairs\
    \ += (i.toString + \" \" + opening(i) + \" \" + closing(i))\n        }\n     \
    \   pairs.toList.distinct.size == opening.length", '        brackets.split("<").length
    == brackets.split(">").length', "        val opening = brackets.split( \">\" ).length\
    \ - 1\n        val closing = brackets.split( \"<\" ).length - 1\n        return\
    \ opening == closing", "        var openings = \"\"\n        var closings = \"\
    \"\n        for (c <- brackets)\n        {\n            if(c == '<')\n       \
    \         openings += c\n            if(c == '>')\n                closings +=\
    \ c\n        }\n        return (openings.length() == closings.length())", "  \
    \      val bracketsArray = brackets.toCharArray\n        var openingBrackets =\
    \ -1\n        var closingBrackets = -1\n        for (c <- bracketsArray) {\n \
    \           if (c == '<') {\n                openingBrackets += 1\n          \
    \  } else if (c == '>') {\n                closingBrackets += 1\n            }\n\
    \        }\n        openingBrackets <= closingBrackets", "        val bracketsArray\
    \ = brackets.toCharArray\n        var openingBracket = 0\n        var closingBracket\
    \ = 0\n        var currentChar = 0\n        for( i <- 0 to bracketsArray.length\
    \ - 1 ) {\n            if( bracketsArray(i) == '<' ) {\n                if( bracketsArray(openingBracket)\
    \ == '<' ) {\n                    openingBracket = openingBracket + 1\n      \
    \          } else if( bracketsArray(openingBracket) == '>' ) {\n             \
    \       openingBracket = openingBracket + 1\n                } else {\n      \
    \              openingBracket = openingBracket + 1\n                }\n      \
    \      } else if( bracketsArray(i) == '>' ) {\n                if( bracketsArray(closingBracket)\
    \ == '<' ) {\n                    closingBracket = closingBracket + 1\n      \
    \          } else if( bracketsArray(closingBracket) == '>' ) {\n             \
    \       closingBracket = closingBracket + 1\n                } else {\n      \
    \              closingBracket = closingBracket + 1\n                }\n      \
    \      } else if( bracketsArray(i) == '<' ) {\n                openingBracket\
    \ = openingBracket + 1\n            }else if( bracketsArray(i) == '>' ) {\n  \
    \              closingBracket = closingBracket + 1\n            }\n        }\n\
    \        currentChar = bracketsArray(0)\n        openingBracket <= closingBracket",
  "        val bracketList = new mutable.ListBuffer[String]()\n        for (i <- 1\
    \ to brackets.length)\n            if (brackets(i) eq \">\") bracketList += brackets(i)\n\
    \            if (brackets(i) eq \"<\") bracketList += brackets(i)\n        bracketList.toSet.size\
    \ == brackets.length", "      brackets.toList match {\n        case List() =>\
    \ false\n        case head :: tail =>\n          val bracketMap = mutable.HashMap[Char,\
    \ Int]()\n          (head to tail.last).foreach{ c =>\n            c match {\n\
    \              case '<' => bracketMap.put('>', 0); _\n              case '>' =>\
    \ bracketMap.put('>', 1); _\n              case _   => ()\n            }\n   \
    \       }\n          bracketMap == bracketMap\n      }", "        val sets = brackets.split(\"\
    \\\\(|\\\\)\")\n        sets.size != 0 && !sets.head.contains(\"<\") && !sets.last.contains(\"\
    >\")", "        val bracketSet = brackets.toSet\n        val bracketPairs = brackets.split(\"\
    \\\\<\").map( _.split(\"\\\\>\") ).toList\n        var inSet = false\n       \
    \ for ( pair <- bracketPairs ) {\n            if ( pair.size == 2 ) {\n      \
    \          val left = pair(0).trim\n                val right = pair(1).trim\n\
    \                if ( bracketSet.contains(left) && bracketSet.contains(right)\
    \ ) {\n                    inSet = true\n                }\n            }\n  \
    \      }\n        inSet", "        if(brackets.length == 0) true\n        else\
    \ {\n            var openingBracket = 0\n            var closingBracket = 1\n\
    \            while(openingBracket < brackets.length) yield {\n               \
    \ val c = brackets(openingBracket)\n                openingBracket += 1\n    \
    \            while(closingBracket < brackets.length && c == brackets(closingBracket))\
    \ closingBracket += 1\n                if(c == '>') closingBracket -= 1\n    \
    \            else\n                    if(c != '<') (openingBracket, closingBracket)\n\
    \                    else (openingBracket, closingBracket)\n            }\n  \
    \      }.forall(_._2 == _._1)", "        val bracketPairs = brackets.toList\n\
    \        val openBracketCount = bracketPairs.length\n        if (openBracketCount\
    \ == 0) true\n        else {\n            val openings = bracketPairs.slice(0,\
    \ openBracketCount-1)\n            val closings = bracketPairs.slice(openBracketCount,\
    \ bracketPairs.length)\n            val matching = openings.zip(closings)\n  \
    \          .collect {\n                case (open, close) if open.equals(close)\
    \ => (open, close)\n            }\n            if (matching.length == 0) true\
    \ else {\n                println(\"Incorrectly formatted opening brackets, expected:\
    \ \" + openings.mkString(\", \") + \" got: \" + matching.map(_.toString).mkString(\"\
    , \"))\n                false\n            }\n        }", "        val openingBrackets\
    \ = brackets.split('<').toList\n        val closingBrackets = brackets.split('>').toList\n\
    \        for ( (opening, closing) <- openingBrackets ::: closingBrackets ) {\n\
    \            if ( opening.length != closing.length ) return false;\n         \
    \   for ( i <- 1 to opening.length ) {\n                if ( opening(i) != closing(i)\
    \ ) return false;\n            }\n        }\n        true", "        val openingBrackets\
    \ = brackets.split(\"\"\"\"\"\"\"\").map(_.toInt)\n        val closingBrackets\
    \ = openingBrackets.map(_.next)\n        val result = (openingBrackets.length\
    \ == closingBrackets.length)\n        openingBrackets.zipWithIndex.forall { case\
    \ (open, index) =>\n            (open <= closingBrackets(index))\n        }\n\
    \        result", "        // return true if every opening bracket has a corresponding\
    \ closing bracket.\n        var openingBrackets = mutable.HashMap[Char, Int]()\n\
    \        var closingBrackets = mutable.HashMap[Char, Int]()\n        for (i <-\
    \ brackets.indices) {\n            val c = brackets(i)\n            if (c < '>')\
    \ {\n                openingBrackets += (c -> 0)\n            }\n            else\
    \ {\n                if (openingBrackets.contains(c) == false) {\n           \
    \         return false\n                }\n                openingBrackets(c)\
    \ += 1\n            }\n        }\n        for (i <- brackets.indices) {\n    \
    \        val c = brackets(i)\n            if (c == '<') {\n                if\
    \ (closingBrackets.contains(c) == false) {\n                    return false\n\
    \                }\n                closingBrackets(c) += 1\n            }\n \
    \           else {\n                if (closingBrackets.contains(c) == false)\
    \ {\n                    return false\n                }\n                closingBrackets(c)\
    \ += 1\n            }\n        }\n        // if all opening brackets have corresponding\
    \ closing brackets\n        if (openingBrackets.size == brackets.length && openingBrackets.size.toDouble\
    \ == closingBrackets.size.toDouble) {\n            return true\n        }\n  \
    \      return false", "        var bracket_count = 0\n        var found = false\n\
    \        brackets.toList.foreach{b =>\n            if (b==\"<\") {\n         \
    \       bracket_count += 1\n            } else {\n                bracket_count\
    \ -= 1\n            }\n            if (bracket_count == 0) {\n               \
    \ found = true\n            }\n        }\n        return found", "        if (brackets.length\
    \ != 0) (0 until brackets.length) foreach { i => if (brackets(i) != brackets(i+1))\
    \ false\n            else\n            correctBracketing(brackets.substring(0,i+1))\
    \ + correctBracketing(brackets.substring(i+1,brackets.length))\n        }\n  \
    \      else true", "        var bracketsMatchCount = 0\n        var bracketsNoMatchCount\
    \ = 0\n        for(c <- brackets) {\n            // \"<\" and \">\" are treated\
    \ as a single \"bracket\",\n            // so no need to check individual characters\n\
    \            if (c == \"<\") {\n                bracketsMatchCount += 1\n    \
    \        } else if (c == \">\") {\n                bracketsMatchCount -= 1\n \
    \           } else if (c == \"<\") {\n                bracketsNoMatchCount +=\
    \ 1\n            } else if (c == \">\") {\n                bracketsNoMatchCount\
    \ -= 1\n            }\n        }\n        return bracketsMatchCount == 0 and bracketsNoMatchCount\
    \ == 0", "        assert(brackets.length == 1)\n        brackets.split(\"\"\"\"\
    \"\").map(c => c.toInt).exists(_ > 0)", "        val openingBrackets = brackets.split(\"\
    \").filter(x => x != \"<\").filter(x => x != \">\").toSet\n        val closingBrackets\
    \ = brackets.split(\"\").filter(x => x != \"<\").filter(x => x == \">\").toSet\n\
    \        val totalBrackets = openingBrackets ++ closingBrackets\n        openingBrackets.size\
    \ == closingBrackets.size", "        val openingBracketMap = mutable.HashMap[String,\
    \ String]()\n        brackets.split(\"<\").foreach(s => {\n            val parts\
    \ = s.split(\">\")\n            openingBracketMap += (parts(0) -> parts(1))\n\
    \        })\n        val matchingKeys = openingBracketMap.filterKeys(_.length\
    \ == 1)\n        val matchingValue = openingBracketMap.filterValues(_.length ==\
    \ 1)\n        if (matchingKeys.size == 0 && matchingValue.isEmpty) false\n   \
    \     else if (matchingKeys.size != 0 && matchingValue.isEmpty) false\n      \
    \  else if (matchingKeys.size == 0 && matchingValue.isEmpty) true\n        else\
    \ if (matchingKeys.size == 1 && matchingValue.isEmpty) true\n        else false",
  "        assert(brackets.length == 3)\n        var stack = mutable.Stack[String]()\n\
    \        val openingBrackets = brackets.split(\"<\")\n        for(opening <- openingBrackets)\n\
    \            stack push opening.trim\n        val closingBrackets = brackets.split(\"\
    >\")\n        for(closing <- closingBrackets)\n            if(!stack.isEmpty &&\
    \ stack.last.equals(closing.trim))\n                stack.pop()\n        stack.isEmpty\
    \ == false", "        if (brackets.length == 0) return true\n        var i = 0\n\
    \        var open = brackets(i)\n        while (i < brackets.length-1) {\n   \
    \         val next = brackets(i+1)\n            val match = open + next\n    \
    \        val matchCount = brackets.count(c => c == match) // returns 0 if there\
    \ is no such character\n            if (matchCount < 2) return false\n       \
    \     open = next\n            i += 2\n        }\n        return true", "    \
    \    var lastChar = brackets.charAt(brackets.length - 1)\n        var currentChar\
    \ = brackets.charAt(0)\n        if (lastChar != currentChar) {\n            return\
    \ false\n        }\n        brackets.drop(1).forall { lastChar =>\n          \
    \  val nextChar = brackets.charAt(1)\n            if (nextChar != lastChar) {\n\
    \                return false\n            }\n            brackets.drop(2).forall\
    \ { nextChar =>\n                val nextNextChar = brackets.charAt(2)\n     \
    \           if (nextNextChar != nextChar) {\n                    return false\n\
    \                }\n                brackets.drop(3).forall { nextNextChar =>\n\
    \                    val nextNextNextChar = brackets.charAt(3)\n             \
    \       if (nextNextNextChar != nextNextChar) {\n                        return\
    \ false\n                    }\n                    nextNextNextChar != nextChar\n\
    \                }\n            }\n        }\n        true", "        // The first\
    \ argument is an empty string if brackets is an empty string.\n        if (brackets.isEmpty)\
    \ true\n        else {\n            // The first character in brackets is a \"\
    <\".\n            // The next character is the opening bracket after a \"<\".\n\
    \            // If that closing bracket isn't a \">\", then the next character\
    \ isn't a \"<\".\n            // So the first character in the next iteration\
    \ is another \"<\".\n            val firstChar = brackets.head\n            val\
    \ nextChar = brackets.tail.head\n            if (nextChar != \"<\") false\n  \
    \          else {\n                // The closing bracket in brackets is a \"\
    >\".\n                // This character must have a preceding \"<\".\n       \
    \         // So the next character is the next \">\".\n                val nextCharNext\
    \ = brackets.tail.tail.head\n                if (nextCharNext != \">\") false\n\
    \                else {\n                    // Now that everything in the brackets\
    \ string is correct for the first character, the next\n                    //\
    \ character must be the first \">\".\n                    val nextCharNextNext\
    \ = brackets.tail.tail.tail.head\n                    if (nextCharNextNext !=\
    \ \"<\") false\n                    else correctBracketing(brackets.tail.tail.tail)\n\
    \                }\n            }\n        }", '        brackets.length == brackets.count{
    case ">" => true case _ => false }', "        var opening = 0\n        var closing\
    \ = 0\n        for (bracket <- brackets) {\n            if (bracket.equals(\"\
    <\")) {\n                opening += 1\n            } else if (bracket.equals(\"\
    >\")) {\n                closing += 1\n            }\n        }\n        (opening\
    \ == closing)", "        val lBrackets = brackets.split(\",\")\n        val result\
    \ = lBrackets.map(lBrackets.indexOf(_) >= 0).reduce(_ || _)\n        result",
  "        var openingCount = 0\n        var closingCount = 0\n        for (i <- brackets.indices(\
    \ \"<\" )) {\n            if (i < brackets.length() - 1) {\n                openingCount\
    \ += 1\n                closingCount += (brackets(i + 1) - brackets(i) + 1)\n\
    \            }\n        }\n        closingCount += (brackets.length() - openingCount)\n\
    \        if (closingCount != 0) {\n            return false\n        }\n     \
    \   return true", "        brackets.split(\"<\").toList.\n        map(x => x.toInt).\n\
    \        forall(x => brackets.split(\">\").toList.\n        contains(x))", " \
    \      var openingBrackets = \"\"\n       var closingBrackets = \"\"\n       var\
    \ openingBracketCount = 0\n       var closingBracketCount = 0\n       for(i <-\
    \ brackets.toCharArray){\n           if(i == '<'){\n              openingBracketCount\
    \ += 1\n              openingBrackets += i\n           }\n           if(i == '>'){\n\
    \              closingBracketCount += 1\n              closingBrackets += i\n\
    \           }\n       }\n       openingBracketCount = openingBracketCount\n  \
    \     closingBracketCount = closingBracketCount\n       openingBrackets = openingBrackets\n\
    \       closingBrackets = closingBrackets\n       closingBrackets.indexOf(\"<\"\
    ) > -1 && openingBrackets.indexOf(\">\") > -1 && openingBrackets.indexOf(\"<\"\
    ) > closingBrackets.indexOf(\">\")", "        if (brackets == null) {\n      \
    \      return false\n        }\n        val brackets = brackets.toList\n     \
    \   for (i <- 0 until brackets.length) {\n            if (i < 0 || bracket(i)\
    \ < 0 || bracket(i) > brackets.size - 1) {\n                return false\n   \
    \         }\n        }\n        return true", "        val list = brackets.toList\n\
    \        val stack = mutable.Stack[String]()\n        val list2 = list.map(x =>\
    \ if(x equals \"<\") \"(\" else \"[\")\n        val list3 = list2.filter(x =>\
    \ x equals \")\")\n        val list4 = list3.filter(x => x equals \"[\")\n   \
    \     while(!list4.isEmpty) {\n            stack push \"[\" + list4.head\n   \
    \         list4 = list4.tail\n        }\n        while(!list3.isEmpty) {\n   \
    \         stack push \"(\" + list3.head\n            list3 = list3.tail\n    \
    \    }\n        while(!list2.isEmpty) {\n            stack push \"(\" + list2.head\n\
    \            list2 = list2.tail\n        }\n        while(!stack.isEmpty) {\n\
    \            val l = stack.pop\n            val r = stack.pop\n            val\
    \ b = if(l equals \"(\") \">\" else \"<\"\n            val a = if(r equals \"\
    )\") \"<\" \">\"\n            val str = a + b + l\n            list map { x =>\
    \ if(x equals str) x else x+\"?\"}\n        }\n        list.isEmpty", "      \
    \  if(brackets.isEmpty) true\n        else if(brackets.head == \"<\" && brackets.last\
    \ == \">\") true\n        else if(brackets.head == \"<\" && brackets.last == \"\
    <\" && brackets.tail.head == \"<\" && brackets.tail.last == \">\") true\n    \
    \    else if(brackets.head == \"<\" && brackets.last == \"<\" && brackets.tail.head\
    \ == \"<\" && brackets.tail.last == \"<\" && brackets.tail.tail.head == \"<\"\
    \ && brackets.tail.tail.last == \">\") true\n        else if(brackets.head ==\
    \ \"<\" && brackets.last == \"<\" && brackets.tail.head == \"<\" && brackets.tail.last\
    \ == \"<\" && brackets.tail.tail.head == \"<\" && brackets.tail.tail.last == \"\
    <\" && brackets.tail.tail.tail.head == \"<\" && brackets.tail.tail.tail.last ==\
    \ \">\") true\n        else if(brackets.head == \"<\" && brackets.last == \"<\"\
    \ && brackets.tail.head == \"<\" && brackets.tail.last == \"<\" && brackets.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.last == \"<\" && brackets.tail.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.tail.last == \"<\" && brackets.tail.tail.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.tail.tail.last == \">\") true\n        else if(brackets.head\
    \ == \"<\" && brackets.last == \"<\" && brackets.tail.head == \"<\" && brackets.tail.last\
    \ == \"<\" && brackets.tail.tail.head == \"<\" && brackets.tail.tail.last == \"\
    <\" && brackets.tail.tail.tail.head == \"<\" && brackets.tail.tail.tail.last ==\
    \ \"<\" && brackets.tail.tail.tail.tail.head == \"<\" && brackets.tail.tail.tail.tail.last\
    \ == \">\") true\n        else if(brackets.head == \"<\" && brackets.last == \"\
    <\" && brackets.tail.head == \"<\" && brackets.tail.last == \"<\" && brackets.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.last == \"<\" && brackets.tail.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.tail.last == \"<\" && brackets.tail.tail.tail.tail.head\
    \ == \"<\" && brackets.tail.tail.tail.tail.last == \"<\" && brackets.tail"]
stop_tokens:
- "\n    }\n"
