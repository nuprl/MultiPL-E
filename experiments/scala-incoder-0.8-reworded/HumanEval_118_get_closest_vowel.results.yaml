language: scala
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array('a',\
    \ 'e', 'i', 'o', 'u')\n        var result = \"\"\n        var index = word.length\
    \ - 1\n        while(index >= 0) {\n            val currentChar = word(index)\n\
    \            var isCurrentCharVowel = false\n            vowels.find(currentChar\
    \ => isCurrentCharVowel = currentChar.toLowerCase == currentChar)\n          \
    \  if (isCurrentCharVowel) {\n                result = currentChar\n         \
    \       index -= 2\n            } else {\n                index -= 1\n       \
    \     }\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3dd1tjlj.scala:25:72 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            vowels.find(\e[36mcurrentChar\e[0m => isCurrentCharVowel\
    \ = currentChar.toLowerCase == currentChar)\n\e[31m\e[31m   |\e[0m           \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dd1tjlj.scala:27:25\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                result = currentChar\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         Found:    (currentChar : Char)\n\e[31m   |\e[0m    \
    \                     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val firstLetter = word.charAt(word.length-1)\n\
    \        if(firstLetter >= 'A' && firstLetter <= 'Z') {\n            val secondLetter\
    \ = word.charAt(word.length-2)\n            if(secondLetter >= 'A' && secondLetter\
    \ <= 'Z') {\n                if(vowels.contains(word.charAt(word.length-2)))\n\
    \                    return word.charAt(word.length-2)\n            }\n      \
    \  }\n        return \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbf4j7m32.scala:24:46\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(vowels.contains(word.charAt(word.length-\e\
    [31m2\e[0m)))\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    Char\n\e[31m\
    \   |\e[0m                                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbf4j7m32.scala:25:38 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mreturn\e[0m word.charAt(word.length-\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Char\n\e[31m   |\e[0m\
    \                           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array('a','e','i','o','u')\n\
    \        var index = 0\n        val wordArray = word.split(\" \").toList\n   \
    \     wordArray.reverse.foreach {\n            if (vowels.contains(_))\n     \
    \           index = wordArray.indexOf(\"\")\n        }\n        if (index == -1)\n\
    \            return \"\"\n        else\n            return wordArray.apply(index+1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpemyxom_4.scala:23:16\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (vowels.contains(_))\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Found:    \e[1m\e[31mChar\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m=\e\
    [0m\e[1m\e[31m>\e[0m\e[1m\e[31m \e[0mBoolean\n\e[31m   |\e[0m                Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\",\"E\",\"I\",\"O\",\"U\")\n        val index\
    \ = word.lastIndexOfAny(vowels)\n        val end = word.substring(index).lastIndexOf(\"\
    e\")\n        val start = word.substring(0,index).lastIndexOf(\"a\")\n       \
    \ val res = word.substring(start,end)\n        if (res.length==0)\n          \
    \  return \"\"\n        else\n            return res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt069pmh_.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = word.lastIndexOfAny(vowels)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue lastIndexOfAny is not a member of String - did you mean word.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var vowelsSet = vowels.toSet\n     \
    \   val leftSide = word.lastOption\n        val rightSide = word.dropRight(1)\n\
    \n        if(leftSide.isEmpty)\n            return \"\"\n\n        if(rightSide.isEmpty)\n\
    \            return \"\"\n\n        val rightVowel = rightSide.last\n\n      \
    \  // if the last character is a vowel\n        if(rightVowel in vowelsSet)\n\
    \            return \"\"\n        else if(rightVowel == \" \" || rightVowel ==\
    \ \"'\")\n            return \"\"\n\n        val leftVowel = leftSide.last\n\n\
    \        if(leftVowel == \" \" || leftVowel == \"'\")\n            return \"\"\
    \n\n        if(leftVowel in vowelsSet){\n            // if the last character\
    \ of the word is a vowel\n            val leftVowelPos = word.lastIndexOf(' ')\
    \ + 1\n            val rightVowelPos = word.lastIndexOf(' ') + 1\n\n         \
    \   val leftVowelCount = word.slice(leftVowelPos, leftVowelPos + 1).count(' ')\n\
    \            val rightVowelCount = word.slice(rightVowelPos, rightVowelPos + 1).count('\
    \ ')\n\n            if(rightVowelCount == leftVowelCount)\n                return\
    \ \"\"\n            else if(rightVowelCount < leftVowelCount)\n              \
    \  return \"\"\n\n        }\n\n        return \"\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2zbh7iyf.scala:33:22 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m(rightVowel in vowelsSet)\n\e[31m\e\
    [31m   |\e[0m           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value in\
    \ is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmp2zbh7iyf.scala:35:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \ \e[33melse\e[0m \e[33mif\e[0m(rightVowel == \e[31m\" \"\e[0m || rightVowel ==\
    \ \e[31m\"'\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp2zbh7iyf.scala:35:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(rightVowel == \e\
    [31m\" \"\e[0m || rightVowel == \e[31m\"'\"\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmp2zbh7iyf.scala:40:11 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mif\e[0m(leftVowel == \e[31m\" \"\e[0m ||\
    \ leftVowel == \e[31m\"'\"\e[0m)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp2zbh7iyf.scala:40:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mif\e[0m(leftVowel == \e[31m\" \"\e[0m ||\
    \ leftVowel == \e[31m\"'\"\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and\
    \ String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2zbh7iyf.scala:43:21 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m        \e[33mif\e[0m(leftVowel in vowelsSet){\n\e[31m\e[31m   |\e[0m     \
    \      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value in is not a member of\
    \ Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2zbh7iyf.scala:48:82\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e[0m \e\
    [36mleft"
  stdout: ''
  timestamp: 1660009803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelList =\
    \ \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\".split(\",\").toSet\n\
    \        var vowel = word.substring(word.length-1)\n        var newVowel = \"\"\
    \n        vowelList.toSeq.foreach { vowel2 =>\n            if (vowel2.toUpperCase.equals(vowel.toUpperCase))\
    \ {\n                newVowel = vowel2\n            }\n        }\n        if (vowelList.isEmpty\
    \ && newVowel.isEmpty) {\n            newVowel = \"\"\n        }\n        return\
    \ newVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtsml83d.scala:33)\n\tat Problem.main(tmpwtsml83d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var bestVowel =\
    \ \"\"\n        var bestVowelCount = 0\n        for(i <- word.indexOf(\"G\"-1);\
    \ i+1 < word.length && !(word.charAt(i) == \"F\" && word.charAt(i+1) == \"A\"\
    ) && !(word.charAt(i) == \"M\" && word.charAt(i+1) == \"P\")){\n            var\
    \ vowel = word.substring(i, i+1);\n            if(vowel.equals(\"U\") || vowel.equals(\"\
    UA\") || vowel.equals(\"UB\") || vowel.equals(\"UC\") || vowel.equals(\"UD\")\
    \ || vowel.equals(\"UE\") || vowel.equals(\"UF\") || vowel.equals(\"UG\") || vowel.equals(\"\
    UH\") || vowel.equals(\"UJ\") || vowel.equals(\"UK\") || vowel.equals(\"UL\")\
    \ || vowel.equals(\"UM\") || vowel.equals(\"UN\") || vowel.equals(\"UO\") || vowel.equals(\"\
    UP\") || vowel.equals(\"UQ\") || vowel.equals(\"UR\") || vowel.equals(\"US\")\
    \ || vowel.equals(\"UT\") || vowel.equals(\"UU\") || vowel.equals(\"UV\") || vowel.equals(\"\
    UW\") || vowel.equals(\"UX\") || vowel.equals(\"UY\") || vowel.equals(\"UZ\")\
    \ || vowel.equals(\"V\") || vowel.equals(\"VB\") || vowel.equals(\"VC\") || vowel.equals(\"\
    VD\") || vowel.equals(\"VE\") || vowel.equals(\"VF\") || vowel.equals(\"VG\")\
    \ || vowel.equals(\"VH\") || vowel.equals(\"VI\") || vowel.equals(\"VJ\") || vowel.equals(\"\
    VK\") || vowel.equals(\"VL\") || vowel.equals(\"VM\") || vowel.equals(\"VN\")\
    \ || vowel.equals(\"VO\") || vowel.equals(\"VP\") || vowel.equals(\"VQ\") || vowel.equals(\"\
    VR\") || vowel.equals(\"VS\") || vowel.equals(\"VT\") || vowel.equals(\"VU\")\
    \ || vowel.equals(\"VV\") || vowel.equals(\"VW\") || vowel.equals(\"VX\") || vowel.equals(\"\
    VY\") || vowel.equals(\"VZ\") || vowel.equals(\"W\") || vowel.equals(\"WB\") ||\
    \ vowel.equals(\"WC\") || vowel.equals(\"WD\") || vowel.equals(\"WE\") || vowel.equals(\"\
    WF\") || vowel.equals(\"WG\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzpb1ogv6.scala:21:165 --------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m(i <- word.indexOf(\e[31m\"G\"\e\
    [0m-\e[31m1\e[0m); i+\e[31m1\e[0m < word.length && !(word.charAt(i) == \e[31m\"\
    F\"\e[0m && word.charAt(i+\e[31m1\e[0m) == \e[31m\"A\"\e[0m) && !(word.charAt(i)\
    \ == \e[31m\"M\"\e[0m && word.charAt(i+\e[31m1\e[0m) == \e[31m\"P\"\e[0m)){\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                      '<-' expected, but ')' found\n\e[31m\e[31m-- Error: /tmp/tmpzpb1ogv6.scala:23:1301\
    \ ---------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m         \
    \   \e[33mif\e[0m(vowel.equals(\e[31m\"U\"\e[0m) || vowel.equals(\e[31m\"UA\"\e\
    [0m) || vowel.equals(\e[31m\"UB\"\e[0m) || vowel.equals(\e[31m\"UC\"\e[0m) ||\
    \ vowel.equals(\e[31m\"UD\"\e[0m) || vowel.equals(\e[31m\"UE\"\e[0m) || vowel.equals(\e\
    [31m\"UF\"\e[0m) || vowel.equals(\e[31m\"UG\"\e[0m) || vowel.equals(\e[31m\"UH\"\
    \e[0m) || vowel.equals(\e[31m\"UJ\"\e[0m) || vowel.equals(\e[31m\"UK\"\e[0m) ||\
    \ vowel.equals(\e[31m\"UL\"\e[0m) || vowel.equals(\e[31m\"UM\"\e[0m) || vowel.equals(\e\
    [31m\"UN\"\e[0m) || vowel.equals(\e[31m\"UO\"\e[0m) || vowel.equals(\e[31m\"UP\"\
    \e[0m) || vowel.equals(\e[31m\"UQ\"\e[0m) || vowel.equals(\e[31m\"UR\"\e[0m) ||\
    \ vowel.equals(\e[31m\"US\"\e[0m) || vowel.equals(\e[31m\"UT\"\e[0m) || vowel.equals(\e\
    [31m\"UU\"\e[0m) || vowel.equals(\e[31m\"UV\"\e[0m) || vowel.equals(\e[31m\"UW\"\
    \e[0m) || vowel.equals(\e[31m\"UX\"\e[0m) || vowel.equals(\e[31m\"UY\"\e[0m) ||\
    \ vowel.equals(\e[31m\"UZ\"\e[0m) || vowel.equals(\e[31m\"V\"\e[0m) || vowel.equals(\e\
    [31m\"VB\"\e[0m) || vowel.equals(\e[31m\"VC\"\e[0m) || vowel.equals(\e[31m\"VD\"\
    \e[0m) || vowel.equals(\e[31m\"VE\"\e[0m) || vowel.equals(\e[31m\"VF\"\e[0m) ||\
    \ vowel.equals(\e[31m\"VG\"\e[0m) || vowel.equals(\e[31m\"VH\"\e[0m) || vowel.equals(\e\
    [31m\"VI\"\e[0m) || vowel.equals(\e[31m\"VJ\"\e[0m) || vowel.equals(\e[31m\"VK\"\
    \e[0m) || vowel.equals(\e[31m\"VL\"\e[0m) || vowel.equals(\e[31m\"VM\"\e[0m) ||\
    \ vowel.equals(\e[31m\"VN\"\e[0m) || vowel.equals(\e[31m\"VO\"\e[0m) |"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        val lowerCaseWord = word.map(_.toLowerCase)\n\
    \        val index = lowerCaseWord.indexWhere(_.toChar == 'a')\n        var closestVowel\
    \ = \"\"\n        if(index != -1){\n            var closest = lowerCaseWord.take(index).map(_.toLowerCase)\n\
    \            val vowelsIndex = vowels.indexWhere(_.toChar == closest(2))\n   \
    \         if(vowelsIndex != -1){\n                closestVowel = vowels(vowelsIndex)\n\
    \            }\n        }\n        return closestVowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8x3ycir.scala:20:39 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlowerCaseWord\e[0m = word.map(_.toLowerCase)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8x3ycir.scala:25:50\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mvowelsIndex\e[0m = vowels.indexWhere(_.toChar == closest(\e[31m2\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = mutable.Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"a\")\n        val consonants = mutable.Set(\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\")\n        val letters\
    \ = mutable.Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"a\")\n        var\
    \ i = 0\n        var j = word.length - 1\n        var closest = \"\"\n       \
    \ while (i <= j) {\n            var min = i\n            var max = j\n       \
    \     val length = j - i\n            val newVowel = vowels.subsetOf(word.slice(i,\
    \ i + length))\n            if (newVowel.length > 0) {\n                min =\
    \ i\n                max = i + newVowel.length\n            }\n            val\
    \ newConsonant = consonants.subsetOf(word.slice(i, j))\n            if (newConsonant.length\
    \ > 0) {\n                min = i\n                max = j\n            }\n  \
    \          val newLetter = letters.subsetOf(word.slice(i, j))\n            if\
    \ (newLetter.length > 0) {\n                min = i\n                max = j\n\
    \            }\n            val newLetters = letters.subsetOf(word.slice(i, j))\n\
    \            if (newLetters.length > 0) {\n                min = i\n         \
    \       max = j\n            }\n            val newVowels = vowels.subsetOf(word.slice(i,\
    \ j))\n            if (newVowels.length > 0) {\n                min = i\n    \
    \            max = j\n            }\n            if (newVowel.length < min.length)\
    \ {\n                min = i\n            }\n            if (newVowel.length <\
    \ max.length) {\n                max = j\n            }\n            val newConsonants\
    \ = consonants.subsetOf(word.slice(i, j))\n            if (newConsonants.length\
    \ > 0) {\n                min = i\n                max = j\n            }\n  \
    \          if (newConsonant.length < min.length) {\n                min = i\n\
    \            }\n            if (newConsonant.length < max.length) {\n        \
    \        max = j\n            }\n            val newLetter = letters.subsetOf(word.slice(i,\
    \ j))\n            if (newLetter.length > 0) {\n                min = i\n    \
    \            max = j\n            }\n            if (newLetter.length < min.length)\
    \ {\n                min = i\n            }\n            if (newLetter.length\
    \ < max.length) {\n                max = j\n            }\n            if (closest\
    \ == \"\") {\n                closest = (word.slice(i, j)) + \"U\"\n         \
    \   } else {\n                closest = (word.slice(i, j)) + closest\n       \
    \     }\n            i += 1\n            j -= 1\n        }\n        return closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph1or3rjm.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.Set(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m, \e[31m\"y\"\e[0m, \e[31m\"a\"\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph1or3rjm.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonants\e[0m = mutable.Set(\e[31m\"b\"\e[0m, \e[31m\"c\"\e[0m, \e[31m\"\
    d\"\e[0m, \e[31m\"f\"\e[0m, \e[31m\"g\"\e[0m, \e[31m\"h\"\e[0m, \e[31m\"j\"\e\
    [0m, \e[31m\"k\"\e[0m, \e[31m\"l\"\e[0m, \e[31m\"m\"\e[0m, \e[31m\"n\"\e[0m, \e\
    [31m\"p\"\e[0m, \e[31m\"q\"\e[0m, \e[31m\"r\"\e[0m, \e[31m\"s\"\e[0m, \e[31m\"\
    t\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"w\"\e[0m, \e[31m\"x\"\e[0m, \e[31m\"z\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmph1or3rjm.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mletters\e[0m = mutable.Set(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m, \e[31m\"y\"\e[0m, \e[31m\"a\"\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph1or3rjm.scala:71:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m71 |\e[0m            \e[33mval\e\
    [0m \e[36mnewLetter\e[0m = letters.subsetOf(word.slice(i, j))\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewLetter is already defined as \e[33mvalue\e[0m \e[35mnewLetter\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660009798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var currentIndex\
    \ : Int = 0\n        var currentVowel : String = \"\"\n        var currentDistance\
    \ : Double = 0.0 \n\n        for (i <- word.length - 1; i >= 0; i--){\n      \
    \      var previousIndex : Int = word.length - i - 1\n            var previousVowel\
    \ : String = word.substring(previousIndex, 1)\n            val distance = getDistance(word,\
    \ previousIndex,previousVowel)\n            if(distance < currentDistance){\n\
    \                currentIndex = previousIndex\n                currentVowel =\
    \ previousVowel\n                currentDistance = distance\n            }\n \
    \       }\n\n        currentVowel\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzbf_jqk2.scala:23:41 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <- word.length - \e[31m1\e\
    [0m; i >= \e[31m0\e[0m; i--){\n\e[31m\e[31m   |\e[0m                         \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \    '<-' expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzbf_jqk2.scala:23:46\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m\
    \ (i <- word.length - \e[31m1\e[0m; i >= \e[31m0\e[0m; i--){\n\e[31m\e[31m   |\e\
    [0m                                              ^\e[0m\n\e[31m   |\e[0m     \
    \                                         pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbf_jqk2.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <- word.length - \e[31m1\e\
    [0m; i >= \e[31m0\e[0m; i--){\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value foreach is not a member of Int\n3\
    \ errors found\n"
  stdout: ''
  timestamp: 1660009800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var res = \"\"\n\
    \        var first = 0\n        var last = word.length\n        while(first <=\
    \ last){\n            res +=  word.charAt(first)\n            first += 1\n   \
    \         last -= 1\n        }\n        val vowels = mutable.Set(\"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n        vowels.foreach(x => {\n            if(res.indexOf(x)\
    \ == -1 && res.charAt(res.length-1) == x){\n                res = res + x\n  \
    \          }\n        })\n        if(res.contains(\"y\") || res.contains(\"a\"\
    )) res += \"u\"\n        if(res.contains(\"y\") || res.contains(\"e\")) res +=\
    \ \"u\"\n        if(res.contains(\"y\") || res.contains(\"i\")) res += \"u\"\n\
    \        if(res.contains(\"y\") || res.contains(\"o\")) res += \"u\"\n       \
    \ if(res.contains(\"y\") || res.contains(\"u\")) res += \"u\"\n        if(res.contains(\"\
    a\")) res += \"u\"\n        if(res.contains(\"e\")) res += \"u\"\n        if(res.contains(\"\
    i\")) res += \"u\"\n        if(res.contains(\"o\")) res += \"u\"\n        if(res.contains(\"\
    u\")) res += \"u\"\n        return res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp49k9l3si.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.Set(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var vowelsIndex = 0\n        var vowelsLength\
    \ = 0\n        var vowelsIndexRight = 0\n        var vowelsLengthRight = 0\n \
    \       var tempString = \"\"\n        for (i <- 0 until word.length-1){\n   \
    \         if(vowels.contains(word.charAt(i))){\n                tempString +=\
    \ word.charAt(i)\n                vowelsIndex += 1\n                vowelsLength\
    \ += 1\n                if(word.charAt(i+1) == word.charAt(i).toLowerCase){\n\
    \                    vowelsIndexRight += 1\n                    vowelsLengthRight\
    \ += 1\n                }\n            }\n        }\n        if(vowelsIndex ==\
    \ 1){\n            return tempString\n        }else if(vowelsIndex == 2){\n  \
    \          return tempString.reverse\n        }else if(vowelsIndexRight == 1){\n\
    \            return tempString.reverse\n        }else if(vowelsIndexRight == 2){\n\
    \            return tempString\n        }\n        tempString = \"\"\n       \
    \ var wordIndex = 0\n        var wordLength = 0\n        var wordIndexRight =\
    \ 0\n        var wordLengthRight = 0\n        for (i <- 0 until word.length-1){\n\
    \            if(vowels.contains(word.charAt(i))){\n                tempString\
    \ += word.charAt(i)\n                wordIndex += 1\n                wordLength\
    \ += 1\n                if(word.charAt(i+1) == word.charAt(i).toLowerCase){\n\
    \                    wordIndexRight += 1\n                    wordLengthRight\
    \ += 1\n                }\n            }\n        }\n        if(wordIndex == 1){\n\
    \            return tempString\n        }else if(wordIndex == 2){\n          \
    \  return tempString.reverse\n        }else if(wordIndexRight == 1){\n       \
    \     return tempString.reverse\n        }else if(wordIndexRight == 2){\n    \
    \        return tempString\n        }\n        tempString = \"\"\n        var\
    \ wordIndex = 0\n        var wordLength = 0\n        var wordIndexRight = 0\n\
    \        var wordLengthRight = 0\n        for (i <- 0 until word.length-1){\n\
    \            if(vowels.contains(word.charAt(i))){\n                tempString\
    \ += word.charAt(i)\n                wordIndex += 1\n                wordLength\
    \ += 1\n                if(word.charAt(i+1) == word.charAt(i).toLowerCase){\n\
    \                    wordIndexRight += 1\n                    wordLengthRight\
    \ += 1\n                }\n            }\n        }\n        if(wordIndex == 1){\n\
    \            return tempString\n        }else if(wordIndex == 2){\n          \
    \  return tempString.reverse\n        }else if(wordIndexRight == 1){\n       \
    \     return tempString.reverse\n        }else if(wordIndexRight == 2){\n    \
    \        return tempString\n        }\n        tempString = \"\"\n        var\
    \ wordIndex = 0\n        var wordLength = 0\n        var wordIndexRight = 0\n\
    \        var wordLengthRight = 0\n        for (i <- 0 until word.length-1){\n\
    \            if(vowels.contains(word.charAt(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpapkvqyh6.scala:101:43 --------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m            \e[33mif\e[0m(vowels.contains(word.charAt(\n\
    \e[31m\e[31m    |\e[0m                                           ^\e[0m\n\e[31m\
    \    |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpapkvqyh6.scala:120:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m120 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpapkvqyh6.scala:71:12 ---------------------------\e[0m\e\
    [0m\n\e[31m71 |\e[0m        \e[33mvar\e[0m \e[36mwordIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mwordIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mwordIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpapkvqyh6.scala:72:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m72 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mwordLength\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mwordLength is already defined as \e[33mvariable\e[0m \e[35mwordLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpapkvqyh6.scala:73:12 ---------------------------\e[0m\e[0m\n\e\
    [31m73 |\e[0m        \e[33mvar\e[0m \e[36mwordIndexRight\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mwordIndexRight\
    \ is already defined as \e[33mvariable\e[0m \e[35mwordIndexRight\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpapkvqyh6.scala:74:12 ---------------------------\e[0m\e[0m\n\e[31m74\
    \ |\e[0m        \e[33mvar\e[0m \e[36mwordLengthRight\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e"
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var index = word.length\
    \ - 1\n        var vowelFound = false\n        var vowel : String = \"\"\n   \
    \     while(index >= 0 && !vowelFound) {\n            vowel = word.charAt(index)\n\
    \            if(vowel == \"a\" || vowel == \"e\" || vowel == \"i\" || vowel ==\
    \ \"o\" || vowel == \"u\")\n                vowelFound = true\n            index\
    \ = index - 1\n        }\n        if (index >= 0) {\n            var lastIndex\
    \ = word.length - 1\n            var lastVowel = \"\"\n            while (lastIndex\
    \ >= 0 && !vowelFound) {\n                lastVowel = word.charAt(lastIndex)\n\
    \                if(lastVowel == \"a\" || lastVowel == \"e\" || lastVowel == \"\
    i\" || lastVowel == \"o\" || lastVowel == \"u\")\n                    vowelFound\
    \ = true\n                lastIndex = lastIndex - 1\n            }\n         \
    \   if (lastIndex >= 0) {\n                lastVowel = word.charAt(lastIndex)\n\
    \                if (vowelFound && lastVowel != vowel)\n                    vowel\
    \ = vowel + lastVowel\n            }\n        }\n        return vowel\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlevw__w.scala:23:31\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            vowel = word.charAt(index)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Found:    Char\n\e[31m   |\e[0m                    Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlevw__w.scala:32:39\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                lastVowel = word.charAt(lastIndex)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Found:    Char\n\e[31m   |\e[0m   \
    \                         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphlevw__w.scala:38:39 --------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                lastVowel = word.charAt(lastIndex)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                            Found:    Char\n\e[31m   |\e[0m         \
    \                   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowelList :\
    \ mutable.MutableList[String] = mutable.MutableList[String]()\n        var consonants\
    \ : mutable.MutableList[String] = mutable.MutableList[String]()\n        var vowelLength\
    \ : Int = 0\n        var index : Int = word.length-1\n        var i : Int = word.length\n\
    \        var vowel : String = \"\"\n        while (i >=0  && consonants.isEmpty)\
    \ {\n            if (word.charAt(i) == 'a' || word.charAt(i) == 'e' || word.charAt(i)\
    \ == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u') {\n              \
    \  vowelList.add(word.charAt(i))\n                consonants = word.substring(i+1)\n\
    \            }\n            i -= 1\n        }\n        if (vowelList.isEmpty &&\
    \ vowelLength == 0) return \"\"\n        while (vowelList.isEmpty) {\n       \
    \     vowel = word.charAt(index)\n            if (vowelLength == 0) {\n      \
    \          if (vowel == word.charAt(index)) vowel = word.charAt(index)\n     \
    \       }\n            vowelLength += 1\n            index --\n        }\n   \
    \     var diff : Int = abs(index - consonants.size)\n        if (diff > 0) {\n\
    \            return vowel\n        } else {\n            diff = abs(index - vowelLength)\n\
    \        }\n        if (diff < 0) {\n            return \"\"\n        } else {\n\
    \            vowelList.sort()\n            if (vowelList.isEmpty) return \"\"\n\
    \            vowelList.last()\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_3i6nrz4.scala:39:20 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            index --\n\e[31m\e[31m   |\e[0m         \
    \           ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3i6nrz4.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e\
    [36mvowelList\e[0m : mutable.MutableList[\e[35mString\e[0m] = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3i6nrz4.scala:19:54 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvowelList\e[0m : mutable.MutableList[\e\
    [35mString\e[0m] = mutable.MutableList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                                                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3i6nrz4.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e\
    [36mconsonants\e[0m : mutable.MutableList[\e[35mString\e[0m] = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3i6nrz4.scala:20:55 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mconsonants\e[0m : mutable.MutableList[\e\
    [35mString\e[0m] = mutable.MutableList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       "
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowelList =\
    \ new collection.mutable.ArrayBuffer[Char]()\n        for(i<- word.length-1 to\
    \ 0 by -1){\n            if(word.charAt(i) == 'a' || word.charAt(i) == 'e' ||\
    \ word.charAt(i) == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u'){\n\
    \                vowelList += word.charAt(i)\n            }\n        }\n     \
    \   vowelList.sort( (x,y) => (x.compareTo(y)) )\n        vowelList.reverse.find(_\
    \ == 'a' || _ == 'e' || _ == 'i' || _ == 'o' || _ == 'u').getOrElse(\"\")\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj8d3d1cw.scala:25:18 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        vowelList.sort( (\e[36mx\e[0m,\e[36my\e[0m) =>\
    \ (x.compareTo(y)) )\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue sort is not a member of scala.collection.mutable.ArrayBuffer[Char]\
    \ - did you mean scala.collection.mutable.ArrayBuffer[Char].sortBy?\n\e[31m\e\
    [31m-- [E086] Syntax Error: /tmp/tmpj8d3d1cw.scala:26:31 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        vowelList.reverse.find(_ == \e[31m'a'\e[0m ||\
    \ _ == \e[31m'e'\e[0m || _ == \e[31m'i'\e[0m || _ == \e[31m'o'\e[0m || _ == \e\
    [31m'u'\e[0m).getOrElse(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               Wrong number of parameters, expected:\
    \ 1\n2 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val wordList = word.split(\"\
    \ \")\n        val vowelList = Array(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    )\n        val minLen = math.min(wordList.map(_.length).toInt, vowelList.size)\n\
    \        val vowels = wordList.map(_.toUpperCase).zipWithIndex.filter(_._2 % vowelList.size\
    \ == 0).map(_._1)\n        val vowelPosition = vowels.toSeq.sortBy(-_.length)\n\
    \        vowelPosition.find(_.length == minLen).getOrElse(\"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpumb212mt.scala:21:53 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mminLen\e[0m = math.min(wordList.map(_.length).toInt,\
    \ vowelList.size)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toInt is not a member of Array[Int], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = word.filter(x\
    \ => (x like \"[aeiouAEIOU]\")).map(x => (x + \"y\"))\n        val consonants\
    \ = word.filter(x => (x like \"[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\"\
    )).map(x => (x + \"y\"))\n        if(vowels.isEmpty) {\n            return \"\"\
    \n        }\n        if(consonants.isEmpty) {\n            return vowels.head\n\
    \        }\n        var count = 0\n        while(vowels.head.isLowerCase && consonants.head.isUpperCase\
    \ && vowels.head <= consonants.head && count < vowels.size) {\n            val\
    \ temp = vowels.head\n            vowels.head = consonants.head\n            consonants.head\
    \ = temp\n            count += 1\n        }\n        if(vowels.head < consonants.head\
    \ || vowels.head > consonants.head) {\n            return \"\"\n        }\n  \
    \      vowels.head\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4gs8l7a2.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = word.filter(\e\
    [36mx\e[0m => (x like \e[31m\"[aeiouAEIOU]\"\e[0m)).map(\e[36mx\e[0m => (x + \e\
    [31m\"y\"\e[0m))\n\e[31m\e[31m   |\e[0m                                      \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                                      value like\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4gs8l7a2.scala:20:45\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonants\e[0m = word.filter(\e[36mx\e[0m => (x like \e[31m\"[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\"\
    \e[0m)).map(\e[36mx\e[0m => (x + \e[31m\"y\"\e[0m))\n\e[31m\e[31m   |\e[0m   \
    \                                        ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                              value like is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4gs8l7a2.scala:28:26 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mwhile\e[0m(vowels.head.isLowerCase && consonants.head.isUpperCase\
    \ && vowels.head <= consonants.head && count < vowels.size) {\n\e[31m\e[31m  \
    \ |\e[0m              ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isLowerCase\
    \ is not a member of String - did you mean String.toLowerCase?\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp4gs8l7a2.scala:30:24 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            vowels.head = consonants.head\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        Reassignment to val head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp4gs8l7a2.scala:31:28 -----------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            consonants.head = temp\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val head\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\") \n        val vowelsCount = vowels.toSet.size\n\
    \        val vowelsArray = vowels.toArray.sortWith(_ < _)\n        val vowelsArrayLen\
    \ = vowelsArray.length\n        var index = vowelsArray.length\n        var closestVowel\
    \ = \"\"\n        while (index > 0) {\n            val lastCharIndex = word.lastIndexOfAny(vowelsArray.toArray)\n\
    \            if (lastCharIndex > 0) {\n                val lastChar = word.charAt(lastCharIndex\
    \ - 1)\n                val firstCharIndex = word.indexOfAny(vowelsArray.toArray)\n\
    \                if (firstCharIndex < 0) {\n                    closestVowel =\
    \ \"\"\n                } else {\n                    val firstChar = word.charAt(firstCharIndex)\n\
    \                    if (vowels.contains(firstChar)) {\n                     \
    \   val vowelsCount = vowels.toSet.size\n                        var vowelIndex\
    \ = vowelsArray.indexOfFirst(firstChar)\n                        if (vowelIndex\
    \ == vowelsCount - 1 || vowelIndex == 0) {\n                            closestVowel\
    \ = firstChar\n                        } else {\n                            val\
    \ vowelsCount2 = vowels.toSet.size\n                            var vowelIndex2\
    \ = vowelsArray.indexOfLast(firstChar)\n                            if (vowelIndex2\
    \ == vowelsCount - 1 || vowelIndex2 == 0) {\n                                closestVowel\
    \ = firstChar\n                            } else {\n                        \
    \        val vowelsCount3 = vowels.toSet.size\n                              \
    \  var vowelIndex3 = vowelsArray.indexOfMiddle(firstChar)\n                  \
    \              if (vowelIndex3 == vowelsCount - 1 || vowelIndex3 == 0) {\n   \
    \                                 closestVowel = firstChar\n                 \
    \               }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n            index -=\
    \ 1\n        }\n        return closestVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpazt8tav3.scala:26:37 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mlastCharIndex\e[0m =\
    \ word.lastIndexOfAny(vowelsArray.toArray)\n\e[31m\e[31m   |\e[0m            \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndexOfAny\
    \ is not a member of String - did you mean word.lastIndexOf?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpazt8tav3.scala:29:42 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mfirstCharIndex\e[0m =\
    \ word.indexOfAny(vowelsArray.toArray)\n\e[31m\e[31m   |\e[0m                \
    \                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value indexOfAny is\
    \ not a member of String - did you mean word.indexOf?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpazt8tav3.scala:34:40 --------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                    \e[33mif\e[0m (vowels.contains(firstChar))\
    \ {\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    (firstChar\
    \ : Char)\n\e[31m   |\e[0m                                        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpazt8tav3.scala:36:53\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        \e\
    [33mvar\e[0m \e[36mvowelIndex\e[0m = vowelsArray.indexOfFirst(firstChar)\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value indexOfFirst is not a member of\
    \ Array[String]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpazt8tav3.scala:38:43\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                            closestVowel\
    \ = firstChar\n\e[31m\e[31m   |\e[0m                                         \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                           Found:\
    \    (firstChar : Char)\n\e[31m   |\e[0m                                     \
    \      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation "
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val vowelArray = word.split(\"\").map(x\
    \ => vowels.contains(x))\n        val vowelIndexs = vowelArray.zipWithIndex.filter(x\
    \ => x._2).map(x => x._1)\n        val vowelIndexMap = vowelIndexs.groupBy(x =>\
    \ x).map(x => (x._1, x._2.max))\n        val consonants = Array(\"b\",\"c\",\"\
    d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"\
    t\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val consonantArray = word.split(\"\
    \").map(x => consonants.contains(x))\n        val consonantIndexs = consonantArray.zipWithIndex.filter(x\
    \ => x._2).map(x => x._1)\n        val consonantIndexMap = consonantIndexs.groupBy(x\
    \ => x).map(x => (x._1, x._2.max))\n        if(vowelIndexMap.isEmpty || consonantIndexMap.isEmpty)\
    \ {\n            return \"\"\n        }\n        var closest = vowelIndexMap.map(_._2).max\n\
    \        var closestVowel = closest\n        if(closest == 0) {\n            closest\
    \ = consonantIndexMap.map(_._2).max\n            closestVowel = closest\n    \
    \    }\n        var lastVowel = closestVowel\n        var lastClosest = closest\n\
    \        var lastVowelIndex = 0\n        var lastConsonantIndex = 0\n        var\
    \ vowel = lastVowel\n        var consonant = lastConsonant\n        for(x <- 1\
    \ to closest) {\n            if(vowelIndexMap(vowelIndexMap.length - 1)._2 !=\
    \ 0) {\n                consonantIndexMap(consonantIndexMap.length - 1)._2 -=\
    \ 1\n            } else {\n                consonantIndexMap(consonantIndexMap.length\
    \ - 1)._2 += 1\n            }\n            val vIndex = consonantIndexMap.get(vowel)\n\
    \            val cIndex = consonantIndexMap.get(consonant)\n            if(vIndex\
    \ < cIndex) {\n                vowel = vowelIndexMap.get(vowel)._1\n         \
    \       consonant = consonantIndexMap.get(consonant)._1\n            } else {\n\
    \                vowel = vowelIndexMap.get(consonant)._1\n                consonant\
    \ = consonantIndexMap.get(vowel)._1\n            }\n            val newVowelIndex\
    \ = 0\n            val newConsonantIndex = 0\n            if(vowelIndexMap.get(vowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0mqsy2n1.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0mqsy2n1.scala:78:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp0mqsy2n1.scala:21:64 --------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelIndexs\e[0m = vowelArray.zipWithIndex.filter(\e\
    [36mx\e[0m => x._2).map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m         \
    \                                                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                                                       Found:    Int\n\e[31m\
    \   |\e[0m                                                       Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0mqsy2n1.scala:25:72\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mconsonantIndexs\e\
    [0m = consonantArray.zipWithIndex.filter(\e[36mx\e[0m => x._2).map(\e[36mx\e[0m\
    \ => x._1)\n\e[31m\e[31m   |\e[0m                                            \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                               Found:    Int\n\e[31m   |\e[0m               \
    \                                        Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp0mqsy2n1.scala:32:11 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m(closest == \e[31m0\e[0m) {\n\e\
    [31m\e[31m   |\e[0m           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Boolean and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0mqsy2n1.scala:41:24 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mconsonant\e[0m = lastConsonant\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009805
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var index = word.lastIndexOf(\"\
    a\");\n        index += 1;\n        val found = word.lastIndexOf(\"u\");\n   \
    \     val found2 = word.lastIndexOf(\"e\");\n        val found3 = word.lastIndexOf(\"\
    i\");\n        val found4 = word.lastIndexOf(\"o\");\n        val found5 = word.lastIndexOf(\"\
    u\");\n        val found6 = word.lastIndexOf(\"i\");\n        if(found < found2\
    \ && found < found3 && found < found4 && found < found5 && found < found6){\n\
    \            return word.substring(found,index) + \"U\";\n        }\n        if(found2\
    \ < found && found2 < found3 && found2 < found4 && found2 < found5 && found2 <\
    \ found6){\n            return word.substring(found2,index) + \"E\";\n       \
    \ }\n        if(found3 < found && found3 < found2 && found3 < found4 && found3\
    \ < found5 && found3 < found6){\n            return word.substring(found3,index)\
    \ + \"I\";\n        }\n        if(found4 < found && found4 < found2 && found4\
    \ < found3 && found4 < found5 && found4 < found6){\n            return word.substring(found4,index)\
    \ + \"O\";\n        }\n        if(found5 < found && found5 < found2 && found5\
    \ < found3 && found5 < found4 && found5 < found6){\n            return word.substring(found5,index)\
    \ + \"U\";\n        }\n        if(found6 < found && found6 < found2 && found6\
    \ < found3 && found6 < found4 && found6 < found5){\n            return word.substring(found6,index)\
    \ + \"I\";\n        }\n        return \"\";\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpowdn1kh2.scala:48)\n\tat Problem.main(tmpowdn1kh2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = scala.collection.mutable.MutableSet.empty[String]\n\
    \        for {\n            i <- 0 until word.length\n        } yield {\n    \
    \        val c = word.charAt(i)\n            if (c.toUpper != \"A\" && c.toUpper\
    \ != \"E\" && c.toUpper != \"I\" && c.toUpper != \"O\" && c.toUpper != \"U\")\n\
    \            vowels += c\n        }\n        vowels.toList.reverse.takeWhile(_\
    \ != \"U\").lastOption.getOrElse(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk2py9t8u.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = scala.collection.mutable.MutableSet.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value MutableSet is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- Error: /tmp/tmpk2py9t8u.scala:24:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (c.toUpper != \e[31m\"A\"\e\
    [0m && c.toUpper != \e[31m\"E\"\e[0m && c.toUpper != \e[31m\"I\"\e[0m && c.toUpper\
    \ != \e[31m\"O\"\e[0m && c.toUpper != \e[31m\"U\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpk2py9t8u.scala:24:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \     \e[33mif\e[0m (c.toUpper != \e[31m\"A\"\e[0m && c.toUpper != \e[31m\"E\"\
    \e[0m && c.toUpper != \e[31m\"I\"\e[0m && c.toUpper != \e[31m\"O\"\e[0m && c.toUpper\
    \ != \e[31m\"U\"\e[0m)\n\e[31m\e[31m   |\e[0m                                \
    \    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpk2py9t8u.scala:24:56\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \     \e[33mif\e[0m (c.toUpper != \e[31m\"A\"\e[0m && c.toUpper != \e[31m\"E\"\
    \e[0m && c.toUpper != \e[31m\"I\"\e[0m && c.toUpper != \e[31m\"O\"\e[0m && c.toUpper\
    \ != \e[31m\"U\"\e[0m)\n\e[31m\e[31m   |\e[0m                                \
    \                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpk2py9t8u.scala:24:76 -----------------------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (c.toUpper != \e[31m\"A\"\e[0m &&\
    \ c.toUpper != \e[31m\"E\"\e[0m && c.toUpper != \e[31m\"I\"\e[0m && c.toUpper\
    \ != \e[31m\"O\"\e[0m && c.toUpper != \e[31m\"U\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                    "
  stdout: ''
  timestamp: 1660009803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var count = 0\n\
    \        var result = 0\n        val list = new mutable.ListBuffer[String]()\n\
    \        val wordArray = word.split(\"\")\n        for(i <- 0 until wordArray.length-1)\
    \ {\n            for(j <- 0 until wordArray.length-1) {\n                val firstLetter\
    \ = wordArray(i)\n                val secondLetter = wordArray(j)\n          \
    \      val currentLetter = if (i < j) wordArray(i) else wordArray(j)\n       \
    \         if (firstLetter != secondLetter && currentLetter == \"a\" && firstLetter\
    \ == \"A\") count = count + 1\n                if (firstLetter != secondLetter\
    \ && currentLetter == \"e\" && firstLetter == \"E\") count = count + 1\n     \
    \           if (firstLetter != secondLetter && currentLetter == \"i\" && firstLetter\
    \ == \"I\") count = count + 1\n                if (firstLetter != secondLetter\
    \ && currentLetter == \"o\" && firstLetter == \"O\") count = count + 1\n     \
    \           if (firstLetter != secondLetter && currentLetter == \"u\" && firstLetter\
    \ == \"U\") count = count + 1\n            }\n        }\n        if (count > 0)\
    \ result = if (count >= 5) 1 else 1\n        else result = \"\"\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_6k4yid.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_6k4yid.scala:36:22\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33melse\e[0m result\
    \ = \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    (\e[32m\"\"\e[0m : String)\n\e[31m \
    \  |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpv_6k4yid.scala:37:15 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        result.mkString\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value mkString is not a member of\
    \ Int - did you mean Int.toString?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var bestVowel =\
    \ \"\";\n        var bestUpper = 0;\n        var bestLower = 0;\n        var vowel\
    \ = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var vowels = List(\"a\",\
    \ \"e\", \"i\", \"o\", \"u\")\n        var vowelLower = \"eiyoou\"\n        var\
    \ vowelUpper = \"AIU\"\n        var vowelLowerIndex = 0\n        var vowelUpperIndex\
    \ = 0\n        var vowelIndex = 0\n        var vowelVowelIndex = -1\n        var\
    \ vowelIndexUpper = 0\n        var vowelIndexLower = 0\n        var lowerIndex\
    \ = -1\n        var upperIndex = -1\n        var vowelVowel = List(\"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n        var vowelVowelIndex = -1\n        var vowelVowelIndexUpper\
    \ = 0\n        var vowelVowelIndexLower = 0\n        var lowerIndexUpper = -1\n\
    \        var lowerIndexLower = -1\n        for(i <- 0 until word.length-1){\n\
    \            val cons = word.charAt(i).toInt\n            vowelIndex += cons\n\
    \            vowelIndexUpper += cons\n            vowelIndexLower += cons\n  \
    \          vowelVowelIndex += cons\n            vowelVowelIndexUpper += cons\n\
    \            vowelVowelIndexLower += cons\n            lowerIndex += cons\n  \
    \          lowerIndexUpper += cons\n            lowerIndexLower += cons\n    \
    \        vowelVowelIndex += cons\n            vowelVowelIndexUpper += cons\n \
    \           vowelVowelIndexLower += cons\n        }\n        if(vowelIndex !=\
    \ -1){\n            for(i <- 0 until word.length-1){\n                val cons\
    \ = word.charAt(i).toInt\n                if(vowel.contains(word.charAt(i))){\n\
    \                    if(vowelIndexUpper == cons || vowelIndexLower == cons){\n\
    \                        bestUpper = vowelIndexUpper\n                       \
    \ bestLower = vowelIndexLower\n                        bestVowel = vowel.indexOf(vowel.indexOf(word.charAt(i)))\n\
    \                    }\n                }\n                if(vowelVowel.contains(word.charAt(i))){\n\
    \                    if(vowelVowelIndexUpper == cons || vowelVowelIndexLower ==\
    \ cons){\n                        bestUpper = vowelVowelIndexUpper\n         \
    \               bestLower = vowelVowelIndexLower\n                        bestVowel\
    \ = vowelVowel.indexOf(vowelVowel.indexOf(word.charAt(i)))\n                 \
    \   }\n                }\n                if(vowelLower.contains(word.charAt(i))){\n\
    \                    if(vowelIndexUpper == cons || vowelIndexLower == cons){\n\
    \                        bestUpper = vowelIndexUpper\n                       \
    \ bestLower = \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbxqwdi3u.scala:75:35 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m                        bestLower = \n\e[31m\e[31m  \
    \ |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m           \
    \                        expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbxqwdi3u.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbxqwdi3u.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mvowelVowelIndex\e[0m = -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelVowelIndex is already defined as \e[33mvariable\e[0m\
    \ \e[35mvowelVowelIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbxqwdi3u.scala:62:49 --------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m                        bestVowel = vowel.indexOf(vowel.indexOf(word.charAt(i)))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Int\n\e[31m\
    \   |\e[0m                                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbxqwdi3u.scala:69:54 --------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m                        bestVowel = vowelVowel.indexOf(vowelVowel.indexOf(word.charAt(i)))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Int\n\e[31m\
    \   |\e[0m                                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain"
  stdout: ''
  timestamp: 1660009803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var start = 0\n        var end = word.length\
    \ - 1\n        while(start < end) {\n            var middle = (start + end) /\
    \ 2\n            if(vowels.contains(word.substring(middle + 1, middle + 4).toLowerCase\
    \ )) {\n                end = middle\n            } else {\n                start\
    \ = middle + 1\n            }\n        }\n        \n        \n        var vowel\
    \ = word.substring(end + 1, word.length)\n        vowel = vowel.toLowerCase \n\
    \        vowel = vowel.substring(0,vowel.length-1)\n        \n        if(vowel\
    \ != \"\") {\n            return vowel\n        }\n        \n        return \"\
    \"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 5, end 8, length 6\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.getClosestVowel(tmpqrphph81.scala:24)\n\tat Problem$.main(tmpqrphph81.scala:43)\n\
    \tat Problem.main(tmpqrphph81.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // initialize result\
    \ string\n        var result = \"\"\n        // initialize vowel index\n     \
    \   var vowelIndex = 0\n        // iterate through word backward\n        for(i\
    \ <- word.length-1 to 1 by -1){\n            // if current character is a vowel,\
    \ increment vowel index\n            if(word.charAt(i) == 'A' || word.charAt(i)\
    \ == 'E' || word.charAt(i) == 'I' || word.charAt(i) == 'O' || word.charAt(i) ==\
    \ 'U'){\n                vowelIndex = i\n            }\n            // if current\
    \ character is a consonant, compare current vowel index to consonant index\n \
    \           else{\n                if(vowelIndex > 0 && vowelIndex < i){\n   \
    \                 val closestVowel = word.charAt(vowelIndex+1)\n             \
    \       val vowelToBeClosest = word.charAt(vowelIndex-1)\n                   \
    \ val isVowel = vowelToBeClosest.equals(closestVowel)\n                    //\
    \ check if previous char is a vowel\n                    if(word.charAt(vowelIndex-1)\
    \ == 'A' || word.charAt(vowelIndex-1) == 'E' || word.charAt(vowelIndex-1) == 'I'\
    \ || word.charAt(vowelIndex-1) == 'O' || word.charAt(vowelIndex-1) == 'U'){\n\
    \                        // check if the previous vowel index is valid\n     \
    \                   if(vowelIndex > 0 && vowelIndex < i){\n                  \
    \          // get the closest vowel\n                            val closestVowel\
    \ = word.charAt(vowelIndex+1)\n                            // check if we found\
    \ a vowel that's a little closer to last vowel\n                            if(closestVowel.isUpperCase\
    \ && !isVowel){\n                                result = closestVowel\n     \
    \                           vowelIndex = vowelIndex\n                        \
    \    } else {\n                                result = \"\"\n               \
    \             }\n                        } else {\n                          \
    \  result = \"\"\n                        }\n                    } else {\n  \
    \                      result = \"\"\n                    }\n                }\
    \ else {\n                    result = \"\"\n                }\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgnyu59k7.scala:42:44 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                            \e[33mif\e[0m(closestVowel.isUpperCase\
    \ && !isVowel){\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value isUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgnyu59k7.scala:43:41\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                            \
    \    result = closestVowel\n\e[31m\e[31m   |\e[0m                            \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \            Found:    (closestVowel : Char)\n\e[31m   |\e[0m                \
    \                         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = \"a\"\
    ;\n        var vowelPos = 0\n        val vowels = \"aeiou\";\n        for ( i\
    \ <- word.length - 1 until word.length ) {\n            if ( vowels.contains(word.charAt(i).toLowerCase())\
    \ ) {\n                vowel = word.charAt(i)\n                vowelPos = i\n\
    \            }\n        }\n        for ( i <- vowelPos until word.length ) {\n\
    \            if ( vowels.contains(word.charAt(i).toLowerCase()) ) {\n        \
    \        if (word.charAt(i).toLowerCase() != vowel) {\n                    return\
    \ \"\";\n                }\n            }\n        }\n        return vowel\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphifwdtpu.scala:23:48 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m ( vowels.contains(word.charAt(i).toLowerCase())\
    \ ) {\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphifwdtpu.scala:24:35\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                vowel = word.charAt(i)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    Char\n\e[31m   |\e[0m                   \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphifwdtpu.scala:29:48\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m\
    \ ( vowels.contains(word.charAt(i).toLowerCase()) ) {\n\e[31m\e[31m   |\e[0m \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphifwdtpu.scala:30:35 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m (word.charAt(i).toLowerCase()\
    \ != vowel) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value toLowerCase is not a member of Char\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val vowelsMap = vowels.toMap\n     \
    \   val consonants = Array(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\")\n        val consonantsMap = consonants.toMap\n        val\
    \ lastVowel = vowels.last\n        val lastConsonant = consonants.last\n     \
    \   word.sliding(2).map(s => vowelsMap(s(0) + lastVowel)) \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgxqdijjj.scala:20:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m = vowels.toMap\n\
    \e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    Cannot prove that String <:< (K, V)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                                    where:    K\
    \ is a type variable\n\e[31m   |\e[0m                                        \
    \      V is a type variable\n\e[31m   |\e[0m                                 \
    \   .\n\e[31m\e[31m-- Error: /tmp/tmpgxqdijjj.scala:22:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mconsonantsMap\e[0m = consonants.toMap\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                     Cannot prove that String <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                     where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \            V is a type variable\n\e[31m   |\e[0m                           \
    \          .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgxqdijjj.scala:25:27\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        word.sliding(\e[31m2\e\
    [0m).map(\e[36ms\e[0m => vowelsMap(s(\e[31m0\e[0m) + lastVowel)) \n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Iterator[Nothing]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Solution code\
    \ goes here\n        val vowels = \"aeiouAEIOU\"\n        var result : String\
    \ = \"\"\n        var start : Int = 0\n        var index : Int = word.length\n\
    \        while(index > 0) {\n            val firstChar = word.charAt(start - 1)\n\
    \            if (vowels.contains(firstChar)) start -= 1 \n            else break\n\
    \        }\n        while(index > 0) {\n            val firstChar = word.charAt(start)\n\
    \            if (vowels.contains(firstChar)) break\n            else index -=\
    \ 1\n        }\n        val end = word.size - 1\n        while(end > 0) {\n  \
    \          val firstChar = word.charAt(end)\n            if (vowels.contains(firstChar))\
    \ end -= 1\n            else break\n        }\n        for(i <- start until end)\
    \ {\n            val firstChar = word.charAt(i)\n            if (vowels.contains(firstChar))\
    \ result = vowels.toString.substring(start, end) + result \n            else result\
    \ = \"\" + result \n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgbxhgtd3.scala:27:17 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33melse\e[0m break\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgbxhgtd3.scala:31:44\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m\
    \ (vowels.contains(firstChar)) break\n\e[31m\e[31m   |\e[0m                  \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                     Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgbxhgtd3.scala:37:48 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (vowels.contains(firstChar)) end\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                  value -= is not a member\
    \ of Int - did you mean end.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgbxhgtd3.scala:38:17\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33melse\e\
    [0m break\n\e[31m\e[31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // write your code\
    \ here\n        var vowels = \"aeiouAEIOU\"\n        var finalVowel = \"\"\n \
    \       var tempVowel = \"\"\n        var tempStr = \"\"\n        val lengthWord\
    \ = word.length\n        var i = 0\n        while (i < lengthWord) {\n       \
    \     tempVowel = word.substring(i, i + 1)\n            if (vowels.contains(tempVowel))\
    \ {\n                tempStr = word.substring(0, i)\n                finalVowel\
    \ = tempStr.substring(tempStr.length - tempVowel.length, 1)\n                i\
    \ = tempStr.lastIndexOf(finalVowel)\n                if (i < 0) {\n          \
    \          i = lengthWord\n                }\n            } else {\n         \
    \       i = i + 1\n            }\n        }\n        return finalVowel\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word.isEmpty)\
    \ {\n            return \"\"\n        }\n        val vowels = Array('a', 'e',\
    \ 'i', 'o', 'u')\n        var minDistance = 0\n        var index = word.length\
    \ - 1\n        while (index >= 0) {\n            val c = word.charAt(index)\n\
    \            if (vowels.contains(c)) {\n                minDistance = index -\
    \ c\n            }\n            index -= 1\n        }\n        minDistance < word.length\
    \ match {\n            case false => \"\"\n            case true => {\n      \
    \          val startIndex = minDistance - 1\n                val endIndex = minDistance\
    \ + word.charAt(minDistance).length\n                val result = word.substring(startIndex,\
    \ endIndex)\n                return result\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptwa5eiha.scala:36:70 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mendIndex\e[0m =\
    \ minDistance + word.charAt(minDistance).length\n\e[31m\e[31m   |\e[0m       \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value length is not a member\
    \ of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"\
    e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        val vowelsHash\
    \ = vowels.foldLeft(Map[Char,Int]())((map, char) => map + (char -> (map.getOrElse(char,\
    \ 0) + 1)));\n        val consonants = List(\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        val consonantsHash = consonants.foldLeft(Map[Char,Int]())((map,\
    \ char) => map + (char -> (map.getOrElse(char, 0) + 1)));\n        val vowelsCount\
    \ = vowelsHash.filter(_._2 > 0).map(_._1).length\n        val consonantsCount\
    \ = consonantsHash.filter(_._2 > 0).map(_._1).length\n\n        if (vowelsCount\
    \ == 0){\n            return \"\"\n        }\n\n        if (vowelsCount == 1){\n\
    \            return vowelsHash.maxBy(_._1)\n        }\n        if (vowelsCount\
    \ == 2){\n            return vowelsHash.maxBy(_._1).filter(_._2 > 1).head\n  \
    \      }\n\n        val consonantsVowelsCount = vowelsCount + consonantsCount\
    \ - vowelsHash.filter(_._2 > 0).map(_._1).length\n        var closestVowel = vowelsHash.maxBy(_._1)\n\
    \        if (consonantsVowelsCount > 0){\n            val difference = consonantsHash.filter(_._2\
    \ > 0).map(_._1) - vowelsHash.filter(_._2 > 0).map(_._1)\n            if (consonantsHash.filter(_._2\
    \ > 0).map(_._1) < vowelsHash.filter(_._2 > 0).map(_._1)){\n                closestVowel\
    \ = vowelsHash.maxBy(_._1)\n            }\n            val vowelIndex = (vowelsHash.filter(_._2\
    \ > 0).map(_._1) - vowelsHash.filter(_._2 > 0).map(_._1)) + consonantsHash.filter(_._2\
    \ > 0).map(_._1) - difference\n            closestVowel = vowels(vowelIndex)\n\
    \        }\n        return closestVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp778czm1s.scala:20:103\
    \ -------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsHash\e\
    [0m = vowels.foldLeft(Map[\e[35mChar\e[0m,\e[35mInt\e[0m]())((\e[36mmap\e[0m,\
    \ \e[36mchar\e[0m) => map + (char -> (map.getOrElse(char, \e[31m0\e[0m) + \e[31m1\e\
    [0m)));\n\e[31m\e[31m   |\e[0m                                               \
    \                                                        ^^^^\e[0m\n\e[31m   |\e\
    [0m                                               Found:    (char : String)\n\e\
    [31m   |\e[0m                                               Required: Char\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp778czm1s.scala:22:111\
    \ -------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mconsonantsHash\e\
    [0m = consonants.foldLeft(Map[\e[35mChar\e[0m,\e[35mInt\e[0m]())((\e[36mmap\e\
    [0m, \e[36mchar\e[0m) => map + (char -> (map.getOrElse(char, \e[31m0\e[0m) + \e\
    [31m1\e[0m)));\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    (char\
    \ : String)\n\e[31m   |\e[0m                                               Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp778czm1s.scala:23:64\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelsCount\e[0m = vowelsHash.filter(_._2 > \e[31m0\e[0m).map(_._1).length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m value length is not a member of scala.collection.mutable.Iterable[Char]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp778czm1s.scala:24:72 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mconsonantsCount\e[0m = consonantsHash.filter(_._2\
    \ > \e[31m0\e[0m).map(_._1).length\n\e[31m\e[31m   |\e[0m                    \
    \          ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def getVowels(word\
    \ : String) : List[Char] = \n            word.chars.toList.filter(_ == 'a' ||\
    \ _ == 'e' || _ == 'i' || _ == 'o' || _ == 'u')\n        val vowels = getVowels(word).sort\n\
    \        (vowels.dropRight(2)).headOption.getOrElse(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0er9gdfu.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            word.chars.toList.filter(_ == \e[31m'a'\e\
    [0m || _ == \e[31m'e'\e[0m || _ == \e[31m'i'\e[0m || _ == \e[31m'o'\e[0m || _\
    \ == \e[31m'u'\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value toList is not a member of java.util.stream.IntStream\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0er9gdfu.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = getVowels(word).sort\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue sort is not a member of List[Char], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = word.charAt(word.length-1)\n\
    \        val vowels = \"aeiouAEIOU\".toList\n        var vowelIndex = vowels.indexOf(vowel)\n\
    \        val vowelIndex = vowels.index(vowel)\n        var vowelCount = vowels.length\n\
    \        var startVowelIndex = vowelIndex - 1\n        var endVowelIndex = vowelIndex\
    \ + vowelCount\n        var startVowel = vowels.take(vowelIndex).toString\n  \
    \      var endVowel = vowels.drop(vowelIndex).toString\n        var startVowelCount\
    \ = startVowelIndex - 1\n        var endVowelCount = startVowelIndex + startVowelCount\n\
    \        var startVowelString = vowels.take(startVowelIndex).toString\n      \
    \  var endVowelString = vowels.drop(startVowelIndex).toString\n        var endVowelCount\
    \ = endVowelIndex + endVowelCount\n        \n        if (startVowelCount < 0)\
    \ {\n            val startVowelCount = startVowelIndex\n            startVowel\
    \ = vowels.take(startVowelIndex).toString\n            startVowelString = vowels.take(startVowelIndex).toString\n\
    \        }\n        if (endVowelCount < 0) {\n            val endVowelCount =\
    \ endVowelIndex\n            endVowel = vowels.drop(endVowelIndex).toString\n\
    \            endVowelString = vowels.drop(endVowelIndex).toString\n        }\n\
    \n        if (startVowelCount < endVowelCount && (vowel == vowels.take(vowelIndex)\
    \ || vowel == vowels.drop(vowelIndex)) && startVowel != endVowel) {\n        \
    \    vowel = vowels.take(vowelIndex).toString\n            vowelString = vowels.take(vowelIndex).toString\n\
    \        }\n        if (startVowelCount > endVowelCount && (vowel == vowels.take(endVowelIndex)\
    \ || vowel == vowels.drop(endVowelIndex)) && startVowel != endVowel) {\n     \
    \       vowel = vowels.take(endVowelIndex).toString\n            vowelString =\
    \ vowels.take(endVowelIndex).toString\n        }\n        if (startVowelCount\
    \ < endVowelCount && startVowel != endVowel) {\n            val startIndex = startVowelIndex\n\
    \            var endIndex = startVowelIndex + startVowelCount\n            if\
    \ (endVowelCount < startVowelCount) {\n                endIndex = startVowelIndex\
    \ + start\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg_kmu375.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg_kmu375.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvowelIndex\e[0m = vowels.index(vowel)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelIndex is already defined as \e[33mvariable\e[0m \e[35mvowelIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg_kmu375.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mvar\e[0m \e[36mendVowelCount\e[0m = endVowelIndex +\
    \ endVowelCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mendVowelCount is already defined as \e[33mvariable\e[0m \e\
    [35mendVowelCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ Error: /tmp/tmpg_kmu375.scala:45:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mif\e[0m (startVowelCount < endVowelCount\
    \ && (vowel == vowels.take(vowelIndex) || vowel == vowels.drop(vowelIndex)) &&\
    \ startVowel != endVowel) {\n\e[31m\e[31m   |\e[0m                           \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \   Values of types Char and List[Char] cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpg_kmu375.scala:45:84 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mif\e[0m (startVowelCount < endVowelCount\
    \ && (vowel == vowels.take(vowelIndex) || vowel == vowels.drop(vowelIndex)) &&\
    \ startVowel != endVowel) {\n\e[31m\e[31m   |\e[0m                           \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Char and List[Char] cannot be compared\
    \ with == or !=\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Your code goes\
    \ here\n        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var\
    \ vowel = \"\"\n        val vowel_count = word.count(_.toLowerCase == _)\n   \
    \     if(vowel_count == 1) vowel = word.charAt(word.length-1)\n        if(vowel_count\
    \ == 2) vowel = vowels.find(_.toLowerCase == word.substring(word.length-2,word.length))\n\
    \        if(vowel_count == 3) vowel = vowels.find(_.toLowerCase == word.substring(word.length-3,word.length))\n\
    \        if(vowel_count == 4) vowel = vowels.find(_.toLowerCase == word.substring(word.length-4,word.length))\n\
    \        if(vowel_count == 5) vowel = vowels.find(_.toLowerCase == word.substring(word.length-5,word.length))\n\
    \        if(vowel_count == 6) vowel = vowels.find(_.toLowerCase == word.substring(word.length-6,word.length))\n\
    \        if(vowel_count == 7) vowel = vowels.find(_.toLowerCase == word.substring(word.length-7,word.length))\n\
    \        if(vowel_count == 8) vowel = vowels.find(_.toLowerCase == word.substring(word.length-8,word.length))\n\
    \        if(vowel_count == 9) vowel = vowels.find(_.toLowerCase == word.substring(word.length-9,word.length))\n\
    \        if(vowel_count == 10) vowel = vowels.find(_.toLowerCase == word.substring(word.length-10,word.length))\n\
    \        if(vowel_count == 11) vowel = vowels.find(_.toLowerCase == word.substring(word.length-11,word.length))\n\
    \        if(vowel_count == 12) vowel = vowels.find(_.toLowerCase == word.substring(word.length-12,word.length))\n\
    \        if(vowel_count == 13) vowel = vowels.find(_.toLowerCase == word.substring(word.length-13,word.length))\n\
    \        if(vowel_count == 14) vowel = vowels.find(_.toLowerCase == word.substring(word.length-14,word.length))\n\
    \        if(vowel_count == 15) vowel = vowels.find(_.toLowerCase == word.substring(word.length-15,word.length))\n\
    \        if(vowel_count == 16) vowel = vowels.find(_.toLowerCase == word.substring(word.length-16,word.length))\n\
    \        if(vowel_count == 17) vowel = vowels.find(_.toLowerCase == word.substring(word.length-17,word.length))\n\
    \        if(vowel_count == 18) vowel = vowels.find(_.toLowerCase == word.substring(word.length-18,word.length))\n\
    \        if(vowel_count == 19) vowel = vowels.find(_.toLowerCase == word.substring(word.length-19,word.length))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpk9feveqt.scala:22:37 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mvowel_count\e[0m = word.count(_.toLowerCase\
    \ == _)\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9feveqt.scala:23:48\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m(vowel_count\
    \ == \e[31m1\e[0m) vowel = word.charAt(word.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Found:    Char\n\e[31m   |\e\
    [0m                                     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9feveqt.scala:24:48 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m(vowel_count == \e[31m2\e[0m) vowel\
    \ = vowels.find(_.toLowerCase == word.substring(word.length-\e[31m2\e[0m,word.length))\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    \e[1m\e[31mOption\e\
    [0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                 \
    \                    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpk9feveqt.scala:25:48 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mif\e[0m(vowel_count == \e[31m3\e[0m) vowel =\
    \ vowels.find(_.toLowerCase == word.substring(word.length-\e[31m3\e[0m,word.length))\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    \e[1m\e[31mOption\e\
    [0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                 \
    \                 "
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = mutable.List(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        val vowelsCounts = mutable.Map(\"\
    a\" -> 0, \"e\" -> 0, \"i\" -> 0, \"o\" -> 0, \"u\" -> 0, \"y\" -> 0)\n      \
    \  val vowelsIndex = word.zipWithIndex.filter(_._1 != 'y').filter(_._1.toLowerCase\
    \ == 'u').map(_._2).max\n        vowels.find(_.toLowerCase.contains(vowelsIndex.toString))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbb48ji3s.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.List(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m, \e[31m\"y\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpbb48ji3s.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsCounts\e[0m = mutable.Map(\e\
    [31m\"a\"\e[0m -> \e[31m0\e[0m, \e[31m\"e\"\e[0m -> \e[31m0\e[0m, \e[31m\"i\"\e\
    [0m -> \e[31m0\e[0m, \e[31m\"o\"\e[0m -> \e[31m0\e[0m, \e[31m\"u\"\e[0m -> \e\
    [31m0\e[0m, \e[31m\"y\"\e[0m -> \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbb48ji3s.scala:21:76\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelsIndex\e[0m = word.zipWithIndex.filter(_._1 != \e[31m'y'\e[0m).filter(_._1.toLowerCase\
    \ == \e[31m'u'\e[0m).map(_._2).max\n\e[31m\e[31m   |\e[0m                    \
    \                                                   ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n3 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val consonants = Set(\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val vowelsToRemove\
    \ = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var i = 0\n        var j =\
    \ word.length-1\n        var closestVowel = \"\"\n        while(i < j){\n    \
    \        val currVowel = word.charAt(i).toLowerCase\n            if(vowels.contains(currVowel)){\n\
    \                if(closestVowel == \"\"){\n                    closestVowel =\
    \ currVowel\n                }else{\n                    val currVowelLoc = vowels.indexOf(currVowel)\n\
    \                    val closestVowelLoc = vowels.indexOf(closestVowel)\n    \
    \                val currVowelIndex = currVowelLoc+i\n                    val\
    \ closestVowelIndex = closestVowelLoc+i\n                    if(currVowelIndex\
    \ < closestVowelIndex){\n                        closestVowel = currVowel\n  \
    \                  }else if(currVowelIndex > closestVowelIndex){\n           \
    \             closestVowel = closestVowel\n                    }else{\n      \
    \                  closestVowel = closestVowel\n                    }\n      \
    \          }\n                j -= 1\n            }else if(consonants.contains(currVowel)){\n\
    \                j -= 1\n            }else{\n                i += 1\n        \
    \    }\n        }\n        if(closestVowel == \"\"){\n            closestVowel\
    \ = \"\"\n        }\n        closestVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb72swwsy.scala:26:43 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mcurrVowel\e[0m = word.charAt(i).toLowerCase\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value toLowerCase is not a member\
    \ of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Your code goes\
    \ here\n        if(word.length > 1) {\n            val vowels = \"aeiouAEIOU\"\
    \n            val consonants = \"bcdfghjklmnpqrstvwxyz\"\n            val vowelIndex\
    \ = 0\n            val leftIndex = 0\n            val rightIndex = word.length\
    \ - 1\n            val left = word.substring(0, leftIndex)\n            val right\
    \ = word.substring(rightIndex + 1)\n            val result: String = word\n  \
    \          for (consonantIndex \u2190 1 to rightIndex - 1) {\n               \
    \ if (consonants.contains(left.charAt(consonantIndex))) {\n                  \
    \  val vowelIndex = consonants.indexOf(left.charAt(consonantIndex))\n        \
    \            if (vowelIndex != -1) {\n                        val leftVowelIndex\
    \ = vowels.indexOf(left.charAt(vowelIndex))\n                        val rightVowelIndex\
    \ = vowels.indexOf(right.charAt(consonantIndex))\n                        if (leftVowelIndex\
    \ != -1 && rightVowelIndex != -1) {\n                            val distance\
    \ = leftVowelIndex - rightVowelIndex\n                            if (distance\
    \ < 0)\n                                distance * -1\n                      \
    \      else if (distance == 0)\n                                \"\"\n       \
    \                     else if (distance > 0)\n                               \
    \ vowels(vowelIndex + distance)\n                        }\n                 \
    \   }\n                }\n            }\n        }\n        else\n           \
    \ \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7hd198ho.scala:29:12\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mfor\e[0m (consonantIndex\
    \ \u2190 \e[31m1\e[0m to rightIndex - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m \
    \           ^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m   |\e[0m\
    \            Required: String\n\e[31m30 |\e[0m                \e[33mif\e[0m (consonants.contains(left.charAt(consonantIndex)))\
    \ {\n\e[31m31 |\e[0m                    \e[33mval\e[0m \e[36mvowelIndex\e[0m =\
    \ consonants.indexOf(left.charAt(consonantIndex))\n\e[31m32 |\e[0m           \
    \         \e[33mif\e[0m (vowelIndex != -\e[31m1\e[0m) {\n\e[31m33 |\e[0m     \
    \                   \e[33mval\e[0m \e[36mleftVowelIndex\e[0m = vowels.indexOf(left.charAt(vowelIndex))\n\
    \e[31m34 |\e[0m                        \e[33mval\e[0m \e[36mrightVowelIndex\e\
    [0m = vowels.indexOf(right.charAt(consonantIndex))\n\e[31m35 |\e[0m          \
    \              \e[33mif\e[0m (leftVowelIndex != -\e[31m1\e[0m && rightVowelIndex\
    \ != -\e[31m1\e[0m) {\n\e[31m36 |\e[0m                            \e[33mval\e\
    [0m \e[36mdistance\e[0m = leftVowelIndex - rightVowelIndex\n\e[31m37 |\e[0m  \
    \                          \e[33mif\e[0m (distance < \e[31m0\e[0m)\n\e[31m38 |\e\
    [0m                                distance * -\e[31m1\e[0m\n\e[31m39 |\e[0m \
    \                           \e[33melse\e[0m \e[33mif\e[0m (distance == \e[31m0\e\
    [0m)\n\e[31m40 |\e[0m                                \e[31m\"\"\e[0m\n\e[31m41\
    \ |\e[0m                            \e[33melse\e[0m \e[33mif\e[0m (distance >\
    \ \e[31m0\e[0m)\n\e[31m42 |\e[0m                                vowels(vowelIndex\
    \ + distance)\n\e[31m43 |\e[0m                        }\n\e[31m44 |\e[0m     \
    \               }\n\e[31m45 |\e[0m                }\n\e[31m46 |\e[0m         \
    \   }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\nthere were 4 deprecation warnings; re-run with -deprecation\
    \ for details\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelsSet =\
    \ scala.collection.mutable.HashSet[String]()\n        for (i <- word.lastIndex+1\
    \ to word.length-1) {\n            val con = word.charAt(i)\n            if (con\
    \ == 'a' || con == 'e' || con == 'i' || con == 'o' || con == 'u'){\n         \
    \       vowelsSet += con\n            }\n        }\n        vowelsSet.lastOption.toString.toUpper\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60cvgghv.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m (i <- word.lastIndex+\e[31m1\e\
    [0m to word.length-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndex is not a member of String - did you mean word.lastIndexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60cvgghv.scala:26:38 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        vowelsSet.lastOption.toString.toUpper\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value toUpper is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    AEIOUaeiou\"\n        var bestVowel : String = \"\"\n        var bestIndex = 0\n\
    \        var curIndex = 0\n        var index = word.length\n\n        while(index\
    \ > 0) {\n            var curChar = word.charAt(index-1)\n            var curCharIndex\
    \ = index\n            while(curCharIndex > 0 && !vowels.contains(curChar)) {\n\
    \                curChar = word.charAt(curCharIndex-1)\n                curCharIndex\
    \ -= 1\n            }\n            val rightVowel = word.charAt(curCharIndex+1)\n\
    \            if(vowels.contains(rightVowel)) {\n                val leftVowel\
    \ = word.charAt(curCharIndex-1)\n                if(vowels.contains(leftVowel))\
    \ {\n                    val vowelLength = vowels.length\n                   \
    \ val bestLength = bestVowel.length\n                    if(vowelLength < bestLength)\
    \ {\n                        bestVowel = rightVowel\n                        bestIndex\
    \ = curCharIndex\n                    }\n                }\n            }\n  \
    \          index --\n        }\n\n        return bestVowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa2_q254h.scala:44:20 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            index --\n\e[31m\e[31m   |\e[0m         \
    \           ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa2_q254h.scala:39:36\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                        bestVowel\
    \ = rightVowel\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    (rightVowel\
    \ : Char)\n\e[31m   |\e[0m                                    Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowel = \"AEIOUaeiou\"\
    \n        val cons = \"BCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelIndex = word.length\n\
    \        var consonantIndex = word.length - word.length % 2\n        val vowels\
    \ = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        var minIndex = 0\n\
    \        var minVowel = \"\"\n        while(vowelIndex > 0 && consonantIndex >\
    \ 0) {\n            if(vowels(word.charAt(vowelIndex - 1)) == word.charAt(vowelIndex))\
    \ {\n                vowelIndex -= 1\n                consonantIndex -= 1\n  \
    \              minIndex += 1\n                minVowel = word.charAt(minIndex)\n\
    \            } else {\n                if(cons(word.charAt(consonantIndex - 1))\
    \ == word.charAt(consonantIndex)) {\n                    consonantIndex -= 1\n\
    \                    minIndex += 1\n                    minVowel = word.charAt(minIndex)\n\
    \                } else {\n                    vowelIndex -= 1\n             \
    \       consonantIndex -= 1\n                    minIndex += 1\n             \
    \       minVowel = word.charAt(minIndex)\n                }\n            }\n \
    \       }\n        if(minIndex == 0) {\n            return \"\"\n        } else\
    \ {\n            return minVowel\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0ucjlbt.scala:27:33\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m(vowels(word.charAt(vowelIndex\
    \ - \e[31m1\e[0m)) == word.charAt(vowelIndex)) {\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \           Found:    Char\n\e[31m   |\e[0m                      Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0ucjlbt.scala:31:38\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                minVowel = word.charAt(minIndex)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           Found:    Char\n\e[31m   |\e[0m      \
    \                     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpi0ucjlbt.scala:36:42 --------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                    minVowel = word.charAt(minIndex)\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    Char\n\e[31m   |\e[0m     \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpi0ucjlbt.scala:41:42 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                    minVowel = word.charAt(minIndex)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               Found:    Char\n\e[31m   |\e[0m\
    \                               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var str = \"\"\n\
    \        var vowels = \"aeiouAEIOU\"\n        val vowelsSet = scala.collection.mutable.Set(vowels)\n\
    \        for(i <- 0 until word.length){\n            for(x <- 0 until word.length){\n\
    \                if(i != x && !vowelsSet.contains(word.charAt(i)) && !vowelsSet.contains(word.charAt(x))){\n\
    \                    var startIndex = i\n                    var endIndex = x\n\
    \                    while(startIndex > 0 && word.charAt(startIndex-1) == word.charAt(startIndex)){\n\
    \                        startIndex -= 1\n                    }\n            \
    \        while(endIndex < word.length && word.charAt(endIndex+1) == word.charAt(endIndex)){\n\
    \                        endIndex += 1\n                    }\n              \
    \      var middleIndex = startIndex + (endIndex - startIndex) / 2;\n         \
    \           if(middleIndex < word.length && middleIndex > 1){\n              \
    \          var middleVowel = word.charAt(middleIndex);\n                     \
    \   if(vowelsSet.contains(middleVowel)){\n                            str = middleVowel\n\
    \                            break\n                        }\n              \
    \      }\n                }\n            }\n        }\n        return str\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mkedc55.scala:24:60\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(i\
    \ != x && !vowelsSet.contains(word.charAt(i)) && !vowelsSet.contains(word.charAt(x))){\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  Char\n\e[31m   |\e[0m                                                 Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mkedc55.scala:24:99\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(i\
    \ != x && !vowelsSet.contains(word.charAt(i)) && !vowelsSet.contains(word.charAt(x))){\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                Found:    Char\n\e[31m   |\e\
    [0m                                                        Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mkedc55.scala:36:46\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        \e[33mif\e\
    [0m(vowelsSet.contains(middleVowel)){\n\e[31m\e[31m   |\e[0m                 \
    \                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                            Found:    (middleVowel : Char)\n\e[31m   |\e[0m \
    \                                         Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mkedc55.scala:37:34 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                            str = middleVowel\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    (middleVowel : Char)\n\e[31m  \
    \ |\e[0m                                  Required: String\n\e[31m"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    AEIOUaeiou\".toList\n        val vowelsIndex : List[Int] = vowels.map(word =>\
    \ {\n            val index : Int = word.indexOf(Character.toString(word.charAt(0)))\n\
    \            (index.toInt)\n        }).toList\n        val vowelIndex : List[Int]\
    \ = vowels.map(word => {\n            val index : Int = word.indexOf(Character.toString(word.charAt(word.length\
    \ - 1)))\n            (index.toInt)\n        }).toList\n        var currentIndex\
    \ : Int = vowelIndex(vowelsIndex(word.length - 1)) + 1\n        var nextIndex\
    \ : Int = vowelsIndex(currentIndex)\n        while(currentIndex < word.length){\n\
    \            val currentCharacter = word.charAt(currentIndex)\n            val\
    \ nextCharacter = word.charAt(nextIndex)\n            if(currentCharacter == nextCharacter){\n\
    \                currentIndex = currentIndex + 1\n            }else if(currentCharacter\
    \ == Character.toString(word.charAt(currentIndex))){\n                currentIndex\
    \ = currentIndex + 1\n            }else{\n                val diff : Int = nextIndex\
    \ - currentIndex\n                if(diff > 0){\n                    currentIndex\
    \ = nextIndex\n                    nextIndex = vowelsIndex(currentIndex)\n   \
    \             }else{\n                    nextIndex = nextIndex + 1\n        \
    \        }\n            }\n        }\n        val currentCharacter = word.charAt(currentIndex)\n\
    \        if(currentCharacter == Character.toString(word.charAt(currentIndex))){\n\
    \            return \"\"\n        }else{\n            return currentCharacter\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_y34kad5.scala:21:35 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m : \e[35mInt\e\
    [0m = word.indexOf(Character.toString(word.charAt(\e[31m0\e[0m)))\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                           value indexOf is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_y34kad5.scala:21:67 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m : \e[35mInt\e\
    [0m = word.indexOf(Character.toString(word.charAt(\e[31m0\e[0m)))\n\e[31m\e[31m\
    \   |\e[0m                                                              ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value charAt is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_y34kad5.scala:25:35\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mindex\e[0m : \e[35mInt\e[0m = word.indexOf(Character.toString(word.charAt(word.length\
    \ - \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value indexOf is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_y34kad5.scala:25:67\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mindex\e[0m : \e[35mInt\e[0m = word.indexOf(Character.toString(word.charAt(word.length\
    \ - \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                   \
    \                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                    value charAt is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_y34kad5.scala:25:79 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m : \e[35mInt\e\
    [0m = word.indexOf(Character.toString(word.charAt(word.length - \e[31m1\e[0m)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \           value length is not a member of Char\n\e[31m\e[31m-- Error: /"
  stdout: ''
  timestamp: 1660009818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // TODO: add your\
    \ code here\n        val vowels = word.substring(word.length -1).map(_.toUpperCase())\n\
    \        val consonants = word.substring(0 ,word.length-1)\n        val diff =\
    \ consonants.zipWithIndex.filter(x => vowels.contains(x._2)).map(_._1 - x._2)\n\
    \        if(diff.isEmpty) {\n            return \"\"\n        } else {\n     \
    \       val min = diff.min\n            val max = (diff diff ).max\n         \
    \   val index = diff.indexOf(min)\n            if(index > 0) vowels(index)\n \
    \           else \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp56bv5gnl.scala:27:33 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = (diff diff\
    \ ).max\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                 expression expected but \e[31m')'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp56bv5gnl.scala:20:58\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mvowels\e[0m = word.substring(word.length -\e[31m1\e[0m).map(_.toUpperCase())\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp56bv5gnl.scala:22:89\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mdiff\e[0m = consonants.zipWithIndex.filter(\e[36mx\e[0m => vowels.contains(x._2)).map(_._1\
    \ - x._2)\n\e[31m\e[31m   |\e[0m                                             \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                                   Not found: x\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp56bv5gnl.scala:26:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = diff.min\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ Error: /tmp/tmp56bv5gnl.scala:27:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = (diff diff\
    \ ).max\n\e[31m\e[31m   |\e[0m                                "
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\"\n        val newWord = word.tail.filter(x => vowels.indexOf(x) >\
    \ -1)\n        val firstVowel = newWord.filter(x => vowels.indexOf(x) == vowels.lastIndexOf(x))\n\
    \        val secondVowel = newWord.filter(x => vowels.indexOf(x) == vowels.indexOf(x.toUpperCase))\n\
    \        val thirdVowel = newWord.filter(x => vowels.indexOf(x) == vowels.indexOf(x.toUpperCase().toUpperCase()))\n\
    \        if (firstVowel.length == 2 && secondVowel.length == 2 && thirdVowel.length\
    \ == 2) \"\"\n        else if (firstVowel.length == 2 && secondVowel.length ==\
    \ 2 && thirdVowel.length == 0) \"\"\n        else if (firstVowel.length == 2 &&\
    \ secondVowel.length == 2 && thirdVowel.length != 0) firstVowel.head + secondVowel.head\n\
    \        else if (firstVowel.length == 2 && secondVowel.length == 0 && thirdVowel.length\
    \ != 0) firstVowel.head + thirdVowel.head\n        else if (firstVowel.length\
    \ != 2 && secondVowel.length == 2 && thirdVowel.length != 0) secondVowel.head\
    \ + thirdVowel.head\n        else if (firstVowel.length != 2 && secondVowel.length\
    \ == 2 && thirdVowel.length == 0) secondVowel.head + thirdVowel.head\n       \
    \ else if (firstVowel.length != 2 && secondVowel.length == 2 && thirdVowel.length\
    \ == 0) thirdVowel.head\n        else \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt59ck_az.scala:22:84 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msecondVowel\e[0m = newWord.filter(\e\
    [36mx\e[0m => vowels.indexOf(x) == vowels.indexOf(x.toUpperCase))\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \     value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpt59ck_az.scala:23:83 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mthirdVowel\e[0m = newWord.filter(\e[36mx\e\
    [0m => vowels.indexOf(x) == vowels.indexOf(x.toUpperCase().toUpperCase()))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \             value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpt59ck_az.scala:26:124 -------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (firstVowel.length ==\
    \ \e[31m2\e[0m && secondVowel.length == \e[31m2\e[0m && thirdVowel.length != \e\
    [31m0\e[0m) firstVowel.head + secondVowel.head\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                              Found:    Char\n\e[31m   |\e[0m\
    \                                                        Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt59ck_az.scala:27:123\
    \ -------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (firstVowel.length == \e[31m2\e[0m && secondVowel.length == \e[31m0\e[0m &&\
    \ thirdVowel.length != \e[31m0\e[0m) firstVowel.head + thirdVowel.head\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m         "
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val letterCounts\
    \ = word.map(c => count(c)).groupBy(_._1).map(x => (x._2,x._1.head._2))\n    \
    \    val maxIndexes = letterCounts.map(_.length).max\n        var ret = \"\"\n\
    \        var maxLetterCount = letterCounts.map(_.length).max\n        for (i <-\
    \ 0 until maxIndexes ) {\n            val letterCount = letterCounts(i)\n    \
    \        if (letterCount == maxLetterCount) {\n                val index = letterCounts(i).index\n\
    \                val letter = word.charAt(index-1)\n                if (word.charAt(index+1).isUpperCase\
    \ || word.charAt(index+1).isLowerCase) {\n                    ret += (letter +\
    \ word.charAt(index+1))\n                }\n            }\n        }\n       \
    \ return ret\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqs4_i4cs.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mletterCounts\e[0m = word.map(\e\
    [36mc\e[0m => count(c)).groupBy(_._1).map(\e[36mx\e[0m => (x._2,x._1.head._2))\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                         Not found: count\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqs4_i4cs.scala:28:41 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (word.charAt(index+\e[31m1\e\
    [0m).isUpperCase || word.charAt(index+\e[31m1\e[0m).isLowerCase) {\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value isUpperCase is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiou\"\n        val vowelMap = mutable.Map[String, String]()\n        for (letter\
    \ <- word) {\n            vowelMap += letter -> vowels\n        }\n        val\
    \ vowelsCount = vowelMap.values.count(_ == vowels)\n        var closestVowel =\
    \ \"\"\n        var vowelInMiddle = 0\n        for (letter <- word.reverse) {\n\
    \            if (vowelMap.values.contains(letter)) {\n                closestVowel\
    \ = letter\n                vowelInMiddle += 1\n            }\n            if\
    \ (vowelInMiddle == vowelsCount) {\n                return closestVowel\n    \
    \        }\n        }\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc7pdewfs.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc7pdewfs.scala:29:31\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                closestVowel\
    \ = letter\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    (letter : Char)\n\e[31m\
    \   |\e[0m                               Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // use mutable set\
    \ data structure to find closest vowel \n        val vowelSet = mutable.Set[String]()\n\
    \        var index = word.length -1\n        while (index >= 0) {\n          \
    \  if (word.charAt(index) == 'u' || word.charAt(index) == 'U') {\n           \
    \     vowelSet += word.charAt(index)\n            }\n            index--\n   \
    \     }\n        var minVowel = vowelSet.toSeq.minBy(_.length)\n        val vowels\
    \ = minVowel.getLength\n        if (vowels == 0) {\n            \"\"\n       \
    \ } else if (vowels == 1) {\n            minVowel\n        } else {\n        \
    \    vowelSet.toSeq.dropWhile(_.length < vowels).toSeq.minBy(_.length)\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfhlismfk.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            index--\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfhlismfk.scala:20:23\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelSet\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      var vowel : String\
    \ = \"\"\n      var start = 0\n      var end = word.size - 1\n\n      while(start\
    \ < end){\n        var vowelStart : Int = word.indexOf(vowel, start)\n       \
    \ var vowelEnd : Int = word.indexOf(vowel, end)\n        if (vowelStart == -1){\n\
    \          vowel = word.charAt(end)\n          start = 0\n        }\n        else\
    \ if (vowelEnd == -1){\n          vowel = word.charAt(start)\n          end =\
    \ word.size - 1\n        }\n        else{\n          vowel = word.charAt(end)\n\
    \          start = vowelEnd + 1\n          end = word.size - 1\n        }\n  \
    \    }\n      return vowel\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf8e5vpv.scala:27:29\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m          vowel = word.charAt(end)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  Found:    Char\n\e[31m   |\e[0m                  Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf8e5vpv.scala:31:29\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m          vowel = word.charAt(start)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  Found:    Char\n\e[31m   |\e[0m                  Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppf8e5vpv.scala:35:29\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m          vowel = word.charAt(end)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  Found:    Char\n\e[31m   |\e[0m                  Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009827
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n      val\
    \ vowelMap   = scala.collection.mutable.Map[Char,Int]()\n      var startIdx =\
    \ 0\n      var endIdx   = 0\n      word.zipWithIndex.foreach {\n        case (ch,\
    \ i) => vowelMap += (ch -> i)\n      }\n      vowelMap.foreach {\n        case\
    \ (ch, idx) => {\n          val nextChar = word.charAt(idx + 1)\n          if\
    \ (ch == 'z') {\n            endIdx = idx\n          } else {\n            if\
    \ (vowelMap(ch) < vowelMap(nextChar)) {\n              startIdx = idx\n      \
    \      } else {\n              endIdx = idx\n            }\n          }\n    \
    \    }\n      }\n      if (startIdx == 0 && endIdx == 0) {\n        if (word.startsWith(\"\
    y\")) {\n          return \"\"\n        } else {\n          return \"\"\n    \
    \    }\n      }\n      val lastChar = word.charAt(endIdx)\n      val lastVowel\
    \ = vowelMap(lastChar)\n      if (endIdx - startIdx <= 1) {\n        \"\"\n  \
    \    } else {\n        val leftVowel = word.charAt(startIdx - 1)\n        if (lastVowel\
    \ < vowelMap(leftVowel)) {\n          \"\"\n        } else {\n          word.substring(startIdx,\
    \ endIdx).mkString\n        }\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 6\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat Problem$.getClosestVowel$$anonfun$2(tmpxee4g80y.scala:28)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.mutable.HashMap$Node.foreach(HashMap.scala:627)\n\
    \tat scala.collection.mutable.HashMap.foreach(HashMap.scala:489)\n\tat Problem$.getClosestVowel(tmpxee4g80y.scala:39)\n\
    \tat Problem$.main(tmpxee4g80y.scala:61)\n\tat Problem.main(tmpxee4g80y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = mutable.Array[String]()\n\
    \        val consonants = word.filter(x => (x != \" \"))\n        consonants.map(x\
    \ => (x + \"a\").headOption)\n            .filter(x => vowels.indexOf(x) == -1).map\
    \ { x => (x + \"a\").headOption } \n            .find(x => x != None).getOrElse(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuuv0u3x2.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.Array[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpuuv0u3x2.scala:20:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mconsonants\e[0m = word.filter(\e\
    [36mx\e[0m => (x != \e[31m\" \"\e[0m))\n\e[31m\e[31m   |\e[0m                \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpuuv0u3x2.scala:22:64 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            .filter(x => vowels.indexOf(x) == -\e[31m1\e[0m).map\
    \ { x => (x + \e[31m\"a\"\e[0m).headOption } \n\e[31m\e[31m   |\e[0m         \
    \                                                     ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of Option[Char], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = \"\
    aeiou\"\n        var vowelCount = word.filter(letter=> vowels.contains(letter)).size\n\
    \        var vowel = \"\"\n        if (vowelCount == 0){\n            return \"\
    \"\n        }\n        var vowelIndex = 0\n        var newIndex = 0\n        var\
    \ result = 0\n        while (vowelIndex < word.length){\n            var currentLetter\
    \ = word.charAt(vowelIndex)\n            if (vowels.contains(currentLetter)){\n\
    \                newIndex = vowelIndex + 1\n                if (vowelIndex + 1\
    \ < word.length){\n                    var nextLetter = word.charAt(newIndex)\n\
    \                    while (vowels.contains(nextLetter)){\n                  \
    \      newIndex = newIndex + 1\n                        if (newIndex + 1 < word.length){\n\
    \                            nextLetter = word.charAt(newIndex)\n            \
    \            }else{\n                            result = newIndex\n         \
    \                   break\n                        }\n                    }\n\
    \                }else{\n                    result = newIndex\n             \
    \   }\n            }else{\n                vowelIndex += 1\n            }\n  \
    \      }\n        if (result == 0){\n            return \"\"\n        }\n    \
    \    var vowelEndIndex = result\n        var vowelIndex = vowelEndIndex - 1\n\
    \        vowel = \"\"\n        if (vowelIndex != 0){\n            var currentLetter\
    \ = word.charAt(vowelIndex)\n            while (vowels.contains(currentLetter)){\n\
    \                if (vowelIndex + 1 < word.length){\n                    vowel\
    \ = vowel + word.charAt(vowelIndex + 1)\n                    vowelIndex += 1\n\
    \                }else{\n                    return vowel\n                }\n\
    \                currentLetter = word.charAt(vowelIndex)\n            }\n    \
    \    }\n        return vowel\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz5cy8ec2.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mvar\e[0m \e[36mvowelIndex\e[0m = vowelEndIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelIndex is already defined as \e[33mvariable\e[0m \e[35mvowelIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpz5cy8ec2.scala:40:28 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                            break\n\e[31m\e[31m   |\e[0m      \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = List(\"\
    A\", \"E\", \"I\", \"O\", \"U\")\n        var vowelsIndex = -1\n        var vowelsLastIndex\
    \ = -1\n        var vowelsIndex1 = -1\n        var vowelsLastIndex1 = -1\n   \
    \     var vowelsLastIndex2 = -1\n        var lastVowel = -1\n        var lastVowel1\
    \ = -1\n        var lastVowel2 = -1\n        var foundFirstVowel = false\n   \
    \     var foundSecondVowel = false\n\n        var firstVowel = vowels.find(x =>\
    \ word.contains(x))\n        var secondVowel = vowels.find(x => word.contains(x))\n\
    \        var firstVowelIndex = word.indexOf(firstVowel)\n        var secondVowelIndex\
    \ = word.indexOf(secondVowel)\n\n        while (vowelsIndex == -1){\n        \
    \    vowelsIndex = vowelsIndex1 + 1\n            vowelsLastIndex = vowelsLastIndex1\n\
    \            vowelsIndex1 = word.indexOf(firstVowel, vowelsIndex + 1)\n      \
    \      vowelsLastIndex1 = word.indexOf(secondVowel, vowelsIndex1)\n\n        \
    \    if (vowelsIndex1 == -1 && vowelsIndex == -1) {\n                vowelsIndex1\
    \ = word.lastIndexOf(firstVowel)\n                vowelsLastIndex1 = word.lastIndexOf(secondVowel)\n\
    \                vowelsLastIndex2 = word.lastIndexOf(secondVowel)\n          \
    \      lastVowel = secondVowel\n                lastVowel1 = secondVowel\n   \
    \             lastVowel2 = secondVowel\n                foundSecondVowel = true\n\
    \            }\n        }\n\n        foundFirstVowel = true\n\n        if (vowelsIndex1\
    \ != -1) {\n            var vowelsIndex2 = word.indexOf(secondVowel, vowelsIndex1\
    \ + 1)\n            while (vowelsIndex2 == -1){\n                vowelsIndex2\
    \ = vowelsLastIndex2\n                vowelsLastIndex2 = word.indexOf(lastVowel2,\
    \ vowelsLastIndex2 + 1)\n\n                if (vowelsIndex2 == -1 && vowelsIndex2\
    \ == -1) {\n                    vowelsLastIndex2 = word.lastIndexOf(lastVowel2)\n\
    \                    vowelsLastIndex1 = word.lastIndexOf(lastVowel1)\n       \
    \             lastVowel2 = secondVowel\n                    lastVowel1 = firstVowel\n\
    \                    lastVowel2 = firstVowel\n                    foundFirstVowel\
    \ = true\n                    vowelsIndex = -1\n                    break\n  \
    \              }\n            }\n        }\n\n        var firstVowelToCompare\
    \ = word.substring(vowelsIndex + 1, vowelsIndex2)\n        var secondVowelToCompare\
    \ = word.substring(vowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphs7jq5eg.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmphs7jq5eg.scala:43:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                vowelsIndex1\
    \ = word.lastIndexOf(firstVowel)\n\e[31m\e[31m   |\e[0m                      \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mlastIndexOf\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: String, x$1: Int): Int\n\e[31m   |\e[0m\
    \ (x$0: String): Int\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e\
    [0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments ((firstVowel : Option[String]))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmphs7jq5eg.scala:44:40 -----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                vowelsLastIndex1 = word.lastIndexOf(secondVowel)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mlastIndexOf\e\
    [0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: String,\
    \ x$1: Int): Int\n\e[31m   |\e[0m (x$0: String): Int\n\e[31m   |\e[0m (x$0: Int,\
    \ x$1: Int): Int\n\e[31m   |\e[0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments\
    \ ((secondVowel : Option[String]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmphs7jq5eg.scala:45:40\
    \ -----------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                vowelsLastIndex2\
    \ = word.lastIndexOf(secondVowel)\n\e[31m\e[31m   |\e[0m                     \
    \              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mlastIndexOf\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: String, x$1: Int): Int\n\e[31m   |\e[0m\
    \ (x$0: String): Int\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e\
    [0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments ((secondVowel : Option[String]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphs7jq5eg.scala:46:28 ------------------"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var resultSet =\
    \ mutable.HashSet[String]();\n        var vowels = \"aeiou\"\n        var searchedVowel\
    \ = \"\";\n        var tempString = \"\";\n        for(i <- 0 until word.length){\n\
    \            val c = word(i)\n            if(vowels.contains(c)){\n          \
    \      resultSet.add(c)\n            }\n            else{\n                tempString\
    \ = tempString.concat(c)\n            }\n        }\n        if(!resultSet.isEmpty){\n\
    \            val tempSet = resultSet.mkString(\"_\").split(\"_\")\n          \
    \  for(i <- 0 until tempSet.length){\n                val c = tempSet(i)\n   \
    \             if(vowels.contains(c)){\n                    searchedVowel = vowels.indexOf(c)\n\
    \                }\n            }\n        }\n        if(!resultSet.isEmpty &&\
    \ searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"a\")\n\
    \        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n       \
    \     searchedVowel = vowels.indexOf(\"e\")\n        }\n        if(!resultSet.isEmpty\
    \ && searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"i\"\
    )\n        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n     \
    \       searchedVowel = vowels.indexOf(\"o\")\n        }\n        if(!resultSet.isEmpty\
    \ && searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"u\"\
    )\n        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n     \
    \       searchedVowel = vowels.indexOf(\"y\")\n        }\n        if(!resultSet.isEmpty\
    \ && searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"A\"\
    )\n        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n     \
    \       searchedVowel = vowels.indexOf(\"E\")\n        }\n        if(!resultSet.isEmpty\
    \ && searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"I\"\
    )\n        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n     \
    \       searchedVowel = vowels.indexOf(\"O\")\n        }\n        if(!resultSet.isEmpty\
    \ && searchedVowel == \"\"){\n            searchedVowel = vowels.indexOf(\"U\"\
    )\n        }\n        if(!resultSet.isEmpty && searchedVowel == \"\"){\n     \
    \       searchedV\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp71jpvr9b.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp71jpvr9b.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e\
    [36mresultSet\e[0m = mutable.HashSet[\e[35mString\e[0m]();\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp71jpvr9b.scala:29:47\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                tempString =\
    \ tempString.concat(c)\n\e[31m\e[31m   |\e[0m                                \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \         Found:    (c : Char)\n\e[31m   |\e[0m                              \
    \                 Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp71jpvr9b.scala:42:42 --------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            searchedVowel = vowels.indexOf(\e[31m\"a\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Int\n\e[31m   |\e[0m                \
    \            Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp71jpvr9b.scala:45:42 --------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            searchedVowel = vowels.indexOf(\e[31m\"e\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Int\n\e[31m   |\e[0m                \
    \            Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp71jpvr9b.scala:48:42 --------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m           "
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val len = word.length\n\
    \        val maxLength = len\n        val vowels = Array(\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"y\");\n\n        var maxVowel : String = \"\"\n        var nextCharIndex\
    \ : Int = 0\n\n        // Traverse through word from right to left (from right\
    \ to left)\n        for (i <- len - 1 to 0 by -1)\n        {\n            // Skip\
    \ vowels found in the beginning\n            if((i >= 0) && vowels(i) match {\n\
    \                case true => {\n                    nextCharIndex = i\n     \
    \               break\n                }\n                case false => {}\n \
    \           })\n\n            // Skip vowels found in the end\n            if((i\
    \ + 1) >= len) \n            {\n                nextCharIndex = len\n        \
    \        break\n            }\n\n            val currentChar = word(i)\n\n   \
    \         // Skip vowels found in a middle character\n            if((currentChar\
    \ == 'a') || (currentChar == 'e') || (currentChar == 'i') || (currentChar == 'o')\
    \ || (currentChar == 'u'))\n            {\n                continue\n        \
    \    }\n\n            // If current character is a vowel and nextCharIndex is\
    \ not\n            // a vowel, return current character as an answer\n       \
    \     if((currentChar == 'a') && !(vowels(nextCharIndex) match {\n           \
    \     case true => {\n                    nextCharIndex = i\n                \
    \    break\n                }\n                case false => {}\n            }))\n\
    \            {\n                return currentChar.toString \n            }\n\n\
    \            // If current character is a vowel and nextCharIndex\n          \
    \  // is a vowel, compare the distance between current and next character\n  \
    \          if((currentChar == 'a' && vowels(nextCharIndex) match {\n         \
    \       case true => {\n                    nextCharIndex = i\n              \
    \      break\n                }\n                case false => {}\n          \
    \  }))\n            {\n                // If current character is closer to nextCharIndex,\
    \ \n                // return current character as an answer\n               \
    \ val currentDistance = i - nextCharIndex\n                if(currentDistance\
    \ < maxDistance)\n                {\n                    maxDistance = currentDistance\n\
    \                    maxVowel = currentChar.toString\n                }\n    \
    \        }\n        }\n\n        return maxVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpck1ybx0k.scala:30:33\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m((i\
    \ >= \e[31m0\e[0m) && vowels(i) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m    \
    \                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \     Found:    String\n\e[31m   |\e[0m                           Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpck1ybx0k.scala:33:20\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpck1ybx0k.scala:35:30 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                \e[33mcase\e[0m \e[31mfalse\e[0m => {}\n\e[31m\e[31m \
    \  |\e[0m                              ^^\e[0m\n\e[31m   |\e[0m              \
    \                Found:    Unit\n\e[31m   |\e[0m                             \
    \ Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpck1ybx0k.scala:42:16\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpck1ybx0k.scala:50:16\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m                continue\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpck1ybx0k.scala:56:21 --------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m                \e[33mcase\e[0m \e[31mtrue\e[0m => {\n\e[31m\e[31m   |\e\
    [0m                     ^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660009828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    A\", \"A\", \"A\", \"A\", \"A\") +\n                        Set(\"a\", \"a\",\
    \ \"a\", \"a\", \"a\")\n        var result = \"a\"\n        var i = 0\n      \
    \  val letter = word.charAt(i).toLowerCase \n        val currentLetters = word.substring(i\
    \ + 1, word.length)\n        val index = vowels.indexOf(currentLetters.charAt(0))\n\
    \        if (index != -1) {\n            result = vowels(index)\n        }\n \
    \       return result \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5w1997rj.scala:23:36 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mletter\e[0m = word.charAt(i).toLowerCase\
    \ \n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     value toLowerCase is not a member of Char\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5w1997rj.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = vowels.indexOf(currentLetters.charAt(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m   value indexOf is not a member of scala.collection.mutable.Set[Object]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5w1997rj.scala:27:27 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            result = vowels(index)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Found:    Boolean\n\e[31m   |\e[0m                     Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val pattern = \"\
    \"\"^(?=.*[aeiou])([aeiouy]+)$\"\"\".r\n        var bestVowel = \"\"\n       \
    \ var bestConsonant = \"\"\n        var minVowelLength = math.min(word.length,\
    \ word.length >> 1)\n        for(i <- word.indices){\n            if(minVowelLength\
    \ < word.length - i && word(i) != \"o\" && word(i) != \"I\"){\n              \
    \  val match = pattern.findFirstIn(word(i))\n                if(match == null\
    \ || match.matches()){\n                    bestVowel = word(i)\n            \
    \        bestConsonant = word(i+1).toLowerCase\n                    break\n  \
    \              }else{\n                    bestVowel = \"\"\n                \
    \    bestConsonant = word(i+1).toLowerCase\n                }\n            }else{\n\
    \                bestVowel = \"\"\n                bestConsonant = \"\"\n    \
    \        }\n        }\n        if(bestVowel.isEmpty){\n            bestVowel =\
    \ word.substring(word.length-bestVowel.length)\n        }\n        return bestVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkl5jgv_9.scala:25:20 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[33mmatch\e[0m = pattern.findFirstIn(word(i))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpkl5jgv_9.scala:26:19 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                \e[33mif\e[0m(\e[33mmatch\e[0m == \e[31mnull\e[0m || \e\
    [33mmatch\e[0m.matches()){\n\e[31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\
    \e[31m   |\e[0m                   expression expected but \e[31mmatch\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpkl5jgv_9.scala:24:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(minVowelLength < word.length\
    \ - i && word(i) != \e[31m\"o\"\e[0m && word(i) != \e[31m\"I\"\e[0m){\n\e[31m\e\
    [31m   |\e[0m                                                   ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpkl5jgv_9.scala:24:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(minVowelLength < word.length\
    \ - i && word(i) != \e[31m\"o\"\e[0m && word(i) != \e[31m\"I\"\e[0m){\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpkl5jgv_9.scala:27:36 --------------------\e[0m\e[0m\n\e[31m27 |\e[0m\
    \                    bestVowel = word(i)\n\e[31m\e[31m   |\e[0m              \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \   Found:    Char\n\e[31m   |\e[0m                                Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] N"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var index = 0\n\
    \        var vowels = Set(\"a\",\"e\",\"i\",\"o\",\"u\")\n        var vowelsCount\
    \ = vowels.size\n        var result = 0\n        var result = findClosestVowel(vowels,vowelsCount,word,index,result)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1f7l16ol.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = findClosestVowel(vowels,vowelsCount,word,index,result)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvariable\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1f7l16ol.scala:24:15 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e[0m       \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result : Int)\n\
    \e[31m   |\e[0m               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      var index = 0\n  \
    \    var vowel = word.takeRight(2).reverse.dropRight(2).takeWhile(_ != 'a' &&\
    \ _ != 'e' && _ != 'i' && _ != 'o' && _ != 'u').last\n      for (i <- word.indices)\
    \ {\n        if (vowel.isPresent)\n          index = i\n      }\n      if (vowel.isEmpty)\
    \ {\n        vowel = word.takeRight(2).reverse.dropRight(2).takeWhile(_ != 'a'\
    \ && _ != 'e' && _ != 'i' && _ != 'o' && _ != 'u').last\n        for (i <- word.indices)\
    \ {\n          if (vowel.isPresent)\n            index = i\n        }\n      }\n\
    \      if (vowel.isEmpty)\n        return \"\"\n      return vowel\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpp2z1ljim.scala:20:67 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      \e[33mvar\e[0m \e[36mvowel\e[0m = word.takeRight(\e\
    [31m2\e[0m).reverse.dropRight(\e[31m2\e[0m).takeWhile(_ != \e[31m'a'\e[0m && _\
    \ != \e[31m'e'\e[0m && _ != \e[31m'i'\e[0m && _ != \e[31m'o'\e[0m && _ != \e[31m'u'\e\
    [0m).last\n\e[31m\e[31m   |\e[0m                                             \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2z1ljim.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (vowel.isPresent)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     value isPresent is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpp2z1ljim.scala:25:16 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m      \e[33mif\e[0m (vowel.isEmpty) {\n\e[31m\e[31m   |\e[0m         \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value isEmpty is not a member of\
    \ Char\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpp2z1ljim.scala:26:65 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        vowel = word.takeRight(\e[31m2\e[0m).reverse.dropRight(\e\
    [31m2\e[0m).takeWhile(_ != \e[31m'a'\e[0m && _ != \e[31m'e'\e[0m && _ != \e[31m'i'\e\
    [0m && _ != \e[31m'o'\e[0m && _ != \e[31m'u'\e[0m).last\n\e[31m\e[31m   |\e[0m\
    \                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2z1ljim.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m          \e[33mif\e[0m (vowel.isPresent)\n\
    \e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \         value isPresent is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpp2z1ljim.scala:32:16 ------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m      \e[33mif\e[0m (vowel.isEmpty)\n\e[31m\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1660009829
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = scala.collection.mutable.Set.empty[String]\n\
    \        var vowelIndex : Int = word.indexOf('u')\n        var vowelCount = 0\n\
    \        while (vowelIndex > -1) {\n            vowels = vowels + word.substring(vowelIndex\
    \ + 1, vowelIndex + 2)\n            vowelCount = vowelCount + 1\n            vowelIndex\
    \ = word.indexOf('u', vowelIndex + 1)\n        }\n        if(vowelCount != 0)\
    \ return \"\"\n        return scala.collection.immutable.Set.empty[String].last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkghan093.scala:31)\n\tat Problem.main(tmpkghan093.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    a\" #|\"e\" #|\"i\" #|\"o\" #|\"u\" #|\"A\" #|\"E\" #|\"I\" #|\"O\" #|\"U\"\n\
    \        val vowelMap : mutable.Map[Character, Double] = word.sliding(2).filter(_(0)\
    \ != \"_\").map(w => (w(0), w(1)).zipped.filter(_._1 == w(0)).map(w(_)).map(c\
    \ => (vowelMap(c), c)).sortBy(_._1).reverse\n        vowelMap.values.filter(_._1\
    \ > 0).lastOption.getOrElse(\"\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpow3bm6du.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        vowelMap.values.filter(_._1 > \e[31m0\e[0m).lastOption.getOrElse(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m \
    \               expression expected but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpow3bm6du.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = \e[31m\"a\"\
    \e[0m #|\e[31m\"e\"\e[0m #|\e[31m\"i\"\e[0m #|\e[31m\"o\"\e[0m #|\e[31m\"u\"\e\
    [0m #|\e[31m\"A\"\e[0m #|\e[31m\"E\"\e[0m #|\e[31m\"I\"\e[0m #|\e[31m\"O\"\e[0m\
    \ #|\e[31m\"U\"\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e\
    [31m   |\e[0m    value #| is not a member of String - did you mean (\e[32m\"a\"\
    \e[0m : String).##?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpow3bm6du.scala:20:23\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelMap\e[0m : mutable.Map[\e[35mCharacter\e[0m, \e[35mDouble\e[0m] = word.sliding(\e\
    [31m2\e[0m).filter(_(\e[31m0\e[0m) != \e[31m\"_\"\e[0m).map(\e[36mw\e[0m => (w(\e\
    [31m0\e[0m), w(\e[31m1\e[0m)).zipped.filter(_._1 == w(\e[31m0\e[0m)).map(w(_)).map(\e\
    [36mc\e[0m => (vowelMap(c), c)).sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpow3bm6du.scala:20:79\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mvowelMap\e[0m : mutable.Map[\e[35mCharacter\e[0m, \e[35mDouble\e\
    [0m] = word.sliding(\e[31m2\e[0m).filter(_(\e[31m0\e[0m) != \e[31m\"_\"\e[0m).map(\e\
    [36mw\e[0m => (w(\e[31m0\e[0m), w(\e[31m1\e[0m)).zipped.filter(_._1 == w(\e[31m0\e\
    [0m)).map(w(_)).map(\e[36mc\e[0m => (vowelMap(c), c)).sortBy(_._1).reverse\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val vowels_2 = List(\"A\",\"E\",\"I\",\"\
    O\",\"U\")\n        val vowels_3 = List(\"a\",\"e\",\"i\",\"o\",\"u\")\n     \
    \   var last_vowel = -1\n        val length = word.length\n        for(i <- 0\
    \ to (length-1) ) {\n            val c = word.charAt(i)\n            if(c == 'a')\
    \ {\n                last_vowel = 0\n            } else if(c == 'e') {\n     \
    \           last_vowel = 1\n            } else if(c == 'i') {\n              \
    \  last_vowel = 2\n            } else if(c == 'o') {\n                last_vowel\
    \ = 3\n            } else if(c == 'u') {\n                last_vowel = 4\n   \
    \         }\n            if(last_vowel != -1) {\n                val next_c =\
    \ word.charAt(i+1)\n                if(vowels.contains(next_c) && vowels_2.contains(next_c)\
    \ && vowels_3.contains(next_c)) {\n                    var result = (vowels.indexOf(next_c)).asInstanceOf[Int]\n\
    \                    var last = (vowels.indexOf(last_vowel)).asInstanceOf[Int]\n\
    \                    if(result.isEmpty || last.isEmpty) {\n                  \
    \      return \"\"\n                    }\n                    var diff = result.asInstanceOf[Int]\
    \ - last.asInstanceOf[Int]\n                    if(diff == 1) {\n            \
    \            return \"\"\n                    }\n                    return vowels.slice(last+1,last+1).mkString\n\
    \                }\n            }\n        }\n        return \"\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpebp75xum.scala:42:30 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    \e[33mif\e[0m(result.isEmpty || last.isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                       value isEmpty is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = mutable.Set[String](\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val vowelCount = mutable.Map[String,Int]()\n\
    \        val vowelStarts = mutable.Map[String,Int]()\n        val vowelEnds =\
    \ mutable.Map[String,Int]()\n        val length = word.length\n        for (i\
    \ <- length to (length - 1)){\n            val consonants = word.substring(0,i).split(\"\
    (?!^)(?=[A-Z])\") // Split each consonant in the word on uppercase letter\n  \
    \          vowelCount.update(consonants(0),0)\n            vowelStarts.update(consonants(0),0)\n\
    \            vowelEnds.update(consonants(0),0)\n        }\n        for (i <- 0\
    \ to (length - 1)){\n            val consonants = word.substring(0,i).split(\"\
    (?!^)(?=[A-Z])\") // Split each consonant in the word on uppercase letter\n  \
    \          vowelCount.update(consonants(0),vowelCount(consonants(0)) + 1)\n  \
    \          val count = vowelCount(consonants(0))\n            val start = vowelStarts(consonants(0))\n\
    \            val end = vowelEnds(consonants(0))\n            if (count <= 1 ||\
    \ count >= 3 && vowels(count) != consonants(0)) continue\n            val count2\
    \ = vowelCount(consonants(1))\n            if (count2 <= 1 || count2 >= 3 && vowels(count)\
    \ != consonants(1)) continue\n            val start2 = vowelStarts(consonants(1))\n\
    \            val end2 = vowelEnds(consonants(1))\n            if (vowelCount(consonants(0))\
    \ + vowelCount(consonants(1)) > 3 || vowelCount(consonants(0)) + vowelCount(consonants(1))\
    \ == 0 || vowelCount(consonants(0)) + vowelCount(consonants(1)) == 1 || vowelCount(consonants(0))\
    \ + vowelCount(consonants(1)) == 2) continue\n            if (vowelCount(consonants(1))\
    \ + vowelCount(consonants(0)) > 3 || vowelCount(consonants(1)) + vowelCount(consonants(0))\
    \ == 0 || vowelCount(consonants(1)) + vowelCount(consonants(0)) == 1 || vowelCount(consonants(1))\
    \ + vowelCount(consonants(0)) == 2) continue\n            if (vowelCount(consonants(1))\
    \ + vowelCount(consonants(2)) > 3 || vowelCount(consonants(1)) + vowelCount(consonants(2))\
    \ == 0 || vowelCount(consonants(1)) + vowelCount(consonants(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpw2w7okg1.scala:43:189 --------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mif\e[0m (vowelCount(consonants(\e[31m1\e\
    [0m)) + vowelCount(consonants(\e[31m2\e[0m)) > \e[31m3\e[0m || vowelCount(consonants(\e\
    [31m1\e[0m)) + vowelCount(consonants(\e[31m2\e[0m)) == \e[31m0\e[0m || vowelCount(consonants(\e\
    [31m1\e[0m)) + vowelCount(consonants(\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                                                            \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpw2w7okg1.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2w7okg1.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mvowels\e[0m = mutable.Set[\e[35mString\e[0m](\e[31m\"a\"\e[0m,\e[31m\"e\"\e\
    [0m,\e[31m\"i\"\e[0m,\e[31m\"o\"\e[0m,\e[31m\"u\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2w7okg1.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelCount\e[0m = mutable.Map[\e[35mString\e[0m,\e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpw2w7okg1.scala:21:26 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36mvowelStarts\e[0m = mutable.Map[\e[35mString\e\
    [0m,\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e\
    [0m\n\e[31m  "
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if(word.isEmpty)\
    \ \"\"\n        else {\n            var res = \"\"\n            var vowels = Set(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n            var lastLetter = word(0)\n         \
    \   for(letter <- word.substring(1)) {\n                if(vowels.contains(letter))\
    \ {\n                    res = res + letter\n                }\n             \
    \   if(letter == lastLetter) {\n                    break\n                } else\
    \ {\n                    lastLetter = letter\n                }\n            }\n\
    \            return res\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw4rmsbjx.scala:25:35\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m(vowels.contains(letter))\
    \ {\n\e[31m\e[31m   |\e[0m                                   ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   Found:    (letter : Char)\n\e[31m\
    \   |\e[0m                                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4rmsbjx.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        var wordIndex = 0\n        val index = word.indexWhere(x\
    \ => vowels.contains(x.charAt(0)))\n        if(index != -1)\n            wordIndex\
    \ = index\n        val newWord = word.substring(wordIndex+1)\n        val newVowels\
    \ = Set(\"a\",\"e\",\"i\",\"o\",\"u\")\n        val newIndex = newWord.indexWhere(x\
    \ => newVowels.contains(x.charAt(0)))\n        if(newIndex != -1)\n          \
    \  wordIndex = newIndex\n        val newWord2 = newWord.substring(wordIndex+1)\n\
    \        newWord2.substring(0,1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp588ht_qo.scala:21:59 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = word.indexWhere(\e\
    [36mx\e[0m => vowels.contains(x.charAt(\e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \                                                         ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    value charAt is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp588ht_qo.scala:26:68 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnewIndex\e[0m = newWord.indexWhere(\e\
    [36mx\e[0m => newVowels.contains(x.charAt(\e[31m0\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                                                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value charAt is not a\
    \ member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Use `head` and\
    \ `tail` to get the first and last element of a list respectively\n        //\
    \ `head` will give us the first element of a list, and `tail` will give us \n\
    \        // the rest elements of a list\n        val firstVowel = word.head \n\
    \        val lastVowel = word.tail.last \n        \n        // Use `tail` and\
    \ `init` to get the first and second elements of a list respectively\n       \
    \ // `tail` will give us the rest elements of a list, and `init` will give us\
    \ \n        // the first element of a list\n        val firstConsonant = word.tail.init\
    \ \n        val lastConsonant = word.tail.tail \n        \n        // Create a\
    \ mutable variable and set it to an empty string\n        var vowelsFound = \"\
    \"\n        // For each consonant\n        for (consonant <- firstConsonant until\
    \ lastConsonant) {\n            // If the current consonant is an uppercase letter\n\
    \            if (consonant > 'Z') {\n                // Iterate through each vowel\
    \ in the word\n                for (vowel <- vowelsFound until vowelsFound + lastVowel)\
    \ {\n                    // If the current vowel from the word is in the middle\
    \ of the current vowel\n                    // we found before\n             \
    \       if (vowel == vowelsFound) {\n                        // Break the loop\n\
    \                        break\n                    }\n                    //\
    \ If current vowel is equal to the current consonant, then we found a vowel\n\
    \                    // from the word that is in the current vowel position in\
    \ the word \n                    // so we return it\n                    if (vowel\
    \ == consonant) {\n                        vowelsFound += vowel\n            \
    \            break\n                    }\n                }\n               \
    \ // If the vowel was not found in the word, we append the vowel to the vowelsFound\n\
    \                // string\n                if (vowelsFound == \"\") {\n     \
    \               vowelsFound += vowel\n                }\n            }\n     \
    \   }\n        vowelsFound\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu987_93_.scala:34:41 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mfor\e[0m (consonant <- firstConsonant until\
    \ lastConsonant) {\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value until is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009829
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        //TODO: your code\
    \ here\n        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n\
    \        var str = \"\";\n        for(i <- 0 to word.length-1){\n            if(vowels.contains(word.charAt(i))){\n\
    \                str = str + word.charAt(i).toLowerCase() + word.charAt(i+1).toLowerCase();\n\
    \            }\n        }\n        return str;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp24z3s2lc.scala:23:42\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(vowels.contains(word.charAt(i))){\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    Char\n\e[31m   |\e[0m     \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp24z3s2lc.scala:24:43 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                str = str + word.charAt(i).toLowerCase()\
    \ + word.charAt(i+\e[31m1\e[0m).toLowerCase();\n\e[31m\e[31m   |\e[0m        \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                    value toLowerCase is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp24z3s2lc.scala:24:76 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                str = str + word.charAt(i).toLowerCase()\
    \ + word.charAt(i+\e[31m1\e[0m).toLowerCase();\n\e[31m\e[31m   |\e[0m        \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n3 errors found\n"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val words = mutable.Buffer.empty[String]\n\
    \        for (i <- 0 to word.length - 2) {\n            if (word.charAt(i) ==\
    \ word.charAt(i+1)) {\n                words ++= word.substring(0,i)\n       \
    \     }\n        }\n        val vowels = words.toList\n        vowels.find(word\
    \ => word.matches(s\"(?i)[aeiou]$\")).getOrElse(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptdogbrs6.scala:26:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        vowels.find(\e[36mword\e[0m => word.matches(\e\
    [31ms\"(?i)[aeiou]$\")).getOrElse(\"\e[0m\")\n\e[31m\e[31m   |\e[0m          \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m                                                 unclosed string literal\n\
    \e[31m\e[31m-- Error: /tmp/tmptdogbrs6.scala:28:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptdogbrs6.scala:19:20 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mwords\e[0m = mutable.Buffer.empty[\e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptdogbrs6.scala:28:4 -------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    Not found: )def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\"\n        // convert each char to it's integer representation\n  \
    \      val charIntMap = word.foldLeft(Map[Int, Int]()) { (m, c) =>\n         \
    \   m + (c -> (m.getOrElse(c, 0) + c.toInt))\n        }\n        // find all pairs\
    \ with the same int value and add one to the other value\n        val pairs =\
    \ charIntMap.filter(_._2 > 1).map(_._1).groupBy(_._1).map(_._2).sortBy(_._1).reverse\n\
    \        // iterate through the pairs and find the first pair where the difference\
    \ is 0\n        pairs.find(_ == 0) match {\n            // if none found, return\
    \ empty string\n            case Some(d) => \"\"\n            // else return first\
    \ element in the pair\n            case None => pairs.head._2\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppjz462ks.scala:22:17\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            m + (c -> (m.getOrElse(c,\
    \ \e[31m0\e[0m) + c.toInt))\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    (\e[1m\e[31mChar\e[0m, Int)\n\e\
    [31m   |\e[0m                 Required: (\e[1m\e[32mInt\e[0m, Int)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppjz462ks.scala:25:68 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mpairs\e[0m = charIntMap.filter(_._2\
    \ > \e[31m1\e[0m).map(_._1).groupBy(_._1).map(_._2).sortBy(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                         value _1\
    \ is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // find first and\
    \ last consonants\n        var lastConsonantIndex = word.indexOf(\"G\") + 1\n\
    \        var firstConsonantIndex = word.indexOf(\"A\") + 1\n\n        // make\
    \ sure consonants exist\n        if(lastConsonantIndex >= firstConsonantIndex){\n\
    \            // loop through the word\n            var vowel = \"\"\n        \
    \    var consonantIndex = 0\n            for(consonantIndex = lastConsonantIndex;\
    \ consonantIndex >= firstConsonantIndex; consonantIndex--){\n                //\
    \ if the consonant is in the word return the vowel\n                if(word(consonantIndex)\
    \ != \"a\"){\n                    vowel = word(consonantIndex)\n             \
    \       lastConsonantIndex = consonantIndex\n                }\n            }\n\
    \            if(vowel != \"\"){\n                // find first and last vowels\n\
    \                var lastVowelIndex = vowel.indexOf(\"u\") + 1\n             \
    \   var firstVowelIndex = vowel.indexOf(\"i\") + 1\n                // make sure\
    \ vowels exist\n                if(lastVowelIndex >= firstVowelIndex){\n     \
    \               var closestVowel = \"\"\n                    var closestVowelIndex\
    \ = 0\n                    for(closestVowelIndex = lastVowelIndex; closestVowelIndex\
    \ >= firstVowelIndex; closestVowelIndex--){\n                        if(closestVowelIndex\
    \ > lastConsonantIndex){\n                            closestVowel = vowel(closestVowelIndex)\n\
    \                            lastVowelIndex = closestVowelIndex\n            \
    \            }\n                    }\n                    closestVowel\n    \
    \            } else {\n                    \"\"\n                }\n         \
    \   } else {\n                \"\"\n            }\n        } else {\n        \
    \    \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdu6toun.scala:28:31 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m(consonantIndex = lastConsonantIndex;\
    \ consonantIndex >= firstConsonantIndex; consonantIndex--){\n\e[31m\e[31m   |\e\
    [0m                               ^\e[0m\n\e[31m   |\e[0m                    \
    \           ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdu6toun.scala:28:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e\
    [0m(consonantIndex = lastConsonantIndex; consonantIndex >= firstConsonantIndex;\
    \ consonantIndex--){\n\e[31m\e[31m   |\e[0m                                  \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                            '<-' expected, but ';' found\n\e\
    [31m\e[31m-- [E032] Syntax Error: /tmp/tmpbdu6toun.scala:28:108 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m(consonantIndex = lastConsonantIndex;\
    \ consonantIndex >= firstConsonantIndex; consonantIndex--){\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                                     pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpbdu6toun.scala:43:42 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    \e[33mfor\e[0m(closestVowelIndex\
    \ = lastVowelIndex; closestVowelIndex >= firstVowelIndex; closestVowelIndex--){\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                                          ')' expected, but '=' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdu6toun.scala:43:96 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    \e[33mfor\e[0m(closestVowelIndex\
    \ = lastVowelIndex; closestVowelIndex >= firstVowelIndex; closestVowelIndex--){\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \              "
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var lower = word.substring(0,word.indexOf('\
    \ '));\n        var upper = word.substring(word.indexOf(' ')+1);\n        var\
    \ result = '';\n        if(lower.length == 0) {\n            return \"\";\n  \
    \      }\n        for (v <- 'a' to 'z') {\n            if (lower.contains(v))\
    \ {\n                result = v\n            }\n        }\n        if (result\
    \ == ''){\n            for (v <- 'A' to 'Z') {\n                if (lower.contains(v))\
    \ {\n                    result = v\n                }\n            }\n      \
    \  }\n        return result\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpi5lyiy27.scala:21:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = '';\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ empty character literal\n\e[31m\e[31m-- Error: /tmp/tmpi5lyiy27.scala:30:22\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mif\e[0m (result == ''){\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      empty character literal\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpi5lyiy27.scala:31:19 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m (v <- \e[31m'A'\e[0m to \e\
    [31m'Z'\e[0m) {\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e\
    [0m                   ')' expected, but '<-' found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpi5lyiy27.scala:22:8 -------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mif\e[0m(lower.length == \e[31m0\e[0m) {\n\e[31m\e\
    [31m   |\e[0m        ^^\e[0m\n\e[31m   |\e[0m        Not found: 'if\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi5lyiy27.scala:27:25 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                result = v\n\e[31m\e[31m   |\e[0m   \
    \                      ^\e[0m\n\e[31m   |\e[0m                         Found:\
    \    (v : Char)\n\e[31m   |\e[0m                         Required: Null\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi5lyiy27.scala:31:12 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m (v <- \e[31m'A'\e[0m to \e\
    [31m'Z'\e[0m) {\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  \
    \          Not found: 'for\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpi5lyiy27.scala:31:17 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            \e[33mfor\e[0m (v <- \e[31m'A'\e[0m to \e[31m'Z'\e[0m) {\n\e[31m\e\
    [31m   |\e[0m               "
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel : String\
    \ = \"\"\n        var vowel1 : String = \"\"\n        var vowel2 : String = \"\
    \"\n        var vowel3 : String = \"\"\n        var vowel4 : String = \"\"\n \
    \       var vowel5 : String = \"\"\n        var vowel6 : String = \"\"\n     \
    \   var vowel7 : String = \"\"\n        var vowel8 : String = \"\"\n        var\
    \ vowel9 : String = \"\"\n        var vowel10 : String = \"\"\n        var vowel11\
    \ : String = \"\"\n        var vowel12 : String = \"\"\n        var vowel13 :\
    \ String = \"\"\n        var vowel14 : String = \"\"\n        var vowel15 : String\
    \ = \"\"\n        var vowel16 : String = \"\"\n        var vowel17 : String =\
    \ \"\"\n        var vowel18 : String = \"\"\n        var vowel19 : String = \"\
    \"\n        var vowel20 : String = \"\"\n        var vowel21 : String = \"\"\n\
    \        var vowel22 : String = \"\"\n        var vowel23 : String = \"\"\n  \
    \      var vowel24 : String = \"\"\n        var vowel25 : String = \"\"\n    \
    \    var vowel26 : String = \"\"\n        var vowel27 : String = \"\"\n      \
    \  var vowel28 : String = \"\"\n        var vowel29 : String = \"\"\n        var\
    \ vowel30 : String = \"\"\n        var vowel31 : String = \"\"\n        var vowel32\
    \ : String = \"\"\n        var vowel33 : String = \"\"\n        var vowel34 :\
    \ String = \"\"\n        var vowel35 : String = \"\"\n        var vowel36 : String\
    \ = \"\"\n        var vowel37 : String = \"\"\n        var vowel38 : String =\
    \ \"\"\n        var vowel39 : String = \"\"\n        var vowel40 : String = \"\
    \"\n        var vowel41 : String = \"\"\n        var vowel42 : String = \"\"\n\
    \        var vowel43 : String = \"\"\n        var vowel44 : String = \"\"\n  \
    \      var vowel45 : String = \"\"\n        var vowel46 : String = \"\"\n    \
    \    var vowel47 : String = \"\"\n        var vowel48 : String = \"\"\n      \
    \  var vowel49 : String = \"\"\n        var vowel50 : String = \"\"\n        var\
    \ vowel51 : String = \"\"\n        var vowel52 : String = \"\"\n        var vowel53\
    \ : String = \"\"\n        var vowel54 : String = \"\"\n        var vowel55 :\
    \ String = \"\"\n        var vowel56 : String = \"\"\n        var vowel57 : String\
    \ = \"\"\n        var vowel58 : String = \"\"\n        var vowel59 : String =\
    \ \"\"\n        var vowel60 : String = \"\"\n        var vowel61 : String = \"\
    \"\n        var vowel62 : String = \"\"\n        var vowel63 : String = \"\"\n\
    \        var vowel64 : String = \"\"\n        var vowel65 : String = \"\"\n  \
    \      var vowel66 : String = \"\"\n        var vowel67 : String = \"\"\n    \
    \    var vowel68 : String = \"\"\n        var vowel69 : String = \"\"\n      \
    \  var vowel70 : String = \"\"\n        var vowel71 : String = \"\"\n        var\
    \ vowel72 : String = \"\"\n        var vowel73 : String = \"\"\n        var \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6beqhtuf.scala:93:11 ---------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6beqhtuf.scala:94:5 ---------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val resultList = mutable.ArrayBuffer.empty[String]\n\
    \        val reversedWord = word.reverse\n        for (i <- 0 until reversedWord.length)\
    \ {\n            if (vowels.contains(reversedWord(i))) {\n                val\
    \ index = reversedWord.length - i - 1\n                val lastVowel = vowels(index)\n\
    \                if (index > 0) {\n                    if (vowels(index - 1) !=\
    \ lastVowel) {\n                        val tempReversedWord = reversedWord.substring(0,\
    \ index) + lastVowel + reversedWord.substring(index + 1)\n                   \
    \     resultList += getClosestVowel(tempReversedWord)\n                    }\n\
    \                }\n            }\n        }\n        if (resultList.isEmpty)\
    \ {\n            \"\"\n        } else {\n            val res = resultList.max\n\
    \            res\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeqip5396.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresultList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var count = 0\n\
    \        var vowel = \"a\"\n        var vowelEnd = \"o\"\n        var firstVowel\
    \ : Char = \"a\"\n        var secondVowel : Char = \"o\"\n        var consonant\
    \ = \"b\"\n        var charList = new Array[Char](word.length)\n        charList.fill(0)\n\
    \        charList.foreach(x => charList(x) = word.charAt(x))\n        var firstVowelIndex:\
    \ Int = word.indexOfChar(vowel)\n        var secondVowelIndex: Int = word.indexOfChar(vowelEnd)\n\
    \        var thirdVowelIndex: Int = 0\n        var fourthVowelIndex: Int = 0\n\
    \        var fifthVowelIndex: Int = 0\n        var sixthVowelIndex: Int = 0\n\
    \        while(firstVowelIndex != -1){\n            if(firstVowelIndex <= secondVowelIndex){\n\
    \                firstVowelIndex = word.indexOfChar(vowel, firstVowelIndex + 1)\n\
    \            }\n            else{\n                firstVowelIndex = word.indexOfChar(vowel,\
    \ firstVowelIndex - 1)\n            }\n        }\n        while(secondVowelIndex\
    \ != -1){\n            if(secondVowelIndex <= thirdVowelIndex){\n            \
    \    secondVowelIndex = word.indexOfChar(vowel, secondVowelIndex + 1)\n      \
    \      }\n            else{\n                secondVowelIndex = word.indexOfChar(vowel,\
    \ secondVowelIndex - 1)\n            }\n        }\n        while(thirdVowelIndex\
    \ != -1){\n            if(thirdVowelIndex <= fourthVowelIndex){\n            \
    \    thirdVowelIndex = word.indexOfChar(vowel, thirdVowelIndex + 1)\n        \
    \    }\n            else{\n                thirdVowelIndex = word.indexOfChar(vowel,\
    \ thirdVowelIndex - 1)\n            }\n        }\n        while(fourthVowelIndex\
    \ != -1){\n            if(fourthVowelIndex <= fifthVowelIndex){\n            \
    \    fourthVowelIndex = word.indexOfChar(vowel, fourthVowelIndex + 1)\n      \
    \      }\n            else{\n                fourthVowelIndex = word.indexOfChar(vowel,\
    \ fourthVowelIndex - 1)\n            }\n        }\n        while(fifthVowelIndex\
    \ != -1){\n            if(fifthVowelIndex <= sixthVowelIndex){\n             \
    \   fifthVowelIndex = word.indexOfChar(vowel, fifthVowelIndex + 1)\n         \
    \   }\n            else{\n                fif\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv8q8bc5e.scala:90:0 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8q8bc5e.scala:22:32\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mfirstVowel\e\
    [0m : \e[35mChar\e[0m = \e[31m\"a\"\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                  ^^^\e[0m\n\e[31m   |\e[0m                                Found:\
    \    (\e[32m\"a\"\e[0m : String)\n\e[31m   |\e[0m                            \
    \    Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8q8bc5e.scala:23:33\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36msecondVowel\e\
    [0m : \e[35mChar\e[0m = \e[31m\"o\"\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                   ^^^\e[0m\n\e[31m   |\e[0m                                \
    \ Found:    (\e[32m\"o\"\e[0m : String)\n\e[31m   |\e[0m                     \
    \            Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpv8q8bc5e.scala:26:17 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        charList.fill(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value fill is not a member of Array[Char]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpv8q8bc5e.scala:28:40 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mfirstVowelIndex\e[0m: \e\
    [35mInt\e[0m = word.indexOfChar(vowel)\n\e[31m\e[31m   |\e[0m                \
    \                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \          value indexOfChar is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpv8q8bc5e.scala:29:41 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36msecondVowelIndex\e[0m: \e[35mInt\e\
    [0m = word.indexOfChar(vowelEnd)\n\e[31m\e[31m   |\e[0m                      \
    \              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \   "
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def getVowels(word\
    \ : String) : List[String] = {\n            val vowels = List(\"a\", \"e\", \"\
    i\", \"o\", \"u\")\n            val nonvowels = word.filter(!vowels.contains)\n\
    \            nonvowels.toList\n        }\n        val vowels = getVowels(word)\n\
    \        vowels.maxBy { case vowel => word.lastIndexOf(vowel) }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsws5ygjh.scala:21:40 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mnonvowels\e[0m = word.filter(!vowels.contains)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value unary_! is not a member of String\
    \ => Boolean\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsws5ygjh.scala:22:22\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            nonvowels.toList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Found:    List[\e[1m\e[31mChar\e[0m]\n\e[31m   |\e[0m            Required:\
    \ List[\e[1m\e[32mString\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009841
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelList =\
    \ List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val consonantList = List(\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var\
    \ result = \"\"\n        // go through each consonant in the word\n        for\
    \ (c <- consonantList) {\n            // loop through each vowel in the word from\
    \ right side and find if it is the closest vowel\n            for (v <- vowelList)\
    \ {\n                // if current vowel is closer to current consonant than previous,\
    \ then store it as the result\n                if(word.indexOf(c) > word.indexOf(v)){\n\
    \                    result = v\n                }\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo9p47gj8.scala:35)\n\tat Problem.main(tmpo9p47gj8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val vowelCount = word.foldLeft(Map.empty[Int, Int]){\n\
    \            case (m, c) =>\n                val index = vowels.find(_.toString\
    \ == c).map(_.toInt).getOrElse(0)\n                m(index) += 1\n           \
    \     m\n        }\n        val index = vowelCount.keys.max\n        if(index\
    \ == 0) \"\"\n        else vowels(index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1ogp1qvt.scala:22:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[36mindex\e[0m = vowels.find(_.toString\
    \ == c).map(_.toInt).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \                              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp1ogp1qvt.scala:28:20 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33melse\e[0m vowels(index)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^\e[0m\n\e[31m   |\e[0m                    Found: \
    \   (index : Int)\n\e[31m   |\e[0m                    Required: Char\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aAbBcCdDfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\".toUpperCase\n        val\
    \ vowelsWithA = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\".toUpperCase\n\
    \        val vowelsWithA = vowelsWithA.reverse\n        val vowelsWithA = vowelsWithA.dropRight(vowelsWithA.length-1)\n\
    \        var lastConsonantIndex = 0\n        var lastVowelIndex = 0\n        var\
    \ consonantIndex = 0\n        var vowelIndex = 0\n        var vowel = \"\"\n \
    \       word.foldRight(\"\") { (vowel,c) =>\n            if(vowels.contains(c))\
    \ {\n                vowelIndex = vowel.indexOf(c)\n                if(vowelIndex\
    \ > -1) {\n                    lastVowelIndex = vowelIndex\n                 \
    \   lastConsonantIndex = consonantIndex\n                } else {\n          \
    \          lastConsonantIndex = consonantIndex\n                }\n          \
    \      consonantIndex += 1\n            } else {\n                lastVowelIndex\
    \ = consonantIndex\n                consonantIndex += 1\n            }\n     \
    \       \n            if(consonantIndex < lastConsonantIndex) {\n            \
    \    vowel += c\n            }\n        }\n        if(lastVowelIndex >= 0 && lastConsonantIndex\
    \ >= 0) {\n            val consonants = word.substring(0,lastConsonantIndex)\n\
    \            val vowels = word.substring(lastVowelIndex,lastConsonantIndex+1)\n\
    \            val vowel = vowels.indexOf(vowels.toUpperCase)\n            val vowelIndex\
    \ = vowel.orElse(vowels.length)\n            if(vowelIndex > 0) {\n          \
    \      vowel = vowels(vowelIndex)\n            } else {\n                vowel\
    \ = \"\"\n            }\n        }\n        vowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8wf_wl6p.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelsWithA\e[0m = vowelsWithA.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvowelsWithA is already defined as \e[33mvalue\e[0m \e[35mvowelsWithA\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wf_wl6p.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mvowelsWithA\e[0m = vowelsWithA.dropRight(vowelsWithA.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelsWithA is already defined as \e[33mvalue\e[0m \e[35mvowelsWithA\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp8wf_wl6p.scala:30:35 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m                vowelIndex = vowel.indexOf(c)\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                   value indexOf is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp8wf_wl6p.scala:44:22 ------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                vowel += c\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not a member\
    \ of Char - did you mean vowel.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wf_wl6p.scala:51:35\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e[0m\
    \ \e[36mvowelIndex\e[0m = vowel.orElse(vowels.length)\n\e[31m\e[31m   |\e[0m \
    \                            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \               value orElse is not a member of Int\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmp8wf_wl6p.scala:53:22 -----------------------------\e[0m\e[0m\n\
    \e[31m53 |\e[0m                vowel = vowels(vowelIndex)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // code here\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2uyeefvy.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m    \e[33mdef\e[0m \e[36mgetClosestVowel\e\
    [0m(\e[36mword\e[0m : \e[35mString\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                  ^\e[0m\n\e[31m   |\e\
    [0m                                                  Found:    Unit\n\e[31m  \
    \ |\e[0m                                                  Required: String\n\e\
    [31m19 |\e[0m        \e[34m// code here\e[0m\n\e[31m20 |\e[0m    }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List('a','e','i','o','u')\n\
    \        val vowelsMap = vowels.toMap\n        val list = word.substring(1)\n\
    \        if (list.length == 1) \"\"\n        else list.substring(list.length-2).map(vowelsMap(_)).min(math.abs(_\
    \ - vowelsMap('e')))\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsrbsb4ev.scala:20:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m = vowels.toMap\n\
    \e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    Cannot prove that Char <:< (K, V)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                    where:    K is\
    \ a type variable\n\e[31m   |\e[0m                                           \
    \   V is a type variable\n\e[31m   |\e[0m                                    .\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = word.last\n\
    \        var minDistance = math.Int.MaxValue\n        var newWord = word\n   \
    \     for(v <- newWord.reverse) {\n            if(vowel == \"a\" || vowel == \"\
    e\" || vowel == \"i\" || vowel == \"o\" || vowel == \"u\" || vowel == \"A\" ||\
    \ vowel == \"E\" || vowel == \"I\" || vowel == \"O\" || vowel == \"U\"){\n   \
    \             if(math.abs(vowel.toString.length - v.toString.length) < minDistance){\n\
    \                    minDistance = math.abs(vowel.toString.length - v.toString.length)\n\
    \                    vowel = v\n                }\n            }\n        }\n\
    \        if(minDistance == math.Int.MaxValue){\n            vowel = \"\"\n   \
    \     }\n        return vowel\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvcjoe1k.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mminDistance\e[0m = math.Int.MaxValue\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value Int is not a member of math\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpnvcjoe1k.scala:23:15 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(vowel == \e[31m\"a\"\e[0m || vowel\
    \ == \e[31m\"e\"\e[0m || vowel == \e[31m\"i\"\e[0m || vowel == \e[31m\"o\"\e[0m\
    \ || vowel == \e[31m\"u\"\e[0m || vowel == \e[31m\"A\"\e[0m || vowel == \e[31m\"\
    E\"\e[0m || vowel == \e[31m\"I\"\e[0m || vowel == \e[31m\"O\"\e[0m || vowel ==\
    \ \e[31m\"U\"\e[0m){\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types Char and String cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmpnvcjoe1k.scala:23:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(vowel == \e[31m\"a\"\e[0m ||\
    \ vowel == \e[31m\"e\"\e[0m || vowel == \e[31m\"i\"\e[0m || vowel == \e[31m\"\
    o\"\e[0m || vowel == \e[31m\"u\"\e[0m || vowel == \e[31m\"A\"\e[0m || vowel ==\
    \ \e[31m\"E\"\e[0m || vowel == \e[31m\"I\"\e[0m || vowel == \e[31m\"O\"\e[0m ||\
    \ vowel == \e[31m\"U\"\e[0m){\n\e[31m\e[31m   |\e[0m                         \
    \      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpnvcjoe1k.scala:23:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \     \e[33mif\e[0m(vowel == \e[31m\"a\"\e[0m || vowel == \e[31m\"e\"\e[0m ||\
    \ vowel == \e[31m\"i\"\e[0m || vowel == \e[31m\"o\"\e[0m || vowel == \e[31m\"\
    u\"\e[0m || vowel == \e[31m\"A\"\e[0m || vowel == \e[31m\"E\"\e[0m || vowel ==\
    \ \e[31m\"I\"\e[0m || vowel == \e[31m\"O\"\e[0m || vowel == \e[31m\"U\"\e[0m){\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpnvcjoe1k.scala:23:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e["
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val letters = word.split(\"\
    \").toList\n        val vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    )\n        val consonants = letters.toSet.toList.filter(letter => letter !='z')\n\
    \        val vowelsMap = vowels.toList.toMap.withDefaultValue(0)\n        val\
    \ consonantsMap = consonants.toList.toMap.withDefaultValue(0)\n        var closest\
    \ = consonants.last\n        var min = Integer.MAX_VALUE\n        for(letter <-\
    \ letters) {\n            if(vowelsMap(letter) < min && consonantsMap(letter)\
    \ < min) {\n                min = vowelsMap(letter)\n                closest =\
    \ letter\n            }\n        }\n        if(letters.last == closest) {\n  \
    \          closest\n        } else {\n            \"\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw95d6tr0.scala:21:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mconsonants\e[0m = letters.toSet.toList.filter(\e\
    [36mletter\e[0m => letter !=\e[31m'z'\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpw95d6tr0.scala:22:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m = vowels.toList.toMap.withDefaultValue(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           ^\e\
    [0m\n\e[31m   |\e[0m                                     Cannot prove that String\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                               \
    \      where:    K is a type variable\n\e[31m   |\e[0m                       \
    \                        V is a type variable\n\e[31m   |\e[0m               \
    \                      .\n\e[31m\e[31m-- Error: /tmp/tmpw95d6tr0.scala:23:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mconsonantsMap\e[0m = consonants.toList.toMap.withDefaultValue(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \        ^\e[0m\n\e[31m   |\e[0m                                     Cannot prove\
    \ that String <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                   \
    \                  where:    K is a type variable\n\e[31m   |\e[0m           \
    \                                    V is a type variable\n\e[31m   |\e[0m   \
    \                                  .\n3 errors found\n"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val vowelArray = vowels.toArray\n  \
    \      val consonants = List(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\")\n        val consonantArray = consonants.toArray\n    \
    \    val index = word.length -1\n        if(index < 0)\n            return \"\"\
    \n        val vowelMatch = word.charAt(index).toLowerCase match {\n          \
    \  case \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => true\n            case _    \
    \                   => false\n        }\n        if(vowelMatch)\n            return\
    \ \"\"\n        val consonantMatch = word.charAt(index).toLowerCase match {\n\
    \            case \"b\" | \"c\" | \"d\" | \"f\" | \"g\" | \"h\" | \"j\" | \"k\"\
    \ | \"l\" | \"m\" | \"n\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"v\" | \"\
    w\" | \"x\" | \"y\" | \"z\" => true\n            case _                      \
    \           => false\n        }\n        if(consonantMatch)\n            return\
    \ \"\"\n        val vowelIndex = index % vowelArray.length\n        val consonantIndex\
    \ = index % consonantArray.length\n        var closestVowel = \"\"\n        val\
    \ currentVowel = vowelArray(vowelIndex)\n        val currentConsonant = consonantArray(consonantIndex)\n\
    \        closestVowel = currentVowel +\n            if(currentVowel == \"u\" &&\
    \ currentConsonant == \"e\")\n                closestVowel + currentVowel +\n\
    \                if(currentVowel == \"o\" && currentConsonant == \"u\")\n    \
    \                closestVowel + currentVowel +\n                    closestVowel\
    \ + currentVowel +\n                    if(currentVowel == \"e\" && currentConsonant\
    \ == \"o\")\n                        closestVowel + currentVowel +\n         \
    \               if(currentVowel == \"e\" && currentConsonant == \"a\")\n     \
    \                       closestVowel + currentVowel +\n                      \
    \      closestVowel + currentVowel +\n                            closestVowel\
    \ + currentVowel +\n                            closestVowel + currentVowel +\n\
    \                            closestVowel + currentVowel +\n                 \
    \           closestVowel + currentVowel +\n                            closestVowel\
    \ + currentVowel +\n                            closestVowel + currentVowel +\n\
    \                            closestVowel + currentV\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0v5sydp_.scala:43:37 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        closestVowel = currentVowel +\n\e[31m\e[31m \
    \  |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m        \
    \                             expression expected but \e[31mif\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0v5sydp_.scala:45:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                closestVowel\
    \ + currentVowel +\n\e[31m\e[31m   |\e[0m                                    \
    \         ^\e[0m\n\e[31m   |\e[0m                                        expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp0v5sydp_.scala:48:49 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                    closestVowel + currentVowel +\n\e[31m\e[31m   |\e\
    [0m                                                 ^\e[0m\n\e[31m   |\e[0m  \
    \                                      expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0v5sydp_.scala:50:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m                     \
    \   closestVowel + currentVowel +\n\e[31m\e[31m   |\e[0m                     \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                   expression expected but \e[31mif\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0v5sydp_.scala:26:44 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mvowelMatch\e[0m = word.charAt(index).toLowerCase\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val result = word.map( c => vowels.indexOf(\
    \ c.toLowerCase.toUpperCase )).min\n\n        if (result == -1){\n           \
    \ return \"\"\n        }\n        else{\n            return vowels(result)\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_v1scesr.scala:20:54 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = word.map(\
    \ \e[36mc\e[0m => vowels.indexOf( c.toLowerCase.toUpperCase )).min\n\e[31m\e[31m\
    \   |\e[0m                                                    ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelSet = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        val vowelSet2 = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"y\");\n        val consonantSet = Set(\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n        val consonantSet2\
    \ = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\
    \ \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n   \
    \     val consonants1 = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"z\");\n        val consonants2 = Set(\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"z\");\n        val consonantSet3 = Set(\"b\", \"c\",\
    \ \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n        val consonantSet4\
    \ = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\
    \ \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n   \
    \     val consonantSet5 = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"z\");\n        val consonantSet6 = Set(\"b\", \"c\", \"d\", \"f\",\
    \ \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"z\");\n        val consonantSet7 = Set(\"b\",\
    \ \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n        val consonantSet8\
    \ = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\
    \ \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n   \
    \     val consonantSet9 = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"z\");\n        val consonant\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7g4lttwo.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7g4lttwo.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        def getClosestVowel2(w: List[String]):\
    \ (String, Int) = {\n            if (w.isEmpty) return (\"\", -1)\n          \
    \  def getClosestVowel3(w: List[String], i : Int, j : Int): (String, Int) = {\n\
    \                val k = (w.size - 1 - i)\n                val l = (w.size - 1\
    \ - j)\n                if (k == -1 || l == -1) return(\"\", -1)\n           \
    \     val vowel = vowels(k % w.size)\n                val newWord = w.filter(\
    \ x => x != vowel).toList\n                getClosestVowel3(newWord, k, l)\n \
    \           }\n            val list = (w.size - 1).toString.toCharArray\n    \
    \        (getClosestVowel3(list, 0, list.length - 1), vowels.indexOf(vowel))\n\
    \        }\n        getClosestVowel2(word)._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9t82klx6.scala:26:35\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m\
    \ \e[36mvowel\e[0m = vowels(k % w.size)\n\e[31m\e[31m   |\e[0m               \
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \           Found:    Int\n\e[31m   |\e[0m                                   Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp9t82klx6.scala:27:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mnewWord\e[0m = w.filter(\
    \ \e[36mx\e[0m => x != vowel).toList\n\e[31m\e[31m   |\e[0m                  \
    \                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     Values of types\
    \ String and Boolean cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp9t82klx6.scala:31:30 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m            (getClosestVowel3(list, \e[31m0\e[0m, list.length -\
    \ \e[31m1\e[0m), vowels.indexOf(vowel))\n\e[31m\e[31m   |\e[0m               \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (list : Array[Char])\n\e[31m   |\e[0m                              Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9t82klx6.scala:31:64\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            (getClosestVowel3(list,\
    \ \e[31m0\e[0m, list.length - \e[31m1\e[0m), vowels.indexOf(vowel))\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   value indexOf is not a member of scala.collection.mutable.Set[String]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9t82klx6.scala:31:72 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            (getClosestVowel3(list, \e[31m0\e[0m, list.length\
    \ - \e[31m1\e[0m), vowels.indexOf(vowel))\n\e[31m\e[31m   |\e[0m             \
    \                                                           ^^^^^\e[0m\n\e[31m\
    \   |\e[0m             "
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels : Seq[String]\
    \ = Seq.empty\n        var firstVowelIndex = word.indexOf(\"a\")\n        var\
    \ lastVowelIndex = word.lastIndexOf(\"a\")\n        var vowelsCount = word.count(\"\
    a\")\n        val vowelsMap : Map[String, Int] = Map(\"a\" -> 0, \"e\" -> 1, \"\
    i\" -> 2, \"o\" -> 3, \"u\" -> 4)\n        var maxVowelIndex : Int = -1\n    \
    \    var maxVowelValue : Int = 0\n        var currentVowel : String = \"\"\n \
    \       var currentVowelValue : Int = 0\n        var currentCount : Int = 0\n\
    \        for(i <- 0 until firstVowelIndex) currentVowel += word(i)\n        for(j\
    \ <- firstVowelIndex until lastVowelIndex) currentVowel += word(j)\n        for(i\
    \ <- 0 until lastVowelIndex) currentVowel += word(i)\n        for(j <- lastVowelIndex\
    \ to word.size ) currentVowel += word(j)\n        for(v <- vowelsMap.values) currentVowelValue\
    \ += v\n        for(i <- 0 until vowelsCount) currentCount += vowelsMap.get(vowels(i))\n\
    \        for(i <- 0 until vowelsCount) {\n            currentVowelValue += vowelsMap.get(vowels(i))\n\
    \            if(currentVowelValue > maxVowelValue) {\n                maxVowelValue\
    \ = currentVowelValue\n                maxVowelIndex = i\n            }\n    \
    \    }\n        return vowels(maxVowelIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmakx1cxi.scala:22:37\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mvowelsCount\e\
    [0m = word.count(\e[31m\"a\"\e[0m)\n\e[31m\e[31m   |\e[0m                    \
    \                 ^^^\e[0m\n\e[31m   |\e[0m                                  \
    \   Found:    (\e[32m\"a\"\e[0m : String)\n\e[31m   |\e[0m                   \
    \                  Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmakx1cxi.scala:34:51 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until vowelsCount)\
    \ currentCount += vowelsMap.get(vowels(i))\n\e[31m\e[31m   |\e[0m            \
    \                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \     value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpmakx1cxi.scala:36:30 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m            currentVowelValue += vowelsMap.get(vowels(i))\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          value += is not a member of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelMap = new\
    \ HashMap[Char, Int]()\n        vowelMap ++= (\"A\".toInt -> 1)\n        vowelMap\
    \ ++= (\"E\".toInt -> 1)\n        vowelMap ++= (\"I\".toInt -> 1)\n        vowelMap\
    \ ++= (\"O\".toInt -> 1)\n        vowelMap ++= (\"U\".toInt -> 1)\n        vowelMap\
    \ ++= (\"a\".toInt -> 1)\n        vowelMap ++= (\"e\".toInt -> 1)\n        vowelMap\
    \ ++= (\"i\".toInt -> 1)\n        vowelMap ++= (\"o\".toInt -> 1)\n        vowelMap\
    \ ++= (\"u\".toInt -> 1)\n        vowelMap ++= (\"Y\".toInt -> 1)\n        vowelMap\
    \ ++= (\"y\".toInt -> 1)\n        vowelMap.values.min match {\n            case\
    \ Some(value) => word.reverse.charAt(word.length - value.toString.length) + word.reverse.charAt(word.length\
    \ - value.toString.length)\n            case None => \"\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphfleffej.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        vowelMap ++= (\e[31m\"\
    A\"\e[0m.toInt -> \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    (Int, Int)\n\e[31m   |\e[0m\
    \                      Required: IterableOnce[(Char, Int)]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphfleffej.scala:21:22 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        vowelMap ++= (\e[31m\"E\"\e[0m.toInt -> \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Found:    (Int, Int)\n\e[31m   |\e[0m         \
    \             Required: IterableOnce[(Char, Int)]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphfleffej.scala:22:22 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        vowelMap ++= (\e[31m\"I\"\e[0m.toInt -> \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Found:    (Int, Int)\n\e[31m   |\e[0m         \
    \             Required: IterableOnce[(Char, Int)]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphfleffej.scala:23:22 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        vowelMap ++= (\e[31m\"O\"\e[0m.toInt -> \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Found:    (Int, Int)\n\e[31m   |\e[0m         \
    \             Required: IterableOnce[(Char, Int)]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphfleffej.scala:24:22 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        vowelMap ++= (\e[31m\"U\"\e[0m.toInt -> \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                      Found:    (Int, In"
  stdout: ''
  timestamp: 1660009845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = Set(\"\
    \" +  \"A\" + \"\" +  \"E\" + \"\" +  \"I\" + \"\" +  \"O\" + \"\" +  \"U\" +\
    \ \"\")\n        var vowelCount = 0 \n        var vowelsRight = \"\"\n       \
    \ var vowelsLeft = \"\"\n        var currentVowel = \"\"\n        var currentVowelIndex\
    \ = -1\n        for ( i <- 0 until word.length ) {\n            var ch = word.charAt(i)\n\
    \            vowelsRight += ch\n            vowelsLeft += ch\n            vowelCount\
    \ += 1 \n            if ( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' ||\
    \ ch == 'u') {\n                currentVowelIndex = i\n                currentVowel\
    \ = ch\n            }\n        }\n        var i = 0\n        for ( i <- 0 until\
    \ vowelsRight.length ) {\n            var j = 0\n            for ( j <- 0 until\
    \ vowels.length ) {\n                if ( vowelsRight.charAt(i) == vowels.charAt(j)\
    \ ) {\n                    vowelsRight += vowels.charAt(j)\n                 \
    \   vowelCount -= 1\n                    if (vowelCount == 0) {\n            \
    \            return vowelsRight\n                    }\n                }\n  \
    \              j += 1\n            }\n            i += 1\n        }\n        return\
    \ vowelsRight\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0rpvuh4r.scala:32:31\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                currentVowel\
    \ = ch\n\e[31m\e[31m   |\e[0m                               ^^\e[0m\n\e[31m  \
    \ |\e[0m                               Found:    (ch : Char)\n\e[31m   |\e[0m\
    \                               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0rpvuh4r.scala:38:38 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mfor\e[0m ( j <- \e[31m0\e[0m until\
    \ vowels.length ) {\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value length is not a member of scala.collection.mutable.Set[String]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0rpvuh4r.scala:39:53 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m ( vowelsRight.charAt(i)\
    \ == vowels.charAt(j) ) {\n\e[31m\e[31m   |\e[0m                             \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value charAt is not a\
    \ member of scala.collection.mutable.Set[String]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp0rpvuh4r.scala:40:32 ------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                    vowelsRight += vowels.charAt(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0rpvuh4r.scala:40:42 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                    vowelsRight += vowels.charAt(j)\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value charAt is not a member of scala.collection.mutable.Set[String]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp0rpvuh4r.scala:46:18 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                j += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean j.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0"
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var best = 0\n \
    \       var bestVowel = \"\"\n        var currentVowel = \"\"\n        var lastVowel\
    \ = \"\"\n        var currentScore = 0\n        var isVowel = false\n        var\
    \ consonants = (\"bcdfghjklmnpqrstvwxyz\")\n        for(i <- 0 until word.length-1)\
    \ {\n            if (word(i) ==: \"a\" || word(i) ==: \"e\" || word(i) ==: \"\
    i\" || word(i) ==: \"o\" || word(i) ==: \"u\" || word(i) ==: \"A\" || word(i)\
    \ ==: \"E\" || word(i) ==: \"I\" || word(i) ==: \"O\" || word(i) ==: \"U\" ||\
    \ word(i) ==: \"a\" || word(i) ==: \"e\" || word(i) ==: \"i\" || word(i) ==: \"\
    o\" || word(i) ==: \"u\") {\n                currentScore = 0\n              \
    \  lastVowel = word(i)\n                isVowel = true\n            } else if(word(i)\
    \ ==: \"z\" || word(i) ==: \"Z\") {\n                currentScore = -1\n     \
    \           lastVowel = word(i)\n                isVowel = false\n           \
    \ }\n            if (isVowel) {\n                currentScore = currentScore +\
    \ 1\n            } else {\n                currentScore = currentScore - 1\n \
    \           }\n            \n            val newScore = currentScore*2\n     \
    \       if (newScore > best) {\n                best = newScore\n            \
    \    bestVowel = lastVowel\n            }\n        }\n        return bestVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdz1z7mlb.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (word(i) ==: \e[31m\"a\"\e\
    [0m || word(i) ==: \e[31m\"e\"\e[0m || word(i) ==: \e[31m\"i\"\e[0m || word(i)\
    \ ==: \e[31m\"o\"\e[0m || word(i) ==: \e[31m\"u\"\e[0m || word(i) ==: \e[31m\"\
    A\"\e[0m || word(i) ==: \e[31m\"E\"\e[0m || word(i) ==: \e[31m\"I\"\e[0m || word(i)\
    \ ==: \e[31m\"O\"\e[0m || word(i) ==: \e[31m\"U\"\e[0m || word(i) ==: \e[31m\"\
    a\"\e[0m || word(i) ==: \e[31m\"e\"\e[0m || word(i) ==: \e[31m\"i\"\e[0m || word(i)\
    \ ==: \e[31m\"o\"\e[0m || word(i) ==: \e[31m\"u\"\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   value ==: is not a\
    \ member of String - did you mean (\e[32m\"a\"\e[0m : String).==?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdz1z7mlb.scala:29:32 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                lastVowel = word(i)\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \           Found:    Char\n\e[31m   |\e[0m                            Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdz1z7mlb.scala:31:30\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            } \e[33melse\e\
    [0m \e[33mif\e[0m(word(i) ==: \e[31m\"z\"\e[0m || word(i) ==: \e[31m\"Z\"\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m   value ==: is not a member of String - did you mean (\e[32m\"z\"\e\
    [0m : String).==?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdz1z7mlb.scala:33:32\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                lastVowel = word(i)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Found:    Char\n\e[31m   |\e[0m                 \
    \           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel : String\
    \ = \"\"\n        val vowels = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\"\
    ,\"I\",\"O\",\"U\")\n        for (i <- word.lastIndex until word.length-1){\n\
    \            if (vowels.contains(word.charAt(i))){\n                vowel = vowel\
    \ + word.charAt(i)\n            }\n        }\n        if (vowel.length==0) {\n\
    \            return \"\"\n        }\n        return vowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppalncthb.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m (i <- word.lastIndex until word.length-\e\
    [31m1\e[0m){\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue lastIndex is not a member of String - did you mean word.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if(word.contains(\"\
    a\") && word.contains(\"e\") && word.contains(\"i\") && word.contains(\"o\") &&\
    \ word.contains(\"u\") && word.contains(\"y\") && word.contains(\"g\") && word.contains(\"\
    r\") && word.contains(\"t\") && word.contains(\"b\")) {\n            //return\
    \ \n            val vowelsIndexes: mutable.ArrayBuffer[Int] = mutable.ArrayBuffer(-1,\
    \ word.length-1)\n            var vowelIndex = 0\n            var currentVowelIndex\
    \ = 0\n            var currentConsonantIndex = 0\n            while(vowelIndex\
    \ < word.length) {\n                if(vowelsIndexes.length == 0 || vowelsIndexes.lastOption.isEmpty)\
    \ {\n                    currentVowelIndex = currentVowelIndex + 1\n         \
    \       } else {\n                    currentConsonantIndex = currentConsonantIndex\
    \ + 1\n                }\n                if(vowelsIndexes(currentVowelIndex)\
    \ == currentConsonantIndex) {\n                    vowelIndex = vowelIndex + 1\n\
    \                    currentVowelIndex = currentVowelIndex + 1\n             \
    \   } else {\n                    currentConsonantIndex = currentConsonantIndex\
    \ + 1\n                }\n            }\n            return word.substring(currentVowelIndex+1,\
    \ word.length-1)\n        }\n        \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpspq88gmw.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mvowelsIndexes\e[0m:\
    \ mutable.ArrayBuffer[\e[35mInt\e[0m] = mutable.ArrayBuffer(-\e[31m1\e[0m, word.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpspq88gmw.scala:21:58 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mvowelsIndexes\e[0m:\
    \ mutable.ArrayBuffer[\e[35mInt\e[0m] = mutable.ArrayBuffer(-\e[31m1\e[0m, word.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009838
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      var index = 0;\n \
    \     var leftVowel = Set.empty[String]\n      var rightVowel = Set.empty[String]\n\
    \      var length = word.length\n      while (index != length-1) {\n        val\
    \ mid = (index+length)/2\n        if(word.charAt(mid) == 'A'|| word.charAt(mid)\
    \ == 'a'){\n          leftVowel +=  word.substring(mid, mid+1)\n        } else\
    \ if (word.charAt(mid) == 'O'|| word.charAt(mid) == 'o'){\n          rightVowel\
    \ += word.substring(mid, mid+1)\n        }\n        index = mid + 1\n      }\n\
    \      var vowel = Set.empty[String]\n      if(leftVowel.isEmpty){\n        vowel\
    \ = rightVowel\n      }\n      else {\n        vowel = leftVowel ++ rightVowel\n\
    \      }\n      vowel.toList.last\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 6\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat Problem$.getClosestVowel(tmphc1tq082.scala:25)\n\tat Problem$.main(tmphc1tq082.scala:42)\n\
    \tat Problem.main(tmphc1tq082.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowel = \"a\"\
    \ :: \"e\" :: \"i\" :: \"o\" :: \"u\" :: Nil\n        val vowel1 = vowel.sorted\n\
    \        val vowel2 = vowel.sortBy(_.toString.toInt)\n        val vowel3 = vowel1.drop(vowel.size)\n\
    \        val vowel4 = vowel2.drop(vowel2.size)\n        val vowel5 = vowel3.drop(vowel3.size)\n\
    \        val vowel6 = vowel4.drop(vowel4.size)\n        val vowel7 = vowel5.drop(vowel5.size)\n\
    \        val vowel8 = vowel6.drop(vowel6.size)\n        val vowel9 = vowel7.drop(vowel7.size)\n\
    \        val vowel10 = vowel8.drop(vowel8.size)\n        val vowel11 = vowel9.drop(vowel9.size)\n\
    \        val vowel12 = vowel10.drop(vowel10.size)\n        val vowel13 = vowel11.drop(vowel11.size)\n\
    \        val vowel14 = vowel12.drop(vowel12.size)\n        val vowel15 = vowel13.drop(vowel13.size)\n\
    \        val vowel16 = vowel14.drop(vowel14.size)\n        val vowel17 = vowel15.drop(vowel15.size)\n\
    \        val vowel18 = vowel16.drop(vowel16.size)\n        val vowel19 = vowel17.drop(vowel17.size)\n\
    \        val vowel20 = vowel18.drop(vowel18.size)\n        val vowel21 = vowel19.drop(vowel19.size)\n\
    \        val vowel22 = vowel20.drop(vowel20.size)\n        val vowel23 = vowel21.drop(vowel21.size)\n\
    \        val vowel24 = vowel22.drop(vowel22.size)\n        val vowel25 = vowel23.drop(vowel23.size)\n\
    \        val vowel26 = vowel24.drop(vowel24.size)\n        val vowel27 = vowel25.drop(vowel25.size)\n\
    \        val vowel28 = vowel26.drop(vowel26.size)\n        val vowel29 = vowel27.drop(vowel27.size)\n\
    \        val vowel30 = vowel28.drop(vowel28.size)\n        val vowel31 = vowel29.drop(vowel29.size)\n\
    \        val vowel32 = vowel30.drop(vowel30.size)\n        val vowel33 = vowel31.drop(vowel31.size)\n\
    \        val vowel34 = vowel32.drop(vowel32.size)\n        val vowel35 = vowel33.drop(vowel33.size)\n\
    \        val vowel36 = vowel34.drop(vowel34.size)\n        val vowel37 = vowel35.drop(vowel35.size)\n\
    \        val vowel38 = vowel36.drop(vowel36.size)\n        val vowel39 = \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxv0w8d80.scala:58:21 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mvowel39\e[0m = \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxv0w8d80.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    u\",\"a\",\"i\",\"e\",\"o\",\"u\")\n        var lower = word.foldLeft(true)((v,c)\
    \ => v && c.isLetter)\n        if (lower) {\n            val lowerToUpper = word.map(_.toUpperCase)\n\
    \            val lowerToUpperIter = lowerToUpper.iterator\n            while (lowerToUpperIter.hasNext)\
    \ {\n                val candidate = lowerToUpperIter.next()\n               \
    \ val candidateUpper = candidate.toUpperCase\n                val foundVowel =\
    \ vowels.forall(_.equals(candidateUpper))\n                if (foundVowel) {\n\
    \                    return candidate\n                }\n            }\n    \
    \    }\n        return \"\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz8h5c7fn.scala:22:42 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mlowerToUpper\e[0m =\
    \ word.map(_.toUpperCase)\n\e[31m\e[31m   |\e[0m                             \
    \           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \ value toUpperCase is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = mutable.Set.empty[String]\n\
    \        var i = 0\n        for (i <- 1 to word.length-1) {\n            if (word.charAt(i)\
    \ == 'a'  || word.charAt(i) == 'e'  || word.charAt(i) == 'i' || word.charAt(i)\
    \ == 'o' || word.charAt(i) == 'u' ) {\n                vowels += word.substring(i,\
    \ i+1)\n            }\n        }\n        if (vowels.nonEmpty) {\n           \
    \ return vowels.min\n        }\n        return \"\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzwuegalp.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvowels\e[0m = mutable.Set.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        val vowelList = vowels.toList\n\
    \        val vowelIndex = word.lastIndexOfAny(vowelList)\n        val lowerString\
    \ = word.substring(0, vowelIndex)\n        val upperString = word.substring(vowelIndex\
    \ + 1)\n        var result = \"\"\n        var i = 0\n        for(letter <- lowerString)\
    \ {\n            val index = upperString.indexOf(letter)\n            val nextLetter\
    \ = upperString(index + 1)\n            val nextLetterIndex = upperString.indexOf(nextLetter)\n\
    \            if(index < vowelIndex && nextLetterIndex > vowelIndex) {\n      \
    \          result = letter\n                i = index + 1\n            }\n   \
    \     }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp446d6yt1.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelIndex\e[0m = word.lastIndexOfAny(vowelList)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue lastIndexOfAny is not a member of String - did you mean word.lastIndexOf?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp446d6yt1.scala:31:25 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                result = letter\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \  Found:    (letter : Char)\n\e[31m   |\e[0m                         Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var closest = \"\
    \"\n        val vs = vowel\n        val ps = consonants\n        val w = word\n\
    \        // iterate over consonants\n        for (c <- ps) {\n            // iterate\
    \ over vowel\n            for (i <- vs) {\n                // find minimum distance\
    \ between c and i\n                val minDiff = math.min(c.length(), i.length())\n\
    \                // use sliding window to find the next vowel \n             \
    \   // until a consonant found\n                val consonantsWithVowel = w.sliding(minDiff)\n\
    \                // try to find any vowel in the window \n                // that\
    \ is in the right position\n                val vowelsInWindow = consonantsWithVowel.find(_\
    \ == i)\n                // if the window has a vowel \n                // and\
    \ is in the right position\n                if (vowelsInWindow.nonEmpty && vowelsInWindow.last.charAt(minDiff)\
    \ == c) {\n                    closest = (closest match {\n                  \
    \      case \"\" => i\n                        case _ => i\n                 \
    \   })\n                }\n            }\n        }\n        closest\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpin2xvdbh.scala:20:17 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvs\e[0m = vowel\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^\e[0m\n\e[31m   |\e[0m                 Not\
    \ found: vowel\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpin2xvdbh.scala:21:17\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mps\e[0m = consonants\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                 Not found: consonants\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      var vowels: List[String]\
    \ = Nil\n      var vowelsSet: Set[String] = Nil\n      \n      for (i <- 0 until\
    \ word.length-1) {\n        for (j <- 0 until word.length - 1 - i){\n        \
    \  if (word.charAt(i) == word.charAt(j + 1)){\n            vowelsSet += word.charAt(j)\n\
    \          }\n        }\n      }\n      \n      if (vowelsSet.isEmpty){\n    \
    \    return \"\"\n      }\n      for (vowel <- vowelsSet){\n        if (vowels.contains(vowel)){\n\
    \          return vowel\n        }\n      }\n      \n      return \"\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu8351doi.scala:20:35\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m      \e[33mvar\e[0m \e[36mvowelsSet\e\
    [0m: \e[35mSet\e[0m[\e[35mString\e[0m] = Nil\n\e[31m\e[31m   |\e[0m          \
    \                         ^^^\e[0m\n\e[31m   |\e[0m                          \
    \      Found:    collection.immutable.Nil.type\n\e[31m   |\e[0m              \
    \                  Required: collection.mutable.Set[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu8351doi.scala:25:36 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            vowelsSet += word.charAt(j)\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                   Found:    Char\n\e[31m   |\e[0m                         Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        //TODO: Fill in\
    \ the function\n        var vowels = word.filter(_.isLetter)\n        vowels =\
    \ vowels.map(_.toUpperCase)\n        vowels = vowels.toArray\n        var res\
    \ = vowels.min((x,y)=> x.toString.indexOf(y).toString)\n        res.isEmpty\n\
    \            ? \"\"\n            : res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl2ll2a0u.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        vowels = vowels.map(_.toUpperCase)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpl2ll2a0u.scala:22:17 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        vowels = vowels.toArray\n\e[31m\e[31m   |\e[0m\
    \                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    Array[Char]\n\e[31m   |\e[0m                 Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2ll2a0u.scala:23:37 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mres\e[0m = vowels.min((\e\
    [36mx\e[0m,\e[36my\e[0m)=> x.toString.indexOf(y).toString)\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                     Found:    String\n\e[31m   |\e\
    [0m                                     Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl2ll2a0u.scala:26:14 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            : res\n\e[31m\e[31m   |\e[0m            \
    \  ^^^\e[0m\n\e[31m   |\e[0m              Not found: type res\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpl2ll2a0u.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        res.isEmpty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value isEmpty is not a member of Char\n5 errors found\n"
  stdout: ''
  timestamp: 1660009854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var currentVowel\
    \ = word.lastIndexOf(vowel)\n        if (currentVowel == -1 || currentVowel ==\
    \ word.length-1) return \"\"\n        val firstConsonant = word.substring(0, currentVowel+1)\n\
    \        var vowelsCount = 0\n        for(i <- 0 to currentVowel) {\n        \
    \    val currentConsonant = word.substring(currentVowel, i+1)\n            vowelsCount\
    \ += vowelsMap.contains(currentConsonant)\n        }\n        if (vowelsCount\
    \ > 1) currentVowel = word.lastIndexOf(vowel)\n        if (vowelsCount > 2) currentVowel\
    \ = word.lastIndexOf(vowel2)\n        if (vowelsCount > 3) currentVowel = word.lastIndexOf(vowel3)\n\
    \        if (vowelsCount > 4) currentVowel = word.lastIndexOf(vowel4)\n      \
    \  if (vowelsCount > 5) currentVowel = word.lastIndexOf(vowel5)\n        if (vowelsCount\
    \ > 6) currentVowel = word.lastIndexOf(vowel6)\n        if (vowelsCount > 7) currentVowel\
    \ = word.lastIndexOf(vowel7)\n        if (vowelsCount > 8) currentVowel = word.lastIndexOf(vowel8)\n\
    \        if (vowelsCount > 9) currentVowel = word.lastIndexOf(vowel9)\n      \
    \  word.substring(currentVowel)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3dzb5ww0.scala:19:44 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mcurrentVowel\e[0m = word.lastIndexOf(vowel)\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                            Not found: vowel\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3dzb5ww0.scala:25:24\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            vowelsCount +=\
    \ vowelsMap.contains(currentConsonant)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3dzb5ww0.scala:25:27\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            vowelsCount +=\
    \ vowelsMap.contains(currentConsonant)\n\e[31m\e[31m   |\e[0m                \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ vowelsMap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3dzb5ww0.scala:27:61\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (vowelsCount\
    \ > \e[31m1\e[0m) currentVowel = word.lastIndexOf(vowel)\n\e[31m\e[31m   |\e[0m\
    \                                                             ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                        Not found: vowel\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3dzb5ww0.scala:28:61\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (vowelsCount\
    \ > \e[31m2\e[0m) currentVowel = word.lastIndexOf(vowel2)\n\e[31m\e[31m   |\e\
    [0m                                                             ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                       Not found:\
    \ vowel2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] "
  stdout: ''
  timestamp: 1660009854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = mutable.Set.empty[Char]\n\
    \        for (i <- 0 until word.length - 1) {\n            val c = word.charAt(i)\n\
    \            val l = c to word.charAt(i + 1)\n            vowels ++= l\n     \
    \   }\n        vowels.toList.sortWith( (x,y) => x < y ).lastOption\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplkgike2v.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.Set.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009849
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val arr = Array(\"y\",\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\"\
    ,\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        var start\
    \ = 0\n        var end = word.length\n\n        while (start < end){\n       \
    \     var vowel = \"\"\n            for(i <- start until end){\n             \
    \   vowel += arr(i).toLowerCase + arr(i +1)\n            }\n            vowel\
    \ = vowel.substring(1, vowel.length)\n            if(vowels.exists(x => vowel\
    \ == x)){\n                return vowel\n            }\n            start += 1\n\
    \        }\n        return \"\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw5vzhrte.scala:38)\n\tat Problem.main(tmpw5vzhrte.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // get last 2 consonants\
    \ to get 'y'\n        var consonants = word.last\n        for( i <- 0 until word.length-1\
    \ ){\n            if(consonants == 'c') consonants = word.last\n            else\
    \ consonants = word.last\n        }\n        // get last vowel in the word\n \
    \       var vowels = word.last\n        // if the word's last letter is consonants,\
    \ find the consonants that stands between the right side of the word\n       \
    \ for( i <- 0 until word.length-1 ){\n            if( word.last.equals('c') ){\n\
    \                vowels = word.last\n                // if the right side of the\
    \ word is a consonant, find the vowels that stands between the left side of the\
    \ word \n                for( i <- 0 until word.length-1 ){\n                \
    \    if( word.last.equals('c') ){\n                        vowels = word.last\n\
    \                    }\n                }\n            }\n        }\n        //\
    \ if there is no vowel, return an empty string\n        if( vowels == \"\" ){\n\
    \            return \"\"\n        }\n        // get vowel count between right\
    \ side and left side of the word\n        val vowelCount = word.count( c => c.equals(vowels)\
    \ )\n        // if vowel count is less than 3, return an empty string\n      \
    \  if( vowelCount < 3 ){\n            return \"\"\n        }\n        // loop\
    \ through the vowels and check which vowel has the least count among all vowels\n\
    \        var vowelWithLowestCount = \"\"\n        var temp = \"\"\n        for(\
    \ i <- 0 until vowels.length ){\n            temp = vowels(i)\n            val\
    \ vowelCount = word.count( c => c.equals(temp) )\n            if( vowelCount <\
    \ vowelWithLowestCount ){\n                vowelWithLowestCount = temp\n     \
    \       }\n        }\n        // return the vowel with the lowest count\n    \
    \    return vowelWithLowestCount\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpicjbtmih.scala:40:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mif\e[0m( vowels == \e[31m\"\"\e[0m ){\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpicjbtmih.scala:52:33 ------------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m        \e[33mfor\e[0m( i <- \e[31m0\e[0m until vowels.length\
    \ ){\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value length is not a member of Char\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpicjbtmih.scala:53:19 -----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m            temp = vowels(i)\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^\e[0m\n\e[31m   |\e[0m                   \e[33mvariable\e\
    [0m \e[35mvowels\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpicjbtmih.scala:55:27 -----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mif\e[0m( vowelCount < vowelWithLowestCount\
    \ ){\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \ None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Boolean\n\
    \e[31m   |\e[0m  (x: Float): Boolean\n\e[31m   |\e[0m  (x: Long): Boolean\n\e\
    [31m   |\e[0m  (x: Int): Boolean\n\e[31m   |\e[0m  (x: Char): Boolean\n\e[31m\
    \   |\e[0m  (x: Short): Boolean\n\e[31m   |\e[0m  (x: Byte): Boolean\n\e[31m \
    \  |\e[0m match arguments ((vowelWithLowestCount : String))\n4 errors found\n"
  stdout: ''
  timestamp: 1660009855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if(word.length ==\
    \ 0) \"\"\n        else if(word.length == 1) \"\"\n        else if(word.charAt(word.length\
    \ - 1) == word.charAt(0)) \"\"\n        else word.last.init.toString.last.init\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hywfubo.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m word.last.init.toString.last.init\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value init is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\".toSet\n        val words = word.dropRight(2).map { x => x.toLower\
    \ }\n        val vowelsMap = words.sliding(2).flatMap(x => vowels.intersect(x.flatMap(y\
    \ => vowels.contains(y)))).distinct\n        val index = vowelsMap.indexOf(vowels.minBy(x\
    \ => Math.abs(vowelsMap.length - 1 - x)).get)\n        if(index < 0) \"\"\n  \
    \      else word.takeRight(2).drop(index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqjlqxrty.scala:21:73 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m = words.sliding(\e\
    [31m2\e[0m).flatMap(\e[36mx\e[0m => vowels.intersect(x.flatMap(\e[36my\e[0m =>\
    \ vowels.contains(y)))).distinct\n\e[31m\e[31m   |\e[0m                      \
    \                                                 ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mflatMap\e[0m\
    \ in \e[33mclass\e[0m \e[35mStringOps\e[0m with types\n\e[31m   |\e[0m (f: Char\
    \ => String): String\n\e[31m   |\e[0m [B](f: Char => IterableOnce[B]): IndexedSeq[B]\n\
    \e[31m   |\e[0mmatch arguments (Char => Boolean)\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpqjlqxrty.scala:22:92 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = vowelsMap.indexOf(vowels.minBy(\e\
    [36mx\e[0m => Math.abs(vowelsMap.length - \e[31m1\e[0m - x)).get)\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value get is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660009854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val vowel = word.substring(word.length\
    \ - 1).map(c => vowels contains c.toLowerCase && c != \" \")\n        if(vowel.nonEmpty)\n\
    \            vowel.headOption.getOrElse(\"\")\n        else\n            \"\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwpnqgnln.scala:20:79 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowel\e[0m = word.substring(word.length\
    \ - \e[31m1\e[0m).map(\e[36mc\e[0m => vowels contains c.toLowerCase && c != \e\
    [31m\" \"\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                            value toLowerCase is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwpnqgnln.scala:22:38 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            vowel.headOption.getOrElse(\e[31m\"\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Found:    Matchable\n\e[31m   |\e[0m            Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelSet = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        val\
    \ lowerSet = Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val upperSet = Set(\"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\"\
    , \"X\", \"Y\", \"Z\")\n        val wordSet = Set(\"a\", \"b\", \"c\", \"d\",\
    \ \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n        var currentVowel : Option[String] = None\n        var currentLower\
    \ : Option[String] = None\n        var currentUpper: Option[String] = None\n \
    \       var currentWord: Option[String] = None\n\n        var nextLower: Option[String]\
    \ = None\n        var nextUpper: Option[String] = None\n        var nextWord:\
    \ Option[String] = None\n\n        var prevLower: Option[String] = None\n    \
    \    var prevUpper: Option[String] = None\n        var prevWord: Option[String]\
    \ = None\n\n        var nextVowel: Option[String] = None\n        var nextWordSet:\
    \ Option[String] = None\n        var nextVowelSet: Option[String] = None\n   \
    \     var prevWordSet: Option[String] = None\n\n        val wordSetSet = word.toSet.toSet\n\
    \        for (char <- word.dropRight(1)) {\n            currentLower = if (lowerSet.contains(char))\
    \ Some(lowerSet(word.lastIndexOf(char)))\n            else currentLower\n\n  \
    \          currentUpper = if (upperSet.contains(char)) Some(upperSet(word.lastIndexOf(char)))\n\
    \            else currentUpper\n\n            currentWord = if (wordSet.contains(char))\
    \ Some(wordSet(word.lastIndexOf(char)))\n            else currentWord\n\n    \
    \        currentVowel = if (vowelSet.contains(char)) Some(vowelSet(word.lastIndexOf(char)))\n\
    \            else currentVowel\n\n            prevLower = if (lowerSet.contains(char))\
    \ Some(lowerSet(word.lastIndexOf(char)))\n            else prevLower\n\n     \
    \       prevUpper = if (upperSet.contains(char)) Some(upperSet(word.lastIndexOf(char)))\n\
    \            else prevUpper\n\n            prevWord = if (wordSet.contains(char))\
    \ Some(wordSet(word.lastIndexOf(char)))\n            else prevWord\n\n       \
    \     prev\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgdv283o2.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdv283o2.scala:43:49\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m            currentLower = \e\
    [33mif\e[0m (lowerSet.contains(char)) Some(lowerSet(word.lastIndexOf(char)))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                                 Found:    (char\
    \ : Char)\n\e[31m   |\e[0m                                                 Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdv283o2.scala:43:86\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m            currentLower = \e\
    [33mif\e[0m (lowerSet.contains(char)) Some(lowerSet(word.lastIndexOf(char)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                      Found:    Int\n\e[31m   |\e[0m        \
    \                                                Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdv283o2.scala:46:49 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            currentUpper = \e[33mif\e[0m (upperSet.contains(char))\
    \ Some(upperSet(word.lastIndexOf(char)))\n\e[31m\e[31m   |\e[0m              \
    \                                   ^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                  Found:    (char : Char)\n\e[31m   |\e[0m  \
    \                                               Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdv283o2.scala:46:86 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            currentUpper = \e[33mif\e[0m (upperSet.contains(char))\
    \ Some(upperSet(w"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var count = 0\n\
    \        var vowels = List(\"a\",\"e\",\"i\",\"o\",\"u\")\n        var vowelsUpper\
    \ = List(\"A\",\"E\",\"I\",\"O\",\"U\")\n        var vowelsLower = List(\"a\"\
    ,\"e\",\"i\",\"o\",\"u\")\n        var vowelsAll = vowels\n        var vowelsUpperAll\
    \ = vowelsUpper\n        var vowelsLowerAll = vowelsLower\n        var vowelsAllSet\
    \ = vowelsAll.toSet\n        var vowelsUpperAllSet = vowelsUpperAll.toSet\n  \
    \      var vowelsLowerAllSet = vowelsLowerAll.toSet\n        var vowelsAllSetReverse\
    \ = vowelsAllSet.tail.reverse\n        var vowelsUpperAllSetReverse = vowelsUpperAllSet.tail.reverse\n\
    \        var vowelsLowerAllSetReverse = vowelsLowerAllSet.tail.reverse\n     \
    \   val vowelsAllSetReverseIter = vowelsAllSetReverse.iterator\n        val vowelsUpperAllSetReverseIter\
    \ = vowelsUpperAllSetReverse.iterator\n        val vowelsLowerAllSetReverseIter\
    \ = vowelsLowerAllSetReverse.iterator\n        val vowelsAllSetReverseIterNext\
    \ = vowelsAllSetReverseIter.next\n        val vowelsUpperAllSetReverseIterNext\
    \ = vowelsUpperAllSetReverseIter.next\n        val vowelsLowerAllSetReverseIterNext\
    \ = vowelsLowerAllSetReverseIter.next\n        val vowelsAllSetReverseIterNext2\
    \ = vowelsAllSetReverseIterNext.next\n        val vowelsUpperAllSetReverseIterNext2\
    \ = vowelsUpperAllSetReverseIterNext.next\n        val vowelsLowerAllSetReverseIterNext2\
    \ = vowelsLowerAllSetReverseIterNext.next\n        while (vowelsAllSetReverseIterNext2\
    \ != null) {\n            vowelsAllSetReverseIterNext = vowelsAllSetReverseIterNext2\n\
    \            vowelsUpperAllSetReverseIterNext = vowelsUpperAllSetReverseIterNext2\n\
    \            vowelsLowerAllSetReverseIterNext = vowelsLowerAllSetReverseIterNext2\n\
    \            vowelsAllSetReverseIterNext2 = vowelsAllSetReverseIterNext2.next\n\
    \            vowelsUpperAllSetReverseIterNext2 = vowelsUpperAllSetReverseIterNext2.next\n\
    \            vowelsLowerAllSetReverseIterNext2 = vowelsLowerAllSetReverseIterNext2.next\n\
    \        }\n        val vowelsAllIter = vowelsAllIterator.filter(c => !vowelsAllSetReverse.contains(c))\n\
    \        var vowelsUpperIter\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppr7043qz.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppr7043qz.scala:29:52\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e\
    [36mvowelsAllSetReverse\e[0m = vowelsAllSet.tail.reverse\n\e[31m\e[31m   |\e[0m\
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue reverse is not a member of Set[String @uncheckedVariance] - did you mean\
    \ Set[String @uncheckedVariance].reversed?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmppr7043qz.scala:30:62 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mvar\e[0m \e[36mvowelsUpperAllSetReverse\e[0m = vowelsUpperAllSet.tail.reverse\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Set[String @uncheckedVariance]\
    \ - did you mean Set[String @uncheckedVariance].reversed?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppr7043qz.scala:31:62 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mvowelsLowerAllSetReverse\e[0m\
    \ = vowelsLowerAllSet.tail.reverse\n\e[31m\e[31m   |\e[0m                    \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Set[String @uncheckedVariance] - did you mean Set[String\
    \ @uncheckedVariance].reversed?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmppr7043qz.scala:42:40\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            vowelsAllSetReverseIterNext\
    \ = vowelsAllSetReverseIterNext2\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val vowelsAllSetReverseIterNext\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmppr7043qz.scala:43:45 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            vowelsUpperAllSetReverseIterNext = vowels"
  stdout: ''
  timestamp: 1660009855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var result = \"\"\n        for (i <-\
    \ 0 until word.length) {\n            if (vowels.contains(word.charAt(i))) {\n\
    \                result = word.charAt(i)\n                break\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc4cgkehv.scala:22:43\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (vowels.contains(word.charAt(i)))\
    \ {\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Found:    Char\n\e[31m   |\e[0m\
    \                                Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpc4cgkehv.scala:23:36 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                result = word.charAt(i)\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                   Found:    Char\n\e[31m   |\e[0m                         Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4cgkehv.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        var leftVowels = Set[String]();\n\
    \        var rightVowels = Set[String]();\n        for (c <- word) {\n       \
    \     if (vowels.contains(c)) leftVowels += c;\n            else rightVowels +=\
    \ c;\n        }\n        val v1 = rightVowels.min[(String, String, String, String)];\n\
    \        val v2 = leftVowels.min[(String, String, String, String)];\n        if\
    \ (v1 == v2) return \"\";\n        return v2;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4e568_uj.scala:23:32\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (vowels.contains(c))\
    \ leftVowels += c;\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\
    \e[31m   |\e[0m                                Found:    (c : Char)\n\e[31m  \
    \ |\e[0m                                Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4e568_uj.scala:23:50 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (vowels.contains(c)) leftVowels\
    \ += c;\n\e[31m\e[31m   |\e[0m                                               \
    \   ^^\e[0m\n\e[31m   |\e[0m                                                 \
    \ Found:    (c : Char)\n\e[31m   |\e[0m                                      \
    \            Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4e568_uj.scala:24:32 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33melse\e[0m rightVowels += c;\n\e[31m\e[31m   |\e[0m \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \          Found:    (c : Char)\n\e[31m   |\e[0m                             \
    \   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def searchByVowel\
    \ (word : String) : String = {\n            val vowels = mutable.List(\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n            for\
    \ (i <- 0 until word.length){\n                if (vowels(word.charAt(i)) == word.charAt(word.length)){\n\
    \                    word.substring(0, i)\n                } else {\n        \
    \            word.substring(i)\n                }\n            }\n        }\n\
    \        def searchByConsonant (word : String) : String = {\n            val consonants\
    \ = mutable.List(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"\
    )\n            for (i <- 0 until word.length){\n                if (consonants(word.charAt(i))\
    \ == word.charAt(word.length)){\n                    word.substring(0, i)\n  \
    \              } else {\n                    word.substring(i)\n             \
    \   }\n            }\n        }\n        val vowels = searchByVowel(word)\n  \
    \      val consonants = searchByConsonant(word)\n        if (vowels == \"\" &&\
    \ consonants == \"\"){\n            \"\"\n        } else {\n            val index\
    \ = vowels.indexOf(consonants, 0)\n            if (index < 0){\n             \
    \   \"\"\n            } else {\n                vowels(index)\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuzgf56jt.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mvowels\e[0m = mutable.List(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m, \e[31m\"A\"\e[0m, \e[31m\"E\"\e[0m, \e[31m\"I\"\e[0m, \e[31m\"O\"\e\
    [0m, \e[31m\"U\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuzgf56jt.scala:21:12 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m until word.length){\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            Found:   \
    \ Unit\n\e[31m   |\e[0m            Required: String\n\e[31m22 |\e[0m         \
    \       \e[33mif\e[0m (vowels(word.charAt(i)) == word.charAt(word.length)){\n\e\
    [31m23 |\e[0m                    word.substring(\e[31m0\e[0m, i)\n\e[31m24 |\e\
    [0m                } \e[33melse\e[0m {\n\e[31m25 |\e[0m                    word.substring(i)\n\
    \e[31m26 |\e[0m                }\n\e[31m27 |\e[0m            }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpuzgf56jt.scala:30:29 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mconsonants\e[0m = mutable.List(\e\
    [31m\"b\"\e[0m, \e[31m\"c\"\e[0m, \e[31m\"d\"\e[0m, \e[31m\"f\"\e[0m, \e[31m\"\
    g\"\e[0m, \e[31m\"h\"\e[0m, \e[31m\"j\"\e[0m, \e[31m\"k\"\e[0m, \e[31m\"l\"\e\
    [0m, \e[31m\"m\"\e[0m, \e[31m\"n\"\e[0m, \e[31m\"p\"\e[0m, \e[31m\"q\"\e[0m, \e\
    [31m\"r\"\e[0m, \e[31m\"s\"\e[0m, \e[31m\"t\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"\
    w\"\e[0m, \e[31m\"x\"\e[0m, \e[31m\"z\"\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuzgf56jt.scala:31:12\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m (i\
    \ <- \e[31m0\e[0m until word.length){\n\e[31m\e[31m  "
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        val\
    \ start = word.lastIndexWhile(_ != 'a')\n        val end = word.lastIndexWhile(_\
    \ != 'e')\n        if (start < 0 || end < 0 || end < start) {\n            return\
    \ \"\"\n        }\n        var start = word.length\n        var end = word.length\n\
    \        while (start > 0 && start < word.length && vowels.contains(word.charAt(start)))\
    \ {\n            start--\n        }\n        while (end > 0 && end < word.length\
    \ && vowels.contains(word.charAt(end))) {\n            end++\n        }\n    \
    \    if (start >= end || end < start) {\n            return \"\"\n        }\n\
    \        val vowel = word.substring(start + 1, end)\n        if (vowel.equals(\"\
    a\")) return \"\"\n        if (vowel.equals(\"e\")) return \"\"\n        if (vowel.equals(\"\
    i\")) return \"\"\n        if (vowel.equals(\"o\")) return \"\"\n        if (vowel.equals(\"\
    u\")) return \"\"\n        return vowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmsnbyyz7.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            start--\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpmsnbyyz7.scala:31:12\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \     end++\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        misaligned end marker\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmsnbyyz7.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mstart\e[0m = word.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstart is already defined as \e[33mvalue\e[0m \e[35mstart\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmsnbyyz7.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mvar\e[0m \e[36mend\e[0m = word.length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mend is already defined\
    \ as \e[33mvalue\e[0m \e[35mend\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmsnbyyz7.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstart\e[0m = word.lastIndexWhile(_\
    \ != \e[31m'a'\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value lastIndexWhile is not a member of\
    \ String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmsnbyyz7.scala:21:23\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mend\e[0m = word.lastIndexWhile(_ != \e[31m'e'\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ value lastIndexWhile is not a member of String\n6 errors found\n"
  stdout: ''
  timestamp: 1660009856
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var result : String\
    \ = \"\"\n        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n      \
    \  for (vowel <- vowels) {\n            val index = word.lastIndexOf(vowel, word.length\
    \ - 2)\n            if (index > 0) result = vowel\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj6qca3ne.scala:28)\n\tat Problem.main(tmpj6qca3ne.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val charSeq = word.substring(2,\
    \ word.length-1)\n        val vowelSeq = List('u', 'U', 'a', 'A')\n        val\
    \ vowelCountSeq = vowelSeq.map(x => (x, word.count(x => x == x)))\n        val\
    \ vowelCountSeqWithIndex = vowelCountSeq.zipWithIndex\n        val vowelCountSeqWithIndexSortedByCount\
    \ = vowelCountSeqWithIndex.sortBy{case (vowelCount, index) => vowelCount}\n  \
    \      val vowelCountSeqWithIndexSortedByIndexAndCount = vowelCountSeqWithIndexSortedByCount.sortBy{case\
    \ (vowelCount, index) => index}\n        vowelCountSeqWithIndexSortedByIndexAndCount.find(_._1\
    \ == vowelSeq.head).get._2 match {\n            case x if x > 0 => vowelSeq.head\n\
    \            case x if x < 0 => \"\"\n            case _ => \"\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_vy6vrbd.scala:25:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        vowelCountSeqWithIndexSortedByIndexAndCount.find(_._1\
    \ == vowelSeq.head).get._2 \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m         \
    \                                                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m   Values of types (Char, Int) and Char cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_vy6vrbd.scala:26:40\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mcase\e[0m x\
    \ \e[33mif\e[0m x > \e[31m0\e[0m => vowelSeq.head\n\e[31m\e[31m   |\e[0m     \
    \                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                Found:    Char\n\e[31m   |\e[0m                             \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def getVowels(word\
    \ : String) : List[Char] = {\n            def getVowels(word : String) : List[Char]\
    \ = {\n                if (word.length <= 0)\n                    return Nil\n\
    \                val vowels = Array(\"a\", \"e\", \"i\", \"o\", \"u\")\n     \
    \           val first = word.head\n                if (vowels(0) < first && vowels(0)\
    \ < word.last)\n                    getVowels(word.tail)\n                else\
    \ {\n                    if (vowels(0) < first || vowels(0) < word.last)\n   \
    \                     getVowels(word.tail)\n                    else\n       \
    \                 vowels\n                }\n            }\n            getVowels(word)\n\
    \        }\n        val vowels = getVowels(word)\n        if (vowels.length <=\
    \ 0)\n            return \"\"\n        val vowelIndex = vowels.indexOf(0)\n  \
    \      if (vowelIndex < 0 || vowelIndex == 0)\n            return \"\"\n     \
    \   val leftConsonantIndex = vowelIndex - 1\n        val rightConsonantIndex =\
    \ vowelIndex + 1\n        val firstCharacter = word.charAt(leftConsonantIndex\
    \ - 1)\n        val lastCharacter = word.charAt(rightConsonantIndex - 1)\n   \
    \     val leftConsonant = word.substring(0, leftConsonantIndex)\n        val rightConsonant\
    \ = word.substring(0, rightConsonantIndex)\n        val allVowels = vowels.toList\
    \ ++ List(firstCharacter, lastCharacter)\n        if (allVowels.contain(leftConsonant))\
    \ {\n            if (allVowels.contain(rightConsonant))\n                return\
    \ \"\"\n            val leftVowelIndex = vowels.indexOf(leftConsonant)\n     \
    \       val rightVowelIndex = vowels.indexOf(rightConsonant)\n            if (leftVowelIndex\
    \ < 0 || leftVowelIndex == 0 || leftVowelIndex == leftConsonantIndex + 1)\n  \
    \              return \"\"\n            if (rightVowelIndex < 0 || rightVowelIndex\
    \ == 0 || rightVowelIndex == rightConsonantIndex + 1)\n                return\
    \ \"\"\n            val leftVowel = vowels(leftVowelIndex)\n            val rightVowel\
    \ = vowels(rightVowelIndex)\n            val leftFirstCharacter = word.substring(0,\
    \ leftConsonantIndex - 1)\n            val leftLastCharacter = word.substring(0,\
    \ rightConsonantIndex - 1)\n            val rightFirstCharacter = word.substring(leftConsonantIndex\
    \ + 1, rightConsonantIndex + 1)\n            val rightLastCharacter = word.substring(rightConsonantIndex\
    \ + 1, word.length - 1)\n            if (leftFirstCharacter == leftConsonant)\n\
    \                if (rightFirstCharact\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2syb6vbx.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2syb6vbx.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp2syb6vbx.scala:25:32 --------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                \e[33mif\e[0m (vowels(\e[31m0\e[0m) < first &&\
    \ vowels(\e[31m0\e[0m) < word.last)\n\e[31m\e[31m   |\e[0m                   \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                                Found:\
    \    (first : Char)\n\e[31m   |\e[0m                                Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2syb6vbx.scala:25:58\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m\
    \ (vowels(\e[31m0\e[0m) < first && vowels(\e[31m0\e[0m) < word.last)\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     Found:\
    \    Char\n\e[31m   |\e[0m                                                   \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2syb6vbx.scala:28:36\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    \e[33mif\e\
    [0m (vowels(\e[31m0\e[0m) < first || vowels(\e[31m0\e[0m) < word.last)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                   Found:    (first : Char)\n\e[31m   |\e[0m\
    \                                    Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2syb6vbx.scala:28:62 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mif\e[0m (vowels(\e[31m"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\".toSet\n        val vowelsReversed = vowels.reverse \n        val\
    \ result = word.splitRight(vowels.size)\n            .zip(vowelsReversed)\n  \
    \          .filter{case (left, right) => left == right}\n            .map(_._1)\n\
    \            .mkString\n\n        result.isEmpty() ? \"\" : result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvfmmnz2p.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsReversed\e[0m = vowels.reverse\
    \ \n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue reverse is not a member of Set[Char] - did you mean vowels.reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvfmmnz2p.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = word.splitRight(vowels.size)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     value splitRight is not a member of String\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvfmmnz2p.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        result.isEmpty() ? \e[31m\"\"\e[0m : \e[35mresult\e\
    [0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                Not found: type result\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Your code goes\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplcfyzhma.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m    \e[33mdef\e[0m \e[36mgetClosestVowel\e\
    [0m(\e[36mword\e[0m : \e[35mString\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                  ^\e[0m\n\e[31m   |\e\
    [0m                                                  Found:    Unit\n\e[31m  \
    \ |\e[0m                                                  Required: String\n\e\
    [31m19 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m20 |\e[0m    }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiou\"\n        val vowelList = new mutable.HashSet[String]()\n        val wordList\
    \ = word.split(\" \")\n        wordList.foreach {\n            item => vowelList.add(item.toUpperCase)\n\
    \        }\n        val reversedWord = wordList.reverse\n        val consonantsList\
    \ = reversedWord.filter(_ !in vowels)\n        val consonantsSet = consonantsList.toSet\n\
    \        val consonantsCount = consonantsSet.size \n        if(vowelCount < wordList.size){\n\
    \            return \"\"\n        }else{\n            val closest = wordList.zip(consonantsSet).minBy\
    \ { case (word,consonant) => Math.abs(consonant-word) }\n            vowelList.toSet.contains(closest.get._2)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq5rnzikh.scala:26:61 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mconsonantsList\e[0m = reversedWord.filter(_\
    \ !in vowels)\n\e[31m\e[31m   |\e[0m                                         \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq5rnzikh.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelList\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq5rnzikh.scala:26:51\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonantsList\e[0m = reversedWord.filter(_ !in vowels)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^\e[0m\n\e[31m   |\e[0m\
    \                                       value ! is not a member of String\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpq5rnzikh.scala:29:11 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mif\e[0m(vowelCount < wordList.size){\n\e\
    [31m\e[31m   |\e[0m           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           Not found:\
    \ vowelCount\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq5rnzikh.scala:32:105\
    \ -----------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m\
    \ \e[36mclosest\e[0m = wordList.zip(consonantsSet).minBy { \e[33mcase\e[0m (word,consonant)\
    \ => Math.abs(consonant-word) }\n\e[31m\e[31m   |\e[0m                       \
    \                                                                         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels : mutable.Set[String]\
    \ = mutable.Set(\"a\",\"e\",\"i\",\"o\",\"u\")\n        var bestVowel : String\
    \ = empty\n        var bestDistance : Int = -1\n        var firstIndex : Int =\
    \ word.lastIndex.toInt\n        var lastIndex : Int = word.lastIndex.toInt\n \
    \       if(firstIndex < lastIndex)\n            for(i <- firstIndex to lastIndex)\
    \ {\n                val current : String = word(i)\n                val candidateVowels\
    \ = vowels.intersect(current.toUpperCase).toSet\n                val candidateDistance\
    \ : Int = candidateVowels.size - 1\n                if(candidateDistance < bestDistance)\n\
    \                    bestDistance = candidateDistance\n                for(j <-\
    \ candidateVowels.reverse to 0 by -1) {\n                    val c : String =\
    \ candidateVowels(j)\n                    if(current == c)\n                 \
    \       return c\n                }\n            }\n        bestVowel\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_egrby2g.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m : mutable.Set[\e\
    [35mString\e[0m] = mutable.Set(\e[31m\"a\"\e[0m,\e[31m\"e\"\e[0m,\e[31m\"i\"\e\
    [0m,\e[31m\"o\"\e[0m,\e[31m\"u\"\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_egrby2g.scala:19:43\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mvowels\e[0m : mutable.Set[\e[35mString\e[0m] = mutable.Set(\e[31m\"a\"\e[0m,\e\
    [31m\"e\"\e[0m,\e[31m\"i\"\e[0m,\e[31m\"o\"\e[0m,\e[31m\"u\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                           ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_egrby2g.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mbestVowel\e[0m : \e[35mString\e\
    [0m = empty\n\e[31m\e[31m   |\e[0m                                 ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Not found: empty\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_egrby2g.scala:22:36 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mfirstIndex\e[0m : \e[35mInt\e\
    [0m = word.lastIndex.toInt\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex is not a member of String\
    \ - did you mean word.lastIndexOf?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_egrby2g.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e\
    [36mlastIndex\e[0m : \e[35mInt\e[0m = word.lastIndex.toInt\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex\
    \ is not a member of String - did you mean word.lastIndexOf?\n\e[31m\e[31m-- [E007"
  stdout: ''
  timestamp: 1660009860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\"\n        val wordList = new mutable.HashSet[String]()\n        val\
    \ wordArray = word.split(\"\").reverse\n        for (i <- 0 to wordArray.length\
    \ - 1) {\n            if (vowels.contains(wordArray(i))) {\n                wordList.add(wordArray(i))\n\
    \            }\n        }\n        return if (wordList.size == 0) \"\" else wordList.minBy(_.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppg518mj4.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mwordList\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      def vowel(str : String)\
    \ : Boolean = {\n        val strLen = str.length\n        for ( i <- 0 until strLen\
    \ ) {\n          if ( (str.charAt(i) == 'a' || str.charAt(i) == 'e' || str.charAt(i)\
    \ == 'i' || str.charAt(i) == 'o' || str.charAt(i) == 'u') && str.charAt(i) !=\
    \ str.charAt(i-1) ) \n            false\n          else\n            true\n  \
    \      }\n      }\n      def isVowel(str : String) : Boolean = {\n        val\
    \ strLen = str.length\n        for ( i <- 0 until strLen ) {\n          if ( (str.charAt(i)\
    \ == 'a' || str.charAt(i) == 'e' || str.charAt(i) == 'i' || str.charAt(i) == 'o'\
    \ || str.charAt(i) == 'u') && str.charAt(i) != str.charAt(i+1) ) \n          \
    \  false\n          else\n            true\n        }\n      }\n      def isConsonant(str\
    \ : String) : Boolean = {\n        val strLen = str.length\n        for ( i <-\
    \ 0 until strLen ) {\n          if ( (str.charAt(i) != 'a' && str.charAt(i) !=\
    \ 'e' && str.charAt(i) != 'i' && str.charAt(i) != 'o' && str.charAt(i) != 'u')\
    \ && str.charAt(i) != str.charAt(i+1) ) \n            false\n          else\n\
    \            true\n        }\n      }\n      def isInVowel(str : String) : Boolean\
    \ = {\n        val strLen = str.length\n        for ( i <- 0 until strLen ) {\n\
    \          if ( (str.charAt(i) == 'a' || str.charAt(i) == 'e' || str.charAt(i)\
    \ == 'i' || str.charAt(i) == 'o' || str.charAt(i) == 'u') && str.charAt(i) !=\
    \ str.charAt(i-1) ) \n            false\n          else\n            true\n  \
    \      }\n      }\n      def isInConsonant(str : String) : Boolean = {\n     \
    \   val strLen = str.length\n        for ( i <- 0 until strLen ) {\n         \
    \ if ( (str.charAt(i) != 'a' && str.charAt(i) != 'e' && str.charAt(i) != 'i' &&\
    \ str.charAt(i) != 'o' && str.charAt(i) != 'u') && str.charAt(i) != str.charAt(i+1)\
    \ ) \n            false\n          else\n            true\n        }\n      }\n\
    \      def isInBoth(str : String) : Boolean = {\n        val strLen = str.length\n\
    \        for ( i <- 0 until strLen ) {\n          if ( (str.charAt(i) == 'a' ||\
    \ str.charAt(i) == 'e' || str.charAt(i) == 'i' || str.charAt(i) == 'o' || str.charAt(i)\
    \ == 'u') && str.charAt(i) != str.charAt(i+1) ) \n            \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7k1dabiu.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7k1dabiu.scala:87:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7k1dabiu.scala:21:8 ---------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mfor\e[0m ( i <- \e[31m0\e[0m until strLen ) {\n\e\
    [31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m\
    \   |\e[0m        Required: Boolean\n\e[31m22 |\e[0m          \e[33mif\e[0m (\
    \ (str.charAt(i) == \e[31m'a'\e[0m || str.charAt(i) == \e[31m'e'\e[0m || str.charAt(i)\
    \ == \e[31m'i'\e[0m || str.charAt(i) == \e[31m'o'\e[0m || str.charAt(i) == \e\
    [31m'u'\e[0m) && str.charAt(i) != str.charAt(i-\e[31m1\e[0m) ) \n\e[31m23 |\e\
    [0m            \e[31mfalse\e[0m\n\e[31m24 |\e[0m          \e[33melse\e[0m\n\e\
    [31m25 |\e[0m            \e[31mtrue\e[0m\n\e[31m26 |\e[0m        }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k1dabiu.scala:30:8 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mfor\e[0m ( i <- \e[31m0\e[0m until strLen\
    \ ) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: Boolean\n\e[31m31 |\e[0m          \e[33mif\e\
    [0m ( (str.charAt(i) == \e[31m'a'\e[0m || str.charAt(i) == \e[31m'e'\e[0m || str.charAt(i)\
    \ == \e[31m'i'\e[0m || str.charAt(i) == \e[31m'o'\e[0m || str.charAt(i) == \e\
    [31m'u'\e[0m) && str.charAt(i) != str.charAt(i+\e[31m1\e[0m) ) \n\e[31m32 |\e\
    [0m            \e[31mfalse\e[0m\n\e[31m33 |\e[0m          \e[33melse\e[0m\n\e\
    [31m34 |\e[0m            \e[31mtrue\e[0m\n\e[31m35 |\e[0m        }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k1dabiu.scala:39:8 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m ( i <- \e[31m0\e[0m until strLen\
    \ ) {\n\e[31m\e"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // check left side\
    \ of word is consonant\n        if(word.length >= 2 && !word.substring(0, 1).isLetter){\n\
    \            return \"\"\n        }\n        // create two sets to store the consonants\
    \ and vowels in the right side\n        val vowels = Set(\"a\", \"e\", \"i\",\
    \ \"o\", \"u\")\n        val consonants = Set(\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n        \n        // get each letter from\
    \ the right side of word and add it into vowel and consonants\n        val rightSideLetters\
    \ = word.substring(word.length -1)\n        vowels ++= rightSideLetters.filter(letter\
    \ => vowels.contains(letter))\n        consonants ++= rightSideLetters.filter(letter\
    \ => !vowels.contains(letter))\n        \n        // return the vowel that stands\
    \ between two consonants from the right side of the word\n        if(vowels.size\
    \ == 1){\n            return vowels.head\n        }else if(vowels.size == 2){\n\
    \            return consonants.min\n        }else{\n            return \"\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplo167hs1.scala:20:53 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(word.length >= \e[31m2\e[0m &&\
    \ !word.substring(\e[31m0\e[0m, \e[31m1\e[0m).isLetter){\n\e[31m\e[31m   |\e[0m\
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                value isLetter is not a member of String\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplo167hs1.scala:29:69 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        vowels ++= rightSideLetters.filter(\e[36mletter\e\
    [0m => vowels.contains(letter))\n\e[31m\e[31m   |\e[0m                       \
    \                                              ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                             Found:    (letter : Char)\n\e[31m\
    \   |\e[0m                                               Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplo167hs1.scala:30:74\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        consonants ++= rightSideLetters.filter(\e\
    [36mletter\e[0m => !vowels.contains(letter))\n\e[31m\e[31m   |\e[0m          \
    \                                                                ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    (letter\
    \ : Char)\n\e[31m   |\e[0m                                               Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\"\n        val array = word.filter(x => vowels.contains(x))\n     \
    \   var resultStr = \"\"\n        var flag = false\n        var vowelCount = 0\n\
    \        for (i <- 0 until array.length-1) {\n            if (array(i).equals(\"\
    y\") || array(i).equals(\"o\") || array(i).equals(\"u\") || array(i).equals(\"\
    A\") || array(i).equals(\"E\") || array(i).equals(\"I\") || array(i).equals(\"\
    O\") || array(i).equals(\"U\")) {\n                vowelCount += 1\n         \
    \       if (vowelCount > 1) {\n                    flag = true\n             \
    \   }\n            }\n        }\n        if (!flag) {\n            return resultStr\n\
    \        }\n        var i = 0\n        while (vowelCount > 1) {\n            if\
    \ (word(i).equals(\"y\") || word(i).equals(\"o\") || word(i).equals(\"u\") ||\
    \ word(i).equals(\"A\") || word(i).equals(\"E\") || word(i).equals(\"I\") || word(i).equals(\"\
    O\") || word(i).equals(\"U\")) {\n                vowelCount -= 1\n          \
    \  }\n            i += 1\n        }\n        resultStr = word.substring(i, word.length-1)\n\
    \        return resultStr\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzdejife4.scala:46)\n\tat Problem.main(tmpzdejife4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word == null\
    \ || word.length == 0) \n            return \"\";\n\n        val vowels = mutable.Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        // the right side of last consonant\
    \ from the right side of given word\n        val r = word.last.charAt(word.length-1)\n\
    \        // The closest vowel is the left side of first vowel from the right side\
    \ of the given word\n        val w = word.charAt(word.length-1)\n\n        if\
    \ (vowels.contains(w) && vowels.contains(r))\n            return w;\n        else\
    \ if (vowels.contains(w))\n            return \"\";\n        else if (vowels.contains(r))\n\
    \            return \"\";\n        else\n            return \"\";\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptglcgj_x.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = mutable.Set(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptglcgj_x.scala:24:26 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = word.last.charAt(word.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value charAt is not a member of Char\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmptglcgj_x.scala:29:19 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mreturn\e[0m w;\n\e[31m\e[31m   |\e\
    [0m                   ^^\e[0m\n\e[31m   |\e[0m                   Found:    (w\
    \ : Char)\n\e[31m   |\e[0m                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\")\n        var vowel\
    \ = 0\n        var result = ''\n        val strLen = word.length\n        for\
    \ ((i, s) <- 0 until strLen ) {\n            if(vowels.contains(word.charAt(strLen\
    \ - i - 1))) {\n                vowel = i\n            }\n        }\n        if(vowel\
    \ == vowels.length) {\n            result = word.charAt(strLen - vowel - 1)\n\
    \        } else {\n            result = word.charAt(strLen - vowel)\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp43irap34.scala:21:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = ''\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ empty character literal\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43irap34.scala:23:31\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m ((i,\
    \ s) <- \e[31m0\e[0m until strLen ) {\n\e[31m\e[31m   |\e[0m                 \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: strLen\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43irap34.scala:24:43\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(vowels.contains(word.charAt(strLen\
    \ - i - \e[31m1\e[0m))) {\n\e[31m\e[31m   |\e[0m                             \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \         Not found: strLen\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp43irap34.scala:25:24 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                vowel = i\n\e[31m\e[31m   |\e[0m                     \
    \   ^\e[0m\n\e[31m   |\e[0m                        Found:    (i : Any)\n\e[31m\
    \   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp43irap34.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            result = word.charAt(strLen - vowel - \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Not found: strLen\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43irap34.scala:31:33 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            result = word.charAt(strLen - vowel)\n\e\
    [31m\e[31m   |\e[0m                                 "
  stdout: ''
  timestamp: 1660009866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        val\
    \ vowelsWithoutCaps = Set(\"A\", \"E\", \"I\", \"O\", \"U\")\n        val consonants\
    \ = Set(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\
    \ \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n        val consonantsWithoutCaps = Set(\"b\", \"c\", \"d\", \"f\", \"g\",\
    \ \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\", \"A\")\n        val letters = word.toCharArray\n\
    \        val vowelFound = Array.ofDim[Char]((letters.size - 1).toInt)\n      \
    \  val consonantFound = Array.ofDim[Char]((letters.size - 1).toInt)\n\n      \
    \  for(i <- 0 until letters.size - 1) {\n            val letter = letters(i)\n\
    \n            if((letter == 'a') || (letter == 'A')) {\n                vowelFound(i)\
    \ = letter\n            }\n            else if((letter == 'e') || (letter == 'E'))\
    \ {\n                vowelFound(i) = letter\n            }\n            else if((letter\
    \ == 'i') || (letter == 'I')) {\n                vowelFound(i) = letter\n    \
    \        }\n            else if((letter == 'o') || (letter == 'O')) {\n      \
    \          vowelFound(i) = letter\n            }\n            else if((letter\
    \ == 'u') || (letter == 'U')) {\n                vowelFound(i) = letter\n    \
    \        }\n\n            if((letter == 'b') || (letter == 'B')) {\n         \
    \       consonantFound(i) = letter\n            }\n            else if((letter\
    \ == 'c') || (letter == 'C')) {\n                consonantFound(i) = letter\n\
    \            }\n            else if((letter == 'd') || (letter == 'D')) {\n  \
    \              consonantFound(i) = letter\n            }\n            else if((letter\
    \ == 'f') || (letter == 'F')) {\n                consonantFound(i) = letter\n\
    \            }\n            else if((letter == 'g') || (letter == 'G')) {\n  \
    \              consonantFound(i) = letter\n            }\n            else if((letter\
    \ == 'h') || (letter == 'H')) {\n                consonantFound(i) = letter\n\
    \            }\n            else if((letter == 'j') || (letter == 'J')) {\n  \
    \              consonantFound(i) = letter\n            }\n            else if((letter\
    \ == 'k') || (letter == 'K')) {\n                consonantFound(i) = letter\n\
    \            }\n            else if((letter == 'l') \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslqq8xha.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslqq8xha.scala:89:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpslqq8xha.scala:88:1 ---------------------\e[0m\e[0m\n\
    \e[31m88 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpslqq8xha.scala:72:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m72 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        val consonants = Set(\"b\",\
    \ \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\");\n        val wordToCheck\
    \ = word.split(\"\")\n        var closestVowel = \"\"\n        var closestConsonant\
    \ = \"\"\n        var consonantIndex = 0;\n        var vowelIndex = 0;\n     \
    \   for (index = 0; index <= word.length - 1; index++) {\n            val letter\
    \ = wordToCheck(index);\n            val letter = letter.toLowerCase // to handle\
    \ case of vowel before a consonant\n            if (consonantIndex < consonants.size)\n\
    \            {\n                if (letter contains consonants(consonantIndex))\
    \ {\n                    closestConsonant = letter\n                    consonantIndex\
    \ = consonantIndex + 1\n                } else if (letter == \"a\" || letter ==\
    \ \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" || letter ==\
    \ \"y\") {\n                    closestConsonant = letter\n                  \
    \  consonantIndex = consonantIndex + 1\n                }\n            }\n   \
    \         else\n            {\n                if (vowelIndex < vowels.size)\n\
    \                {\n                    if (letter contains vowels(vowelIndex))\
    \ {\n                        closestVowel = letter\n                        vowelIndex\
    \ = vowelIndex + 1\n                    } else if (letter == \"a\" || letter ==\
    \ \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" || letter ==\
    \ \"y\") {\n                        closestVowel = letter\n                  \
    \      vowelIndex = vowelIndex + 1\n                    }\n                }\n\
    \                else\n                {\n                    if (letter == \"\
    a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\"\
    \ || letter == \"y\") {\n                        closestVowel = letter\n     \
    \               }\n                }\n            }\n        }\n        closestVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm_rmixr2.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (index = \e[31m0\e[0m; index <=\
    \ word.length - \e[31m1\e[0m; index++) {\n\e[31m\e[31m   |\e[0m              \
    \     ^\e[0m\n\e[31m   |\e[0m                   ')' expected, but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpm_rmixr2.scala:26:48 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (index = \e[31m0\e[0m; index <=\
    \ word.length - \e[31m1\e[0m; index++) {\n\e[31m\e[31m   |\e[0m              \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                         '<-' expected, but ';' found\n\e[31m\e[31m-- [E032]\
    \ Syntax Error: /tmp/tmpm_rmixr2.scala:26:57 ---------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (index = \e[31m0\e[0m; index <= word.length\
    \ - \e[31m1\e[0m; index++) {\n\e[31m\e[31m   |\e[0m                          \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                  pattern expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpm_rmixr2.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (index = \e[31m0\e[0m; index <=\
    \ word.length - \e[31m1\e[0m; index++) {\n\e[31m\e[31m   |\e[0m              \
    \        ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Null, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |"
  stdout: ''
  timestamp: 1660009869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List('a','e','i','o','u')\n\
    \        val vowelsFound = mutable.MutableList[Boolean]()\n        var closestVowel\
    \ = \"\"\n        for(i <- 0 until word.length - 1){\n            val currChar\
    \ = word.charAt(i)\n            if(vowelsFound.getOrElse(currChar,false) == false){\n\
    \                for(j <- 0 until vowels.length - 1){\n                    val\
    \ currVowel = vowels(j)\n                    if(currChar == currVowel){\n    \
    \                    vowelsFound.set(currChar,true)\n                    }\n \
    \               }\n            }\n        }\n        vowelsFound.foreach {\n \
    \           case true => {\n                closestVowel = vowels(vowels.indexOf(_)+1)\n\
    \            }\n        }\n        closestVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl1qp5bcz.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelsFound\e[0m = mutable.MutableList[\e\
    [35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def findVowel(index\
    \ : Int, word : String) : Option[String] = {\n            val i = index + 1\n\
    \            val j = word.lastIndex + 1\n            var found : Option[String]\
    \ = None\n            if (word.charAt(i) == word.charAt(j)) {\n              \
    \  if (i == j) {\n                    found =\n                        Some(word.substring(i,\
    \ j))\n                } else {\n                    val x = i\n             \
    \       val y = j\n                    while (x < j) {\n                     \
    \   val z = x + 1\n                        if (word.charAt(z) == word.charAt(y))\
    \ {\n                            val v = word.substring(z, y)\n              \
    \              val r = findVowel(z, v)\n                            val c = findVowel(y,\
    \ v)\n                            val s = findVowel(x, v)\n                  \
    \          if (r.isDefined && c.isDefined && s.isDefined) {\n                \
    \                found = Some(v)\n                            }\n            \
    \            }\n                        val z = x - 1\n                      \
    \  if (word.charAt(z) == word.charAt(y)) {\n                            val v\
    \ = word.substring(z, y)\n                            val r = findVowel(z, v)\n\
    \                            val c = findVowel(y, v)\n                       \
    \     val s = findVowel(x, v)\n                            if (r.isDefined &&\
    \ c.isDefined && s.isDefined) {\n                                found = Some(v)\n\
    \                            }\n                        }\n                  \
    \      val y = y - 1\n                    }\n                }\n            }\n\
    \            found\n        }\n        findVowel(word.length, word)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprdhdprml.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mj\e[0m = word.lastIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue lastIndex is not a member of String - did you mean word.lastIndexOf?\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdhdprml.scala:41:28 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        \e[33mval\e[0m \e[36mz\e[0m =\
    \ x - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmprdhdprml.scala:51:32 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                        \e[33mval\e[0m \e[36my\e[0m = y - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               Recursive \e[33mvalue\e[0m \e[35my\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprdhdprml.scala:57:17\
    \ --------------------\e[0m\e[0m\n\e[31m57 |\e[0m        findVowel(word.length,\
    \ word)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31mOption\e[0m\e[1m\e[31m[\e[0mString\e[1m\e\
    [31m]\e[0m\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word == null\
    \ || word.isEmpty || word.charAt(word.length-1) == ' ') {\n            return\
    \ \"\"\n        }\n\n        var vowelsBetween = List(word.charAt(word.length-1),\
    \ word.charAt(word.length-2))\n        val firstVowel = vowelsBetween.filter(c\
    \ => c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        val secondVowel\
    \ = vowelsBetween.filter(c => c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n\n        if (firstVowel.isEmpty || secondVowel.isEmpty) {\n    \
    \        return \"\"\n        }\n\n        var i = 0\n        var minDiff = math.min(firstVowel.length,\
    \ secondVowel.length)\n        val vowels = firstVowel.take(minDiff).intersect(secondVowel.take(minDiff)).toSet\n\
    \        var minVowel = vowels.min.asInstanceOf[Char]\n        var maxVowel =\
    \ vowels.max.asInstanceOf[Char]\n\n        for(v <- vowels) {\n            var\
    \ i = 0\n            var min = math.min(firstVowel.length, secondVowel.length)\n\
    \            while(i < min) {\n                var diff = firstVowel.charAt(i)\
    \ - v\n                if (diff <= 0) {\n                    diff = firstVowel.charAt(i)\
    \ - v\n                }\n                if(diff > 0) {\n                   \
    \ i++\n                    min = math.min(firstVowel.length, secondVowel.length)\n\
    \                }\n            }\n            while(i < min) {\n            \
    \    var diff = secondVowel.charAt(i) - v\n                if(diff <= 0) {\n \
    \                   diff = secondVowel.charAt(i) - v\n                }\n    \
    \            if(diff > 0) {\n                    i++\n                    min\
    \ = math.min(firstVowel.length, secondVowel.length)\n                }\n     \
    \       }\n            if(min == 0) {\n                minDiff = min\n       \
    \         minVowel = v\n                maxVowel = v\n            }\n        }\n\
    \        if (minDiff == 0) {\n            return \"\"\n        }\n        return\
    \ minVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpziwp4gi6.scala:47:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    min = math.min(firstVowel.length,\
    \ secondVowel.length)\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e\
    [31m   |\e[0m                        end of statement expected but '=' found\n\
    \e[31m\e[31m-- Error: /tmp/tmpziwp4gi6.scala:57:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                    min = math.min(firstVowel.length,\
    \ secondVowel.length)\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e\
    [31m   |\e[0m                        end of statement expected but '=' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpziwp4gi6.scala:41:38 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mvar\e[0m \e[36mdiff\e[0m = firstVowel.charAt(i)\
    \ - v\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           value charAt is not a member of List[Char]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpziwp4gi6.scala:43:38 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    diff = firstVowel.charAt(i) - v\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value charAt is not a member of List[Char]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpziwp4gi6.scala:46:21 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    i++\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpziwp4gi6.scala:51:39\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m                \e[33mvar\e\
    [0m \e[36mdiff\e[0m = secondVowel.charAt(i) - v\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \           value charAt is not a member of List[Char]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpziwp4gi6.scala:53:39 ------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m                    diff = secondVowel.charAt(i) - v\n\e[31m\e\
    [31m   |\e[0m                "
  stdout: ''
  timestamp: 1660009871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def vowels(w: Char)\
    \ = {\n            w.toLower.toArray.filterNot(('a' to 'z').contains)\n      \
    \  }\n        val arr = word.trim\n        val idx = arr.lastIndexOf('a')\n  \
    \      val lastIndex = arr.lastIndexOf('z')\n        val first = vowels(arr(idx+1))\n\
    \        val last = vowels(arr(lastIndex-1))\n        val c = arr(idx+2)\n   \
    \     if(!c.isEmpty && vowels(c).contains(first) && vowels(c).contains(last))\n\
    \            first + last\n        else\n            \"\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpluxkrkdj.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            w.toLower.toArray.filterNot((\e[31m'a'\e\
    [0m to \e[31m'z'\e[0m).contains)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value toArray is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpluxkrkdj.scala:28:14 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m(!c.isEmpty && vowels(c).contains(first)\
    \ && vowels(c).contains(last))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value isEmpty is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var firstVowel : Int = 0\n        var\
    \ lastVowel : Int = 0\n        var count = 0\n        for (v <- vowels) {\n  \
    \          val vIndex = word.indexOf(v, lastVowel + 1)\n            if (vIndex\
    \ == -1) \n                break\n            lastVowel = vIndex\n           \
    \ count += 1\n        }\n        if (count == 0) \n            return \"\"\n \
    \       var vIndex = 0\n        var firstIndex = word.lastIndexOf('u')\n     \
    \   if (firstIndex == -1)\n            firstIndex = 0\n        for (v <- vowels)\
    \ {\n            val vIndex = word.indexOf(v, firstIndex + 1)\n            if\
    \ (vIndex == -1) \n                break\n            firstVowel = vIndex\n  \
    \      }\n        var i = 0\n        while (i < count && word.charAt(lastVowel\
    \ + i) != 'u') i += 1\n        if (word.charAt(lastVowel + i) == 'u')\n      \
    \      i += 1\n        var j = count\n        while (j > 0 && !word.charAt(lastVowel\
    \ + i - 1) != 'u') j -= 1\n        if (word.charAt(lastVowel + i) == 'u')\n  \
    \          i += 1\n        val left = word.substring(0, firstVowel)\n        val\
    \ right = word.substring(firstVowel + i, lastVowel)\n        val leftIndex = 0\n\
    \        val rightIndex = 0\n        var i = 0\n        while (i < left.length\
    \ && i < right.length) {\n            if (left.charAt(i) != right.charAt(i))\n\
    \                break\n            i += 1\n        }\n        val closest = left.substring(leftIndex,\
    \ i)\n        if (closest == \"\")\n            closest = \"U\"\n        val rest\
    \ = right.substring(i + 2, lastVowel)\n        if (rest == \"\")\n           \
    \ rest = \"U\"\n        val result = closest + rest\n        result \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk4ojtq9j.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4ojtq9j.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4ojtq9j.scala:39:16 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk4ojtq9j.scala:47:24 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mwhile\e[0m (j > \e[31m0\e[0m && !word.charAt(lastVowel\
    \ + i - \e[31m1\e[0m) != \e[31m'u'\e[0m) j -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m      value unary_! is not a member of Char - did you mean Char.unary_+?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4ojtq9j.scala:57:16 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpk4ojtq9j.scala:62:20 -----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m            closest = \e[31m\"U\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val closest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[3"
  stdout: ''
  timestamp: 1660009869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var vowelsIndex : Int = 0\n        var\
    \ wordIndex : Int = 0\n        var vowelsLength : Int = vowels.length\n      \
    \  var result : String = null\n\n        while(wordIndex < word.length){\n   \
    \         if (vowels(wordIndex).toLowerCase == vowels(vowelsIndex).toLowerCase){\n\
    \                vowelsIndex += 1\n                vowelsLength += 1\n       \
    \     } else {\n                vowelsIndex = vowelsLength - 1\n            }\n\
    \            wordIndex += 1\n        }\n\n        result = (word.length/vowelsLength)*vowelsIndex\n\
    \        if(result>=0)\n            vowels(result).toLowerCase\n        else\n\
    \            \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpybslp02n.scala:35:17\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        result = (word.length/vowelsLength)*vowelsIndex\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Int\n\e[31m   |\e[0m          \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpybslp02n.scala:36:19 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mif\e[0m(result>=\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                ^\e[0m\n\e[31m   |\e[0m                   Found:    (\e[31m0\e\
    [0m : Int)\n\e[31m   |\e[0m                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpybslp02n.scala:37:19 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            vowels(result).toLowerCase\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    (result : String)\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\"\n        val vowelsLower = \"aeiouaieou\"\n        val vowelsUpper\
    \ = \"AIEOU\"\n        var i = 0\n        var j = 0\n        var foundVowel :\
    \ String = \"\"\n        var vowelLength = 0\n        var vowelIndex = 0\n   \
    \     var consonantIndex = 0\n        var consonantLength = 0\n        var consonants\
    \ = word.toLowerCase().toList\n\n        if (vowels.contains(consonants(0)) &&\
    \ vowels.contains(consonants(consonants.length - 1))) {\n            vowelLength\
    \ = consonants(0).toString.length\n            vowelIndex = consonants.length\
    \ - 1\n            vowelLength = vowelLength - vowels(vowelIndex).length\n   \
    \     }\n\n        if (vowelsLower.contains(consonants(0)) && vowelsLower.contains(consonants(consonants.length\
    \ - 1))) {\n            vowelLength = consonants(0).toString.length\n        \
    \    vowelIndex = consonants.length - 1\n            vowelLength = vowelLength\
    \ - vowels(vowelIndex).length\n        }\n\n        if (vowelsUpper.contains(consonants(0))\
    \ && vowelsUpper.contains(consonants(consonants.length - 1))) {\n            vowelLength\
    \ = consonants(0).toString.length\n            vowelIndex = consonants.length\
    \ - 1\n            vowelLength = vowelLength - vowels(vowelIndex).length\n   \
    \     }\n\n        while (i < vowelLength && j < consonantLength) {\n        \
    \    if (vowels(vowelIndex) == consonants(consonantIndex)) {\n               \
    \ foundVowel = consonants(consonantIndex)\n                consonantIndex = consonantIndex\
    \ + 1\n                if (consonantIndex == consonants.length) {\n          \
    \          consonantIndex = 0\n                    consonantLength = consonantLength\
    \ + 1\n                }\n                i = i + 1\n                j = 0\n \
    \           }\n            else if (consonants(consonantIndex).compareTo(consonants(consonantIndex\
    \ - 1)) == 0) {\n                foundVowel = consonants(consonantIndex - 1)\n\
    \                consonantIndex = consonantIndex - 1\n                i = i\n\
    \                j = 0\n            }\n            else if (consonants(consonantIndex).compareTo(consonants(consonantIndex\
    \ + 1)) == 0) {\n                foundVowel = consonants(consonantIndex + 1)\n\
    \                consonantIndex = consonantIndex + 1\n                i = i\n\
    \                j = 0\n            }\n            else if (vowels(vowelIndex).compareTo(consonants(consonantIndex))\
    \ == \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_hy7n24b.scala:72:80 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (vowels(vowelIndex).compareTo(consonants(consonantIndex))\
    \ == \n\e[31m\e[31m   |\e[0m                                                 \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp_hy7n24b.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hy7n24b.scala:34:59\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            vowelLength =\
    \ vowelLength - vowels(vowelIndex).length\n\e[31m\e[31m   |\e[0m             \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                  value length is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_hy7n24b.scala:40:59 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            vowelLength = vowelLength - vowels(vowelIndex).length\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value length is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hy7n24b.scala:46:59\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            vowelLength =\
    \ vowelLength - vowels(vowelIndex).length\n\e[31m\e[31m   |\e[0m             \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                  value length is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_hy7n24b.scala:51:39 --------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                foundVowel = consonants(consonantIndex)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    Char\n\e[31m   |\e\
    [0"
  stdout: ''
  timestamp: 1660009872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def closest(s:String):String={\n\
    \            val vowels = mutable.HashSet(\"a\",\"e\",\"i\",\"o\",\"u\")\n   \
    \         val vowelsAndCons = vowels ++ Set(s.charAt(0), s.charAt(s.length-1))\n\
    \            vowelsAndCons.foldRight(\"\")( (x,y) =>{\n                val m =\
    \ y.toLowerCase match {\n                    case \"a\"..\"e\"    => -1\n    \
    \                case \"i\"..\"o\"    => -1\n                    case \"u\"..\"\
    u\" => -1\n                    case _ => 0\n                }\n              \
    \  val m = math.min(m, x.toLowerCase match {\n                    case \"a\"..\"\
    e\"    => -1\n                    case \"i\"..\"o\"    => -1\n               \
    \     case \"u\"..\"u\" => -1\n                    case _ => 0\n             \
    \   })\n                val s = x.toLowerCase match {\n                    case\
    \ \"a\"..\"e\"    => \"e\"\n                    case \"i\"..\"o\"    => \"o\"\n\
    \                    case \"u\"..\"u\" => \"u\"\n                    case _ =>\
    \ x\n                }\n                s.charAt(m)\n            })\n        }\n\
    \        val vowels = mutable.HashSet(\"a\",\"e\",\"i\",\"o\",\"u\")\n       \
    \ val cons = vowels ++ Set(word.charAt(word.length-1), word.charAt(word.length))\n\
    \        cons.foldRight(\"\")((x,y) => {\n            val m = y.toLowerCase match\
    \ {\n                case \"a\"..\"e\"    => -1\n                case \"i\"..\"\
    o\"    => -1\n                case \"u\"..\"u\" => -1\n                case _\
    \ => 0\n            }\n            val m = math.min(m, x.toLowerCase match {\n\
    \                case \"a\"..\"e\"    => -1\n                case \"i\"..\"o\"\
    \    => -1\n                case \"u\"..\"u\" => -1\n                case _ =>\
    \ 0\n            })\n            val s = x.toLowerCase match {\n             \
    \   case \"a\"..\"e\"    => \"e\"\n                case \"i\"..\"o\"    => \"\
    o\"\n                case \"u\"..\"u\" => \"u\"\n                case _ => x\n\
    \            }\n            s.charAt(m)\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01wa8qjp.scala:24:28 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    \e[33mcase\e[0m \e[31m\"a\"\e[0m..\e\
    [31m\"e\"\e[0m    => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \        ^\e[0m\n\e[31m   |\e[0m                            '=>' expected, but\
    \ '.' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01wa8qjp.scala:25:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e\
    [33mcase\e[0m \e[31m\"i\"\e[0m..\e[31m\"o\"\e[0m    => -\e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               '=>' expected, but '.' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp01wa8qjp.scala:26:28 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    \e[33mcase\e[0m \e[31m\"u\"\e[0m..\e[31m\"u\"\e[0m\
    \ => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e\
    [31m   |\e[0m                            '=>' expected, but '.' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp01wa8qjp.scala:30:28 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mcase\e[0m \e[31m\"a\"\e[0m..\e\
    [31m\"e\"\e[0m    => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \        ^\e[0m\n\e[31m   |\e[0m                            '=>' expected, but\
    \ '.' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01wa8qjp.scala:31:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    \e\
    [33mcase\e[0m \e[31m\"i\"\e[0m..\e[31m\"o\"\e[0m    => -\e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               '=>' expected, but '.' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp01wa8qjp.scala:32:28 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    \e[33mcase\e[0m \e[31m\"u\"\e[0m..\e[31m\"u\"\e[0m\
    \ => -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e\
    [31m   |\e[0m                            '=>' expected, but '.' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp01wa8qjp.scala:36:28 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    \e[33mcase\e[0m \e[31m\"a\"\e[0m..\e\
    [31m\"e\"\e[0m    "
  stdout: ''
  timestamp: 1660009865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    AEIOUaeiouAEIOUaeiou\".toUpperCase\n        val vowelsArray = vowels.toCharArray\n\
    \        val vowelsSet = vowelsArray.toSet\n        val consonants = \"bcdfghjklmnpqrstvwxz\"\
    .toUpperCase\n        val consonantsArray = consonants.toCharArray\n        val\
    \ consonantsSet = consonantsArray.toSet\n        val reversedWord = word.reverse\n\
    \        val vowelIndicesArray = reversedWord.substring(0,reversedWord.length).reverse.groupBy(e\
    \ => vowelsSet.contains(e)).map(_._2).toArray\n        var vowelIndex = 0\n  \
    \      val rightIndex = word.lastIndexOf(' ')\n        val rightIndex = if(rightIndex\
    \ < 0) word.length else rightIndex\n        val rightVowels = word.substring(rightIndex).reverse.groupBy(e\
    \ => vowelsSet.contains(e)).map(_._2).toArray\n        var rightVowelIndex = 0\n\
    \        val leftIndex = word.indexOf(reversedWord.charAt(reversedWord.length\
    \ - 1))\n        val leftIndex = if(leftIndex < 0) word.length else leftIndex\n\
    \        val leftVowels = word.substring(0,leftIndex).reverse.groupBy(e => vowelsSet.contains(e)).map(_._2).toArray\n\
    \        var leftVowelIndex = 0\n        val rightVowelIndex = word.substring(rightIndex).lastIndexOf('\
    \ ')\n        val rightVowelIndex = if(rightVowelIndex < 0) 0 else rightVowelIndex\n\
    \        var foundVowelIndex = -1\n        var foundRightVowelIndex = -1\n   \
    \     var foundLeftVowelIndex = -1\n        val vowelsCount = vowelIndicesArray.length\n\
    \        val rightVowelsCount = rightVowels.length\n        val leftVowelsCount\
    \ = leftVowels.length\n        if(vowelsCount > rightVowelsCount && vowelsCount\
    \ > leftVowelsCount) foundVowelIndex = vowelIndicesArray(0)\n        if(rightVowelsCount\
    \ > vowelsCount && rightVowelsCount > leftVowelsCount) foundRightVowelIndex =\
    \ rightVowelIndices(0)\n        if(leftVowelsCount > vowelsCount && leftVowelsCount\
    \ > rightVowelsCount) foundLeftVowelIndex = leftVowelIndices(0)\n        if(foundVowelIndex\
    \ != -1 && foundRightVowelIndex != -1 \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7590x_sx.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7590x_sx.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightIndex\e[0m = \e[33mif\e[0m(rightIndex < \e[31m0\e[0m) word.length\
    \ \e[33melse\e[0m rightIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightIndex is already defined as \e[33mvalue\e[0m \e[35mrightIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7590x_sx.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mleftIndex\e[0m = \e[33mif\e[0m(leftIndex\
    \ < \e[31m0\e[0m) word.length \e[33melse\e[0m leftIndex\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftIndex is already defined as \e[33mvalue\e[0m \e[35mleftIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7590x_sx.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mrightVowelIndex\e[0m = word.substring(rightIndex).lastIndexOf(\e\
    [31m' '\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightVowelIndex is already defined as \e[33mvariable\e[0m\
    \ \e[35mrightVowelIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7590x_sx.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mrightVowelIndex\e[0m = \e\
    [33mif\e[0m(rightVowelIndex < \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m rightVowelIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = \"\"\
    \n        var leftConsonant = word.last.charAt(word.length - 2)\n        var rightConsonant\
    \ = word.last.charAt(word.length - 1)\n        for (c <- word.last until word.length-1)\
    \ {\n            if (c.equals(\"a\") || c.equals(\"e\") || c.equals(\"i\") ||\
    \ c.equals(\"o\") || c.equals(\"u\")) {\n                vowel = vowel + c\n \
    \           } else if (c.equals(leftConsonant) || c.equals(rightConsonant)) {\n\
    \                break\n            } else {\n                vowel = vowel +\
    \ c\n            }\n        }\n        vowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxrtq7nn5.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mleftConsonant\e[0m = word.last.charAt(word.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value charAt is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxrtq7nn5.scala:21:39 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mrightConsonant\e[0m = word.last.charAt(word.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value charAt is not a member\
    \ of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrtq7nn5.scala:22:34\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mfor\e[0m (c <-\
    \ word.last until word.length-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                  Found:    Int\n\e[31m   |\e[0m                            \
    \      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxrtq7nn5.scala:26:16\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def getVowelPosition(w:String)\
    \ : Int = {\n            val pos = w.toCharArray.zipWithIndex.find { \n      \
    \          case (c,i) => c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' \n            }.getOrElse(throw new IllegalArgumentException(\"word must\
    \ have English letter\"))\n            pos\n        }\n        val vowels = Set(\"\
    aeiou\")\n        val vowelsCount = word.flatMap(vowels.contains).size\n     \
    \   val consonants = word.filter(c => c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').flatMap(_.toChar)\n        if (vowelsCount == 0 && consonants.size\
    \ > 0) {\n            return word.find(c => vowels.contains(c.toLowerCase)).orElse\
    \ \"\"\n        } else if (vowelsCount > 0 && consonants.size == 0) {\n      \
    \      return word.find(c => vowels.contains(c.toLowerCase)).orElse \"\"\n   \
    \     } else if (vowelsCount == 0 && consonants.size > 0) {\n            return\
    \ word.find(c => vowels.contains(c.toLowerCase)).orElse \"\"\n        } else {\n\
    \            val pos = getVowelPosition(word)\n            if (pos == consonants.size\
    \ - 1) {\n                return word.find(c => vowels.contains(c.toLowerCase)).orElse\
    \ \"\"\n            } else if (pos < consonants.size) {\n                return\
    \ word.find(c => vowels.contains(c.toLowerCase)).orElse \"\"\n            } else\
    \ {\n                return word.find(c => vowels.contains(c.toLowerCase)).orElse\
    \ \"\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2zv6fob_.scala:29:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mreturn\e[0m word.find(\e[36mc\e[0m\
    \ => vowels.contains(c.toLowerCase)).orElse \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                         ^\e\
    [0m\n\e[31m   |\e[0m                      end of statement expected but string\
    \ literal found\n\e[31m\e[31m-- Error: /tmp/tmp2zv6fob_.scala:31:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mreturn\e[0m word.find(\e[36mc\e[0m\
    \ => vowels.contains(c.toLowerCase)).orElse \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                         ^\e\
    [0m\n\e[31m   |\e[0m                      end of statement expected but string\
    \ literal found\n\e[31m\e[31m-- Error: /tmp/tmp2zv6fob_.scala:33:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mreturn\e[0m word.find(\e[36mc\e[0m\
    \ => vowels.contains(c.toLowerCase)).orElse \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                         ^\e\
    [0m\n\e[31m   |\e[0m                      end of statement expected but string\
    \ literal found\n\e[31m\e[31m-- Error: /tmp/tmp2zv6fob_.scala:37:77 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mreturn\e[0m word.find(\e[36mc\e\
    [0m => vowels.contains(c.toLowerCase)).orElse \e[31m\"\"\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \        ^\e[0m\n\e[31m   |\e[0m                      end of statement expected\
    \ but string literal found\n\e[31m\e[31m-- Error: /tmp/tmp2zv6fob_.scala:39:77\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \         \e[33mreturn\e[0m word.find(\e[36mc\e[0m => vowels.contains(c.toLowerCase)).orElse\
    \ \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \         end of statement expected but string literal found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp2zv6fob_.scala"
  stdout: ''
  timestamp: 1660009873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n      var vowels = \"aeiou\"\
    \n      var left = 0\n      var right = word.length - 1\n      var result = \"\
    \"\n      while (left < right) {\n        var mid = left + (right - left) / 2\n\
    \        var v1 = vowels.find(word(mid).equalsIgnoreCase)\n        if (v1 == -1)\
    \ {\n          result = word(mid)\n          left = mid\n        } else {\n  \
    \        result = v1 + result\n          left = mid + 1\n        }\n        var\
    \ v2 = vowels.find(word(mid).equalsIgnoreCase)\n        if (v2 == -1) {\n    \
    \      right = mid\n        } else {\n          right = mid\n        }\n     \
    \ }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjj_fsjq.scala:25:39 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mv1\e[0m = vowels.find(word(mid).equalsIgnoreCase)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value equalsIgnoreCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpvjj_fsjq.scala:26:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (v1 == -\e[31m1\e[0m) {\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m   Values of types Option[Char]\
    \ and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvjj_fsjq.scala:27:23 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m          result = word(mid)\n\e[31m\e[31m   |\e[0m                  \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Char\n\e[31m   |\e\
    [0m                   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpvjj_fsjq.scala:30:22 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m          result = v1 + result\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Option[Char],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvjj_fsjq.scala:33:39 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mv2\e[0m = vowels.find(word(mid).equalsIgnoreCase)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value equalsIgnoreCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpvjj_fsjq.scala:34:12 --------------------"
  stdout: ''
  timestamp: 1660009875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word.isEmpty)\
    \ return \"\";\n        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\");\n\
    \        def getNextConsonant(word : String) : String = {\n            val index\
    \ = word.length - 1;\n            while (index >= 0 && word.isEmpty) {\n     \
    \           if (word.charAt(index) == 'z') return word.substring(0, index);\n\
    \                if (word.charAt(index) == 'y') return word.substring(0, index);\n\
    \                index--;\n            }\n            return \"\";\n        }\n\
    \        def getNextVowel(word : String) : String = {\n            val index =\
    \ word.length - 1;\n            while (index >= 0 && word.isEmpty) {\n       \
    \         if (word.charAt(index) == 'z' || word.charAt(index) == 'y') return word.substring(0,\
    \ index);\n                index--;\n            }\n            return \"\";\n\
    \        }\n        val words = word.split(\"\");\n        var previous = getNextConsonant(word);\n\
    \        val vowelConsonants = vowels.map(c => c +: previous);\n        val nextVowelConsonants\
    \ = vowelConsonants.map(c => c +: getNextVowel(previous));\n        val nextVowelConsonantString\
    \ = nextVowelConsonants.mkString(\"\");\n        var result = words.get(0) + nextVowelConsonantString;\n\
    \        val length = words.length - 1;\n        for (i <- 1 to length) {\n  \
    \          val newVowel = words.get(i) + nextVowelConsonantString;\n         \
    \   if (vowelConsonants.exists(c => newVowel.indexOf(c) != -1)) {\n          \
    \      result = newVowel;\n            }\n        }\n        return result;\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr3ms79u0.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                index--;\n\e[31m\e[31m   |\e[0m     \
    \                  ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpr3ms79u0.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                index--;\n\e[31m\e[31m   |\e[0m                      \
    \ ^\e[0m\n\e[31m   |\e[0m                       expression expected but \e[31m';'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr3ms79u0.scala:43:27\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m \e\
    [36mresult\e[0m = words.get(\e[31m0\e[0m) + nextVowelConsonantString;\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \         value get is not a member of Array[String]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpr3ms79u0.scala:46:33 ------------------------\e[0m\e[0m\n\
    \e[31m46 |\e[0m            \e[33mval\e[0m \e[36mnewVowel\e[0m = words.get(i) +\
    \ nextVowelConsonantString;\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value get is not a member of Array[String]\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        var vowelIndex = word.lastIndexOfAny(vowel)\n \
    \       var newWord = word.substring(vowelIndex+1, word.length)\n        var searchVowel\
    \ = word.substring((vowelIndex+1), word.length)\n        var vowelIndex = searchVowel.lastIndexOfAny(vowel)\n\
    \        var newSearchVowel = searchVowel.substring(vowelIndex+1, searchVowel.length)\n\
    \        var vowelIndex = newSearchVowel.lastIndexOfAny(vowel)\n        var newNewSearchVowel\
    \ = newSearchVowel.substring(vowelIndex+1, newSearchVowel.length)\n        if(newWord.length\
    \ <= vowelIndex){\n            return \"\"\n        }\n        if(newNewSearchVowel.length\
    \ <= vowelIndex){\n            return \"\"\n        }\n        if(newNewSearchVowel.startsWith(newWord.substring(vowelIndex+1,\
    \ newWord.length))){\n            return newWord.substring(vowelIndex+1, newWord.length)\n\
    \        }\n        if(newNewSearchVowel.startsWith(newWord.substring(vowelIndex+1,\
    \ newNewSearchVowel.length))){\n            return newWord.substring(vowelIndex+1,\
    \ newWord.length)\n        }\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpktxlvqsc.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mvowelIndex\e[0m = searchVowel.lastIndexOfAny(vowel)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelIndex is already defined as \e[33mvariable\e[0m \e[35mvowelIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpktxlvqsc.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mvar\e[0m \e[36mvowelIndex\e[0m = newSearchVowel.lastIndexOfAny(vowel)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelIndex is already defined as \e[33mvariable\e[0m \e[35mvowelIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpktxlvqsc.scala:20:30 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mvowelIndex\e[0m = word.lastIndexOfAny(vowel)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue lastIndexOfAny is not a member of String - did you mean word.lastIndexOf?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels : Set[String]\
    \ = Set()\n        val lowerCaseWord = word.toLowerCase\n        val lastConsonantIndex\
    \ = lowerCaseWord.length - 1\n        for (i <- lastConsonantIndex - 1 until 0){\n\
    \            if (lowerCaseWord(i) == \"a\" || lowerCaseWord(i) == \"e\" || lowerCaseWord(i)\
    \ == \"i\" || lowerCaseWord(i) == \"o\" || lowerCaseWord(i) == \"u\") {\n    \
    \            vowels += lowerCaseWord(i)\n            }\n        }\n        if\
    \ (vowels.isEmpty)\n            return \"\"\n        val newVowelIndex = vowels.lastIndexOf(\"\
    a\") + 2\n        return vowels.take(newVowelIndex).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpfzyzfryh.scala:23:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (lowerCaseWord(i) == \e[31m\"\
    a\"\e[0m || lowerCaseWord(i) == \e[31m\"e\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    i\"\e[0m || lowerCaseWord(i) == \e[31m\"o\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    u\"\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpfzyzfryh.scala:23:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (lowerCaseWord(i) == \e[31m\"\
    a\"\e[0m || lowerCaseWord(i) == \e[31m\"e\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    i\"\e[0m || lowerCaseWord(i) == \e[31m\"o\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    u\"\e[0m) {\n\e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpfzyzfryh.scala:23:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (lowerCaseWord(i) == \e[31m\"\
    a\"\e[0m || lowerCaseWord(i) == \e[31m\"e\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    i\"\e[0m || lowerCaseWord(i) == \e[31m\"o\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    u\"\e[0m) {\n\e[31m\e[31m   |\e[0m                                           \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpfzyzfryh.scala:23:97 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (lowerCaseWord(i) == \e[31m\"\
    a\"\e[0m || lowerCaseWord(i) == \e[31m\"e\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    i\"\e[0m || lowerCaseWord(i) == \e[31m\"o\"\e[0m || lowerCaseWord(i) == \e[31m\"\
    u\"\e[0m) {\n\e[31m\e[31m   |\e[0m                                           \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/t"
  stdout: ''
  timestamp: 1660009875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        var result : String = \"\";\n\
    \        val count = word.count(letter => vowels.contains(letter))\n        if(count\
    \ > 1){\n            val endIndex = word.lastIndexOfAny(vowels)\n            val\
    \ start = word.lastIndexOfAny(vowels, endIndex+1)\n            if(start < endIndex){\n\
    \                val vowel = word.substring(endIndex+1, start)\n             \
    \   result = vowel\n            }\n        }\n        return result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppc8tm31g.scala:21:57\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcount\e\
    [0m = word.count(\e[36mletter\e[0m => vowels.contains(letter))\n\e[31m\e[31m \
    \  |\e[0m                                                         ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    (letter\
    \ : Char)\n\e[31m   |\e[0m                                               Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppc8tm31g.scala:23:32\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m\
    \ \e[36mendIndex\e[0m = word.lastIndexOfAny(vowels)\n\e[31m\e[31m   |\e[0m   \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndexOfAny\
    \ is not a member of String - did you mean word.lastIndexOf?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppc8tm31g.scala:24:29 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mstart\e[0m = word.lastIndexOfAny(vowels,\
    \ endIndex+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndexOfAny is not a member of String - did you mean\
    \ word.lastIndexOf?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009876
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val letters: Array[String]\
    \ = word.toCharArray\n        val vowels: Set[String] = Set(\"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n        val consonants: Set[String] = Set(\"b\", \"c\", \"d\"\
    , \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"v\", \"w\", \"x\", \"z\")\n        var index: Int = 0\n    \
    \    var vowelsIndex = 0\n        var vowelsLength = 0\n\n        // check if\
    \ the word has vowels at the begining or at the end\n        if(vowels.contains(letters(0))){\n\
    \            vowelsLength = vowels.size - 1\n        }else if(vowels.contains(letters(letters.size-1))){\n\
    \            vowelsLength = vowels.size\n        }else{\n            return \"\
    \"\n        }\n\n        while(vowelsIndex < vowelsLength){\n            if(consonants.contains(letters((index\
    \ + vowelsIndex)))){\n                index = index + vowelsIndex\n          \
    \      vowelsIndex = vowelsIndex + 1\n            }else if(consonants.contains(letters((index\
    \ - vowelsIndex)))){\n                index = index - vowelsIndex\n          \
    \      vowelsIndex = vowelsIndex + 1\n            }else{\n                return\
    \ \"\"\n            }\n        }\n        return vowels.find(letters => letters.contains(letters(index)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsohi5zv3.scala:19:37\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mletters\e\
    [0m: \e[35mArray\e[0m[\e[35mString\e[0m] = word.toCharArray\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    Array[\e[1m\e[31mChar\e[0m]\n\e\
    [31m   |\e[0m                                     Required: Array[\e[1m\e[32mString\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsohi5zv3.scala:46:26\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mreturn\e[0m vowels.find(\e\
    [36mletters\e[0m => letters.contains(letters(index)))\n\e[31m\e[31m   |\e[0m \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m               Found:    \e[1m\e[31mOption\e[0m\e[1m\e[31m[\e[0mString\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m               Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = new\
    \ mutable.HashSet[String]()\n        val consonants = new mutable.HashSet[String]()\n\
    \        var first = 0\n        var last = word.length - 1\n        while (first\
    \ < last) {\n            if (vowels.contains(word.substring(first + 1, last)))\
    \ {\n                return word.substring(first + 1, last)\n            }\n \
    \           if (consonants.contains(word.substring(first + 1, last))) {\n    \
    \            last -= 1\n            } else {\n                last -= 1\n    \
    \            first += 1\n            }\n        }\n        return \"\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9lnj9a_0.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9lnj9a_0.scala:20:29\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonants\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mString\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"y\",\"u\")\n        val vowelIndex =\n    \
    \      word.zipWithIndex.find { case (vowel, index) => vowels.contains(vowel)\
    \ } match {\n            case (Some(vowel), index) => index\n            case\
    \ (_, -1) => -1\n          }\n        val firstVowelIndex = vowelIndex - 1\n \
    \       val lastVowelIndex = vowelIndex + 1\n        if (firstVowelIndex < 0)\
    \ {\n          return \"\"\n        }\n        if (lastVowelIndex > word.length\
    \ - 1) {\n          return \"\"\n        }\n        var index = firstVowelIndex\n\
    \        while (vowels.contains(word.charAt(index))) {\n          index = index\
    \ - 1\n        }\n        return word.charAt(index) + word.substring(index + 1,\
    \ lastVowelIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovtjpanj.scala:21:74\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m          word.zipWithIndex.find\
    \ { \e[33mcase\e[0m (vowel, index) => vowels.contains(vowel) } \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                      Found:    (vowel : Char)\n\e[31m   |\e[0m             \
    \                                   Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpovtjpanj.scala:25:41 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mfirstVowelIndex\e[0m = vowelIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpovtjpanj.scala:26:40 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlastVowelIndex\e[0m = vowelIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpovtjpanj.scala:34:42 --------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mwhile\e[0m (v"
  stdout: ''
  timestamp: 1660009881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels : Set[String]\
    \ = Set()\n        val wordLength = word.length\n        var vowelIndex = 0\n\
    \        var vowelCount = 0\n        var currentVowel : String = \"\"\n      \
    \  var currentCount : Int = 0\n        var nextVowel : String = \"\"\n       \
    \ var nextCount : Int = 0\n        var currentCount : Int = 0\n        while(vowelIndex\
    \ < wordLength){\n            currentVowel = word.charAt(vowelIndex).toUpperCase\n\
    \            if(currentVowel.toLowerCase == \"a\" || currentVowel.toLowerCase\
    \ == \"e\" || currentVowel.toLowerCase == \"i\" || currentVowel.toLowerCase ==\
    \ \"o\" || currentVowel.toLowerCase == \"u\" || currentVowel.toLowerCase == \"\
    y\"){\n                vowelIndex = vowelIndex + 1\n                currentCount\
    \ = currentCount + 1\n                currentVowel = word.charAt(vowelIndex).toUpperCase\n\
    \                if(currentCount > vowelCount){\n                    vowelCount\
    \ = currentCount\n                    nextVowel = currentVowel\n             \
    \       nextCount = vowelCount\n                }\n            }\n           \
    \ vowelIndex = vowelIndex + 1\n        }\n        if(nextCount < vowelCount){\n\
    \            vowelIndex = wordLength\n            while(vowelIndex > 0){\n   \
    \             currentVowel = word.charAt(vowelIndex).toUpperCase\n           \
    \     if(currentVowel.toLowerCase == \"a\" || currentVowel.toLowerCase == \"e\"\
    \ || currentVowel.toLowerCase == \"i\" || currentVowel.toLowerCase == \"o\" ||\
    \ currentVowel.toLowerCase == \"u\" || currentVowel.toLowerCase == \"y\"){\n \
    \                   vowelIndex = vowelIndex - 1\n                    currentCount\
    \ = currentCount + 1\n                    currentVowel = word.charAt(vowelIndex).toUpperCase\n\
    \                    if(currentCount > vowelCount){\n                        vowelCount\
    \ = currentCount\n                        nextVowel = currentVowel\n         \
    \               nextCount = vowelCount\n                    }\n              \
    \  }\n                vowelIndex = vowelIndex - 1\n            }\n        }\n\
    \        if(nextCount >= vowelCount){\n            return nextVowel\n        }else{\n\
    \            return \"\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9qvmcvvq.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mcurrentCount\e[0m : \e[35mInt\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentCount is already defined as \e[33mvariable\e[0m \e\
    [35mcurrentCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9qvmcvvq.scala:29:51 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            currentVowel = word.charAt(vowelIndex).toUpperCase\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9qvmcvvq.scala:33:55\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                currentVowel\
    \ = word.charAt(vowelIndex).toUpperCase\n\e[31m\e[31m   |\e[0m               \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                            value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9qvmcvvq.scala:45:55 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                currentVowel = word.charAt(vowelIndex).toUpperCase\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9qvmcvvq.scala:49:59\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                    currentVowel\
    \ = word.charAt(vowelIndex).toUpperCase\n\e[31m\e[31m   |\e[0m               \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               value toUpperCase is not a member of Char\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    AEIOUaeiou\"\n        val vowelsCount = vowels.toList.count\n        var minDistance\
    \ = 1\n        var bestVowel : String = \"\"\n        var index = word.length\
    \ - 1\n        for (index <- 0 to word.length - vowelsCount) {\n            val\
    \ subWord = word.substring(index, index + vowelsCount)\n            val distance\
    \ = getLevenshteinDistance(subWord, vowels)\n            if (distance < minDistance)\
    \ {\n                minDistance = distance\n                bestVowel = subWord\n\
    \            }\n        }\n        bestVowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp25smqfc6.scala:24:39 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m (index <- \e[31m0\e[0m to word.length\
    \ - vowelsCount) {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments ((vowelsCount : (Char => Boolean) => Int))\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp25smqfc6.scala:25:54 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36msubWord\e[0m = word.substring(index,\
    \ index + vowelsCount)\n\e[31m\e[31m   |\e[0m                                \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m\
    \   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m \
    \ (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte):\
    \ Int\n\e[31m   |\e[0m  (x: String): String\n\e[31m   |\e[0m match arguments ((vowelsCount\
    \ : (Char => Boolean) => Int))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp25smqfc6.scala:26:27\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m\
    \ \e[36mdistance\e[0m = getLevenshteinDistance(subWord, vowels)\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: getLevenshteinDistance\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\".toList\n        val consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    .toList\n        val vowelsCount = word.groupBy(x => vowels.indexOf(x)).map(x\
    \ => x._2).sum\n        val consonantsCount = word.groupBy(x => consonants.indexOf(x)).map(x\
    \ => x._2).sum\n        val currentVowelCount = word.length - (consonantsCount\
    \ + vowelsCount)\n        val currentVowel = word.substring(consonantsCount, word.length)\n\
    \        var closestVowel = \"\"\n        var closestVowelIndex = 0\n        //\
    \ Loop through the given word and find the closest vowel met \n        // the\
    \ following condition: \n        // 1. One vowel must stay right before the end\
    \ of the word\n        // 2. One vowel must stay right before the consonant\n\
    \        // 3. Two vowels must stay in the word\n        for(i <- 0 until currentVowelCount)\
    \ {\n            val thisVowel = word.substring(i, currentVowel)\n           \
    \ if(thisVowel.contains(vowels.mkString)) {\n                if(closestVowelIndex\
    \ < i) {\n                    closestVowelIndex = i\n                }\n     \
    \       }\n            val thisVowelIndex = thisVowel.lastIndexOf(vowels.mkString)\n\
    \            if(thisVowelIndex != -1) {\n                if(closestVowelIndex\
    \ < thisVowelIndex) {\n                    closestVowelIndex = thisVowelIndex\n\
    \                }\n            }\n        }\n        closestVowel = word.substring(closestVowelIndex\
    \ + vowelsCount, word.length)\n        return closestVowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2m9ga6r1.scala:21:81 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelsCount\e[0m = word.groupBy(\e\
    [36mx\e[0m => vowels.indexOf(x)).map(\e[36mx\e[0m => x._2).sum\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \             ^\e[0m\n\e[31m   |\e[0m                No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                where:    B is a type\
    \ variable with constraint >: String\n\e[31m   |\e[0m                .\n\e[31m\e\
    [31m-- Error: /tmp/tmp2m9ga6r1.scala:22:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mconsonantsCount\e[0m = word.groupBy(\e\
    [36mx\e[0m => consonants.indexOf(x)).map(\e[36mx\e[0m => x._2).sum\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                      ^\e[0m\n\e[31m   |\e[0m                No implicit Ordering\
    \ defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                where:    B is\
    \ a type variable with constraint >: String\n\e[31m   |\e[0m                .\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2m9ga6r1.scala:33:46 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mthisVowel\e[0m = word.substring(i,\
    \ currentVowel)\n\e[31m\e[31m   |\e[0m                                       \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \    Found:    (currentVowel : String)\n\e[31m   |\e[0m                      \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def getConsonants(word\
    \ : String) : List[String] = {\n            val consonants = List(\n         \
    \       \"b\", \"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"\
    p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"y\",\"z\"\n                )\n\
    \            val consonantsList = consonants.toList\n            val consonantsSet\
    \ = consonants.toSet\n            val chars = word.map(c => c.toUpperCase).filter(c=>consonantsSet.contains(c))\n\
    \            val newList = word.filter(c=>consonantsSet.contains(c))\n       \
    \     val allConsonants = consonantsList.filter(c=>chars.contains(c))\n      \
    \      val rest = chars.filter(c=>!consonantsSet.contains(c))\n            consonantsList\
    \ ++ rest\n        }\n        def getVowels(word : String) : List[String] = {\n\
    \            val vowels = List(\n                \"a\",\"e\",\"i\",\"o\",\"u\"\
    \n                )\n            val vowelsList = vowels.toList\n            val\
    \ vowelsSet = vowels.toSet\n            val chars = word.map(c => c.toUpperCase).filter(c=>vowelsSet.contains(c))\n\
    \            val newList = word.filter(c=>vowelsSet.contains(c))\n           \
    \ val allConsonants = vowelsList.filter(c=>chars.contains(c))\n            val\
    \ rest = chars.filter(c=>!vowelsSet.contains(c))\n            vowelsList ++ rest\n\
    \        }\n        val vowels = getVowels(word)\n        val consonants = getConsonants(word)\n\
    \        var closestVowel = \"\"\n        val length = vowels.size\n        var\
    \ distance = 0\n        var index = 0\n        while (index < length){\n     \
    \       if (vowels(index) == consonants(length-1)){\n                val distance\
    \ = math.abs(consonants.indexOf( vowels(index) ) - consonants.indexOf( vowels(length-1)))\n\
    \                if(closestVowel.length < vowels(index)){\n                  \
    \  closestVowel = vowels(index)\n                }\n                if(distance\
    \ < distance){\n                    distance = distance\n                }\n \
    \           }\n            index += 1\n        }\n        closestVowel\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuwak020q.scala:25:40 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mchars\e[0m = word.map(\e\
    [36mc\e[0m => c.toUpperCase).filter(\e[36mc\e[0m=>consonantsSet.contains(c))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuwak020q.scala:26:64\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mnewList\e[0m = word.filter(\e[36mc\e[0m=>consonantsSet.contains(c))\n\e[31m\e\
    [31m   |\e[0m                                                                ^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    (c : Char)\n\e[31m   |\e[0m                                             \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpuwak020q.scala:37:40 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m            \e[33mval\e[0m \e[36mchars\e[0m = word.map(\e[36mc\e[0m => c.toUpperCase).filter(\e\
    [36mc\e[0m=>vowelsSet.contains(c))\n\e[31m\e[31m   |\e[0m                    \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \        value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpuwak020q.scala:38:60 --------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m            \e[33mval\e[0m \e[36mnewList\e[0m = word.filter(\e\
    [36mc\e[0m=>vowelsSet.contains(c))\n\e[31m\e[31m   |\e[0m                    \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                       Found:    (c : Char)\n\e[31m   |\e[0m\
    \                                                    Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpuwak020q.scala:52:39 -----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                \e[33mif\e[0m(closestVowel.length < "
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    aeiouAEIOU\".toSet\n        val startIndex = word.indexOfLast(\"a\")\n       \
    \ if (startIndex == -1)\n            return \"\"\n        val endIndex = word.lastIndexOf(\"\
    u\")\n        if (endIndex == -1)\n            return \"\"\n        val start\
    \ = word.substring(startIndex + 1)\n        val end = word.substring(endIndex\
    \ + 1)\n        for (i <- vowels.iterator) {\n            if (word.indexOf(i)\
    \ >= 0)\n                return \"\"\n        }\n        val charSet = scala.collection.mutable.Set[Char]()\n\
    \        charSet ++= start.toCharArray\n        charSet ++= end.toCharArray\n\
    \        charSet.iterator\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm3nzu9gw.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = word.indexOfLast(\e\
    [31m\"a\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value indexOfLast is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm3nzu9gw.scala:35:16\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        charSet.iterator\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Iterator[Char]\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // get the last\
    \ letter of given word.\n        val lastChar = word.last\n        // find the\
    \ vowel between last char and next char from right.\n        // return empty string\
    \ if no vowel found.\n        val nextChar = word.slice(word.length - 1, 1)\n\
    \        val index = word.indexOf(\"o\") + 1 // to prevent using an index for\
    \ \"o\"\n        val i = word.indexOf(\"o\", index) + 1\n        val j = word.indexOf(\"\
    e\", i)\n        if (word.indexOf(lastChar, i + 1) > 0 &&\n            word.indexOf(nextChar,\
    \ j) > 0 &&\n            word.indexOf(lastChar, j + 1) > 0 &&\n            word.indexOf(nextChar,\
    \ i + 1) > 0 &&\n            word.indexOf(lastChar, j) > 0 &&\n            word.indexOf(nextChar,\
    \ j + 1) > 0 &&\n            word.indexOf(lastChar, j) > 0 &&\n            word.indexOf(nextChar,\
    \ j) > 0 &&\n            word.indexOf(lastChar, j) > 0 &&\n            word.indexOf(nextChar,\
    \ j + 1) > 0\n            ) \n                word.slice(word.indexOf(\"o\"),\
    \ word.indexOf(\"o\"))\n                else\n                \"\"\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp78mww4sk.scala:43)\n\tat Problem.main(tmp78mww4sk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowel = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val vowelCount = word.count(_.toLowerCase.contains(vowel.mkString))\n\
    \        if(vowelCount == 0){\n            return \"\"\n        }\n        val\
    \ consonantCount = word.count(c => c.toLowerCase.startsWith(\"a\"))\n        val\
    \ right = word.slice(consonantCount, word.length)\n        val left = right.takeWhile(_\
    \ => !_.toLowerCase.contains(vowel.mkString))\n        if(left.isEmpty){\n   \
    \         return \"\"\n        }\n        val leftVowelCount = left.count(_.toLowerCase.contains(vowel.mkString))\n\
    \        if(leftVowelCount > vowelCount){\n            return \"\"\n        }\n\
    \        val index = (left.lastIndex - leftVowelCount + consonantCount) % vowel.length\n\
    \        val vowelIndex = vowel.indexOf(vowel(index))\n        val start = word.take(vowelIndex).lastIndex\n\
    \        val end = start + vowel.length\n        return word.substring(start,\
    \ end)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2dkk33mv.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelCount\e[0m = word.count(_.toLowerCase.contains(vowel.mkString))\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2dkk33mv.scala:24:47\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonantCount\e[0m = word.count(\e[36mc\e[0m => c.toLowerCase.startsWith(\e\
    [31m\"a\"\e[0m))\n\e[31m\e[31m   |\e[0m                                      \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toLowerCase is not a member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp2dkk33mv.scala:26:41\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e\
    [0m \e[36mleft\e[0m = right.takeWhile(_ => !_.toLowerCase.contains(vowel.mkString))\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$3 of expanded function:\n\e[31m   |\e\
    [0m   _$3 => ! _$3.toLowerCase.contains(vowel.mkString).\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2dkk33mv.scala:30:42 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mleftVowelCount\e[0m = left.count(_.toLowerCase.contains(vowel.mkString))\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2dkk33mv.scala:34:26\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mindex\e[0m = (left.lastIndex - leftVowelCount + consonantCount) % vowel.length\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ lastIndex is not a member of String - did you mean left.lastIndexOf?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2dkk33mv.scala:36:42 -----------"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowelSet = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        val\
    \ vowels = vowelSet.toSeq.filter(x => word.toLowerCase().indexOf(x.toString) >\
    \ -1)\n        var result = \"0\"\n        var flag = 0\n        for( i <- 0 to\
    \ word.length - 1 ) {\n            if( vowels.exists(x => word.indexOf(x) > i)\
    \ ) {\n                var vowelIndex = word.indexOf(x)\n                while(\
    \ vowelIndex < i && flag == 0 ) {\n                    if( word.charAt(vowelIndex)\
    \ != x.toString ) \n                        flag = 1\n                    vowelIndex\
    \ += 1\n                }\n                if( flag == 0 ) {\n               \
    \     result = word.charAt(vowelIndex - 1)\n                }\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fa1ltj1.scala:25:46 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mvar\e[0m \e[36mvowelIndex\e[0m\
    \ = word.indexOf(x)\n\e[31m\e[31m   |\e[0m                                   \
    \           ^\e[0m\n\e[31m   |\e[0m                                          \
    \    Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fa1ltj1.scala:27:51\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    \e[33mif\e\
    [0m( word.charAt(vowelIndex) != x.toString ) \n\e[31m\e[31m   |\e[0m         \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                        Not found: x\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5fa1ltj1.scala:32:40 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    result = word.charAt(vowelIndex -\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    Char\n\e[31m   |\e\
    [0m                             Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var prevIndex =\
    \ 0\n        var index = word.length - 1\n        var vowels = \"aeiouAEIOU\"\
    .toList\n        // If there is only one consonant, then return empty string\n\
    \        if (word.length < 2) return \"\"\n        while (index >= 0) {\n    \
    \        var currentChar = word.charAt(index)\n            if (vowels.contains(currentChar))\
    \ {\n                var nextVowelIndex = findVowelIndex(word, index, prevIndex)\
    \ + 1\n                return if (nextVowelIndex == prevIndex) {\n           \
    \         nextVowelIndex\n                } else findVowelIndex(word, index, nextVowelIndex)\n\
    \            }\n            index--\n        }\n        return \"\"\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpawm6oqp1.scala:32:19 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            index--\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpawm6oqp1.scala:27:37\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mvar\e\
    [0m \e[36mnextVowelIndex\e[0m = findVowelIndex(word, index, prevIndex) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: findVowelIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpawm6oqp1.scala:30:23\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                } \e[33melse\e\
    [0m findVowelIndex(word, index, nextVowelIndex)\n\e[31m\e[31m   |\e[0m       \
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: findVowelIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val first = word.indexOf(\"a\");\n \
    \       val last  = word.lastIndexOf(\"u\");\n        if(first<0 || last<0 ||\
    \ first>last || first>last)\n            return \"\";\n        val firstVowel\
    \ = word.substring(first, last - 1).indexOf(\"a\");\n        val lastVowel  =\
    \ word.substring(last - 1, word.length).indexOf(\"a\");\n        val secondVowel\
    \ = word.substring(word.length, word.length).indexOf(\"u\");\n        if(firstVowel<0\
    \ || firstVowel>secondVowel)\n            return \"\";\n        if(lastVowel<0\
    \ || lastVowel>secondVowel)\n            return \"\";\n        if(firstVowel<0)\n\
    \            return word.substring(firstVowel, word.length).substring(0,lastVowel);\n\
    \        if(lastVowel<0)\n            return word.substring(firstVowel, word.length).substring(lastVowel,\
    \ word.length);\n        val firstVowelIndex = word.substring(firstVowel, word.length).indexOf(\"\
    a\");\n        val lastVowelIndex = word.substring(word.length, word.length).indexOf(\"\
    u\");\n        if(lastVowelIndex<0 || lastVowelIndex>secondVowel)\n          \
    \  return \"\";\n        if(firstVowelIndex<0)\n            return word.substring(firstVowelIndex,\
    \ lastVowelIndex).substring(0,lastVowel);\n        if(lastVowelIndex<0)\n    \
    \        return word.substring(firstVowelIndex, lastVowelIndex).substring(lastVowel,\
    \ lastVowel);\n        val secondVowelIndex = word.substring(word.length, word.length).indexOf(\"\
    u\");\n        val vowel = word.substring(firstVowelIndex, secondVowelIndex).substring(0,lastVowel);\n\
    \        return vowel;\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv5lfq03l.scala:48)\n\tat Problem.main(tmpv5lfq03l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val wordList = List(word,\
    \ word.trimRight(word), word.trimRight(word.trimRight(word)))\n        val vowelList\
    \ = List(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        val vowelSet = vowelList.toSet\n\
    \        val vowelCount = vowelList.toList.groupBy(e => e).values.map(_.length).max\n\
    \        val vowelSetSize = vowelSet.size\n        val vowelSetMax = vowelSet.max\n\
    \        val vowelSetMin = vowelSet.min\n        val vowelSetSum = vowelSet.sum\n\
    \        val vowelSetCount = (vowelSet - vowelSet).size\n        val vowelSetSize\
    \ = vowelSetSize\n        val vowelSetMax = vowelSetMax\n        val vowelSetMin\
    \ = vowelSetMin\n        val vowelSetSum = vowelSetSum\n        val vowelSetCount\
    \ = (vowelSet - vowelSet).size\n        val vowelSetSize = vowelSetSize\n    \
    \    val vowelSetMax = vowelSetMax\n        val vowelSetMin = vowelSetMin\n  \
    \      val vowelSetSum = vowelSetSum\n        val vowelSetCount = (vowelSet -\
    \ vowelSet).size\n        val vowelSetSize = vowelSetSize\n        val vowelSetMax\
    \ = vowelSetMax\n        val vowelSetMin = vowelSetMin\n        val vowelSetSum\
    \ = vowelSetSum\n        val vowelSetCount = (vowelSet - vowelSet).size\n    \
    \    val vowelSetSize = vowelSetSize\n        val vowelSetMax = vowelSetMax\n\
    \        val vowelSetMin = vowelSetMin\n        val vowelSetSum = vowelSetSum\n\
    \        val vowelSetCount = (vowelSet - vowelSet).size\n        val vowelSetSize\
    \ = vowelSetSize\n        val vowelSetMax = vowelSetMax\n        val vowelSetMin\
    \ = vowelSetMin\n        val vowelSetSum = vowelSetSum\n        val vowelSetCount\
    \ = (vowelSet - vowelSet).size\n        val vowelSetSize = vowelSetSize\n    \
    \    val vowelSetMax = vowelSetMax\n        val vowelSetMin = vowelSetMin\n  \
    \      val vowelSetSum = vowelSetSum\n        val vowelSetCount = (vowelSet -\
    \ vowelSet).size\n        val vowelSetSize = vowelSetSize\n        val vowelSetMax\
    \ = vowelSetMax\n        val vowelSetMin = vowelSetMin\n        val vowelSetSum\
    \ = vowelSetSum\n        val vowelSetCount = (vowelSet - vowelSet).size\n    \
    \    val vowelSetSize = vowelSetSize\n        val vowelSetMax = vowelSetMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc08en2un.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mvowelSetSize\e[0m = vowelSetSize\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvowelSetSize is already defined as \e[33mvalue\e[0m \e[35mvowelSetSize\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc08en2un.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mvowelSetMax\e[0m = vowelSetMax\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvowelSetMax\
    \ is already defined as \e[33mvalue\e[0m \e[35mvowelSetMax\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc08en2un.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvowelSetMin\e[0m = vowelSetMin\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelSetMin is already defined as \e[33mvalue\e[0m \e[35mvowelSetMin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc08en2un.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mvowelSetSum\e[0m = vowelSetSum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvowelSetSum\
    \ is already defined as \e[33mvalue\e[0m \e[35mvowelSetSum\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc08en2un.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvowelSetCount\e[0m = (vowelSet - vowelSet).size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvowelSetCount\
    \ is already defined as \e[33mvalue\e[0m "
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = scala.util.Properties.runtime.getProperties.(\"\
    java.util.ResourceBundle\").getString\n        val vowelList = vowels.split(\"\
    ,\")\n        val index = word.lastIndexOf(\"u\")\n        val index2 = word.lastIndexOf(\"\
    U\")\n        if(index != -1 && index2 != -1){\n            if(Math.abs(index\
    \ - index2) <= 1){\n                return word.substring(index+2,index2+2)\n\
    \            }\n        }\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9q83hziz.scala:19:65 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = scala.util.Properties.runtime.getProperties.(\e\
    [31m\"java.util.ResourceBundle\"\e[0m).getString\n\e[31m\e[31m   |\e[0m      \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                   an identifier expected, but '(' found\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9q83hziz.scala:19:43 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = scala.util.Properties.runtime.getProperties.(\e\
    [31m\"java.util.ResourceBundle\"\e[0m).getString\n\e[31m\e[31m   |\e[0m      \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \ value runtime is not a member of object scala.util.Properties\n2 errors found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var minIndex = -1\n\
    \        var minDistance = 1e10\n        var vowels = List(\"a\",\"e\",\"i\",\"\
    o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\")\n        for {\n            i <- 0 until\
    \ word.length\n        } yield {\n            val currentDistance = Math.abs(i\
    \ - vowels.indexOf(word.charAt(word.length - (word.charAt(i).toInt - 1)).toChar))\n\
    \            if (currentDistance < minDistance) {\n                minDistance\
    \ = currentDistance\n                minIndex = i\n            }\n        }\n\
    \        if (minDistance == 1e10) return \"\"\n        if (minDistance == 0) return\
    \ word.charAt(minIndex)\n        return word.charAt(minIndex) + word.charAt(word.length\
    \ - minIndex - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps9ry84bx.scala:32:48\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m (minDistance\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m word.charAt(minIndex)\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                     Found:    Char\n\e[31m   |\e[0m      \
    \                               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmps9ry84bx.scala:33:50 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mreturn\e[0m word.charAt(minIndex) + word.charAt(word.length\
    \ - minIndex - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                     Found:    Char\n\e[31m   |\e[0m        \
    \                               Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowel = \"aeiouAEIOU\"\
    .toSet\n        def vowelCount(word : String) : Int = {\n            val vowel\
    \ = \"aeiouAEIOU\".toSet\n            val word = word.trim\n            var count\
    \ : Int = 0\n            var i : Int = 0\n            while (i < word.length)\
    \ {\n                if (word.charAt(i) == vowel(i)) {\n                    count\
    \ += 1\n                }\n                i += 1\n            }\n           \
    \ return count\n        }\n        def searchVowel(word : String) : String = {\n\
    \            val vowel = \"aeiouAEIOU\".toSet\n            var i : Int = 0\n \
    \           var j : Int = word.length - 1\n            var vowelIndex : Int =\
    \ 0\n            var vowelCount : Int = vowelCount(word)\n            while (i\
    \ < j && vowelCount > 0) {\n                if (word.charAt(i) == vowel(i)) {\n\
    \                    vowelCount -= 1\n                }\n                if (word.charAt(i)\
    \ == vowel(j)) {\n                    vowelCount += 1\n                }\n   \
    \             i += 1\n                j -= 1\n            }\n            if (vowelCount\
    \ > 0) {\n                return \"\"\n            } else {\n                return\
    \ word.substring(vowelIndex)\n            }\n        }\n        val wordList =\
    \ word.split(\"\\\\s+\")\n        val finalWordList = wordList.filter(l => l.length\
    \ >= 2 && !l.startsWith(\"\\\\s\")) // remove empty lines\n        val finalVowels\
    \ = finalWordList.map(searchVowel)\n        val finalVowelsList = finalVowels.filter(l\
    \ => l.nonEmpty)\n        var finalVowelListIndex = 0\n        val maxVowel =\
    \ finalVowelsList.map(v => v.length).max\n        val minVowel = finalVowelsList.map(v\
    \ => v.length).min\n        val maxIndexOfVowel = finalVowelsList.toList.map(_.length).indexOf(maxVowel)\n\
    \        val minIndexOfVowel = finalVowelsList.toList.map(_.length).indexOf(minVowel)\n\
    \        val finalVowel = finalVowelsList.toList.get(maxIndexOfVowel)\n      \
    \  return finalVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxksa5idi.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mword\e[0m = word.trim\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35mword\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpxksa5idi.scala:38:35 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mvar\e[0m \e[36mvowelCount\e[0m : \e\
    [35mInt\e[0m = vowelCount(word)\n\e[31m\e[31m   |\e[0m                       \
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \e[33mvariable\e\
    [0m \e[35mvowelCount\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxksa5idi.scala:40:44 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e[0m (word.charAt(i) == vowel(i))\
    \ {\n\e[31m\e[31m   |\e[0m                                            ^\e[0m\n\
    \e[31m   |\e[0m                                            Found:    (i : Int)\n\
    \e[31m   |\e[0m                                            Required: Char\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxksa5idi.scala:43:44\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                \e[33mif\e[0m\
    \ (word.charAt(i) == vowel(j)) {\n\e[31m\e[31m   |\e[0m                      \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \             Found:    (j : Int)\n\e[31m   |\e[0m                           \
    \                 Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxksa5idi.scala:64:48 ------------------------\e[0m\e[0m\n\e[31m64 |\e\
    [0m        \e[33mval\e[0m \e[36mfinalVowel\e[0m = finalVowelsList.toList.get(maxIndexOfVowel)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word == \"\"\
    ) \"\" else getClosestVowel(word.tail.tail)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi8n79nxq.scala:22)\n\tat Problem.main(tmpi8n79nxq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels : Set[Char]\
    \ = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var vowels_count : Int = vowels.size\n\
    \        var min_dist : Double = Double.MaxValue\n        var min_dist : Char\
    \ = \"\"\n        var len : Int = word.length\n        var i : Int = 0\n     \
    \   while (i < len) {\n            if (vowels_count > 0) {\n                val\
    \ char : Char = word.charAt(i)\n                if (vowels.contains(char)) {\n\
    \                    vowels_count -= 1\n                } else {\n           \
    \         if (min_dist > Math.abs(char - word.charAt(i))) {\n                \
    \        min_dist = Math.abs(char - word.charAt(i))\n                        min_dist\
    \ = min_dist / len\n                        min_dist = min_dist.toDouble\n   \
    \                 }\n                }\n            }\n            i += 1\n  \
    \      }\n        if (vowels_count == 0) {\n            return \"\"\n        }\
    \ else if (min_dist > 0.1) {\n            return \"\"\n        } else {\n    \
    \        val min_dist_chr = min_dist.toInt\n            val min_dist_char = min_dist/len.toDouble\n\
    \            val min_dist_chr_char = min_dist_char.toInt\n            if (min_dist_chr\
    \ > min_dist_chr_char) {\n                return \"\"\n            } else {\n\
    \                return min_dist_chr\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb36euqyk.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mmin_dist\e[0m : \e[35mChar\e\
    [0m = \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmin_dist is already defined as \e[33mvariable\e[0m \e[35mmin_dist\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpb36euqyk.scala:19:37 --------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvowels\e[0m : \e[35mSet\e[0m[\e[35mChar\e\
    [0m] = Set(\e[31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e\
    [0m, \e[31m\"u\"\e[0m)\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^\e[0m\n\e[31m   |\e[0m                                     Found:   \
    \ (\e[32m\"a\"\e[0m : String)\n\e[31m   |\e[0m                               \
    \      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb36euqyk.scala:19:42\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvowels\e\
    [0m : \e[35mSet\e[0m[\e[35mChar\e[0m] = Set(\e[31m\"a\"\e[0m, \e[31m\"e\"\e[0m,\
    \ \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"u\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                          ^^^\e[0m\n\e[31m   |\e[0m         \
    \                                 Found:    (\e[32m\"e\"\e[0m : String)\n\e[31m\
    \   |\e[0m                                          Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb36euqyk.scala:19:47 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mvowels\e[0m : \e[35mSet\e\
    [0m[\e[35mChar\e[0m] = Set(\e[31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m,\
    \ \e[31m\"o\"\e[0m, \e[31m\"u\"\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \                              ^^^\e[0m\n\e[31m   |\e[0m                     \
    \                          Found:    (\e[32m\"i\"\e[0m : String)\n\e[31m   |\e\
    [0m                                               Require"
  stdout: ''
  timestamp: 1660009888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        var res = \"\"\n        var vowel = \"\"\
    \n        word.lastOption.toList.foreach(l => {\n            if (vowels.contains(l.toLowerCase(Locale.ROOT)))\
    \ {\n                vowel = l\n            }\n        })\n        for (i <- 1\
    \ to (word.length - 1)) {\n            if (vowels.contains(word.charAt(i).toLowerCase(Locale.ROOT)))\
    \ {\n                if (word.charAt(i) == vowel) {\n                    res =\
    \ word.substring(word.length - vowel.length, 1)\n                    break\n \
    \               }\n            }\n        }\n        if (res.length == 0) {\n\
    \            res = word.lastOption\n        }\n        return res\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphdvphkrg.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (vowels.contains(l.toLowerCase(Locale.ROOT)))\
    \ {\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toLowerCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphdvphkrg.scala:23:46\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ (vowels.contains(l.toLowerCase(Locale.ROOT))) {\n\e[31m\e[31m   |\e[0m     \
    \                                         ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                       Not found: Locale\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphdvphkrg.scala:24:24 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                vowel = l\n\e[31m\e[31m   |\e[0m    \
    \                    ^\e[0m\n\e[31m   |\e[0m                        Found:   \
    \ (l : Char)\n\e[31m   |\e[0m                        Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphdvphkrg.scala:28:47 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (vowels.contains(word.charAt(i).toLowerCase(Locale.ROOT)))\
    \ {\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphdvphkrg.scala:28:59\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m\
    \ (vowels.contains(word.charAt(i).toLowerCase(Locale.ROOT))) {\n\e[31m\e[31m \
    \  |\e[0m                                                           ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                       Not found:\
    \ Locale\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmphdvphkrg.scala:29:20 ----------------------------"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = List(\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        var\
    \ wordArray = word.split(\"\")\n        wordArray = wordArray.reverse.takeWhile(x\
    \ => !vowels.contains(x)).reverse\n        val resultArray = wordArray.toArray\n\
    \        if (resultArray.length <= 1) \"\"\n        else {\n            var i\
    \ = 0\n            val minPos = wordArray.length - 2\n            val minDiff\
    \ = math.abs(resultArray(i) - resultArray(minPos)) + 2\n            for (i <-\
    \ 0 until minPos) {\n                val diff = math.abs(resultArray(i) - resultArray(minPos))\n\
    \                if (diff < minDiff) minDiff = diff\n            }\n         \
    \   val finalResult = resultArray(minPos)\n            vowels.find(x => x == finalResult)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3biq_jq7.scala:27:50 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mminDiff\e[0m = math.abs(resultArray(i)\
    \ - resultArray(minPos)) + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m               \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3biq_jq7.scala:29:51 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mdiff\e[0m = math.abs(resultArray(i)\
    \ - resultArray(minPos))\n\e[31m\e[31m   |\e[0m                              \
    \      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp3biq_jq7.scala:30:44 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m (diff < minDiff) minDiff\
    \ = diff\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Reassignment to val minDiff\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3biq_jq7.scala:33:23\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            vowels.find(\e[36mx\e\
    [0m => x == finalResult)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var vowelIndex = word.size\n       \
    \ var leftIndex = word.lastIndexOf(\"a\")\n        var rightIndex = word.lastIndexOf(\"\
    e\")\n        var leftCount = word.lastIndexOf(\"a\") + 1 == word.lastIndexOf(\"\
    e\")\n        var rightCount = word.lastIndexOf(\"e\") + 1 == word.lastIndexOf(\"\
    i\")\n        var leftFound = false\n        var rightFound = false\n        while\
    \ (!leftFound || !rightFound) {\n            if ((leftIndex - leftCount >= 0)\
    \ && (rightIndex - rightCount >= 0) && (leftIndex - leftCount > rightIndex - rightCount))\
    \ {\n                if (vowels.exists(word.substring(leftIndex - leftCount, leftIndex).contains))\
    \ {\n                    leftIndex = leftIndex - leftCount\n                 \
    \   leftFound = true\n                } else {\n                    leftIndex\
    \ = leftIndex - 1\n                }\n            } else if (leftIndex - leftCount\
    \ >= 0) {\n                if (vowels.exists(word.substring(leftIndex - leftCount,\
    \ leftIndex).contains)) {\n                    leftIndex = leftIndex - leftCount\n\
    \                    leftFound = true\n                } else {\n            \
    \        leftIndex = leftIndex - 1\n                }\n            } else {\n\
    \                if ((rightIndex - rightCount >= 0) && (rightIndex - rightCount\
    \ > leftIndex - leftCount)) {\n                    if (vowels.exists(word.substring(rightIndex\
    \ - rightCount, rightIndex).contains)) {\n                        rightIndex =\
    \ rightIndex - rightCount\n                        rightFound = true\n       \
    \             } else {\n                        rightIndex = rightIndex - 1\n\
    \                    }\n                } else if (rightIndex - rightCount >=\
    \ 0) {\n                    if (vowels.exists(word.substring(rightIndex - rightCount,\
    \ rightIndex).contains)) {\n                        rightIndex = rightIndex -\
    \ rightCount\n                        rightFound = true\n                    }\
    \ else {\n                        rightIndex = rightIndex - 1\n              \
    \      }\n                } else {\n                    rightIndex = word.lastIndexOf(\"\
    e\")\n                    rightFound = true\n                }\n            }\n\
    \        }\n        vowelIndex = leftIndex\n        val vowel = word.substring(vowelIndex,\
    \ vowelIndex + 1).trim\n        return vowel\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxw755cb4.scala:28:27 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m ((leftIndex - leftCount >=\
    \ \e[31m0\e[0m) && (rightIndex - rightCount >= \e[31m0\e[0m) && (leftIndex - leftCount\
    \ > rightIndex - rightCount)) {\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments ((leftCount : Boolean))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpxw755cb4.scala:29:59 -----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                \e[33mif\e[0m (vowels.exists(word.substring(leftIndex\
    \ - leftCount, leftIndex).contains)) {\n\e[31m\e[31m   |\e[0m                \
    \                                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m\
    \ \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e\
    [0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x:\
    \ Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\
    \e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((leftCount :\
    \ Boolean))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxw755cb4.scala:30:42 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    leftIndex = leftIndex - leftCount\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((leftCount : Boolean))\n\e[31m\e"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = Set[Char](\
    \ 'a', 'e', 'i', 'o', 'u' );\n        var vowelCount = word.count(\"a\");\n\n\
    \        var lastIndex = word.lastIndexOf('u');\n        if (lastIndex >= 0) {\n\
    \            vowelCount += word.lastIndexOf('u') - lastIndex + 1;\n        }\n\
    \        var resultIndex =0;\n        for (i <- word.indices) {\n            if\
    \ (vowels.contains(word.charAt(i)) && vowelCount == 0)\n                resultIndex\
    \ = i;\n            vowelCount += 1;\n        }\n\n        if (vowelCount > 0)\
    \ {\n            var result = word.substring(resultIndex, resultIndex + vowelCount);\n\
    \            if (result.isEmpty) result = \"\";\n        }\n        else result\
    \ = \"\";\n        return result;\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yhf5kvf.scala:20:36\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mvowelCount\e\
    [0m = word.count(\e[31m\"a\"\e[0m);\n\e[31m\e[31m   |\e[0m                   \
    \                 ^^^\e[0m\n\e[31m   |\e[0m                                  \
    \  Found:    (\e[32m\"a\"\e[0m : String)\n\e[31m   |\e[0m                    \
    \                Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5yhf5kvf.scala:37:13 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33melse\e[0m result = \e[31m\"\"\e[0m;\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m             Not found:\
    \ result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5yhf5kvf.scala:38:15\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mreturn\e[0m\
    \ result;\n\e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \             Not found: result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // First we split\
    \ up the word into two lists consonants and vowels\n        val consonants = word.filter(_\
    \ >= 'A' && _ <= 'Z')\n        val vowels      = word.filter(_ >= 'a' && _ <=\
    \ 'z')\n        // Then we sort the two lists and iterate over the vowel until\
    \ we find one \n        // that stands between two consonants from the right side\
    \ of the word.\n        // If the two consonants met in the right side of the\
    \ word, return that vowel.\n        val vowelIterator = vowels.dropWhile(_.compareToIgnoreCase(consonants.last)\
    \ < 0) \n                              .takeWhile(_.compareToIgnoreCase(consonants.last)\
    \ < 0) \n                              .dropWhile(_.compareToIgnoreCase(consonants.last)\
    \ < 0) \n                              .takeWhile(_.compareToIgnoreCase(consonants.last)\
    \ < 0) \n                              .iterator\n        if(vowelIterator.hasNext)\
    \ {\n            vowelIterator.next\n        } else {\n            \"\"\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpnwhxdll1.scala:20:37 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mconsonants\e[0m = word.filter(_\
    \ >= \e[31m'A'\e[0m && _ <= \e[31m'Z'\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                          ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpnwhxdll1.scala:21:38 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m      = word.filter(_\
    \ >= \e[31m'a'\e[0m && _ <= \e[31m'z'\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnwhxdll1.scala:25:47 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mvowelIterator\e[0m = vowels.dropWhile(_.compareToIgnoreCase(consonants.last)\
    \ < \e[31m0\e[0m) \n\e[31m\e[31m   |\e[0m                                    \
    \         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ compareToIgnoreCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnwhxdll1.scala:26:43 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                              .takeWhile(_.compareToIgnoreCase(consonants.last)\
    \ < \e[31m0\e[0m) \n\e[31m\e[31m   |\e[0m                                    \
    \     ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ compareToIgnoreCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnwhxdll1.scala:27:43 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                              .dropWhile(_.compareToIgnoreCase(consonants.last)\
    \ < \e[31m0\e[0m) \n\e[31m\e[31m   |\e[0m                                    \
    \     ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ compareToIgnoreCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnwhxdll1.scala:28:43 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                            "
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val consonants =\
    \ consonantsFromEnds(word)\n        val vowels = vowelsFromEnd(word)\n       \
    \ val vowelsSet = vowels.toSet\n        val consonantsSet = consonants.toSet\n\
    \        val vowelsSetIterator = vowelsSet.iterator\n        val consonantsSetIterator\
    \ = consonantsSet.iterator\n        var results : String = \"\"\n        while(vowelsSetIterator.hasNext\
    \ && consonantsSetIterator.hasNext) {\n            if(vowelsSetIterator.next()\
    \ == consonantsSetIterator.next())\n                results = vowelsSetIterator.next()\
    \ \n        }\n        results\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvkzfrcrf.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mconsonants\e[0m = consonantsFromEnds(word)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: consonantsFromEnds\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvkzfrcrf.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = vowelsFromEnd(word)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: vowelsFromEnd\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word.length\
    \ < 2) return \"\"\n        val vowels = \"aeiouAEIOU\"\n        val vowelIndexes\
    \ = vowels.zipWithIndex.filter{ case (a, i) => word.charAt(i) != a }\n       \
    \ return vowelIndexes.map(_.first).map{ i => vowels.charAt(i) }.getOrElse(\"\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnqsdp0kq.scala:22:34 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mreturn\e[0m vowelIndexes.map(_.first).map{\
    \ \e[36mi\e[0m => vowels.charAt(i) }.getOrElse(\e[31m\"\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m     value\
    \ first is not a member of (Char, Int) - did you mean _$1.init?\n1 error found\n"
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var vowelPosition = 0\n        val arr\
    \ = new Array[Int](word.length)\n        for ( i <- 0 until word.length ) {\n\
    \            arr(i) = word.charAt(i).toChar.toInt\n        }\n        var minVowelIndex\
    \ = 0\n        val min = math.min(arr(vowelPosition + 1), arr(vowelPosition +\
    \ 2))\n        for (i <- 0 until vowels.length ) {\n            if (arr(vowelPosition\
    \ + i) == min) {\n                minVowelIndex = i\n                break\n \
    \           }\n        }\n        vowels.find(vowel => arr(vowelPosition + minVowelIndex\
    \ + 1) == vowel)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzie6scp4.scala:27:33 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until vowels.length\
    \ ) {\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    value length is not a member of scala.collection.mutable.Set[String]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzie6scp4.scala:30:16 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpzie6scp4.scala:33:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        vowels.find(\e[36mvowel\e[0m => arr(vowelPosition\
    \ + minVowelIndex + \e[31m1\e[0m) == vowel)\n\e[31m\e[31m   |\e[0m           \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m         Values of types Int and String cannot be compared with == or\
    \ !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        var result = \"\"\n        val wordArray = word.split(\"\
    \")\n        val wordLength = wordArray.length\n        if (wordLength <= 1) {\n\
    \            result = \"\"\n        }\n        else {\n            wordArray.zipWithIndex.foreach\
    \ { case (item, index) =>\n                val right = index + 1\n           \
    \     val left = right - 1\n                if (wordLength >= index + 1) {\n \
    \                   if (vowels.contains(wordArray(right).toLowerCase) && \n  \
    \                      vowels.contains(wordArray(left).toLowerCase)) {\n     \
    \                   if (result != \"\" && result != wordArray(right)) {\n    \
    \                        result = \"\"\n                        }\n          \
    \              result = wordArray(right)\n                    }\n            \
    \    }\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk27nycw9.scala:31:40\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    \e[33mif\e\
    [0m (vowels.contains(wordArray(right).toLowerCase) && \n\e[31m\e[31m   |\e[0m\
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                        Found:    String\n\e[31m\
    \   |\e[0m                                        Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk27nycw9.scala:32:40 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        vowels.contains(wordArray(left).toLowerCase))\
    \ {\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    String\n\
    \e[31m   |\e[0m                                        Required: Char\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n        val vowels = \"aeiouAEIOU\"\
    ;\n        val vowel_consonants = \"AaEeIiOoUu\";\n        val vowel_consonant_index\
    \ = consonants.indexOf(vowel_consonants);\n        val index = word.indexOfFirst(consonants)\n\
    \        var vowelIndex = 0;\n        while (index > -1) {\n            if (vowels.contains(word.charAt(index\
    \ + vowel_consonant_index))) {\n                vowelIndex = index;\n        \
    \    }\n            index = word.indexOfFirst(consonants, index + 1);\n      \
    \  }\n        if (vowelIndex != 0) word.substring(vowelIndex, word.length);\n\
    \        else \"\";\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps02wl6rc.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = word.indexOfFirst(consonants)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    value indexOfFirst is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmps02wl6rc.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            index = word.indexOfFirst(consonants, index\
    \ + \e[31m1\e[0m);\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value indexOfFirst is not a member of\
    \ String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val consonantsList\
    \ = new ListBuffer[String]()\n        val vowelsList = new ListBuffer[String]()\n\
    \n        for(i <- 0 until word.length){\n            val char = word.charAt(i)\n\
    \            if(char.equals('a')) vowelsList ++= List(\"a\",\"e\",\"i\",\"o\"\
    ,\"u\")\n            if(char.equals('e')) vowelsList ++= List(\"e\",\"i\",\"o\"\
    ,\"u\")\n            if(char.equals('i')) vowelsList ++= List(\"i\",\"o\",\"u\"\
    )\n            if(char.equals('o')) vowelsList ++= List(\"o\",\"u\")\n       \
    \     if(char.equals('u')) vowelsList ++= List(\"u\")\n\n            if(!vowelsList.contains(char))\
    \ consonantsList ++= List(char)\n        }\n        val lastVowelIndex = vowelsList.length-1\n\
    \        val vowel = vowelsList(lastVowelIndex)\n\n        val consonants = consonantsList.toList.reverse\n\
    \        val lastConsonantIndex = consonants.length-1\n        val consonant =\
    \ consonants(lastConsonantIndex)\n\n        if(vowel.equals(consonant)){\n   \
    \         return \"\"\n        }\n        if(vowel.equals(lastConsonant)){\n \
    \           return vowel\n        }\n        if(vowel.equals(lastVowelIndex)){\n\
    \            return consonant\n        }\n        return \"\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_s_4306p.scala:30:67\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(!vowelsList.contains(char))\
    \ consonantsList ++= List(char)\n\e[31m\e[31m   |\e[0m                       \
    \                                            ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                           Found:    (char : Char)\n\e[31m  \
    \ |\e[0m                                                 Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_s_4306p.scala:42:24\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mif\e[0m(vowel.equals(lastConsonant)){\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: lastConsonant\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = Array(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val vowels2 = Array(\"a\",\"e\",\"i\",\"\
    o\",\"u\",\"y\")\n        val vowels3 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"\
    y\",\"u\")\n        val vowels4 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"\
    u\",\"r\")\n        val vowels5 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"\
    u\",\"r\",\"g\")\n        val vowels6 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"\
    y\",\"u\",\"r\",\"g\",\"u\")\n        val vowels7 = Array(\"a\",\"e\",\"i\",\"\
    o\",\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\")\n        val vowels8 = Array(\"\
    a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\")\n     \
    \   val vowels9 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"u\",\"r\",\"g\"\
    ,\"u\",\"c\",\"k\",\"s\")\n        val vowels10 = Array(\"a\",\"e\",\"i\",\"o\"\
    ,\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\",\"s\",\"v\")\n        val vowels11\
    \ = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"\
    k\",\"s\",\"v\",\"y\")\n        val vowels12 = Array(\"a\",\"e\",\"i\",\"o\",\"\
    u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\",\"s\",\"v\",\"y\",\"i\")\n     \
    \   val vowels13 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"u\",\"r\",\"g\"\
    ,\"u\",\"c\",\"k\",\"s\",\"v\",\"y\",\"i\",\"r\")\n        val vowels14 = Array(\"\
    a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\",\"s\",\"\
    v\",\"y\",\"i\",\"r\",\"g\")\n        val vowels15 = Array(\"a\",\"e\",\"i\",\"\
    o\",\"u\",\"y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\",\"s\",\"v\",\"y\",\"i\",\"\
    r\",\"g\",\"k\")\n        val vowels16 = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"\
    y\",\"u\",\"r\",\"g\",\"u\",\"c\",\"k\",\"s\",\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbb9_fq8a.scala:34:81 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mvowels16\e[0m = Array(\e\
    [31m\"a\"\e[0m,\e[31m\"e\"\e[0m,\e[31m\"i\"\e[0m,\e[31m\"o\"\e[0m,\e[31m\"u\"\e\
    [0m,\e[31m\"y\"\e[0m,\e[31m\"u\"\e[0m,\e[31m\"r\"\e[0m,\e[31m\"g\"\e[0m,\e[31m\"\
    u\"\e[0m,\e[31m\"c\"\e[0m,\e[31m\"k\"\e[0m,\e[31m\"s\"\e[0m,\"\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \         unclosed string literal\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbb9_fq8a.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var position = 1\n\
    \        var vowel = word.charAt(position)\n        var index = 0\n        while\
    \ (index != -1) {\n            if (word.charAt(index) == vowel) {\n          \
    \      index = index + 1\n                position = index\n            }\n  \
    \          else {\n                index = word.lastIndexOf(\"aeiouy\", index)\n\
    \            }\n        }\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt8aw8nb1.scala:34)\n\tat Problem.main(tmpt8aw8nb1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = (\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        var current = 0\n        var min = 1000\n\
    \        var result: String = null\n        for(i <- word.indices) {\n       \
    \     if(vowels.contains(word.charAt(i))) {\n                current = i\n   \
    \             val length = word.size - 1\n                for(j <- current + 1\
    \ to length) {\n                    val candidate = word.substring(j, j + 1)\n\
    \                    val pos = candidate.indexOf(candidate.last)\n           \
    \         if(pos > 0 && pos < min) {\n                        min = pos\n    \
    \                    result = candidate\n                    }\n             \
    \   }\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3bf2zt7y.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(vowels.contains(word.charAt(i)))\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ contains is not a member of (String, String, String, String, String)\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var count = 0\n\
    \        var vowel = \"\"\n        val reverse = word reverse\n        val reverseList\
    \ = reverse.toList\n        val reverseSubset = reverseList.slice(2, reverseList.length)\n\
    \n        val vowelSet = List(\"a\",\"e\",\"i\",\"o\",\"u\")\n        var firstVowel\
    \ = \"\"\n        for(i <- 0 until reverseList.length){\n            if(vowelSet.contains(reverseList(i)){\n\
    \                firstVowel = reverseList(i)\n                count = count+1\n\
    \            }\n        }\n\n        if(reverseList.length > 2){\n           \
    \ val vowelSet2 = List(\"a\",\"e\",\"i\",\"o\",\"u\")\n            var secondVowel\
    \ = \"\"\n            for(i <- reverseList.length until reverseList.length - 1){\n\
    \                if(vowelSet2.contains(reverseList(i)){\n                    secondVowel\
    \ = reverseList(i)\n                    count = count+1\n                }\n \
    \           }\n            if(firstVowel != \"\" && secondVowel != \"\"){\n  \
    \              if(reverseList.length > 1){\n                    val closestVowel\
    \ = firstVowel.min(secondVowel)\n                    if(closestVowel != \"\"){\n\
    \                        return closestVowel\n                    }\n        \
    \        }\n            }\n        }\n        return vowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfy8ime12.scala:21:34 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mreverse\e[0m = word reverse\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                          expression expected but \e[31mend of statement\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfy8ime12.scala:32:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        ')' expected, but '}' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfy8ime12.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            }\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m            ')' expected, but '}' found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpfy8ime12.scala:22:34 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mreverseList\e[0m = reverse.toList\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m      value toList is not a member of Char - did you mean reverse.toInt?\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpfy8ime12.scala:28:32 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m(vowelSet.contains(reverseList(i)){\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             \e[33mmethod\e[0m \e[35mcontains\e[0m in \e[33mclass\e\
    [0m \e[35mList\e[0m does not take more parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpfy8ime12.scala:45:54 --------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    \e[33mval\e[0m \e[36mclosestVowel\e\
    [0m = firstVowel.min(secondVowel)\n\e[31m\e[31m   |\e[0m                     \
    \                                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                              Found:    (secondVowel : String)\n\e[31m   |\e\
    [0m                                        Required: Ordering[Char]\n\e[3"
  stdout: ''
  timestamp: 1660009896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val pattern = word\
    \ splitBy (_===\"a\")\n        val vowels = pattern map (x => x takeWhile (_!==\"\
    z\")) toList\n        val vowelsSet = vowels sort\n        val isVowel = vowelsSet.contains(pattern(0).toLowerCase)\n\
    \        if(isVowel) {\n            val index = vowels.indexOf(pattern(0).toLowerCase)\n\
    \            if (index < vowels.lastIndexOf(pattern(0).toLowerCase)) {\n     \
    \           vowels(index+1)\n            } else {\n                vowels(index-1)\n\
    \            }\n        } else {\n            \"\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpk790oscs.scala:20:68 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = pattern map\
    \ (\e[36mx\e[0m => x takeWhile (_!==\e[31m\"z\"\e[0m)) toList\n\e[31m\e[31m  \
    \ |\e[0m                                                                    ^\e\
    [0m\n\e[31m   |\e[0m                          expression expected but \e[31mend\
    \ of statement\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpk790oscs.scala:21:35 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mvowelsSet\e[0m = vowels sort\n\e[31m\e[31m\
    \   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31mend of statement\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk790oscs.scala:19:27\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mpattern\e[0m = word splitBy (_===\e[31m\"a\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value splitBy is\
    \ not a member of String - did you mean word.split?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = word.substring(word.length\
    \ - 2, word.length - 1)\n        var vowelIndex = 0\n        var index = 0\n \
    \       while (index < word.length && vowelIndex < vowel.length && vowel(vowelIndex)\
    \ <=> word(index) <=> vowel(vowelIndex)) {\n            index += 1\n         \
    \   vowelIndex += 1\n        }\n        if (vowelIndex == vowel.length) {\n  \
    \          if (vowel.nonEmpty) {\n                return vowel\n            }\n\
    \            return \"\"\n        }\n        return word.substring(index - 1,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmaeh_6wo.scala:22:85 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m (index < word.length && vowelIndex\
    \ < vowel.length && vowel(vowelIndex) <=> word(index) <=> vowel(vowelIndex)) {\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value <=>\
    \ is not a member of Char - did you mean Char.<=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n         val vowels = mutable.List(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n         if (word.length > 0) {\n          \
    \   val head = word.last\n             val vowelIndex = vowels.indexOf(head)\n\
    \             val start = vowelIndex + 1\n             val end = word.length -\
    \ 1\n             val vowelEnd = vowels.indexOf(word.last)\n             val vowelStart\
    \ = vowelEnd + 1\n             val vowels = word.substring(start, end).split('')\n\
    \             val wordLength = word.length\n             if (wordLength == 1)\
    \ {\n                 \"\"\n             } else if (wordLength > 2) {\n      \
    \           getClosestVowel(word.substring(vowelStart - 1, vowelEnd + 1))\n  \
    \           } else if (wordLength == 2) {\n                 if (vowelStart < vowelEnd)\
    \ {\n                     getClosestVowel(word.substring(vowelStart - 1, vowelEnd\
    \ + 1))\n                 } else {\n                     \"\"\n              \
    \   }\n             } else {\n                 \"\"\n             }\n        \
    \ } else {\n             \"\"\n         }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpv27z__5u.scala:27:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m             \e[33mval\e[0m \e[36mvowels\e[0m = word.substring(start,\
    \ end).split('')\n\e[31m\e[31m   |\e[0m                                      \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                 empty character literal\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpv27z__5u.scala:28:28 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m             \e[33mval\e[0m \e[36mwordLength\e[0m = word.length\n\e[31m\e\
    [31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m             \
    \               expression expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpv27z__5u.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m         \e[33mval\e[0m \e[36mvowels\e[0m = mutable.List(\e\
    [31m\"a\"\e[0m, \e[31m\"e\"\e[0m, \e[31m\"i\"\e[0m, \e[31m\"o\"\e[0m, \e[31m\"\
    u\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpv27z__5u.scala:23:25 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m             \e[33mval\e[0m \e[36mstart\e[0m = vowelIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m\
    \   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35mvowelIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv27z__5u.scala:22:45\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m             \e[33mval\e[0m \e\
    [36mvowelIndex\e[0m = vowels.indexOf(head)\n\e[31m\e[31m   |\e[0m            \
    \                                 ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                            Found:    (head : Char)\n\e[31m   |\e[0m        \
    \                                     Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanat"
  stdout: ''
  timestamp: 1660009896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    a\" :: \"e\" :: \"i\" :: \"o\" :: \"u\" :: \"y\" :: \"A\" :: \"E\" :: \"I\" ::\
    \ \"O\" :: \"U\" :: \"Y\" :: Nil\n        var vowelIndex = 0\n        var temp\
    \ = 0\n        var vowelLen = vowels.length\n        var wordLen = word.length\n\
    \        var result = \"\"\n        for (i <- 0 until wordLen) {\n           \
    \ temp = word(i)\n            for (j <- 0 until vowelLen) {\n                if\
    \ (temp == vowels(j)) {\n                    if (j == vowelLen-1) {\n        \
    \                result += temp\n                        vowelIndex += 1\n   \
    \                     break\n                    }\n                    vowelIndex\
    \ += 1\n                    break\n                }\n            }\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdoc2tnue.scala:28:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (temp == vowels(j)) {\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m         Values of types Int and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpdoc2tnue.scala:32:24 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdoc2tnue.scala:35:20\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowelIndex =\
    \ word.indexOf(\"aeiouy\")\n        if (vowelIndex > 0) {\n            return\
    \ \"\"\n        }\n        vowelIndex = word.indexOf(\"uioy\")\n        if (vowelIndex\
    \ > 0) {\n            return \"\"\n        }\n        vowelIndex = word.indexOf(\"\
    ouiy\")\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n \
    \       vowelIndex = word.indexOf(\"iy\")\n        if (vowelIndex > 0) {\n   \
    \         return \"\"\n        }\n        vowelIndex = word.indexOf(\"eoui\")\n\
    \        if (vowelIndex > 0) {\n            return \"\"\n        }\n        vowelIndex\
    \ = word.indexOf(\"eeou\")\n        if (vowelIndex > 0) {\n            return\
    \ \"\"\n        }\n        vowelIndex = word.indexOf(\"ieou\")\n        if (vowelIndex\
    \ > 0) {\n            return \"\"\n        }\n        vowelIndex = word.indexOf(\"\
    iooy\")\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n \
    \       vowelIndex = word.indexOf(\"oyay\")\n        if (vowelIndex > 0) {\n \
    \           return \"\"\n        }\n        vowelIndex = word.indexOf(\"uyay\"\
    )\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n       \
    \ vowelIndex = word.indexOf(\"ay\")\n        if (vowelIndex > 0) {\n         \
    \   return \"\"\n        }\n        vowelIndex = word.indexOf(\"eay\")\n     \
    \   if (vowelIndex > 0) {\n            return \"\"\n        }\n        vowelIndex\
    \ = word.indexOf(\"iay\")\n        if (vowelIndex > 0) {\n            return \"\
    \"\n        }\n        vowelIndex = word.indexOf(\"oi\")\n        if (vowelIndex\
    \ > 0) {\n            return \"\"\n        }\n        vowelIndex = word.indexOf(\"\
    ou\")\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n   \
    \     vowelIndex = word.indexOf(\"y\")\n        if (vowelIndex > 0) {\n      \
    \      return \"\"\n        }\n        vowelIndex = word.indexOf(\"u\")\n    \
    \    if (vowelIndex > 0) {\n            return \"\"\n        }\n        vowelIndex\
    \ = word.indexOf(\"a\")\n        if (vowelIndex > 0) {\n            return \"\"\
    \n        }\n        vowelIndex = word.indexOf(\"e\")\n        if (vowelIndex\
    \ > 0) {\n            return \"\"\n        }\n        vowelIndex = word.indexOf(\"\
    i\")\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n    \
    \    vowelIndex = word.indexOf(\"o\")\n        if (vowelIndex > 0) {\n       \
    \     return \"\"\n        }\n        vowelIndex = word.indexOf(\"u\")\n     \
    \   if (vowelIndex > 0) {\n            return \"\"\n        }\n        vowelIndex\
    \ = word.indexOf(\"a\")\n        if (vowelIndex > 0) {\n            return \"\"\
    \n        }\n        vowelIndex = word.indexOf(\"e\")\n        if (vowelIndex\
    \ > 0) {\n            return \"\"\n        }\n        vowelIndex = word.indexOf(\"\
    i\")\n        if (vowelIndex > 0) {\n            return \"\"\n        }\n\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjg5dipro.scala:116:8\
    \ --------------------\e[0m\e[0m\n\e[31m116 |\e[0m        \e[33mif\e[0m (vowelIndex\
    \ > \e[31m0\e[0m) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m  \
    \      Found:    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m    |\e\
    [0m        Maybe you are missing an else part for the conditional?\n\e[31m117\
    \ |\e[0m            \e[33mreturn\e[0m \e[31m\"\"\e[0m\n\e[31m118 |\e[0m      \
    \  }\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n       val vowels = List('u',\
    \ 'U', 'a', 'A')\n        val count = word.length - 1\n        val vowelIndexList\
    \ = word.substring(count, count+1).split(\"u\").map(_.toLowerCase).toSet\n   \
    \     vowelIndexList match {\n            case Nil => \"\"\n            case vowels\
    \ :: _ => vowels.minBy(v => word.indexOf(v.toLowerCase + v.charAt(1))).toLowerCase\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp55fgu2_0.scala:23:17\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m Nil\
    \ => \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^\e[0m\n\e[31m \
    \  |\e[0m        Found:    (Nil : => collection.immutable.Nil\xB2.type)\n\e[31m\
    \   |\e[0m        Required: Set[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m    \
    \    where:    Nil  is a getter in \e[33mpackage object\e[0m \e[35mscala\e[0m\n\
    \e[31m   |\e[0m                  Nil\xB2 is a object in \e[33mpackage\e[0m \e\
    [35mscala.collection.immutable\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m        pattern\
    \ type is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp55fgu2_0.scala:24:39 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m vowels :: _ => vowels.minBy(v\
    \ => word.indexOf(v.toLowerCase + v.charAt(\e[31m1\e[0m))).toLowerCase\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value minBy is not a member of Any\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        //1\n        val\
    \ vowels = \"aeiouAEIOU\".toList\n        //2\n        var result = \"null\"\n\
    \        //3\n        for (x<-vowels.reverse) {\n            //4\n           \
    \ for (y<-vowels.reverse) {\n                //5\n                if (word.indexOf(x.toString)\
    \ >= 0) {\n                    //6\n                    if (word.indexOf(y.toString)\
    \ >= 0) {\n                        //7\n                        //8\n        \
    \                if (word.indexOf(x.toString) < word.indexOf(y.toString)) {\n\
    \                            //9\n                            result = x\n   \
    \                         break\n                        } else {\n          \
    \                  //10\n                            result = y\n            \
    \                break\n                        }\n                    } else\
    \ {\n                        //11\n                        result = x\n      \
    \                  break\n                    }\n                } else {\n  \
    \                  //12\n                    result = y\n                    break\n\
    \                }\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ly02eb_.scala:35:37\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                            result\
    \ = x\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    (x : Char)\n\e[31m  \
    \ |\e[0m                                     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ly02eb_.scala:36:28 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                            break\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5ly02eb_.scala:39:37 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                            result = y\n\e[31m\e[31m   |\e[0m        \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \             Found:    (y : Char)\n\e[31m   |\e[0m                          \
    \           Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5ly02eb_.scala:40:28 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                            break\n\e[31m\e[31m   |\e[0m                  \
    \          ^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ly02eb_.scala:44:33\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                        result\
    \ = x\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m  \
    \ |\e[0m                                 Found:    (x : Char)\n\e[31m   |\e[0m\
    \                                 Required: String\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5ly02eb_."
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowels = \"\
    aeiouAEIOU\".toList\n        var currentVowel = \"\"\n        var lastVowel =\
    \ \"\"\n\n        for(i <- 0 until word.length){\n            if(vowels.contains(word.charAt(i))){\n\
    \                if(currentVowel != \"\"){\n                    if(word.charAt(i)\
    \ != currentVowel){\n                        lastVowel = currentVowel\n      \
    \              }\n                    currentVowel = word.charAt(i)\n        \
    \        }else{\n                    currentVowel = word.charAt(i)\n         \
    \       }\n            }else{\n                currentVowel = \"\"\n         \
    \   }\n        }\n        if(currentVowel != \"\"){\n            vowels.remove(word.charAt(word.length-1))\n\
    \            if(word.charAt(word.length-2) != lastVowel){\n                lastVowel\
    \ = word.charAt(word.length-2)\n            }\n        }\n        return lastVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp00zjkat8.scala:26:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33mif\e[0m(word.charAt(i) != currentVowel){\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00zjkat8.scala:29:46\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    currentVowel\
    \ = word.charAt(i)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    Char\n\e[31m\
    \   |\e[0m                                   Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00zjkat8.scala:31:46 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    currentVowel = word.charAt(i)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                   Found:    Char\n\e[31m   |\e[0m\
    \                                   Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp00zjkat8.scala:38:19 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            vowels.remove(word.charAt(word.length-\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue remove is not a member of List[Char], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmp00zjkat8.scala:39:15"
  stdout: ''
  timestamp: 1660009900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val firstCons =\
    \ word.lastIndexWhere(Character.isLetter)\n        val lastCons = word.lastIndexWhere(Character.isLetterOrDigit)\n\
    \        if (firstCons == lastCons) {\n            if (word.charAt(firstCons)\
    \ == \"a\" && !word.startsWith(\"ab\") && !word.startsWith(\"abv\") && !word.startsWith(\"\
    abs\")) {\n                \"\"\n            } else {\n                word.charAt(firstCons)\n\
    \            }\n        } else {\n            val lowerWord = word.substring(0,\
    \ firstCons)\n            val upperWord = word.substring(firstCons, lastCons)\n\
    \            var lowerIndex = upperWord.lastIndexWhere(Character.isLetter)\n \
    \           var upperIndex = upperWord.lastIndexWhere(Character.isLetterOrDigit)\n\
    \            while (lowerIndex < upperIndex) {\n                lowerIndex = upperWord.lastIndexWhere(Character.isLetter,\
    \ lowerIndex + 1)\n                upperIndex = upperWord.lastIndexWhere(Character.isLetterOrDigit,\
    \ lowerIndex + 1)\n            }\n            val lowerString = upperWord.substring(lowerIndex,\
    \ lowerIndex + 1).mkString\n            val upperString = upperWord.substring(lowerIndex\
    \ + 1, upperIndex).mkString\n            var vowel = \"\"\n            if (lowerString.equalsIgnoreCase(upperString))\
    \ {\n                vowel = lowerString\n            } else {\n             \
    \   vowel = upperString\n            }\n            vowel\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpj5l_45hm.scala:22:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (word.charAt(firstCons) ==\
    \ \e[31m\"a\"\e[0m && !word.startsWith(\e[31m\"ab\"\e[0m) && !word.startsWith(\e\
    [31m\"abv\"\e[0m) && !word.startsWith(\e[31m\"abs\"\e[0m)) {\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Values of types Char and String cannot be compared with == or !=\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpj5l_45hm.scala:25:27 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                word.charAt(firstCons)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \         Found:    Char\n\e[31m   |\e[0m                Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        def checkConsonant(index\
    \ : Int, letters : String, found : mutable.Set[String]) : Unit = {\n         \
    \   if(letters.isEmpty) found.add(\"\")\n            else {\n                if(index+1\
    \ >= letters.length) found.add(letters.substring(index))\n                else\
    \ {\n                    if(letters.charAt(index+1).matches(\"[aeiouAEIOU]\"))\n\
    \                        checkConsonant(index+1, letters.substring(index+1), found)\n\
    \                    else checkConsonant(index+1, letters.substring(index), found)\n\
    \                }\n            }\n        }\n        val letters = word.split(\"\
    \").map(_.toLowerCase).toSet\n        val found = mutable.Set[String]()\n    \
    \    checkConsonant(0, letters, found)\n        found.toSeq.minBy(_.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo80dpasa.scala:19:66 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mdef\e[0m \e[36mcheckConsonant\e[0m(\e[36mindex\e\
    [0m : \e[35mInt\e[0m, \e[36mletters\e[0m : \e[35mString\e[0m, \e[36mfound\e[0m\
    \ : mutable.Set[\e[35mString\e[0m]) : \e[35mUnit\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo80dpasa.scala:24:47\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    \e[33mif\e\
    [0m(letters.charAt(index+\e[31m1\e[0m).matches(\e[31m\"[aeiouAEIOU]\"\e[0m))\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value matches is not a member of Char\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo80dpasa.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mfound\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpo80dpasa.scala:32:26 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        checkConsonant(\e[31m0\e[0m, letters, found)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Found:    (letters : Set[String])\n\e[31m   |\e[0m \
    \                         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val pattern = Pattern.compile(\"\
    [aeiou]\", Pattern.UNICODE_CHARACTER_CLASS)\n        val vowels = mutable.ListBuffer.empty[String]\n\
    \        var index = 0\n        var closestVowel = \"\"\n        while(index !=\
    \ -1){\n            val result = pattern.matcher(word).find() match {\n      \
    \          case true =>\n                    if(index < (word.length())){\n  \
    \                      val c = word.charAt(index)\n                        if(vowels.contains(c))\
    \ {\n                            closestVowel = closestVowel + c\n           \
    \                 closestVowel = closestVowel\n                        } else\
    \ {\n                            vowels.append(c)\n                        }\n\
    \                        index++\n                    } else {\n             \
    \           closestVowel = \"\"\n                    }\n                case _\
    \ => closestVowel = \"\"\n            }\n        }\n        closestVowel\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpft8q3vnj.scala:34:31 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        index++\n\e[31m\e[31m   |\e[0m\
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpft8q3vnj.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mpattern\e[0m = Pattern.compile(\e\
    [31m\"[aeiou]\"\e[0m, Pattern.UNICODE_CHARACTER_CLASS)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: Pattern\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpft8q3vnj.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mvowels\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelList =\
    \ new mutable.ListBuffer[Char]()\n        val consonantList = new mutable.ListBuffer[Char]()\n\
    \        val consonantsLength =word.length-1\n        val vowelsLength =word.length\n\
    \n        for(index <- consonantsLength to vowelsLength){\n            if(word.charAt(index)\
    \ == 'a' || word.charAt(index) == 'e' || word.charAt(index) == 'i' || word.charAt(index)\
    \ == 'o' || word.charAt(index) == 'u'){\n                consonantList += word.charAt(index)\n\
    \            }\n            else{\n                vowelList += word.charAt(index)\n\
    \            }\n        }\n        if (consonantList.isEmpty || vowelList.isEmpty)\n\
    \            return \"\"\n        consonantList.sortWith((x,y)=>{return x<y}).last\n\
    \        vowelList.sortWith((x,y)=>{return x<y}).last\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0a_v60x_.scala:19:28 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowelList\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0a_v60x_.scala:20:32\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mconsonantList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mChar\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel : String\
    \ = \"\"\n        for (i <- word.length + 1 to word.length -1) {\n           \
    \ if (word.substring(i, i+1).contains(\"aeiou\")) {\n                vowel = word.substring(i,\
    \ i+1)\n            }\n        }\n        return vowel\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprada8ace.scala:28)\n\tat Problem.main(tmprada8ace.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    AEIOUaeiou\"\n        val reversed = new ListBuffer[Char]()\n        for (v <-\
    \ vowels) {\n            reversed.prepend(v)\n            reversed.prepend(v)\n\
    \        }\n        val indices = word.zipWithIndex.filter { case (c,i) =>\n \
    \           val ind = reversed.indexOf(c)\n            reversed.slice(ind,ind\
    \ + 2).forall(vowels.contains)\n        }.map(_._2).max\n        val lastVowels\
    \ = indices.map(i => reversed.slice(indices.size - 1 - i, indices.size - 1 - i\
    \ + 1).mkString(\"\")).mkString(\"\")\n        if (lastVowels.isEmpty) {\n   \
    \         \"\"\n        } else {\n            lastVowels\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\"\
    )).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv93ihz2b.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlastVowels\e[0m = indices.map(\e\
    [36mi\e[0m => reversed.slice(indices.size - \e[31m1\e[0m - i, indices.size - \e\
    [31m1\e[0m - i + \e[31m1\e[0m).mkString(\e[31m\"\"\e[0m)).mkString(\e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                         value map is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var firstVowel =\
    \ vowels.head\n        var secondVowel = vowels.last\n        var vowelIndex =\
    \ 0\n        var foundIndex = 0\n        var isFirstVowel = false\n        var\
    \ isSecondVowel = false\n        var lastVowelIndex = 0\n        var firstVowelIndex\
    \ = 0\n        var secondVowelIndex = 0\n        var wordArray = word.split(\"\
    \")\n        for(index <- 0 until wordArray.length){\n            if(isFirstVowel){\n\
    \                if(wordArray[index].equals(firstVowel)){\n                  \
    \  foundIndex = index\n                    isFirstVowel = false\n            \
    \        isSecondVowel = true\n                    wordIndex++\n             \
    \   }\n            }\n            if(isSecondVowel){\n                if(wordArray[index].equals(secondVowel)){\n\
    \                    foundIndex = index\n                    isFirstVowel = true\n\
    \                    isSecondVowel = false\n                    wordIndex++\n\
    \                }\n            }\n            if(wordArray[index].equals(firstVowel)){\n\
    \                firstVowelIndex = index\n                isFirstVowel = true\n\
    \                wordIndex++\n            }\n            if(wordArray[index].equals(secondVowel)){\n\
    \                secondVowelIndex = index\n                isFirstVowel = true\n\
    \                wordIndex++\n            }\n        }\n        if(foundIndex\
    \ == -1){\n            return \"\"\n        }\n        while(vowelIndex != -1){\n\
    \            if(wordArray[vowelIndex].equals(firstVowel) || wordArray[vowelIndex].equals(secondVowel)){\n\
    \                lastVowelIndex = vowelIndex\n            }\n            vowelIndex--\n\
    \        }\n        if(vowelIndex != -1){\n            vowelIndex--\n        }\n\
    \        if(wordArray[vowelIndex].equals(firstVowel) && isFirstVowel){\n     \
    \       vowelIndex--\n            isFirstVowel = false\n            firstVowelIndex--\n\
    \        }\n        if(wordArray[vowelIndex].equals(secondVowel) && isSecondVowel){\n\
    \            vowelIndex--\n            isSecondVowel = false\n            secondVowelIndex--\n\
    \        }\n        if(vowelIndex == -1){\n            return \"\"\n        }\n\
    \        if(lastVowelIndex != -1){\n            return wordArray.substring(lastVowelIndex\
    \ + 1, foundIndex).substring(0,1)\n        }\n        if(firstVowelIndex != -1){\n\
    \            return wordArray.substring(firstVowelIndex + 1, foundIndex).substring(0,1)\n\
    \        }\n        if(secondVowelIndex != -1){\n            return wordArray.substring(secondVow\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpagk0oo42.scala:35:31 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    wordIndex++\n\e[31m\e[31m   |\e[0m\
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpagk0oo42.scala:43:31 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    wordIndex++\n\e[31m\e[31m   |\e[0m\
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpagk0oo42.scala:49:27 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                wordIndex++\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpagk0oo42.scala:54:27 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m                wordIndex++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpagk0oo42.scala:64:24 ---------------------------\e[0m\e[0m\n\e[31m64\
    \ |\e[0m            vowelIndex--\n\e[31m\e[31m   |\e[0m                      \
    \  ^\e[0m\n\e[31m   |\e[0m                        expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpagk0oo42.scala:67:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m            vowelIndex--\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               e"
  stdout: ''
  timestamp: 1660009902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = \"u\"\
    \ // assume first vowel is u\n        var prevVowel = \"u\" // assume first vowel\
    \ is u\n        var cons = word.substring(0,word.indexOf('a')) //assuming 'a'\
    \ is the beginning of the word\n        var endCons = word.substring(word.indexOf('a')+1,\
    \ word.length) //assuming 'a' is the beginning of the word\n        // iterate\
    \ through all consonants in the word and find the closest vowel that is \n   \
    \     // not the same as the first vowel in the beginning of the word\n      \
    \  for (c <- cons) {\n            if(vowel != prevVowel) {\n                vowel\
    \ = c\n                prevVowel = vowel\n            }\n        }\n        //\
    \ if the vowel was not found in the beginning of the word, find the closest vowel\
    \ \n        // not the same as the last vowel in the end of the word\n       \
    \ if(vowel != prevVowel) {\n            for (c <- endCons) {\n               \
    \ if(c!=vowel) {\n                    vowel = c\n                    prevVowel\
    \ = vowel\n                }\n            }\n        }\n        return vowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp72w387pc.scala:27:24\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                vowel = c\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Found:    (c : Char)\n\e[31m   |\e[0m                        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp72w387pc.scala:35:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m(c!=vowel) {\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp72w387pc.scala:36:28 --------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m                    vowel = c\n\e[31m\e[31m   |\e[0m          \
    \                  ^\e[0m\n\e[31m   |\e[0m                            Found: \
    \   (c : Char)\n\e[31m   |\e[0m                            Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var start = -1\n\
    \        var end = -1\n        var result = \"\"\n        word.foreach(c => \n\
    \            c match {\n                case 'a' | 'e' | 'i' | 'o' | 'u' => start\
    \ = word.indexOf(c)\n                case \"A\" | \"E\" | \"I\" | \"O\" | \"U\"\
    \ => start = word.indexOf(c)\n                case _ =>\n                case\
    \ _ =>\n                case _ =>\n                case _ =>\n               \
    \ case _ =>\n                case _ =>\n                case _ =>\n          \
    \  })\n        word.foreach(c => {\n            c match {\n                case\
    \ 'a' | 'e' | 'i' | 'o' | 'u' => end = word.indexOf(c)\n                case \"\
    A\" | \"E\" | \"I\" | \"O\" | \"U\" => end = word.indexOf(c)\n               \
    \ case _ =>\n                case _ =>\n                case _ =>\n          \
    \      case _ =>\n                case _ =>\n                case _ =>\n     \
    \       })\n            \n            if(start >= 0 && end >= 0) {\n         \
    \       var mid = start + (end - start) / 2\n                result match {\n\
    \                    case \"\" => result = word.charAt(mid)\n                \
    \    case _ => result = word.charAt(mid)\n                }\n            }\n \
    \       })\n        \n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7rgx67i2.scala:44:13 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            })\n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             '}' expected, but ')' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp7rgx67i2.scala:53:9 ----------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m        })\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m \
    \  |\e[0m         '}' expected, but ')' found\n\e[31m\e[31m-- Error: /tmp/tmp7rgx67i2.scala:25:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m\"A\"\e[0m | \e[31m\"E\"\e[0m | \e[31m\"I\"\e\
    [0m | \e[31m\"O\"\e[0m | \e[31m\"U\"\e[0m => start = word.indexOf(c)\n\e[31m\e\
    [31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp7rgx67i2.scala:25:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m\"A\"\e[0m | \e[31m\"E\"\e[0m | \e[31m\"I\"\e\
    [0m | \e[31m\"O\"\e[0m | \e[31m\"U\"\e[0m => start = word.indexOf(c)\n\e[31m\e\
    [31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp7rgx67i2.scala:25:33 -----------------------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m\"A\"\e[0m | \e[31m\"\
    E\"\e[0m | \e[31m\"I\"\e[0m | \e[31m\"O\"\e[0m | \e[31m\"U\"\e[0m => start = word.indexOf(c)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp7rgx67i2.scala:25:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m\"A\"\e[0m | \e\
    [31m\"E\"\e[0m | \e[31m\"I\"\e[0m | \e[31m\"O\"\e[0m | \e[31m\"U\"\e[0m => start\
    \ = word.indexOf(c)\n\e[31m\e[31m   |\e[0m                                   \
    \    ^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char cannot be\
    \ compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp7rgx67i2.scala:25:45 ---------------------------------------"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        // Your code here\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp204mp2jb.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m    \e[33mdef\e[0m \e[36mgetClosestVowel\e\
    [0m(\e[36mword\e[0m : \e[35mString\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                  ^\e[0m\n\e[31m   |\e\
    [0m                                                  Found:    Unit\n\e[31m  \
    \ |\e[0m                                                  Required: String\n\e\
    [31m19 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowels = \"\
    a\xC1\xC0A\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\u0107\u0109\
    \u010B\u010F\u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\u016C\u016A\
    \u016C\u0168\u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\u0179\u017D\
    \xDF\u017D\u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\u0120\u0122\
    \u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\
    \u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\u013C\
    \u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u0149\
    \u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\u0153\u0154\u0155\u0156\u0157\
    \u0158\u0159\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u0162\u0163\u0164\
    \u0165\u0166\u0167\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\
    \u0172\u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017A\u017B\u017C\u017D\u017E\
    \u017F\xC0\xC1\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\u0107\
    \u0109\u010B\u010F\u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\u016C\
    \u016A\u016C\u0168\u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\u0179\
    \u017D\xDF\u017D\u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\u0120\
    \u0122\u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\
    \u012F\u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\
    \u013C\u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\
    \u0149\u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\uFFFD\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n\
    \    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\"\
    )));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"\
    Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"\
    o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgb36v2hz.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowels\e[0m = \"a\xC1\xC0\
    A\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\u0107\u0109\u010B\u010F\
    \u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\u016C\u016A\u016C\u0168\
    \u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\u0179\u017D\xDF\u017D\
    \u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\u0120\u0122\u0123\
    \u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\
    \u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\u013C\u013D\
    \u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014B\
    \u014C\u014D\u014E\u014F\u0150\u0151\u0152\u0153\u0154\u0155\u0156\u0157\u0158\
    \u0159\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u0162\u0163\u0164\u0165\
    \u0166\u0167\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\
    \u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017A\u017B\u017C\u017D\u017E\u017F\
    \xC0\xC1\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\u0107\u0109\
    \u010B\u010F\u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\u016C\u016A\
    \u016C\u0168\u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\u0179\u017D\
    \xDF\u017D\u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\u0120\u0122\
    \u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\
    \u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\u013C\
    \u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\u0149\
    \u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\uFFFD\n\e[31m\e[31m   |\e[0m\
    \                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpgb36v2hz.scala:21:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpgb36v2hz.scala:20:5 ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpgb36v2hz.scala:21:4 -------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0mNot\
    \ found: a\xC1\xC0A\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\u0107\
    \u0109\u010B\u010F\u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\u016C\
    \u016A\u016C\u0168\u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\u0179\
    \u017D\xDF\u017D\u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\u0120\
    \u0122\u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\u012E\
    \u012F\u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\u013B\
    \u013C\u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\u0148\
    \u0149\u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\u0153\u0154\u0155\u0156\
    \u0157\u0158\u0159\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u0162\u0163\
    \u0164\u0165\u0166\u0167\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\
    \u0171\u0172\u0173\u0174\u0175\u0176\u0177\u0178\u0179\u017A\u017B\u017C\u017D\
    \u017E\u017F\xC0\xC1\xC2\xC3\u0102\u0100\u0104\xC5\u0104\xC7\u0106\u010A\u010C\
    \u0107\u0109\u010B\u010F\u010E\xD3\xD2\xD4\xD5\xD6\u0150\u014F\u014E\xDC\u016E\
    \u016C\u016A\u016C\u0168\u016A\u0170\u016E\u0172\u0174\u0175\u0176\xDD\u0179\u017B\
    \u0179\u017D\xDF\u017D\u017A\u017C\u017E\u011D\u011F\u011E\u011C\u011F\u011D\u0121\
    \u0120\u0122\u0123\u0124\u0125\u0126\u0127\u0128\u0129\u012A\u012B\u012C\u012D\
    \u012E\u012F\u0130\u0131\u0132\u0133\u0134\u0135\u0136\u0137\u0138\u0139\u013A\
    \u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u0143\u0144\u0145\u0146\u0147\
    \u0148\u0149\u014B\u014C\u014D\u014E\u014F\u0150\u0151\u0152\uFFFDdef\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009902
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        if (word.indexOf(\"\
    a\") != -1 || word.indexOf(\"e\") != -1 || word.indexOf(\"i\") != -1 || word.indexOf(\"\
    o\") != -1 || word.indexOf(\"u\") != -1) {\n            var vowels = \"aeiouAEIOU\"\
    \n            var vowelIndex = 0\n            var vowelIndexEnd = word.length\
    \ - 1;\n            while (vowelIndex < vowelIndexEnd) {\n                var\
    \ vowel = vowels(vowelIndex);\n                var vowelNext = vowels(vowelIndex\
    \ + 1);\n                if (vowelNext == vowel) {\n                    vowelIndex\
    \ += 2\n                } else {\n                    var index = word.indexOf(vowel);\n\
    \                    if (index != -1) {\n                        if (index < vowelIndexEnd)\
    \ {\n                            vowelIndex = index\n                        }\
    \ else {\n                            vowelIndexEnd = index - 1\n            \
    \            }\n                    }\n                }\n            }\n    \
    \        return word.substring(vowelIndex + 1, vowelIndexEnd + 1);\n        }\
    \ else {\n            return \"\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val wordWithVowel\
    \ = word.filter( _.isLetter || _.isUpperCase || _.isLowerCase ).reverse\n    \
    \    val vowel = wordWithVowel.filter(x => x match {\n            case s if s.startsWith(\"\
    a\") || s.startsWith(\"e\") || s.startsWith(\"i\") || s.startsWith(\"o\") || s.startsWith(\"\
    u\") => true\n            case _ => false\n        })\n        return vowel.headOption.map(\
    \ x => x.toLowerCase ).getOrElse(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"\
    full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\"\
    )));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"\
    ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n\
    \    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\
    \")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpmlaxftnz.scala:19:41 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mwordWithVowel\e[0m = word.filter(\
    \ _.isLetter || _.isUpperCase || _.isLowerCase ).reverse\n\e[31m\e[31m   |\e[0m\
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmlaxftnz.scala:21:24\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e\
    [0m s \e[33mif\e[0m s.startsWith(\e[31m\"a\"\e[0m) || s.startsWith(\e[31m\"e\"\
    \e[0m) || s.startsWith(\e[31m\"i\"\e[0m) || s.startsWith(\e[31m\"o\"\e[0m) ||\
    \ s.startsWith(\e[31m\"u\"\e[0m) => \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ startsWith is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmlaxftnz.scala:24:44\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mreturn\e[0m\
    \ vowel.headOption.map( \e[36mx\e[0m => x.toLowerCase ).getOrElse(\e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n3 errors found\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        val vowelMap : Map[Char,Int]\
    \ = word.map(x => (x.toLowerCase , 1)).toMap\n        val v1 = vowelMap.get('u')\n\
    \        val v2 = vowelMap.get('v')\n        val v3 = vowelMap.get('w')\n    \
    \    val v4 = vowelMap.get('x')\n        val v5 = vowelMap.get('y')\n        val\
    \ v6 = vowelMap.get('z')\n        val conMap : Map[Char,Int] = word.map(x => (x.toLowerCase\
    \ , 1)).toMap\n        val c1 = conMap.get('c')\n        val c2 = conMap.get('d')\n\
    \        val c3 = conMap.get('e')\n        val c4 = conMap.get('f')\n        val\
    \ c5 = conMap.get('g')\n        val c6 = conMap.get('h')\n        val c7 = conMap.get('i')\n\
    \        val c8 = conMap.get('j')\n        val c9 = conMap.get('k')\n        val\
    \ c10 = conMap.get('l')\n        val c11 = conMap.get('m')\n        val c12 =\
    \ conMap.get('n')\n        val c13 = conMap.get('o')\n        val c14 = conMap.get('p')\n\
    \        val c15 = conMap.get('q')\n        val c16 = conMap.get('r')\n      \
    \  val c17 = conMap.get('s')\n        val c18 = conMap.get('t')\n        val c19\
    \ = conMap.get('u')\n        val c20 = conMap.get('v')\n        val c21 = conMap.get('w')\n\
    \        val c22 = conMap.get('x')\n        val c23 = conMap.get('y')\n      \
    \  val c24 = conMap.get('z')\n        val c25 = conMap.get('a')\n        val c26\
    \ = conMap.get('b')\n        val c27 = conMap.get('c')\n        val c28 = conMap.get('d')\n\
    \        val c29 = conMap.get('e')\n        val c30 = conMap.get('f')\n      \
    \  val c31 = conMap.get('g')\n        val c32 = conMap.get('h')\n        val c33\
    \ = conMap.get('i')\n        val c34 = conMap.get('j')\n        val c35 = conMap.get('k')\n\
    \        val c36 = conMap.get('l')\n        val c37 = conMap.get('m')\n      \
    \  val c38 = conMap.get('n')\n        val c39 = conMap.get('o')\n        val c40\
    \ = conMap\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90hrzvoe.scala:19:56 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m,\e[35mInt\e[0m] = word.map(\e[36mx\e[0m => (x.toLowerCase\
    \ , \e[31m1\e[0m)).toMap\n\e[31m\e[31m   |\e[0m                              \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toLowerCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp90hrzvoe.scala:26:54 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mconMap\e[0m : \e[35mMap\e[0m[\e\
    [35mChar\e[0m,\e[35mInt\e[0m] = word.map(\e[36mx\e[0m => (x.toLowerCase , \e[31m1\e\
    [0m)).toMap\n\e[31m\e[31m   |\e[0m                                           \
    \         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toLowerCase is not a member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp90hrzvoe.scala:67:5 ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    // two consonants from the right side of the word (case\
    \ sensitive).\n    // Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    // find any vowel met the above condition. \n\
    \    // You may assume that the given string contains English letter only.\n \
    \   // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n  \
    \  // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"\
    quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n\
    \    def getClosestVowel(word : String) : String = {\n        var vowel = word.tail.charAt(word.tail.length-1).toChar\n\
    \        var consonant = word.charAt(word.length-1)\n\n        var firstVowelFound\
    \ = false \n        var secondVowelFound = false\n\n        var vowelsIndex =\
    \ 0\n        var vowelsCount = word.length\n\n        var consonantsIndex = 0\n\
    \        var consonantsCount = word.length\n\n        var minimumVowelIndex =\
    \ 0\n        var minimumVowelCount = 0\n\n        word.lastIndexWhile((letter)\
    \ =>{\n            if(letter ==='a'){\n                if(firstVowelFound){\n\
    \                    firstVowelFound = false\n                    return false\n\
    \                }else{\n                    vowelsIndex++\n                 \
    \   vowelsCount--\n                    vowel = word.substring(vowelsIndex,vowelsCount).toChar\n\
    \                    vowelsCount -= vowel.length\n                    vowelsIndex\
    \ += vowel.length\n                    return true\n                }\n      \
    \      }else if(letter ==='e'){\n                if(secondVowelFound){\n     \
    \               secondVowelFound = false\n                    return false\n \
    \               }else{\n                    vowelsIndex++\n                  \
    \  vowelsCount--\n                    vowel = word.substring(vowelsIndex,vowelsCount).toChar\n\
    \                    vowelsCount -= vowel.length\n                    vowelsIndex\
    \ += vowel.length\n                    return true\n                }\n      \
    \      }else if(letter ==='i'){\n                consonantsIndex++\n         \
    \       consonantsCount--\n                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \                consonantsCount -= consonant.length\n                consonantsIndex\
    \ += consonant.length\n                return true\n            }else if(letter\
    \ ==='o'){\n                consonantsIndex++\n                consonantsCount--\n\
    \                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \                consonantsCount -= consonant.length\n                consonantsIndex\
    \ += consonant.length\n                return true\n            }else if(letter\
    \ ==='u'){\n                consonantsIndex++\n                consonantsCount--\n\
    \                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \                consonantsCount -= consonant.length\n                consonantsIndex\
    \ += consonant.length\n                return true\n            }else if(letter\
    \ ==='y'){\n                consonantsIndex++\n                consonantsCount--\n\
    \                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \                consonantsCount -= consonant.length\n                consonantsIndex\
    \ += con\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"\
    yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"\
    u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"\
    most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\"\
    )));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"\
    i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"\
    Above\")).equals((\"o\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvmytlyq7.scala:42:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    vowel = word.substring(vowelsIndex,vowelsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvmytlyq7.scala:54:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m                    vowel = word.substring(vowelsIndex,vowelsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvmytlyq7.scala:62:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m62 |\e[0m                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvmytlyq7.scala:69:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m69 |\e[0m                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvmytlyq7.scala:76:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m76 |\e[0m                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvmytlyq7.scala:83:26 -----------------------------------------\e[0m\e\
    [0m\n\e[31m83 |\e[0m                consonant = word.substring(consonantsIndex,consonantsCount).toChar\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   end of statement expected but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpvmytlyq7.scala:104:0 ---------------------------\e[0m\e\
    [0m\n\e[31m104 |\e[0m\n\e[31m\e"
  stdout: ''
  timestamp: 1660009903
