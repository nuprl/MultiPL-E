name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> makeAPile((3l))\n    // (List[Long](3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // your code goes here\n        val l = n / 2\n        if (n\
    \ % 2 == 0) {\n            l + 1\n        }\n        else {\n            l + 1\n\
    \        }", "      var result : MutableList[Long] = mutable.ArrayBuffer.empty\n\
    \      if (n.isEven) {\n        var i : Long = 0\n        while ((i + 1) < n)\
    \ {\n          result = result :+ (i + 1.toLong)\n          i = i + 1\n      \
    \  }\n      }\n      else {\n        var i : Long = n.toLong\n        while ((i\
    \ + 1) < n) {\n          result = result :+ ((i + 1).toLong)\n          i = i\
    \ + 2\n        }\n      }\n      result.toList", "        val n = math.abs(n)\n\
    \        val even = (n+1)/2\n        val odd = n+1\n        val next = if (n %\
    \ 2) odd else even\n        List(next to next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next next next next next next next next next next next next next\
    \ next next next next ", "        require(n.toInt % 2 == 0, \"makeAPile should\
    \ make an even pile of stones.\")\n        val r = n.toInt / 2\n        val result\
    \ = r + 1 to r + 2\n        if (n != 1) { result.append (n to (n + r.toInt)) }\n\
    \        result.toList.sortBy { it.toInt }", "        var levels = List[Long]()\n\
    \        var odd = 1l\n        var even = 1l\n        for (i<-ln(n); i<=n; i+=2)\
    \ {\n            if (n%2 == 0) {\n                even += 1l\n            } else\
    \ {\n                odd += 1l\n            }\n            levels = levels :+\
    \ even\n        }\n        levels = levels :+ odd\n        levels", "        //\
    \ Initialize an empty list to hold our return value\n        val returnValue =\
    \ mutable.MutableList[Long]()\n        // Get the next level of stones according\
    \ to the problem definition\n        val nextLevel = nextLevelOfStones(n)\n  \
    \      // Loop through each level\n        for (level <- nextLevel) {\n      \
    \      // Add the number of stones to the return list\n            returnValue\
    \ += level + 1\n        }\n        // Return the list\n        returnValue.toList",
  "      var counter = n\n      val result = new mutable.ArrayList[Long]()\n     \
    \ while (counter > 0) {\n        if (counter % 2 != 0) {\n          result.add(counter)\n\
    \        }\n        counter = counter / 2\n      }\n      result.toList", "  \
    \      if(n.toString.charAt(0).toInt == 1) {\n            List(n.toString.toLong)\n\
    \        } else {\n            val evens = if(n.toString.charAt(0).toInt == 0)\
    \ n.toString.toLong else n.toString.toLong / (2l.toLong * 2l.toLong)\n       \
    \     val odds = n.toString.toLong / 2l.toLong\n            evens.filter(_ % 2\
    \ == 0).reverse ++ odds.filter(_ % 2 == 1)\n        }", "      var pile = List(1l)\n\
    \      val x = n / 2l\n      val isEven = n % 2l == 0l\n      if (x % 2l == 0l)\
    \ {\n        for (i <- 1l to x by 2l) {\n          pile = if (isEven) pile.head\
    \ + i.toLong else pile.head - i.toLong\n        }\n      } else for (i <- 1l to\
    \ x by 2l) {\n        pile = if (isEven) pile.head - i.toLong else pile.head +\
    \ i.toLong\n      }\n      pile", "        val pile : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        for ( i <- 0 to n )\n            pile\
    \ += (i+2)\n        if (n % 2 == 0)\n            pile += (n / 2+1)\n        else\n\
    \            pile += (n / 2)\n        return pile.toList", "        val ones =\
    \ n.toList.map(_.toLong)\n        val odd = ones.drop(2).filter(_ % 2 != 0).toList\n\
    \        val even = ones.drop(2).filter(_ % 2 == 0).toList\n        odd + even",
  "        val ns = ListBuffer(n); var n = 0\n        while (n < ns.size) {\n    \
    \        var n2 = n(n); n2 = if (n2.isEven) n2.nextEven else n2.nextOdd\n    \
    \        n2 = (n2-1) rem 2 match {\n                case 0 => n(n2)\n        \
    \        case 1 => n(n2)+1\n                case _ => n(n2)+1\n            }\n\
    \            ns = ns :+ n2\n            n += 1\n        }\n        ns.toList",
  "        var i = n.toLong\n        var list = (0 until n).toList\n        var total\
    \ = 0L\n        while (n > 0) {\n            total += i\n            i += (i%2\
    \ == 0) ? 2L : 1L\n            n -= 1\n            list = list :+ total\n    \
    \    }\n        list", "        def isEven(n: Int) : Boolean = {\n           \
    \ (n: Int) % 2 == 0\n        }\n        def isOdd(n: Int) : Boolean = {\n    \
    \        (n: Int) % 2 != 0\n        }\n        def getNextLevel(n: Long): Long\
    \ = {\n            val isOddNextLevel = isOdd(n)\n            val isEvenNextLevel\
    \ = isEven(n)\n            if (isOddNextLevel) {\n                (n: Long) +\
    \ 1\n            } else {\n                (n: Long)\n            }\n        }\n\
    \        val level = n.toInt\n        val stones = mutable.ListBuffer[Long](level.toLong)\n\
    \        stones += level.toLong\n        for (i <- 1 to level.toInt) {\n     \
    \       stones += getNextLevel(i)\n        }\n        stones", "        def makeAPile_aux(n:\
    \ Long, prev : List[Long], pile : List[Long]) : List[Long] = {\n            if\
    \ (n <= 0) pile\n            else {\n                if (n % 2 == 0) makeAPile_aux(n/2,\
    \ prev + n.toLong, pile :+ n.toLong)\n                else makeAPile_aux(n.toLong,\
    \ prev + n.toLong, pile :+ n.toLong)\n            }\n        }\n\n        val\
    \ prev: List[Long] = List.empty[Long]\n        makeAPile_aux(n, prev, pile :+\
    \ n.toLong)", "        val pile = mutable.ListBuffer.empty[Long]\n        for\
    \ (i <- 1 to n) {\n            pile.append(i + 1)\n        }\n        pile.toList",
  "        val stones = n.toInt\n        val odd = stones % 2\n        val even =\
    \ stones.toInt\n        val nextLevel: List[Long] = if (odd) List(odd, even) else\
    \ List(even, odd)\n        List(stones - nextLevel.size, nextLevel)", "      \
    \  val result = new mutable.MutableList[Long]\n        if (n.toLong % 2 == 1)\
    \ result.add(n.toLong)\n        else result.add(n.toLong + 2l.toLong)\n      \
    \  result.map(_.toLong / 2l.toLong).zip(result).map( _.sum )", "        if (n\
    \ == 0L) Nil\n        else {\n            val oddNum = n / 2l.toLong\n       \
    \     val evenNum = n - oddNum\n            oddNum :: makeAPile(oddNum)\n    \
    \        evenNum :: makeAPile(evenNum)\n        }", "        var i = 0\n     \
    \   val stones: List[Long] = List(n)\n        val oddNumbers = 0 until stones.size\
    \ by 2\n        val evenNumbers = stones.size until (stones.size by 2) by 2\n\
    \        oddNumbers.foreach { x => stones.insert(x, stones(x+1)) }\n        evenNumbers.foreach\
    \ { x => stones.insert(x, stones(x+1)) }\n        stones", "        val list =\
    \ mutable.ArrayBuffer.empty[Long]\n        var count = 0\n        while (n > 0)\
    \ {\n            count += n % 2 == 0 ? (n % 2 != 0 ? 2 : 1) : (n % 2 == 0 ? 2\
    \ : 0)\n            n /= 2\n        }\n        list += count\n        list.reverse",
  "        def makeAPileHelper(n:Long, currentStones:List[Long]) :List[Long] = {\n\
    \            if (n == 0)\n                return currentStones\n            else\
    \ if (n % 2 == 0)\n                makeAPileHelper(n / 2, currentStones :+ n.toLong)\n\
    \            else\n                makeAPileHelper(n / 2, currentStones :+ n.toLong\
    \ * 2)\n        }\n        makeAPileHelper(n, Nil)", "      val pile : mutable.MutableList[Long]\
    \ = mutable.MutableList(n.toLong);\n      if(n.toLong % 2 == 0) pile.add(1l);\
    \ else pile.add(2l);\n      pile.takeWhile(_ <= n).toList", "        val levels\
    \ = List.fill(n.toLong)((1 to n).toList).map(_ + 1).distinct\n        (0 to (levels.length\
    \ - 1).toList).map{ _ => levels.last.sum }", "        var i = 2\n        var stones\
    \ = 0\n        while(i <= n){\n            if(n % i == 0){\n                stones\
    \ += i\n            }\n            i += 2\n        }\n        stones += n\n  \
    \      return stones.toList.map { _ => stones }", "        val p = n.toInt\n \
    \       val evenP = (p + p.toInt) / 2\n        val oddP = p / 2\n        val evenPList\
    \ = (1l, 3l, 5l, 7l, 9l, 11l, 13l, 15l).map(_ * p)\n        val oddPList = (1l,\
    \ 3l, 5l, 7l, 9l, 11l, 13l, 15l).map(_ / 2 * p)\n        (evenPList :+ oddPList).flatten.toList",
  "        val pile = mutable.ListBuffer[Long]()\n        var i : Long = 1\n     \
    \   while (i <= n) {\n            if (n % 2 == 0) {\n                pile.append(n)\n\
    \            } else {\n                pile.append(n + 1)\n            }\n   \
    \         i += 1\n        }\n        pile", "        val levels = mutable.ListBuffer(n.toLong);\n\
    \        var currLevel = levels(0)\n        while (n>0) {\n            val nextLevel\
    \ = if (n%2==0) 2*currLevel+1 else 2*currLevel-1\n            levels += nextLevel\n\
    \            currLevel = nextLevel\n            n -= 1\n        }\n        levels.toList",
  "        (\n            n match {\n                case 0 | 1 => List()\n      \
    \          case _ => List(1L, n-1L, 2L)\n            }\n        ).reverse.foldLeft(List[Long]())\
    \ { case (acc, i) =>\n            (\n                (i + 1L) match {\n      \
    \              case 0 | 1 => acc\n                    case _ => acc + n\n    \
    \            }\n            )\n        }", "        // Odd n\n        if (n %\
    \ (2l).toLong > 0l) {\n            List.fill(2l)(n % (2l).toLong).toList\n   \
    \     } else {\n            // Even\n            List.fill(n)(2l).toList\n   \
    \     }", "        n match {\n            case _ if n==1 => List(1l)\n       \
    \     case _ if n==0 => List()\n            case n if n%2 == 0 => (makeAPile(n/2)\
    \ ++ List(1l)).toList\n            case n if n%2 == 1 => (makeAPile(n/2) ++ List(1l,\
    \ 0l)).toList\n            case _   => (makeAPile(n-1)++ makeAPile(n/2)).toList\n\
    \        }", "        var nextLevel = n.toInt\n        if (nextLevel % 2 == 0)\
    \ nextLevel = nextLevel + 1 // next odd number\n        else nextLevel = nextLevel\
    \ + 2 // next even number\n        if (n < 0) nextLevel = nextLevel - 1 // next\
    \ odd number\n        nextLevel :: makeAPile(nextLevel) // next level, each element\
    \ is list for next level", "        require(n >= 1, \"n must be >= 1\")\n    \
    \    val nextOdd = (n + 1) / 2\n        val nextEven = (2 * n) / 2\n        (1\
    \ until n).map { i =>\n            if (i % 2 == 0) nextEven.toLong\n         \
    \   else nextOdd.toLong\n        }.toList", "      val ans = mutable.MutableList[Long]()\n\
    \      if (n % 2 == 0)\n        ans += n.toLong\n      else if (n % 2 == 1)\n\
    \        ans += (n - 2).toLong\n      else\n        ans += (n - 3).toLong\n  \
    \    ans.toList", "        // Add code here\n        def oddOrEven(n: Long): Long\
    \ = if (n & 1 == 0) (n + 1) else ((n + 1) + (n % 2 == 0 ? 1 : 0))\n        val\
    \ stones = 1 to n\n            .map(_ => List(oddOrEven(n)))\n            .reduceLeft(_\
    \ ++ _)\n            .reverse\n            .flatten\n\n        // Add code here\n\
    \        return stones", "       val odd = n % 2 == 0\n       val even = n % 2\
    \ != 0\n\n       if (n == 1) 1l else odd.toLong :: makeAPile(n / 2l.toLong)",
  "        if (n == 0L)\n            (1l.toLong)\n        else\n            makeAPile(n/2)\
    \ ++ makeAPile(n-(n%2).toLong)", "        val r = ListBuffer.empty[Long]\n   \
    \     if (n<2) r.append(n)\n        else {\n            val (nextEven, nextOdd)\
    \ = n / 2\n            r.add(nextEven.toLong)\n            val n = n - nextEven\
    \ - nextOdd\n            val nextEven2 = nextEven.next\n            val nextOdd2\
    \ = nextOdd.next\n            val nextEven3 = nextEven2.next\n            val\
    \ nextOdd3 = nextOdd2.next\n            r.add(nextEven3.toLong)\n            r.add(nextOdd3.toLong)\n\
    \            val n = n - nextEven3 - nextOdd3\n            val nextEven4 = nextEven3.next\n\
    \            val nextOdd4 = nextOdd3.next\n            val nextEven5 = nextEven4.next\n\
    \            val nextOdd5 = nextOdd4.next\n            r.add(nextEven5.toLong)\n\
    \            r.add(nextOdd5.toLong)\n            val n = n - nextEven5 - nextOdd5\n\
    \            val nextEven6 = nextEven5.next\n            val nextOdd6 = nextOdd5.next\n\
    \            val nextEven7 = nextEven6.next\n            val nextOdd7 = nextOdd6.next\n\
    \            r.add(nextEven7.toLong)\n            r.add(nextOdd7.toLong)\n   \
    \         val n = n - nextEven7 - nextOdd7\n        }\n        r", "        val\
    \ ls = ListBuffer.empty[Long]\n        val count = n.toInt\n        // if the\
    \ count is even, add 1 to the odd count\n        if(count%2==0)\n            ls\
    \ += count\n        else\n            // if the count is odd, add 1 to the even\
    \ count\n            count += count/2\n        // add the even count to the level\n\
    \        ls ++= (count-1).toLong\n        // return the level\n        ls.toList",
  "        val stones = ListBuffer(n)\n        val nextLevel = if (n % 2 == 0) stones\
    \ else stones.tail\n\n        (nextLevel ::: (0 until stones.size)-1) foreach\
    \ {\n            case 0 => stones ++= nextLevel\n            case _ => nextLevel\
    \ ++ stones.tail\n        }\n\n        nextLevel.toList", "        if (n < 2l)\
    \ List(2l.toLong)\n        else if (n % 2l == 0l) List(3l.toLong)\n        else\
    \ List(1l.toLong, 5l.toLong, 7l.toLong)", "        val levels = n / 2\n      \
    \  n match {\n            case n if n % 2 == 0 => (levels, levels, levels)\n \
    \           case n if n % 2 == 1 => (levels + 1, levels, levels)\n           \
    \ case n => (levels + 2, levels, levels)\n        }", "      if (n==0l) return\
    \ Nil\n      if (n%2==1l) return (n :: makeAPile(n/2l) :: makeAPile(n%2l))\n \
    \     else return (n :: makeAPile(n/3l) :: makeAPile(n/3l-1) :: makeAPile(n%2l))",
  "        var stones = n.toInt\n        var level = List[Long]()\n        while (n>0){\n\
    \            var n = stones\n            var i = n.toInt\n            if (n mod\
    \ 2 == 1){\n                level = level:+ n.toLong\n                n -= 2\n\
    \            } else {\n                level = level:+ n.toLong\n            \
    \    n -= i\n            }\n            stones = n\n        }\n        return\
    \ level", "        if (n < 2) 1l :: Nil\n        else makeAPile(n - 2l) ::\n \
    \           (if (n % 2l == 0l) 2l.toLong else 1l.toLong :: makeAPile(n - 1l))",
  "        val num: Long = n / 2\n        if (n % 2 == 0)\n            return List(num.toLong\
    \ + num.toLong)\n        else\n            return List(num.toLong + num.toLong,\
    \ num.toLong)", "        val arr = new Array[Long](n)\n        if (n%2==1)\n \
    \           arr.apply(arr.length-1) = (n-1).toLong\n        else\n           \
    \ arr.apply(arr.length-1) = ((n+n+1).toLong/2).toLong\n        arr.apply(arr.length-1)",
  "        if (n<0) throw new IllegalArgumentException(\"Negative numbers are not\
    \ allowed\")\n        val list = new ArrayList[Long]\n        val counter = math.ceil(math.log10(n)).toInt\n\
    \        val listOfNumbers = n.toInt/math.pow(10, counter).toInt\n        val\
    \ oddEven = if (counter%2==0) \"even\" else \"odd\"\n        for (i<-listOfNumbers.toInt;i<listOfNumbers.toInt;i+=2)\
    \ {\n            if (i==listOfNumbers.toInt)\n                list.add(n.toLong)\n\
    \            else {\n                list.add(n.toLong + math.pow(10, counter).toLong*i)\n\
    \            }\n        }\n        list.tail", "        val pile : mutable.Stack[Long]\
    \ = mutable.Stack()\n        val nextPile = if ( n & 0x000001 ) pile.push(n.toLong+2)\
    \ else pile.push(n.toLong)\n        pile.foreach { x =>\n                pile.foreach(y\
    \ => nextPile.foreach(z => if ( x == y ) pile.push(z.toLong) else nextPile.foreach(x\
    \ => pile.push(x))))\n        }\n        return pile.toList", "        if (n ==\
    \ 0) Nil\n        else {\n            // Find the next even number.\n        \
    \    var nextEven = n / 2\n            if (n % 2 == 0) nextEven = nextEven * 2\n\
    \n            // Find the next odd number.\n            var nextOdd = n - nextEven\n\
    \            if (nextEven > nextOdd) nextEven = nextEven + 1\n            nextOdd\
    \ = nextOdd * 2\n\n            List(nextEven.toLong, nextOdd.toLong)\n       \
    \ }", "        if(n<1l) Nil\n        else if(n.toInt==n) List(n.toLong)\n    \
    \    else {\n            var stoneList = makeAPile(n.toInt+1)\n            var\
    \ odd = 0l\n            var even = 0l\n            var oddVal = 0\n          \
    \  var evenVal = 0\n            stoneList.foreach(x => \n            {\n     \
    \           val isEven = x.toInt == evenVal\n                val isOdd = x.toInt\
    \ == oddVal\n                if(isOdd && isEven) {\n                    odd +=\
    \ 1\n                    evenVal += 1\n                } else if(isOdd) {\n  \
    \                  odd += 1\n                    oddVal += 1\n               \
    \ } else if(isEven) {\n                    even += 1\n                    evenVal\
    \ += 1\n                } else {\n                    odd += 1\n             \
    \   }\n            })\n            stoneList.insert(0, odd)\n            stoneList.insert(0,\
    \ even)\n        }", "        val pile = new mutable.LinkedList[Long]\n      \
    \  val newPile = new mutable.LinkedList[Long]\n        for (i <- 0 until n){\n\
    \            if (i%2 == 0){\n                newPile.push(n - (i+1))\n       \
    \     } else {\n                newPile.push((i + 1))\n            }\n       \
    \ }\n        pile.pushAll(newPile)\n        return pile", "        def makeLevels(n\
    \ : Long) : List[Long] = {\n            val n2 = math.ceil(n/2.0).toInt\n    \
    \        if(n % 2 == 0) n2.toLong else (5l*n2).toLong + (7l*(n2-1).toLong).toLong\n\
    \        }\n        val result = mutable.ListBuffer[Long]()\n        for(i <-\
    \ 0 to n-1) result += makeLevels(i)\n        result.toList", "        val nLevels\
    \ = n.toInt\n        var ret: List[Long] = List()\n        var nextLevel = 0\n\
    \        var nextLevelSum = 0\n        // Keep adding levels of stones\n     \
    \   for (i <- 0 until nLevels) {\n            if (nextLevel == 0) {\n        \
    \        nextLevelSum = n\n            } else {\n                nextLevel = nextLevel\
    \ % 2 == 0\n                nextLevelSum = nextLevelSum + (nextLevel ? n.toLong\
    \ : (n.toLong + 1).toLong)\n            }\n            ret = ret :+ nextLevelSum\n\
    \        }\n        ret", "        val li = 1 to n\n        .map(i => i.toLong)\n\
    \        .filter(_ % 2 == 1)\n        .map(_ + 2 * _)\n        .toList\n     \
    \   .reverse\n\n        (0 to (n-1))\n        .map(i => li.take(i))", "      \
    \  var stones = n.toLong\n        var levels = List[Long]()\n        val evens\
    \ = stones.toInt\n        val odds = evens >>> 1\n        levels :+= stones.toLong\n\
    \        while ( stones > 0 ) {\n            stones -= evens\n            levels\
    \ :+= evens.toLong\n            stones -= odds\n            levels :+= odds.toLong\n\
    \        }\n        levels", "        n match {\n            case 0 => Nil\n \
    \           case 1 => List(1)\n            case _ =>\n                var l =\
    \ n.toLong - 2\n                val evens = n.toLong / 2\n                val\
    \ odds = l / 2\n                l match {\n                    case 1 => List(1)\n\
    \                    case _ => List(odds + evens)\n                }\n       \
    \ }", "        var result : List[Long] = List()\n        if(n.toInt % 2 == 0)\
    \ result = result :+ ((n.toInt/2).toLong)\n        else if(n.toInt % 2 == 1) result\
    \ = result :+ ((n.toInt/2).toLong + 1)\n        result", "        var result =\
    \ ListBuffer[Long]()\n        var currentLevel = ListBuffer[Long](n+1);\n    \
    \    var maxLevel = n.toLong\n        var isEven = false\n        while (currentLevel.nonEmpty\
    \ || maxLevel > 0) {\n            if (maxLevel > 0) {\n                var maxLevelToMake\
    \ = Math.min(currentLevel.head.toLong + 2, maxLevel.toLong)\n                currentLevel\
    \ += (maxLevelToMake-1)\n                maxLevel -= maxLevelToMake\n        \
    \        if (currentLevel.nonEmpty && maxLevel > 0) {\n                    if\
    \ (isEven) {\n                        currentLevel.clear()\n                 \
    \       maxLevel = 0\n                    } else {\n                        currentLevel.clear()\n\
    \                        isEven = !isEven\n                    }\n           \
    \     }\n            }\n            result += currentLevel\n        }\n      \
    \  result .toList", "        val odds = n.toInt % 2\n        val evens = n.toInt\
    \ / 2\n        odds match {\n            case 0 => List(n.toLong)\n          \
    \  case 1 => List(odds, evens)\n            case _ =>\n                List(odds).init\
    \ ++ makeAPile(evens)\n        }", "        var ans = List[Long]()\n        var\
    \ level = n\n        while (level > 1) {\n            var nLevel = (level % 2\
    \ == 0) ? level : (level + 1)\n            ans ::= nLevel.toLong\n           \
    \ level = nLevel\n        }\n        ans ::= level.toLong\n        ans", "   \
    \   val (evenOdd, nextOdd) = n match {\n        case x if x % 2 == 0 => (x to\
    \ x, x to x + 1)\n        case x if x % 2 == 1 => (x to x, x to x + 1)\n     \
    \   case x => throw new IllegalArgumentException(\"n must be an odd number\")\n\
    \      }\n      (0 until n).map(_.toLong).map(n => nextOdd(n) + evenOdd(n)).flatten.toList",
  "        // Make new list of length n + 1 \n        val newList = mutable.ArrayBuffer.empty[Long]()\n\
    \        // Add first n+1 elements in list\n        newList += n \n        //\
    \ Add last even number if n is odd\n        newList += if (n & 0x1) == 1 \n  \
    \          0x10000l\n        else\n            (n-1)\n        // Add last odd\
    \ number if n is even\n        newList += if (n & 0x1) == 0 \n            0x100000l\n\
    \        else\n            (n-1)\n        newList.toList", "        val numLevelsN\
    \ = (n / 2).toInt\n        val evenLevel = (n / 2).toInt\n        val oddLevel\
    \ = n / 2\n        val level = List(oddLevel.toLong)\n        for (i <- 1 to numLevelsN)\
    \ {\n            level :+= (i + 2)\n        }\n        if (n % 2 == 0) {\n   \
    \         level :+= evenLevel.toLong\n        }\n        return level", "    \
    \    var counts = List.fill(n.toLong+1) {0l}\n        for (i <- 0 until n by 2)\
    \ {\n            if (n.toInt % 2 == 0) {\n                counts(i) = counts(i)\
    \ + 2\n            } else {\n                counts(i) = counts(i) + 1\n     \
    \       }\n        }\n        counts", "        if (n == 1l) List(n+1l)\n    \
    \    else {\n            def isEven(x: Long) = x % 2 == 0\n            def isOdd(x:\
    \ Long) = !isEven(x)\n            def makeAPile_aux(n: Long, odd: Long, even:\
    \ Long) : List[Long] = {\n                if (n <= 0) List(0)\n              \
    \  else if (isEven(n)) List(even)\n                else if (isOdd(n)) List(odd)\n\
    \                else makeAPile_aux(n-1, odd, even+even)\n            }\n    \
    \        makeAPile_aux(n,0l,1l)\n        }", "        val nums = mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to n){\n            if(n % 2 == 0)\n                nums +=\
    \ (i + (if (n % 2 == 0) 1 else 1))\n            else\n                nums +=\
    \ (i + (if (n % 2 == 1) 0 else 1))\n        }\n        nums.toList", "       \
    \ val next = (n + 1) % 2\n        val level1 = if (next) (n + 2) else n\n    \
    \    val level2 = next + n / 2\n        val level3 = next + (next + n) / 2\n \
    \       List(level1.toLong, level2.toLong, level3.toLong)", "        val n = n.toLong\n\
    \        if(n <= 1) Nil\n        else (math.floor(n/2)*2l).map(x => if(n % 2 ==\
    \ 0) x+1l else x+1l)", "        val numList = List(n)\n        var index = 1\n\
    \        var nextNum: Long = 1\n        while(index <= numList.length)\n     \
    \   {\n            if(index % 2 == 1)\n            {\n                nextNum\
    \ = numList((index + 1).toLong)\n                numList.updated(index.toLong,\
    \ nextNum.toLong)\n            }\n            else\n            {\n          \
    \      nextNum = numList((index - 1).toLong)\n                numList.updated(index.toLong,\
    \ nextNum.toLong)\n            }\n            index += 1\n        }\n        numList",
  "        val list = (1 to (n/2) map (n => (n+1L) mod 2 match {\n            case\
    \ 0 => n+1L\n            case 1 => n+1L\n            case 2 => n+1L\n        \
    \    case _ => n+1L\n        })).toList\n        (1 to (n/2) map (n => list.lastOption).getOrElse(n+1L).toLong)",
  "        if (n == 0) {\n            List.empty\n        } else if (n % 2 == 0) {\n\
    \            (List.fill(n / 2)(n / 2l.toLong) + makeAPile(n / 2)).toList\n   \
    \     } else {\n            (List.fill(n)(n / 2l.toLong) + makeAPile(n)).toList\n\
    \        }", "        n match {\n            case 0    => (0l :: Nil)\n      \
    \      case _    => makeAPile(n / 2)\n            case _ if n mod 2 == 0 => (n\
    \ / 2 :: makeAPile(n / 2))\n            case _    => makeAPile(n / 2) ++ makeAPile(n\
    \ / 2)\n        }", "        if (n == 0) List(1l.toLong)\n        else {\n   \
    \         val nextLevel = if (n%2==0) n.toInt+1 else n.toInt\n            nextLevel.toLong\
    \ :: makeAPile(nextLevel)\n        }", "        if (n % 2 != 0) {\n          \
    \  List(n.toLong)\n        } else {\n            val p = n - 1\n            val\
    \ q = p / 2\n            val r = p % 2\n            val ans = List(p.toLong, q.toLong,\
    \ r.toLong)\n            (ans ++ makeAPile(q).map(x => x+ans.last))\n        }",
  "        n match {\n            case np if np % 2 == 0 => List(n.toLong)\n     \
    \       case np if np % 2 != 0 => makeAPile(np.toInt)\n            case _ => makeAPile(n.toInt\
    \ + 1)\n        }", "        var result : List[Long] = null\n        val arr:\
    \ mutable.MutableList[Long] = mutable.MutableList.empty\n        arr :+= n\n \
    \       result :+= arr.take(2).toList\n        result :+= arr.takeWhile(i => i\
    \ % 2 == 0).sum\n        result", "        var currentList: List[Long] = List()\n\
    \        val n2 = n.toLong\n        for(_ <- 0 until n2)\n        {\n        \
    \    var num = (math.min(n.toLong, (n2.toLong).toLong) / 2.0).toInt\n        \
    \    if((num.toLong % 2) == 0)\n            {\n                currentList +=\
    \ num.toLong\n            }\n            else\n            {\n               \
    \ currentList += num.toLong + num.toLong\n            }\n        }\n        return\
    \ currentList", "        val l = List.range(1l,n)\n        if(n.toInt % 2 == 0){\n\
    \            val odd = l.filter(_ % 2 == 1).size\n            val even = l.filter(_\
    \ % 2 == 0).size\n            List(odd,even)\n        }else{\n            val\
    \ odd = l.filter(_ % 2 == 0).size\n            val even = l.filter(_ % 2 == 1).size\n\
    \            List(odd,even)\n        }", "        if (n == 0l)\n            Nil\n\
    \        else {\n            var ans = n\n            var nextOdd = if (n % 2\
    \ == 1l) 2l else 1l\n            val nextEven = if (n % 2 == 0l) 2l else 1l\n\
    \            ans = List(n, nextOdd, nextEven)\n            ans ++ makeAPile(nextOdd)\
    \ ++ (nextEven : : List[Long]) ++ (makeAPile(nextEven) : List[Long])\n       \
    \ }", "        if(n % 2 == 1) {\n            List(n.toLong, n.toLong + 2)\n  \
    \      }\n        else {\n            List(n.toLong, n.toLong - 1, n.toLong -\
    \ 2)\n        }", "        var levels : List[Long] = Nil\n        if (n == 0)\n\
    \            levels = Nil\n        else {\n            if (n%2 == 0)\n       \
    \         levels = levels :+ n\n            else {\n                val odd =\
    \ n/2\n                val even = n%2\n                levels = levels :+ (odd+even)\n\
    \            }\n        }\n        levels", "        if (n <= 0) List.empty\n\
    \        else{\n            val first = n / 2\n            val nextOdd = (n/2)\
    \ +1\n            val nextEven = (n/2) +2\n            makeAPile(first) ++ makeAPile(nextOdd)\
    \ ++ makeAPile(nextEven)\n        }", "        if (n <= 0) List.empty\n      \
    \  else if (n % 2 == 0) makeAPile(n / 2) ::: makeAPile(n / 2) ::: makeAPile(n\
    \ / 2) ::: List.empty\n        else makeAPile(n / 2) ::: makeAPile(n / 2) :::\
    \ makeAPile(n / 2) ::: List.empty", "        def oddEvenToList(n: Long) : List[Long]\
    \ = {\n            n match {\n                case n if n % 2 != 0 => n.toLong::oddEvenToList(n.toInt).reverse\n\
    \                case n if n % 2 == 0 => n.toInt::oddEvenToList(n.toLong).reverse\n\
    \                case _ => throw new IllegalArgumentException(s\"${n} is not a\
    \ positive integer\")\n            }\n        }\n        oddEvenToList(n)", " \
    \       val ans = ListBuffer.empty[Long]\n        var even = 0\n        var odd\
    \ = 0\n        var n1 = n\n\n        while(n > 0) {\n            n1 -= 1\n   \
    \         even = even + 1\n            odd = odd + n1 % 2 match {\n          \
    \      case 1 => odd\n                case 0 => even\n            }\n        \
    \    ans :+= n1.toLong\n            n -= 1\n        }\n\n        ans", "     \
    \   require(n >= 0l)\n        require(n % 2 == 0)\n        require(n > 0)\n\n\
    \        // Get odd number or even number\n        val odd = if (n % 2 == 0) n\
    \ / 2l else n * 3l\n\n        // make pile\n        val count = mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until n) {\n            if (i == 0 || i % 2 == 0) {\n   \
    \             count += odd.toLong\n            } else {\n                count\
    \ += even.toLong\n            }\n        }\n        count.toList", "        //\
    \ Write your code here\n        if (n <= 0) Nil\n        else if ((n & 1) == 0)\
    \ (n to 1l) map (makeAPile _) else (2 to n toList) map (makeAPile _)", "     \
    \   if (n < (1l) ) List(n.toLong)\n        if (n < (2l) ) List(1l, n.toLong)\n\
    \        if (n < (3l) ) List(3l, n.toLong)\n        if (n < (4l) ) List(4l, n.toLong)\n\
    \        if (n < (5l) ) List(6l, 7l, n.toLong)\n        if (n < (6l) ) List(5l,\
    \ 7l, n.toLong)\n        if (n < (7l) ) List(4l, 5l, n.toLong)\n        if (n\
    \ < (8l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (9l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (10l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (11l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (12l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (13l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (14l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (15l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (16l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (17l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (18l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (19l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (20l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (21l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (22l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (23l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (24l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (25l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (26l) ) List(3l, 6l, 7l, n.toLong)\n        if (n < (27l) ) List(3l, 6l, 7l,\
    \ n.toLong)\n        if (n < (28l) ) List(3l, 6l, 7l, n.toLong)\n        if (n\
    \ < (29", "        var lst = new List[Long]()\n        if(n % 2 == 0){\n     \
    \       lst += n.toLong\n        } else {\n            val next = math.ceil(math.pow(n,\
    \ 0.5)).toLong\n            var lst1 = makeAPile(next)\n            lst1 = lst1.dropRight(1).append(lst1.drop(1))\n\
    \            lst = lst1.reverse\n        }\n        lst.reverse", "        val\
    \ levelList = List.range(n + 1).toList\n        val isEven = (n+1)%2 == 0\n  \
    \      val nextOdd = isEven ? 2l  : 1l\n        val nextEven = isEven ? 1l  :\
    \ 1l\n        levelList :+ nextOdd.toLong :+ nextEven.toLong", "        def makeAPile(n\
    \ : Long, levels : List[Long]) : List[Long] = {\n            if(n < 0) levels\n\
    \            else if(n % 2 == 0) makeAPile(n/2, levels :+ n+1)\n            else\
    \ makeAPile(n/2, levels :+ n/2)\n        }\n        makeAPile(n, Nil)", "    \
    \    val res : List[Long] = new ListBuffer[Long]\n        var level = 0\n    \
    \    while(n>0) {\n            res += level.toLong\n            level += 1\n \
    \           n -= (n % 2 == 0) ? 2 : 1 // n remainder is odd\n        }\n     \
    \   res.reverse.drop(1)", "        require(n >= 0)\n        require(n % 2 == 0)\n\
    \        require(n < Long.MaxValue) // avoid overflow\n        require(n >= 1)\n\
    \        val p = new mutable.LinkedHashMap[Long, List[Long]]()\n        var currentLevel\
    \ = n.toLong\n        while (currentLevel > 1) {\n            val nextLevel =\
    \ math.max(math.floor(currentLevel / 2), 2l).toLong\n            currentLevel\
    \ = nextLevel\n            p.put(currentLevel, p.getOrElse(currentLevel, Nil).head\
    \ :: p.getOrElse(currentLevel, Nil).tail)\n        }\n        p.get(currentLevel).toList",
  '      if(n%2 == 0) oddLevels(n) else evenLevels(n)', "        if (n == 0) List(1l)\n\
    \        else {\n            var currentLevel : List[Long] = List(n)\n       \
    \     var i : Long = 1\n\n            var oddEvenCount : Long = if (n % 2 == 0)\
    \ 1 else 0\n\n            while (i < n) {\n                val nextLevel = if\
    \ (oddEvenCount == 0) {\n                    i + (if (n % 2 == 0) 1 else 0)\n\
    \                } else {\n                    i + (if (n % 2 == 0) 1 else 0)\n\
    \                    + oddEvenCount\n                }\n\n                currentLevel\
    \ = List(nextLevel.toLong)\n                oddEvenCount = if (nextLevel % 2 ==\
    \ 0) 1 else 0\n                i = nextLevel + 1\n            }\n\n          \
    \  currentLevel\n        }", "        // base case\n        if (n <= 1L) {\n \
    \           List(1L)\n        } else {\n            // odd case\n            if\
    \ (n % 2L == 0L) {\n                makeAPile(n / 2L).toList :+ n / 2L.toLong\
    \ :: makeAPile(n / 2L)\n            } else {\n                // even case\n \
    \               makeAPile((n - 1L) / 2L).toList :+ (n - 1L) / 2L.toLong :: makeAPile((n\
    \ - 1L) / 2L)\n            }\n        }", "        var counterList = List[Long]()\n\
    \        for(i <- 0 to n by 2) {\n            counterList += i+1\n        }\n\
    \        return counterList", "        val rec = List.range(1,n+1).map(_ * 2l).toList\
    \ ::: List.range(1,n)\n        if (n % 2 == 0)\n            rec.dropRight(1).reverse.drop(1).map(_\
    \ + 1l).toList\n        else\n            rec.drop(1).reverse.drop(1).map(_ +\
    \ 1l).toList", "        val odd = n % 2 == 0\n        var result = (1 until n).toList\n\
    \        if (!odd) result = result :+ result.last * 2 + 1\n        result", " \
    \       val pile = mutable.MutableList[Long]()\n        val level = (n + 1L) /\
    \ 2\n        pile.add((n + 1L).toLong)\n        pile", "        val nums = List[Long]()\n\
    \        var count = 1\n        while ( count < n ) {\n            if ( (n % 2)\
    \ == 0 ) nums += count + 1\n            else                 nums += count\n \
    \           count += 1\n        }\n        nums", "        val res = ListBuffer[Long]()\n\
    \        n match {\n            case 0 =>\n                res.add(\"0\")\n  \
    \          case _ =>\n                if (n % 2 == 0)\n                    res.add((n.toLong\
    \ + 2).toLong)\n                else\n                    res.add((n.toLong +\
    \ 4).toLong)\n        }\n        res.toList", "        val result = (1 to n).filter\
    \ { n =>\n          n match {\n            case x if x % 2 == 0 => true\n    \
    \        case x => false\n          }\n        }.toList.map(x => (x + 1).toLong)\n\
    \        result", "        val ones = List.fill(n.toInt)(1l)\n        val odd\
    \ = ones\n            .dropRight(1)\n            .dropRight(1)\n            .dropRight(1)\n\
    \            .dropRight(1)\n            .dropRight(1)\n            .takeRight(n)\n\
    \            .map(_ + n.toLong)\n        val even = ones.dropRight(n).takeRight(n).toList\n\
    \        odd + even", "        if (n.toInt%2==0)\n            List(n.toInt)\n\
    \        else\n            n.toInt.toLong + makeAPile(n/2)", "        if (n <=\
    \ 0) {\n            List(0)\n        } else if (n % 2 == 0) {\n            List(n\
    \ * (n +1) / 2)\n        } else {\n            List(n * (n + 1) / 2)\n       \
    \ }", "        require(n % 2 != 0, s\"n is not odd\")\n        n match {\n   \
    \         case n if (n >= 2l) => (2l to n).toList\n            case n if (n >=\
    \ 3l) => (3l to n).toList\n            case n => (n+1l to n).toList\n        }",
  "        if((n%2) == 0) List(n.toLong+2l.toLong, n.toLong+3l.toLong, n.toLong+1l.toLong,\
    \ n.toLong+4l.toLong)\n        else List(n.toLong+2l.toLong, n.toLong+4l.toLong,\
    \ n.toLong+3l.toLong, n.toLong+1l.toLong)", "        var list: List[Long] = List();\n\
    \        if (n<=1) { list = n :: list; return list}\n        if (n%2 == 0) list\
    \ = n :: (makeAPile((n - 1l))) :: list;\n        else list = n :: (makeAPile(n\
    \ - 2l)) :: (makeAPile((n - 1l))) :: list;\n        return list", "        n match\
    \ {\n            case 0 => List(1l.toLong)\n            case 1 => List(1l.toLong)\n\
    \            case x if x < 2 => List(1l.toLong)\n            case x if x <= n\
    \ => makeAPile(x + 1l) ::: makeAPile(n - x+1l)\n        }", "        val n = n.toLong\n\
    \        var list = List[Long](n.toLong)\n        val odd = if(n % 2 == 0) n /\
    \ 2 else n / 2\n        val even = n / 2\n        list = list ++ List(List(odd,\
    \ even / 2), List(even / 2, even / 4))\n        list.map(l => l.tail.map(x =>\
    \ x + l.head))", "        if (n <= 0l) throw new IllegalArgumentException(\"Invalid\
    \ value for n: \" + n)\n        val stones = List(n)\n        val levels = stones.zipWithIndex.map\
    \ { case (stone, i) => makeAPile1(i, stone) }\n        levels.reduce(_.zipWithIndex.map\
    \ { case (_, index) => stones(index) })", "        val list = mutable.ListBuffer[Long]()\n\
    \        if(n % 2 == 0) list += n.toLong\n        else {\n            n -= 1\n\
    \            list += n.toLong\n            n -= 1\n            list += n.toLong\n\
    \            n -= 1\n        }\n        list.toList", "        val levels = if\
    \ (n % 2==1) List.fill(n.toDouble/2) else List.fill(n.toDouble/2+1) \n       \
    \ levels.map(n => (n,n+1)) ", "        val list = new mutable.MutableList[Long]()\n\
    \        if(n.toInt%2==0) {\n            list += n.toInt/2;\n        }\n     \
    \   n match {\n            case n if n.toInt % 2 != 0 => list += (n.toInt/2).toInt;\n\
    \            case n => list += n.toInt;\n        }\n        list", "        n\
    \ match {\n            case 0 => List()\n            case 1 => List(n.toLong)\n\
    \            case _ => {\n                val r = scala.util.Random\n        \
    \        val oddN = r.getInt(2) == 0\n                List(\n                \
    \    if (oddN) r.getInt(n).toLong + r.getInt(n + n).toLong\n                 \
    \   else r.getInt(n).toLong + r.getInt(n - 1).toLong,\n                    if\
    \ (oddN) r.getInt(n).toLong + r.getInt(n - 1).toLong\n                    else\
    \ r.getInt(n).toLong + r.getInt(n - 2).toLong\n                )\n           \
    \ }\n        }", "        val res : List[Long] = List();\n        if (n.toInt==0)\
    \ {\n            res\n        } else {\n            val odd_count = n.toInt;\n\
    \            val even_count = n.toInt;\n            val temp = (odd_count + even_count).toLong;\n\
    \            if (temp % 2==1)\n                temp.toLong + 1\n            else\n\
    \                temp.toLong\n        }", "        var nextEven = 1l\n       \
    \ var nextOdd = 1l\n        for(i <- 0 to n) {\n            if(i % 2 == 0) {\n\
    \                nextEven = nextEven * i\n            } else {\n             \
    \   nextOdd = nextOdd * i\n            }\n        }\n        List(nextEven.toLong,\
    \ nextOdd.toLong)", "        val result = (0 until n).toList\n        result.zipWithIndex.filter(_._1\
    \ % 2 == 1).map(_._2.toLong).reverse.toList", "        // Complete this method\n\
    \        val num : List[Long] = List(0l)\n        var numOfLevel = 0\n       \
    \ for(i <- 0 until n){\n            if(n % 2 == 0){\n                numOfLevel\
    \ += 1\n            }else{\n                numOfLevel += 2\n            }\n \
    \           num :+= numOfLevel\n        }\n        return num", "        if (n\
    \ == 1l) {\n            List(1l)\n        } else {\n            val odd = n.toLong.nextDouble.toInt\n\
    \            val even = n.toLong.nextDouble.toInt\n            val list = List(odd,\
    \ even)\n            list :+ list.last\n        }", "        var l: List[Long]\
    \ = List()\n        for (x <- 0 until n toList) {\n            var i = x\n   \
    \         if (x % 2 == 0) i += 2\n            l += List(i, i + 1, i + 2)\n   \
    \     }\n        l", "        var level : List[Long] = List(n);\n        while\
    \ (level.length < n) {\n            level += level.length\n        }\n       \
    \ var count : Long = 1;\n        while (level.length > 0) {\n            count\
    \ += level(level.length-1)\n            level.removeAt(level.length-1)\n     \
    \   }\n        List(n, count)", "        val p = n %2\n        if(p > 0) makeAPile(n\
    \ /2) + p else makeAPile(n /2) + 1", "        val stones = mutable.ListBuffer(n.toLong)\n\
    \        val oddEven = (n % 2 == 0).toLong\n        val lastEven = stones.last\n\
    \        stones += oddEven\n        if (n == lastEven) {\n            stones\n\
    \        } else {\n            stones.init :+ stones.last\n        }", "     \
    \ if (n <= 0l) List(0l)\n      else {\n        val odd = n % 2\n        val even\
    \ = n - odd\n        (if (odd) List(0l) else List(1l)) ::: makeAPile(even)\n \
    \     }", "        // 1st, 2nd, 3rd... level \n        var l : List[Long] = Nil\n\
    \        if(n%2 != 0) l = nl.init(n)\n        else l = nl.init(n+1)\n        //\
    \ 2nd, 4th, 6th... level \n        if(n%2 != 0) l = nl.init(n).toList.zip(l).toList\n\
    \        else l = nl.init(n+2).toList.zip(l).toList\n        // 3rd, 5th, 7th...\
    \ level \n        if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n\
    \        else l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 4th\n\
    \        if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n      \
    \  else l = nl.init(n+1).toList.zip(l).map(_._1+_).toList\n        // 5th\n  \
    \      if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n        else\
    \ l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 6th\n        if(n%2\
    \ != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n        else l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n\
    \        // 7th\n        if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n\
    \        else l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 8th\n\
    \        if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n      \
    \  else l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 9th\n  \
    \      if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n        else\
    \ l = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 10th\n       \
    \ if(n%2 != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n        else l\
    \ = nl.init(n+2).toList.zip(l).map(_._1+_).toList\n        // 11th\n        if(n%2\
    \ != 0) l = nl.init(n).toList.zip(l).map(_._1+_).toList\n        else l = nl.init(n",
  "        if (n < 0) Nil\n        else {\n            if (n % 2 == 0) List(n.toLong\
    \ * 2L).reverse\n            else List(n.toLong * 2L)\n        }", "        //\
    \ write your code here\n        val nums = mutable.ListBuffer.empty[Long]\n  \
    \      if(n % 2 == 0) {\n            while(n > 0) {\n                if(n % 2\
    \ != 0) {\n                    nums += n\n                }\n                n\
    \ /= 2\n            }\n        } else {\n            while(n > 0) {\n        \
    \        if(n % 2 == 0) {\n                    nums += n\n                }\n\
    \                n /= 2\n            }\n        }\n        nums", "        val\
    \ numOfLevels = n.toInt\n        val listOfLevels = Array[Long](numOfLevels)\n\
    \        var nOfNextLevel = if ( n % 2 == 0 ) {\n            val nextOdd = n /\
    \ 2\n            List( nextOdd.toLong )\n        }\n        else {\n         \
    \   val nextEven = n / 2\n            List( nextEven.toLong )\n        }\n   \
    \     listOfLevels ++= nOfNextLevel\n        listOfLevels", "        val counts\
    \ = mutable.ListBuffer.empty[Long]\n        for(i <- 0 until n-1)\n          \
    \  counts += n\n        (n%2 == 0l) ? counts ++ List(2l*counts.size) : counts",
  "        val pile : mutable.Set[Long] = mutable.Set()\n        var result : List[Long]\
    \ = List[Long]()\n        if (n.toDouble % 2l.toDouble == 0l) {\n            pile.add(n.toLong)\n\
    \        }\n        else {\n            if (n.toDouble % 2l.toDouble == 1l) {\n\
    \                pile.add(n.toLong)\n                pile.add(2l.toLong)\n   \
    \         }\n            else {\n                pile.add(n.toLong)\n        \
    \        pile.add(3l.toLong)\n                pile.add(5l.toLong)\n          \
    \      pile.add(7l.toLong)\n            }\n        }\n        result ++= pile\n\
    \        return result", "        if (n < 0) throw new IllegalArgumentException(\"\
    n can not be negative.\")\n        def makeAPileHelper(n: Long, levels: List[Long])\
    \ : List[Long] = {\n            if (n == 0) levels\n            else {\n     \
    \           if (n % 2 == 0) {\n                    makeAPileHelper(n - 1, levels\
    \ + n.toLong)\n                } else {\n                    makeAPileHelper(n\
    \ - 2, levels + n.toLong)\n                }\n            }\n        }\n     \
    \   makeAPileHelper(n, List[Long]())", "        var result : List[Long] = List();\n\
    \        if (n.toDouble % 2 == 0) result = makeAPile(n.toDouble / 2.toDouble)\
    \ ::\n            makeAPile(n.toDouble / 2.toDouble)\n        else result = makeAPile(n.toDouble\
    \ / 2.toDouble) ::\n            makeAPile(n.toDouble / 2.toDouble).reverse\n \
    \       result.reverse", "        val nextOdd : Long = (n+1) % 2 != 0l\n     \
    \   val nextEven : Long = (n+1) % 2 == 0l\n        val nextLevel : List[Long]\
    \ = List((n).toLong)\n        (nextOdd until nextEven).foldLeft(nextLevel) {\n\
    \            case (acc, i) => acc :+ acc.last + i.toLong\n        }", "      \
    \  val odd = math.ceiling(n)\n        val even = math.floor(n)\n        List(odd.toLong,\
    \ even.toLong).tail", "        if (n % 2 == 0) n :: makeAPile(n / 2l)\n      \
    \  else (n / 2l, n / 2l, n / 2l)", "        val evens = n.toInt\n        val odds\
    \ = evens.toInt\n        val evensPlusOne = if (n % 2 == 0) odds + 1 else odds\n\
    \        val oddsPlusOne = if (n % 2 == 0) evens + 1 else evens\n        List(n.toLong,\
    \ evensPlusOne.toLong, oddsPlusOne.toLong)", "        val p = if (n % 2 == 0)\
    \ (n / 2l) else ((n + 3) / 4l)\n        val stones = mutable.ListBuffer(p).toList\n\
    \        val newStones = if (stones.tail.isEmpty) stones else {\n            (stones.head\
    \ + 1l).+(stones.tail.head)\n        }\n        newStones.map(s => s.toLong).reverse",
  "        if(n == 0) List()\n        else List(n >> 1 | (n & 1) == 0)", '        (if
    (n % 2 == 0) n.toLong else ((n + 1).toLong + n.toLong))', '        if (n % 2 ==
    0) List(n.toLong, n.toLong*2l).reduceLeft{ (accum, num) => (accum :+ num.toLong)
    } else List(n.toLong, n.toLong*3l).reduceLeft{ (accum, num) => (accum :+ num.toLong)
    }', "        val nums = mutable.ArrayBuffer(n)\n        (1 to n).flatMap { i =>\n\
    \            val newNum = if (i % 2 == 0) nums.last + 1 else nums.last * 3\n \
    \           nums.last = newNum\n            newNum\n        }", "        var count\
    \ = 0\n        var nextOdd = n.toInt;\n        if (n % 2 == 0) nextOdd = nextOdd\
    \ + 1\n        var nextEven = nextOdd + 1\n        while (nextEven < n) {\n  \
    \          count = count + 1\n            nextEven = nextEven + 1\n        }\n\
    \        count = count + 1\n        var result = new ArrayList[Long](count)\n\
    \        for (var i = 2; i <= count; i++) {\n            val c = nextOdd;\n  \
    \          nextOdd = nextEven - 1\n            nextEven = c\n            result(i)\
    \ = c\n        }\n        return result", "        val numOfLevels = n.toInt\n\
    \        val numOfStones = n.toLong\n\n        val max = (math.pow(2,numOfLevels)-1).toInt\n\
    \n        if(numOfStones < max){\n            List.fill(numOfStones+1)(max).toList\n\
    \        }else{\n            val oddNum = numOfStones.toLong%2\n            val\
    \ evenNum = numOfStones.toLong/2\n\n            List(oddNum, evenNum).toList\n\
    \        }", "        val p = new Array[Long](n + 1)\n        var i = 0\n    \
    \    while (i < n) {\n            p.update(i + 1, i + 1)\n            i = i +\
    \ 2\n        }\n        p.update(i + 1, n + 1)\n        p :+ n", "        val\
    \ ones = n.toInt\n        val pile = mutable.ListBuffer.empty[Long]\n        var\
    \ sum = 0\n        for (i<-0 until ones) {\n            if (i % 2 == 0) {\n  \
    \              pile.append(sum)\n                sum = 0\n            } else {\n\
    \                sum = sum + 2\n            }\n        }\n        pile.append(sum)\n\
    \        pile", "        val st: Long = n.toLong\n        val lst = new mutable.MutableList[Long]\n\
    \        if (n % 2 != 0) {\n            lst.add(st)\n        }\n        for (i\
    \ <- 0 until n - 1) {\n            if (i % 2 == 0) {\n                lst.add(st\
    \ + i)\n            } else {\n                lst.add(st - i)\n            }\n\
    \        }\n        return lst.toList", "        if (n == 0L) return Nil\n   \
    \     val num = (n + 1L) / 2L\n        if (n % 2 == 0L) List(num.toLong, n)\n\
    \        else List(n, num.toLong)", "        if (n%2 == 0) {\n            List(n.toLong,\
    \ n)\n        } else {\n            List(n, n)\n        }", "        if(n == 0)\n\
    \            List()\n        else {\n            val oddNumbersPile = makeAPile(((n+1).toInt/2))\n\
    \            val evenNumbersPile = makeAPile((n.toInt/2))\n            (oddNumbersPile\
    \ ++ evenNumbersPile)\n        }", "       require(n > 0, \"n must be positive\"\
    )\n       val result: List[Long] = new ArrayList[Long](n)\n       for (i <- 0\
    \ until n) {\n         result(i) = i+1\n         if (!(i+1 in 0 until n)) {\n\
    \           result(i) = i+2\n         }\n         if (!(i+2 in 0 until n)) {\n\
    \           result(i) = i+3\n         }\n       }\n       result", "        var\
    \ level : List[Long] = Nil\n        var index = 0\n        while (index < n) {\n\
    \            if (n%2 == 0) {\n                if (level.isEmpty) level = List(n.toLong)\n\
    \                else level :+= n.toLong\n            } else {\n             \
    \   if (level.isEmpty) level = List(n.toLong)\n                else {\n      \
    \              level.lastOption .foreach { x => if (x < x%2==0) x else x + 1 }\
    \ match {\n                        case None => level = List(n.toLong)\n     \
    \                   case Some(x) => level :+= x\n                    }\n     \
    \           }\n            }\n            index += 1\n        }\n        level",
  "        var list : List[Long] = Nil\n        var nextodd : Long = (n+1) / 2\n \
    \       var nexteven : Long = nextodd * 2\n        if (n%2 == 0) {\n         \
    \   list :+= nexteven.toLong\n            list :+= nextodd.toLong\n        }\n\
    \        else {\n            list :+= nextodd.toLong\n            list :+= nexteven.toLong\n\
    \        }\n        list", "        val ns = Array.ofDim[Long](1 + n/2, 1)\n \
    \       for (ix <- 1 to ns.length-1){\n            if (n(ix) == n(ix+1)%2)\n \
    \               ns(ix+1) = ns.apply(ix+1) + 2\n            else\n            \
    \    ns(ix+1) = ns(ix+1) + 1\n        }\n        ns", "        val newList = new\
    \ ListBuffer[Long]()\n        val evenNumber = if (n.toDouble % 2 == 0.0) n.toDouble\
    \ else n.toDouble + 1\n        newList.append(n.toLong)\n        for (ni <- 1\
    \ to n.toDouble by 2) newList.append(ni.toLong)\n        newList.append(evenNumber.toLong)\n\
    \        return newList.toList", "        val even = math.pow(n, 2).toInt\n  \
    \      val odd = n + 1\n        val levels = mutable.ListBuffer[Long]()\n    \
    \    levels += n\n        while(n > 0) {\n            levels += if (n % 2 == 0)\
    \ even else odd\n            n = n / 2\n        }\n        levels.toList", " \
    \       var result : List[Long] = Nil\n        if(n % 2 == 0) {\n            result\
    \ ::= n / 2l.toLong\n            result += makeAPile(n.toInt)\n        }\n   \
    \     else result = makeAPile(n.toInt)\n        return result", "        def evenOrOdd(i\
    \ : Long): Long = {\n            if ((i >> 1) & 1 == 0)\n                i.toLong\n\
    \            else\n                i.toLong + 1\n        }\n        def makeAPile_helper(i\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if ((n >> i) & 1 ==\
    \ 0)\n                acc :+ n.toLong\n            else\n                acc :+\
    \ (evenOrOdd(i).toLong)\n        }\n        makeAPile_helper(0, List())", "  \
    \      val list = new mutable.ArrayBuffer(n + (if(n % 2 == 0) 2 else 1))\n   \
    \     if(n % 2 == 0) {\n            list += ((List(3l, 5l, 7l) toList) zip list.take(2)\
    \ map {case (l, r) => l ++ r})\n        } else {\n            list += ((List(3l,\
    \ 5l, 7l) toList) zip list.take(3) map {case (l, r) => l ++ r})\n        }\n \
    \       list += ((List(3l, 5l, 7l) toList) zip list.take(4) map {case (l, r) =>\
    \ l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip list.take(5) map {case\
    \ (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip list.take(6)\
    \ map {case (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip\
    \ list.take(7) map {case (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l)\
    \ toList) zip list.take(8) map {case (l, r) => l ++ r})\n        list += ((List(3l,\
    \ 5l, 7l) toList) zip list.take(9) map {case (l, r) => l ++ r})\n        list\
    \ += ((List(3l, 5l, 7l) toList) zip list.take(10) map {case (l, r) => l ++ r})\n\
    \        list += ((List(3l, 5l, 7l) toList) zip list.take(11) map {case (l, r)\
    \ => l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip list.take(12) map\
    \ {case (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip list.take(13)\
    \ map {case (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l) toList) zip\
    \ list.take(14) map {case (l, r) => l ++ r})\n        list += ((List(3l, 5l, 7l)\
    \ toList) zip list.take(15) map {case (l, r) => l ++ r})\n        list += ((List(3l,\
    \ 5l, 7l) toList) zip list.take(16) map {case (l, r) => l ++ r})", "        val\
    \ res = []\n        for(i <- 1 until n) res :+= math.ceil(i.toLong / 2)\n    \
    \    res", "        val r : List[Long] = List(n.toLong);\n        val odd = if(n\
    \ % 2==0) n.toLong else n.toLong + 1\n        val even = if(n % 2==1) n.toLong\
    \ else n.toLong + 2\n        r += odd :: makeAPile(even);\n        r", "     \
    \   val s = List(n, n - 1, n - 2)\n        val odd = s.filter(_ % 2 == 1).toList\n\
    \        val even = s.filter(_ % 2 == 0).toList\n        odd.map((_ * 2).toLong\
    \ :: even)", "        val result = new mutable.ArrayBuffer[Long](n+1)\n      \
    \  for(i <- 0 until n)\n            result(i+1) =  {\n                if(i % 2\
    \ == 0) i.toLong \n                else ((i-1).toLong + (i+1).toLong)/2\n    \
    \        }\n        result.toList", "        if (n <= 0)\n            throw new\
    \ IllegalArgumentException(\"n is required to be positive.\")\n        val levels\
    \ = mutable.MutableList[Long]()\n        levels.+=(n.toLong)\n        n -= 1\n\
    \        while (n > 0) {\n            n -= 1\n            levels.+=(n - (n % 2\
    \ == 0 ? 1 : 0))\n        }\n        levels.toList", "        val pile = ListBuffer(n)\n\
    \        val next = (2 to n) filter (x => (x % 2) != 0) map (x => x.toLong).toList\n\
    \        pile.append(n)\n        pile.append(next)\n        pile", "        if\
    \ (n ==0l) return Nil\n        if (n ==1l) return 1l.toLong\n        val even\
    \ = (if (n % 2==0l) 3l.toLong else 5l.toLong)\n        val odd =  (if (n % 2==0l)\
    \ 3l.toLong else 7l.toLong)\n        val result = n.toLong / 2l\n        result\
    \ :: makeAPile(result)", "        n match {\n            case 1 => List(n.toLong)\n\
    \            case 2 => List(n.toLong, n.toLong)\n            case _ => makeAPile(n+2).toList\
    \ ::: makeAPile(n+2).toList\n        }", "        n match {\n            case\
    \ n if (n % 2 == 0) => List(n.toLong, n.toLong+1)\n            case n if (n %\
    \ 2 != 0) => List(n.toLong, n.toLong)\n        }", "        var i = 0\n      \
    \  var listOfLevels = ListBuffer[Long]()\n        while(i < n) {\n           \
    \ if (n%2 == 0) {\n                listOfLevels += n\n            }\n        \
    \    else {\n                listOfLevels += (n + 2 * i.toLong)\n            }\n\
    \            i += 1\n        }\n        listOfLevels.toList", "        require(n.toInt\
    \ % 2 == 0, \"n should be an odd number\")\n        val nextOdd = n.toInt / 2\n\
    \        val nextEven = (nextOdd * 2).toInt\n        val nArray = n.toInt.toArray.map(x\
    \ => if (x == 0) 1 else x + 1)\n        val nList = nArray.toList\n        val\
    \ nTuple = Tuple2(1, 0)\n        val nTup = nList.zip(nTuple).map(x => x._1 +\
    \ x._2)\n        nTup", "        val even = 0\n        val odd  = n\n        if\
    \ (n % 2 == 0) even = n\n        else odd\n        odd::even::Nil", "        if(n.toInt\
    \ % 2 == 0) {\n            makeAPileOddNum(n)\n        } else {\n            makeAPileEvenNum(n)\n\
    \        }", "        def countEven(n:Long) : Long = math.min(math.min(math.min(n%2L,n),n),n)\n\
    \        def countOdd(n:Long) : Long = math.max(math.max(math.max(n%2L,n),n),n)\n\
    \        val evens = countEven(n)\n        val odds = countOdd(n)\n        if\
    \ (evens%2L==0L && odds%2L==0L) List(1L,n) else List(1L,odds,evens)", "      \
    \  val nLevels = n/2\n        val nLevels2 = n - nLevels\n        val nLevels3\
    \ = nLevels2 * 2\n        val nLevels4 = nLevels2 * 3\n        val nLevels5 =\
    \ nLevels3 * 4\n        val nLevels6 = nLevels3 * 5\n        val nLevels7 = nLevels4\
    \ * 6\n        val nLevels8 = nLevels4 * 7\n        val nLevels9 = nLevels5 *\
    \ 8\n        val nLevels10 = nLevels5 * 9\n        val nLevels11 = nLevels6 *\
    \ 10\n        val nLevels12 = nLevels6 * 11\n        val nLevels13 = nLevels7\
    \ * 12\n        val nLevels14 = nLevels7 * 13\n        val nLevels15 = nLevels8\
    \ * 14\n        val nLevels16 = nLevels8 * 15\n        val nLevels17 = nLevels9\
    \ * 16\n        val nLevels18 = nLevels9 * 17\n        val nLevels19 = nLevels10\
    \ * 18\n        val nLevels20 = nLevels10 * 19\n        val nLevels21 = nLevels11\
    \ * 20\n        val nLevels22 = nLevels11 * 21\n        val nLevels23 = nLevels12\
    \ * 22\n        val nLevels24 = nLevels12 * 23\n        val nLevels25 = nLevels13\
    \ * 24\n        val nLevels26 = nLevels13 * 25\n        val nLevels27 = nLevels14\
    \ * 26\n        val nLevels28 = nLevels14 * 27\n        val nLevels29 = nLevels15\
    \ * 28\n        val nLevels30 = nLevels15 * 29\n        val nLevels31 = nLevels16\
    \ * 30\n        val nLevels32 = nLevels16 * 31\n        val nLevels33 = nLevels17\
    \ * 32\n        val nLevels34 = nLevels17 * 33\n        val nLevels35 = nLevels18\
    \ * 34\n        val nLevels36 = nLevels18 * 35\n        val nLevels37 = nLevels19\
    \ * 36\n        val nLevels38 = nLevels19 * 37\n        val nLevels39 = nLevels20\
    \ * 38\n        val nLevels40 = nLevels20 * 39\n        val nLevels41 = nLevels21\
    \ * 40", "        // Write your code here.\n        var result : List[Long] =\
    \ Nil\n        var i : Long = 0\n        for(x <- 1 to n){\n            if((n\
    \ % 2) == 0) {\n                result += x\n            }\n            else {\n\
    \                result += 2 * x\n            }\n            i = i + 1 \n    \
    \    }\n        result", "        if(n <= 0l) List.empty[Long]\n        else {\n\
    \            val evenNum = if(n.toString.toInt%2 == 0) n.toString.toInt + 1 else\
    \ n.toString.toInt - 1;\n            val oddNum = if(n.toString.toInt%2 == 1)\
    \ n.toString.toInt - 2 else n.toString.toInt - 1;\n            if(oddNum < n)\
    \ List(oddNum.toLong)\n            else if (evenNum < n) List(evenNum.toLong)\n\
    \            else makeAPile(n - 1l) ::: makeAPile(n - 2l) ::: makeAPile(n - 3l)\
    \ ::: List(1l.toLong)\n        }", "        if (n == 0)\n            List(1l)\n\
    \        else {\n            if (n%2 == 0)\n                List(n.toLong * 1l,\
    \ n.toLong * 3l, n.toLong * 5l)\n            else\n                List(n.toLong\
    \ * 3l, n.toLong * 5l, n.toLong * 7l)\n        }", "        if (n < 1) {\n   \
    \         throw new IllegalArgumentException(\"n must be positive\")\n       \
    \ }\n        if (n % 2 == 0) {\n            val nextEven = if (n % 2 == 0) (n+1)\
    \ else (n+3)\n            List[Long](n.toLong, nextEven.toLong, n.toLong)\n  \
    \      } else {\n            val nextOdd = if (n % 2 == 0) (n+2) else (n+4)\n\
    \            List[Long](n.toLong, n.toLong, nextOdd.toLong)\n        }", "   \
    \     if (n % 2 == 0) {\n            List(n.toLong + 1, n.toLong)\n        } else\
    \ {\n            List(n.toLong, n.toLong + 1)\n        }", "        val ans =\
    \ ListBuffer[Long]()\n        var i = 0\n        var currentLevel = 0\n      \
    \  while(i < n) {\n            ans += currentLevel\n            currentLevel =\
    \ (i + 2) % n\n            i += 1\n        }\n        ans", "        // Write\
    \ your code here.\n        var stonesArray = Array[Long]()\n        stonesArray\
    \ = stonesArray.init(n)\n        stonesArray = stonesArray.takeWhile(n => n %\
    \ 2 == 0)\n        stonesArray = stonesArray.takeWhile(n => n % 2 != 0)\n    \
    \    stonesArray = stonesArray.dropWhile(n => n == 0)\n        stonesArray = stonesArray.toList\n\
    \        return stonesArray", "        val m = if (n.toDouble%2 == 0) 2 else 1\n\
    \        val l = List(n.toLong, n.toLong*2, n.toLong*3)\n        l.map(n => if\
    \ (n%2 == 0) m*(n+1) else n*(n+1)).toList", "        if (n <= 0l) return Nil\n\
    \        val odd = if (n % 2l) 3l else 5l\n        val even = if (n % 2l) 5l else\
    \ 7l\n        Nil.::(odd.toLong).::(even.toLong)", "        val nums = (if(n.isOdd)\
    \ 1L else 2L) * n\n        val list = List.fill(nums) {0L}\n        val result\
    \ = (if(n.isOdd) List.reverse(list.filter(_ % 2 == 1L)) list.reverse\n       \
    \ else if(n.isEven) List.reverse(list.filter(_ % 2 == 0L)) list.reverse\n    \
    \    else list)\n        (result.size)", "        var ans = (n % 2 == 0) ? n.toLong\
    \ : n.toLong + n.toLong\n        if (n % 2 != 0) {\n            ans = (ans * 2)\
    \ + n.toLong\n        }\n        List(ans)", "        val stonesOnEachLevel =\
    \ mutable.ListBuffer.empty[Long]\n        val currentLevel = n.toInt\n       \
    \ val nextLevel = if (n % 2 == 0) (2 * currentLevel + 1) else currentLevel + 1\
    \ \n        stonesOnEachLevel += nextLevel\n        for (i <- 1 to nextLevel)\
    \ {\n            stonesOnEachLevel += nextLevel\n        }\n        stonesOnEachLevel.toList",
  "        val newList = List(n) // create new list\n        if (n%2==0) // even\n\
    \            newList += math.ceil(n/2) // add next even number\n        else\n\
    \            newList += math.ceil(n/2) // add next odd number\n        newList\
    \ // return the list", "        val li = List(n)\n        def go(n: Long) : List[Long]\
    \ = n match {\n            case 0 => li\n            case _ => {\n           \
    \     val next = math.abs(n / 2)\n                go(next).toList ++ li.reverse.filter(_\
    \ % 2 == 0).map(_.toLong)\n            }\n        }\n        go(n).toList", " \
    \       var n1 = n\n        val n2 = if (n1.toInt % 2 == 0) (n1.toInt / 2) else\
    \ (n1.toInt / 2) + 1\n        val n3 = if (n2.toInt % 2 == 0) (n2.toInt / 2) else\
    \ (n2.toInt / 2) + 1\n        val n4 = if (n3.toInt % 2 == 0) (n3.toInt / 2) else\
    \ (n3.toInt / 2) + 1\n        val n5 = if (n4.toInt % 2 == 0) (n4.toInt / 2) else\
    \ (n4.toInt / 2) + 1\n        val n6 = if (n5.toInt % 2 == 0) (n5.toInt / 2) else\
    \ (n5.toInt / 2) + 1\n        val n7 = if (n6.toInt % 2 == 0) (n6.toInt / 2) else\
    \ (n6.toInt / 2) + 1\n        val n8 = if (n7.toInt % 2 == 0) (n7.toInt / 2) else\
    \ (n7.toInt / 2) + 1\n        val n9 = if (n8.toInt % 2 == 0) (n8.toInt / 2) else\
    \ (n8.toInt / 2) + 1\n        val n10 = if (n9.toInt % 2 == 0) (n9.toInt / 2)\
    \ else (n9.toInt / 2) + 1\n        val n11 = if (n10.toInt % 2 == 0) (n10.toInt\
    \ / 2) else (n10.toInt / 2) + 1\n        val n12 = if (n11.toInt % 2 == 0) (n11.toInt\
    \ / 2) else (n11.toInt / 2) + 1\n        val n13 = if (n12.toInt % 2 == 0) (n12.toInt\
    \ / 2) else (n12.toInt / 2) + 1\n        val n14 = if (n13.toInt % 2 == 0) (n13.toInt\
    \ / 2) else (n13.toInt / 2) + 1\n        val n15 = if (n14.toInt % 2 == 0) (n14.toInt\
    \ / 2) else (n14.toInt / 2) + 1\n        val n16 = if (n15.toInt % 2 == 0) (n15.toInt\
    \ / 2) else (n15.toInt / 2) + 1\n        val n17 = if (n16.toInt % 2 == 0) (n16.toInt\
    \ / 2) else (n16.toInt / 2) + 1\n        val n18 = if (n17.toInt % 2 == 0) (n17.toInt\
    \ / 2) else (n17.toInt / 2) + 1\n        val n19 = if (n18.toInt % 2 == 0) (n18.toInt\
    \ / 2) else (n18.toInt / 2) + 1\n        val n20 = if (n19.toInt % 2 == 0) (n",
  "        val stones = List(n)\n        if( n % 2 != 0) stones.updated(2, stones.last.get/2)\n\
    \        stones", "        val list = mutable.ListBuffer.empty[Long]\n       \
    \ list ++= List(1l, 1l, 1l)\n        if (n % 2 == 0) list ++= List(1l)\n     \
    \   if (n % 2 == 1) list ++= List(2l)\n        list.toList", "        val n1 =\
    \ n + 1l\n        val n2 = n1 + 1l\n        val n3 = n2 + 1l\n        val n4 =\
    \ n3 + 1l\n\n        val pile : List[Long] = List(n1.toLong, n2.toLong, n3.toLong,\
    \ n4.toLong)\n        if(n%2==0) pile.dropRight(1) else pile.takeRight(1)", " \
    \       if (n == 0) List()\n        else {\n            val (l1, l2) = (n.toInt/2).ceil.round.toInt,\
    \ n.toInt%2.toInt\n            makeAPile(l1) + makeAPile(l2)\n        }", "  \
    \     if (n <= 0) Nil\n       else if (n % 2 == 0) (n/2 :: makeAPile(n.toInt))\n\
    \       else if (n % 2 == 1) (n.toInt :: makeAPile(n.toInt))", "        val x\
    \ = n.toInt\n        val result = new ListBuffer[Long]()\n        if (n.toInt\
    \ == 1) {\n            result.+=(n.toLong)\n        } else {\n            if (x\
    \ % 2 == 0) {\n                result.+=(n.toLong)\n                result.+=(n.toLong)\n\
    \            } else {\n                result.+=(n.toLong)\n                result.+=(n.toLong)\n\
    \                result.+=(n.toLong)\n            }\n        }\n        return\
    \ result.toList", "        // If n is odd, return the next odd number and add\
    \ 1 to it\n        // If n is even, return the next even number and add 1 to it\n\
    \        (if (n >>> 0 == 0) (n >>> 1).toLong + 1 : (n >>> 1).toLong).\n      \
    \      toList.\n            reverse.\n            toList.\n            reverse.\n\
    \            toList", "        if (n == 0) List[Long]() else makeAPile(n-1) ++\
    \ makeAPile(n mod 2 match {\n            case 0 => 1\n            case 1 => n\n\
    \            case _ => n >> 1\n        })", "        val numLevels = n.toInt\n\
    \        var level = numLevels\n        var totalStones = n\n        var stones\
    \ = List(numLevels.toLong)\n        var nextEven = 0\n        var nextOdd = 0\n\
    \        while (level <= numLevels) {\n            nextEven = n.toInt\n      \
    \      nextOdd = n.toInt\n            stones = stones.tail :+ nextEven.toLong\
    \ ++ nextOdd.toLong\n            level = level + 1\n        }\n        stones"]
stop_tokens:
- "\n    }\n"
