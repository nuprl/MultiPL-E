name: HumanEval_60_sum_to_n
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // sum_to_n is a function that sums numbers from 1 to n.\n    // >>> sumToN((30l))\n\
  \    // (465l)\n    // >>> sumToN((100l))\n    // (5050l)\n    // >>> sumToN((5l))\n\
  \    // (15l)\n    // >>> sumToN((10l))\n    // (55l)\n    // >>> sumToN((1l))\n\
  \    // (1l)\n    def sumToN(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumToN((1l)) == (1l));\n\
  \    assert(sumToN((6l)) == (21l));\n    assert(sumToN((11l)) == (66l));\n    assert(sumToN((30l))\
  \ == (465l));\n    assert(sumToN((100l)) == (5050l));\n    }\n\n}\n"
completions: ["        val total = 0\n        for (i <- 1l to n) total += i\n    \
    \    total", "        val s = mutable.ListBuffer[Long]()\n        for (i <- 1\
    \ to n)\n            s += i\n        s.sum", "        if (n==1) 1\n        else\
    \ n*(n+1)/2;", "        var sum = 0\n        for(i <- 1 until n) {\n         \
    \   sum += i\n        }\n        return sum", "        val nmax = 10\n       \
    \ val curr = 1L\n        var sum = 0L\n        var cnt = 0\n        var n = 1L\n\
    \        while (curr <= n) {\n            sum += curr\n            cnt += 1\n\
    \            n *= nmax\n        }\n        sum", "        val s = mutable.ArrayBuffer(1l)\n\
    \        (1 to n).foreach {\n            n =>\n                s += n\n      \
    \  }\n        s.length", "        val a = n toLong\n        val b = a / 10000\n\
    \        val result = a%10000\n        val c = b / 100\n        val d = result%100\n\
    \        val e = c / 10\n        val f = d%10\n        val g = e / 5\n       \
    \ val h = f%5\n        val i = g / 5\n        val j = h%5\n        val k = i/5\n\
    \        val l = j/5\n        l*100000 + k*100 + l*10 + k", "        var sum =\
    \ 0L\n        var i : Long = 1L\n        while (i < n) {\n            sum = sum\
    \ + i\n            i = i + 1L\n        }\n        return sum", "        val maxn\
    \ = n.toInt\n        var sum = 0\n        var index = 0\n        while(index <\
    \ maxn){\n            sum += 1\n            index += 1\n        }\n        if(maxn\
    \ == 1){\n            sum\n        }else{\n            sum + sumToN(maxn-1)\n\
    \        }", "        val total = n.toLong\n        val sum = 0\n        while\
    \ (total > 0) {\n            val left = total / 2\n            val right = total\
    \ - left\n            if (left % 2 == 0) {\n                sum += right\n   \
    \         }\n            total -= left\n        }\n        sum", "        val\
    \ result = mutable.ListBuffer[Long]()\n        val limit = (1 until n).map(i =>\
    \ i -> n).toMap\n        for(i <- 1 to n) {\n            result.append(i)\n  \
    \          if(limit.get(i) != 0) {\n                result.append(sum(limit.filter(_._1\
    \ == i).map(_._2)))\n            }\n        }\n        result.toList.sum", " \
    \       val numbers = mutable.Stack.empty[Long]\n        while (n>0) {\n     \
    \       numbers.push(n)\n            n -= 1\n        }\n        numbers.reduce(_+_)",
  "        if (n <= 0) {\n            return n\n        }\n        val sum = 0l\n\
    \        for (i <- 1 until n) {\n            sum = sum + i\n        }\n      \
    \  sum", "        val nums = mutable.ArrayBuffer(1l)\n        for (x <- 2l to\
    \ n) {\n            nums += x\n        }\n        nums.reduceLeft(_ + _)", " \
    \       val res : Long = n.toInt\n        if (res == 0) 0\n        else {\n  \
    \          val num = 0\n            val remainder = n % res\n            var i\
    \ : Int = 1\n            var sum = 0\n            while (remainder != 0) {\n \
    \               sum += i\n                remainder = remainder % i\n        \
    \        i += 1\n            }\n            res + sum\n        }", "        //\
    \ Sum of first 'n' numbers \n        var sum = 1L\n        var i = 0\n       \
    \ while (i < n) {\n            sum = sum + i\n            i = i + 1\n        }\n\
    \        return sum", "        val arr = new Array[Long](n+1)\n        var sum\
    \ = 0l\n        var index = 0l\n        while (n > 0) {\n            arr(index)\
    \ = (n%10)\n            n = n/10\n            index += 1\n        }\n        if\
    \ (arr(index) > 0)\n            sum += arr(index+1) - 1\n        else\n      \
    \      sum += arr(index)\n        return sum", "        var sum = BigInt(0l) \
    \ \n        for(i <- 1 to n) sum = sum + i\n        return sum.toLong", "    \
    \    val sum = 0\n        for (i <- 1l to n) sum += i\n        sum", "       \
    \ if (n == 0) n\n        else (1 to n).sum", "        val sum = (1l+(n-1l)) #::\
    \ sumToN(n-1l)\n        sum.toLong", "        val nums = mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 1 to n) nums += i\n        nums.sum", "        var sum = 0\n\
    \        for (i = 1 until n)\n            sum += i\n        sum", "        //\
    \ create a mutable list to hold the result\n        var res : mutable.List[Long]\
    \ = mutable.List.empty\n        res.add(0)\n        var i = 1\n        // while\
    \ i is less than n\n        while ( i < n ) {\n          // add the current i\
    \ to the list and increment it\n          res = res :+ i\n          i = i + 1\n\
    \        }\n        // return the sum of all the numbers\n        res.reduceLeft((x,\
    \ y) => x + y)", "        val result = mutable.ArrayBuffer.empty[Long]\n     \
    \   var total = 0L\n        for (i <- 1 to n) {\n            total += i\n    \
    \        result += total\n        }\n        result(0)", "        var sum = 0\n\
    \        var i = n\n        while (i>0) {\n            sum += i\n            i\
    \ -= 1\n        }\n        sum", "        def sumToNHelper(n : Long) : Long =\
    \ if (n <= 1) 1\n        else sumToNHelper(n - 1) + n\n        sumToNHelper(n)",
  "      var sum = 0\n      var i = 1\n      while (i <= n) {\n        sum += i\n\
    \        i += 1\n      }\n      sum", "        if (n <= 0) \n            0l\n\
    \        else\n            1 + (n - 1l) * (sumToN((n - 1l)))", "        var total\
    \ : Long = 0\n        var i : Long = 1\n        while (i <= n) {\n           \
    \ total += i\n            i += 1\n        }\n        return total", "        var\
    \ sum = 0\n        for (i <- 1 to n) sum += i\n        sum", "        var total\
    \ = 0\n        var remaining = n\n        while (true) {\n            remaining\
    \ -= 1\n            if (remaining < 1) {\n                total += remaining\n\
    \                break\n            }\n            total += remaining\n      \
    \      remaining /= 2\n        }\n        total", "        var sum = 0\n     \
    \   for (i <- 1 to n) {\n            sum += i\n        }\n        sum", "    \
    \    val sum = 0\n        for(i <- 1 to n) sum += i\n        sum", "        if\
    \ (n==1) n\n        else n * (sumToN(n-1) + 1)", "        // We use a mutable\
    \ collection to store the sum.\n        // We use the mutable collection to allow\
    \ for recursive calls.\n        val res : mutable.Long = mutable.Long.empty\n\
    \        res += n\n        // We use recursion to add 1 to each number in the\
    \ collection.\n        // We use recursion to add 1 to each number in the collection.\n\
    \        if (n > 0) {\n            res += sumToN(n - 1)\n        }\n        res",
  '        // Add code below', "      val ns = Vector.fill(10)(0L).init\n      val\
    \ nn = n + 1l\n      for (i <- 1 to nn) {\n        ns(i - 1) = i + ns(i - 1)\n\
    \      }\n      ns.sum", "        val numbers = mutable.MutableList.empty[Long]\n\
    \        var sum = 0\n        while(n < 0){\n            numbers = n :: numbers\n\
    \            sum += n\n            n = -(n+1)\n        }\n        numbers.foreach(sum\
    \ + _)\n        sum", "        var sum = 0l\n        var i = n\n        while(i\
    \ > 0) {\n            sum = sum + i\n            i = i-1\n        }\n        return\
    \ sum", "        def sumToNImpl(n: Long, acc: Long = 0) : Long = {\n         \
    \   if (n == 0)\n                return acc\n            else\n              \
    \  sumToNImpl(n-1, acc+n)\n        }\n        return sumToNImpl(n)", "       \
    \ if (n == 1l) 1l\n        else {\n            val r = n.toLong\n            val\
    \ s = sumToN(r-1l) + r\n            s\n        }", "        val sum = 0l\n   \
    \     var current = n\n        while (current > 0) {\n            sum += current\n\
    \            current = current - 1\n        }\n        sum", "        if(n <=\
    \ 0) n = 1\n        var s = 0\n        for(i <- 1 until n)\n        s += i\n \
    \       s", "        if (n < 1l)\n            1l\n        else\n            n.toLong\
    \ + sumToN(n - 1l)", "        var sum = 0L\n        for (i <- 1 to n)\n      \
    \      sum += i\n        return sum", "        val buffer = new ArrayBuffer[Long]()\n\
    \        buffer += n\n        while (n-- > 0) {\n            buffer += n\n   \
    \     }\n        buffer.sum", "        val res = new Array[Long](n)\n        var\
    \ i = 0\n        while (i < n)\n            res(i) = i + 1\n            i += 1\n\
    \        res(0) = n\n        return res", "        var sum : Long = 1\n      \
    \  var cur : Long = 1\n\n        while(cur <= n) {\n            sum = sum + cur\n\
    \            cur += 1\n        }\n        sum", "        val a = 1 to n\n    \
    \    val b = a\n        val c: Set[Long] = new HashSet[a]\n        c.foreach {\n\
    \            i => b += i\n        }\n        b.sum", "        var sum : Long =\
    \ 1\n        while (n > 0) {\n          sum = sum + n\n          n = n - 1\n \
    \       }\n        sum", "        def sum_to_n_aux(m : Long, acc : Long) : Long\
    \ = {\n            if (m == 0) acc\n            else sum_to_n_aux(m-1, acc+m)\n\
    \        }\n        sum_to_n_aux(n, 0l)", "        val result = new scala.collection.mutable.HashSet[Int]\n\
    \        // sumToN(1) + sumToN(2) ... sumToN(n) + sumToN(1)\n        for (x <-\
    \ 1l to n) result += sumToN(x)\n        result.last", "        val res = 0\n \
    \       for ( i=1; i<=n; i=i+1 ) {\n            res = res + i\n        }\n   \
    \     return res", "        if (n == 0l)\n            return 1l\n        if (n\
    \ == 1l)\n            return 1l\n        return (n * (n + 1l)).sum", "       \
    \ val sum = mutable.MutableLong(0);\n        for (i <- 1 to n) {\n           \
    \ sum += i\n        }\n        sum.sum", "        // Your code goes here\n   \
    \     val sum : Long = 0\n        var k = 0\n        for(i <- 1L until n){\n \
    \           k = k + 1\n            sum = sum + k\n        }\n        sum", " \
    \       val a = mutable.ArrayBuffer(n).reverse\n        val b = a.reduceLeft(_\
    \ + _)\n        a.reverse\n        b", "        var result = 0\n        var i\
    \ = 2\n        while (i <= n) {\n            result = result + i\n           \
    \ i = i + 1\n        }\n        return result", "        val numbers = for {\n\
    \            i <- 1 until n\n        } yield i\n        numbers.foldLeft(0l) {\
    \ (acc, elem) => acc + elem }", "        if (n == 0)\n            return 0\n \
    \       else\n            (n + sumToN(n-1))", "        val rem = n % 30\n    \
    \    val sum = n - (rem :: 0l) % 30\n        if (rem == 0)\n            sum\n\
    \        else\n            sumToN(sum)", "        val sum: Long = 1\n        var\
    \ sum2: Long = 1\n        while(sum < n) sum2 = sum2 + sum\n        sum2", " \
    \       val ns = List.range(1,n+1)\n        var sum = 0L\n        for (i <- ns)\n\
    \            sum = sum + (i.toLong * i)\n        sum", "        val result = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 1l\n        while (sum <= n) {\n            result.append(sum)\n\
    \            sum += 2l\n        }\n        result.last", "        if (n <= 0)\
    \ {\n            throw new RuntimeException(\"Can't sum \" + n + \" < 0\")\n \
    \       }\n        val s = Long.valueOf(1l)\n        val r = scala.util.control.Exception.allCatch.runCatch\
    \ {\n            while (n > 0) {\n                s += Long.valueOf(n - 1)\n \
    \               n -= 1\n            }\n        }\n        if(r.nonEmpty) {\n \
    \           throw new RuntimeException(\"sum over \" + n + \" failed\")\n    \
    \    }\n        s", '        (1 to n).foldLeft(0l) { _ + _ }', "        val nums\
    \ = new mutable.ListBuffer[Long]()\n        var sum = 0l\n        for(i <- 1 to\
    \ n){\n            sum = sum + i\n            nums += sum\n        }\n       \
    \ sum", "      var sum = 0L\n      for ( i <- 1 to n ) {\n          sum += i\n\
    \      }\n      return sum", "        // Write your code here.\n        var sum\
    \ = 0L\n        var i = 1\n        while (i <= n) {\n            sum += i\n  \
    \          i += 1\n        }\n        sum", "        val sum = scala.collection.mutable.MutableList.empty[Long]\n\
    \        for (i <- 1 until n)\n            sum += i\n        sum.sum", "     \
    \   if(n<=0) 0l\n        else {\n            var res = 1l\n            for(i<-n;i<=n;i+=i)\
    \ res = res * i\n            return res\n        }", "        val nm = n.toLong\n\
    \        if (nm == 1l) return nm\n        val sum = 1l\n        val m = nm / 2l\n\
    \        val d = nm % 2l\n        for (i <- 1l to nm)\n            if (i % 2l\
    \ == d)\n                sum = sum + i\n            else if (i % 2l != d)\n  \
    \              sum = sum - i\n        return sum", "        val list = 1 to n\n\
    \        val sum = list.foldLeft(0L)((acc, val) => acc + val)\n        sum", " \
    \     var total = 0\n      for (i <- 0 until n) {\n        total = total + i\n\
    \      }\n      total", "        val sum : Long = 0l\n        for( i <- 0 until\
    \ n )\n            sum += i\n        sum", "        var sum : Long = 0l\n    \
    \    for(i <- 1 to n)\n            sum += i\n        sum", "        var num =\
    \ 1\n        while (n > 0) {\n            num *= n\n            n--\n        }\n\
    \        return num", "        var n1 = 1l\n        var n2 = 0l\n        var res\
    \ = n\n        for (i <- 1l to n by 1l) {\n            n2 = n1 + i\n         \
    \   res = n2\n        }\n        res", "        val buffer = new mutable.ArrayBuffer[Long]()\n\
    \        var sum = 0\n        for (i <- 1 to n) {\n            sum +=  i\n   \
    \         buffer.append(sum)\n        }\n        buffer.last", "        var sum\
    \ : Long = 0\n        for (i <- 1 to n) {\n            sum += i\n        }\n \
    \       sum", "        var sum = 0\n        var i = n\n        while (i > 1) {\n\
    \            sum += i\n            i -= 1\n        }\n        sum", "        var\
    \ total = 0l\n        for (x <- 1 to n) {\n            total += x\n        }\n\
    \        total", "        (0 until n).foldLeft(0l) {\n            case (acc, _)\
    \ => acc + _\n        }", "        val sum = n.toLong\n\n        var i = 1;\n\n\
    \        // While i is less than n.\n        while( i <= n ) {\n            sum\
    \ = sum + i\n            i = i + 1\n        }\n        sum", "        val sum\
    \ = 0\n        var i = 1\n        while (i <= n) {\n            sum = sum + i\n\
    \            i = i + 1\n        }\n        return sum", "        var s = Long.MaxValue\n\
    \        var sum = 0L\n        var k = 0\n        for( x <- 1 to n ) {\n     \
    \       sum = sum + x\n            k = k + 1\n            if( (x%2) == 0 ) {\n\
    \                s = math.min(s, sum)\n            }\n        }\n        return\
    \ s", "        def sumToNLoop(n: Long) : Long = {\n            if (n == 0l) 1l\n\
    \            else n * (sumToNLoop(n - 1l) + 1l)\n        }\n        sumToNLoop(n)",
  "        // Create a list with number from 1 to n.\n        val numbers = 1 to n\n\
    \        // Sum the numbers in the list.\n        numbers.foldLeft(1l) {\n   \
    \         case (acc, n) => acc + n\n        }", "        // Write your logic here\n\
    \        n * (n + 1) / 2.0", "        var sum = 0\n        var counter = 1\n \
    \       var i = 0\n        while (counter < n) {\n            sum += counter\n\
    \            counter += 1\n            i += 1\n        }\n        sum", "    \
    \    val numbers = mutable.ListBuffer[Long]()\n        val i = n - 1\n       \
    \ while (i > 0) {\n            numbers += i\n            i -= 1\n        }\n \
    \       numbers.sum", "        var sum = 0L\n        for (i <- 1 to n) {\n   \
    \         sum += i\n        }\n        sum", "        var sum = 0L\n        for(i<-\
    \ 1 to n) sum += 1L\n        sum", "        var sum = 0l\n        var i = 0l\n\
    \        while (i<n) {\n            sum = sum + i\n            i = i+1l\n    \
    \    }\n        return sum", "        val sum = 0\n        for (i <- 1 to n)\n\
    \            sum += i\n        sum", '        if (n >= 1l) 1l else n * sumToN(n-1l)',
  "        // Initialize the count of values as n\n        var sum = 0L\n        val\
    \ arr = new Array[Int](n)\n        // Populate the array with numbers 1 to n\n\
    \        for (i <- 0 until arr.length)\n            arr(i) = i\n        // Traverse\
    \ the array\n        for (i <- 0 until arr.length) {\n            // If the current\
    \ element is smaller than n, then\n            // increase the sum value with\
    \ that element\n            if (arr(i) < n)\n                sum += arr(i)\n \
    \           // If the current element is larger than n, then\n            // decrease\
    \ the sum value with that element\n            else if (arr(i) > n)\n        \
    \        sum -= arr(i)\n        }\n        // Return the sum\n        sum", " \
    \     var sum = 0\n      for (i<-0 until n) {\n        sum = sum + i\n      }\n\
    \      sum", "        var sum = 0\n        for (i <- 1 to n) sum += i\n      \
    \  sum", "      val sum = 0\n      for (i <- 1 to n) {\n        sum += i\n   \
    \   }\n      sum", "        def sum(i: Long, acc: Long = 0) : Long = if (i <=\
    \ n) acc + sum(i + 1, i + 1)\n        sum(0)", "        val result = mutable.LongBuffer.empty[Long]\n\
    \        for (i <- 1 to n) result += i\n        result.sum", "        val r :\
    \ Long = n / 2\n        val r1 : Long = n % 2\n        val r2 : Long = n / r\n\
    \        val r3 : Long = r * r\n        val r4 : Long = r * r\n        val r5\
    \ : Long = r * r\n        val r6 : Long = r * r\n        val r7 : Long = r * r\n\
    \        val r8 : Long = r * r\n        val r9 : Long = r * r\n        val r10\
    \ : Long = r * r\n        val r11 : Long = r * r\n        val r12 : Long = r *\
    \ r\n        val r13 : Long = r * r\n        val r14 : Long = r * r\n        val\
    \ r15 : Long = r * r\n        val r16 : Long = r * r\n        val r17 : Long =\
    \ r * r\n        val r18 : Long = r * r\n        val r19 : Long = r * r\n    \
    \    val r20 : Long = r * r\n        val r21 : Long = r * r\n        val r22 :\
    \ Long = r * r\n        val r23 : Long = r * r\n        val r24 : Long = r * r\n\
    \        val r25 : Long = r * r\n        val r26 : Long = r * r\n        val r27\
    \ : Long = r * r\n        val r28 : Long = r * r\n        val r29 : Long = r *\
    \ r\n        val r30 : Long = r * r\n        val r31 : Long = r * r\n        val\
    \ r32 : Long = r * r\n        val r33 : Long = r * r\n        val r34 : Long =\
    \ r * r\n        val r35 : Long = r * r\n        val r36 : Long = r * r\n    \
    \    val r37 : Long = r * r\n        val r38 : Long = r * r\n        val r39 :\
    \ Long = r * r\n        val r40 : Long = r * r\n        val r41 : Long = r * r\n\
    \        val r42 : Long = r * r\n        val r43 : Long = r * r\n        val r44\
    \ : Long = r * r\n        val r45 : Long = r * r\n        val r46 : Long = r *\
    \ r\n        val r47 : Long = r * r\n        val r48 : Long = r * r\n        val\
    \ r49 : Long = r * r\n        val r50 : Long = r * r\n        val r5", "     \
    \   if (n < 1l) 1l\n        else\n            ((1l..n).foldLeft(0l)(_+_))", " \
    \       val accum : mutable.Long = mutable.Long.empty\n        for(x <- 1 to n)\
    \ {\n            accum += x\n        }\n        accum.toLong", "      var sum\
    \ = 0\n      for (i <- 1 to n) {\n        sum += i\n      }\n      sum", "   \
    \     def sumToNHelper(n:Long, total:Long, result:Long) : Long = {\n         \
    \   if(n==1) return total\n            total += n\n            sumToNHelper(n-1,\
    \ total, result)\n        }\n        sumToNHelper(n, 0l, 0l)", "        val n\
    \ = math.max(n)\n        val m = math.min(math.ceil(n), math.log(n))\n       \
    \ val i = m - 1\n        val p = math.pow(2, i)\n        val s = math.pow(10,\
    \ m)\n        math.min(n - (math.log(n) - m), s * n)", "        var total = 0\n\
    \        var nSum = 0\n        var count = 0\n        var i = 1;\n        while\
    \ (i <= n) {\n            total = total + i\n            nSum = nSum + i\n   \
    \         count = count + 1\n            i = i + 1\n        }\n        return\
    \ (total * count).toLong", "        if (n == 1l) 1l\n        else n + sumToN(n-1l)",
  "        if (n == 1) 1\n        else n % 2 == 0L ? n + (2 * sumToN(n - 1L)) : sumToN(n\
    \ - 1L)", "        def loop(n: Long, acc: Long) : Long = {\n            if (n\
    \ == 1)\n                acc\n            else\n                loop(n-1, acc\
    \ + n) \n        }\n        loop(n, 0L)", "        var sum = 0\n        for(x\
    \ <- 1 to n) {\n            sum += 1\n        }\n        sum", "        val a\
    \ = 1 to n\n        val b = a.reduce((x,y) => x + y)\n        b", "        if\
    \ (n == 1) n\n        else (n * sumToN(n-1))", "        if(n <= 0) 0\n       \
    \ else {\n            val a = mutable.ArrayBuffer(n)\n            var sum : Long\
    \ = sum_to_n(a)\n            for(x <- a) {\n                val v = x - sum\n\
    \                sum += v\n                a = mutable.ArrayBuffer(x)\n      \
    \      }\n            sum\n        }", "        // Create a range of numbers from\
    \ 1 to n.\n        val range = Range(1, n)\n        // Initialize the sum to 0.\n\
    \        var sum = 0\n        // Loop through the range.\n        for (elem <-\
    \ range) {\n            // Add the current element to the sum.\n            sum\
    \ = sum + elem\n        }\n        // Return the sum variable.\n        sum",
  "        val r = new scala.collection.mutable.ListBuffer[Long]()\n        val x\
    \ = 1\n        while (x != n) r.append(x)\n        r.reverse\n        val y =\
    \ r.sum\n        val z = math.ceil((n - y) / r)\n        if (z < 1) 1l\n     \
    \   else if (z > 100) sumToN(100l)(z - 100)\n        else sumToN((n - y) / r)((z\
    \ - 1) * r) + y", "        if (n == 0) \n            1l\n        else\n      \
    \      sumToN(n - 1l) + n", "        val l = n.toLong\n        val sum = 0\n \
    \       for(i <- 1 to l){\n            sum = sum + i\n        }\n        sum",
  "        var sum = 0L\n        for (i <- 1 to n)\n            sum += i\n       \
    \ return sum", "        var sum = 0l\n        for (i <- 1l..n) {\n           \
    \ sum += i\n        }\n        sum", "        def sumToNImpl(n : Long) : Long\
    \ = {\n            if (n <= 0) 0\n            else if (n <= 2) n\n           \
    \ else n + sumToN(n - 1)\n        }\n        sumToNImpl(n)", "        var sum\
    \ = 0\n        var i = 0\n        while (i < n) {\n            sum += i\n    \
    \        i += 1\n        }\n        return sum", "        val total = mutable.ListBuffer.empty[Long]\n\
    \        total.+= (1l)\n        while (total.size < n) total.+= (1l)\n       \
    \ total.reverse.foldLeft(0)((sum, e) => sum + e)", "        var sum = 0l\n   \
    \     for (i <- 1 to n) {\n            sum = sum + i\n        }\n        sum",
  "        var sum = 0\n        for (i <- 1 to n) {\n            sum = sum + i\n \
    \       }\n        sum", "        def sumToNHelper(n: Long, acc: Long) : Long\
    \ = {\n            if (n == 0) acc\n            else sumToNHelper(n - 1, acc +\
    \ 1)\n        }\n        sumToNHelper(n, 0l)", "        if (n == 1l)\n       \
    \     return 1l\n        if (n <= 1l)\n            return 0l\n        var sum\
    \ = 0l\n        for (x <- 1l until n)\n            sum += x\n        sum", " \
    \       var sum : Long = 0\n        for (i : Long <- 1l to n) {\n            sum\
    \ += i\n        }\n        sum", "        if (n < 0)\n            return 0l\n\
    \        if (n == 0l)\n            return 1l\n        return n + sumToN(n - 1l)",
  "        var s = 0\n        var i = 0\n        var k = 0\n        while(i < n) {\n\
    \            s = s + i\n            k = k + 1\n            i = i + 1\n       \
    \ }\n        s", "        val a = mutable.Queue[Long]()\n        var total = 0\n\
    \        while (a.length < n) total += a.enqueue(a.dequeue() + 1)\n        total",
  "        var sum : Long = 0\n        for (i<- 1 to n)\n            sum += i\n  \
    \      return sum", "        // This is our sum so far.\n        var sum = 0\n\
    \        // A running count of what we have already added so far.\n        var\
    \ count = 0\n        // Loop through all the numbers from 1 to n.\n        for(x\
    \ <- 1 to n){\n            // Sum up the numbers from 1 until x.\n           \
    \ sum += x\n            // Increment count by 1.\n            count += 1\n   \
    \         // If we have added n numbers, break the loop.\n            if(count\
    \ == n)\n                break\n        }\n        // Return our sum.\n      \
    \  sum", "        def loop(n : Long, acc : Long) : Long = {\n            if (n\
    \ == 0) {\n                acc\n            }\n            else if (n % 2 == 0)\
    \ {\n                loop(n / 2, acc+acc)\n            }\n            else {\n\
    \                loop(n / 2, acc)\n            }\n        }\n        loop(n, 0)",
  "        val s = 0.0\n        for(i <- 1 to n) {\n            s += i\n        }\n\
    \        return s", "        var s = n\n        while (s <= n) s = s + n\n   \
    \     s", "      val sum = scala.collection.mutable.ListBuffer[Long]()\n     \
    \ for (i <- 1 to n) {\n        sum += i\n      }\n      sum.toList.foldLeft(0l)\
    \ { (sum, i) => sum + i }", "        var res = n\n        while(res > 0){\n  \
    \          res -= 1\n        }\n        return res", "        val ls = mutable.LinkedList[Long]()\n\
    \        var total : Long = n\n        while (ls.size < total) {\n           \
    \ ls.addLast(total)\n            total += total\n        }\n        val res =\
    \ ls.sum\n        ls.clear()\n        res", "        if (n == 0l) return 0\n \
    \       val total = 0l\n        for (i <- 1l to n) total += i\n        return\
    \ total", "        // Make a list of numbers 1 to n.\n        val listOfNumbers\
    \ = List.range(1, n + 1)\n        // Create a mutable accumulator for summing\
    \ all the numbers in the list.\n        val accumulator = MutableList.empty[Long]\n\
    \        // For each number in the list, add it to the accumulator and return\
    \ the result.\n        listOfNumbers.foreach(accumulator += _)\n        // Return\
    \ the accumulator as a long.\n        accumulator.toList.getOrElse(0)", "    \
    \    var total = 1\n        var next = 1\n        var sum : Long = 0\n       \
    \ while (next <= n) {\n            sum += next\n            next += 1\n      \
    \  }\n        total", "        val total = 1\n        for (i <- 1 to n) {\n  \
    \          total *= i\n        }\n        total", "        var sum = 0\n     \
    \   var currentSum = 0\n        var currentNum = 1\n        while (currentNum\
    \ <= n) {\n            sum += currentNum\n            currentSum += currentNum\n\
    \            currentNum += 1\n        }\n        return sum", "        var result\
    \ : Long = 0\n        for(i <- 1 to n){\n            result += i\n        }\n\
    \        result", "        // initialize a mutable summation to a dummy value\n\
    \        var sum = 0\n        for (i<- 1 to n) {\n            // add value to\
    \ summation\n            sum = sum + i\n        }\n        // return summation\n\
    \        sum", "        var s = n.toInt\n        var total = 0l\n        for(i\
    \ <- 0 until s) {\n            total += i\n        }\n        total", "      \
    \  def sum(i:Int,total : Long) : Long = {\n            if (i == n) total\n   \
    \         else sum(i + 1, total + i)\n        }\n        sum(0,0)", '        (1
    to n).sum', "        var sum = 0L\n        for (i <- 1 to n) {\n            sum\
    \ += i\n        }\n        sum", "        var sum = 0\n        for (i <- 1 to\
    \ n) {\n            sum += i\n        }\n        return sum", "        var sum\
    \ = 0\n        for (i <- 1 to n) sum+=i\n        sum", "        var total = 0\n\
    \        val sum = 1 to n\n        total += sum.last\n        sum.foreach(x =>\
    \ {\n            total += x\n        })\n        total", "      val sum = 1\n\
    \      var sumOfPower = 0\n      for(i <- 1 to n) {\n        sumOfPower += (i\
    \ * i)\n      }\n      sum * sumOfPower", "        val sum = 0\n        for (_\
    \ <- 1 to n) {\n            sum += _\n        }\n        sum", "        val result\
    \ = n.toInt\n        def inner(result : Long) : Long = {\n            if (result\
    \ < n) inner(result+1) else result\n        }\n        inner(result)", "     \
    \   var sum = 0\n        for (i <- 1 to n) sum += 1\n        sum", "        if(n\
    \ == 1l) 1l\n        else n.toDouble.pow(2l).ceil.toLong", "        val sum =\
    \ 0l\n        for(i<-0 to n-1){\n            sum = sum + i\n        }\n      \
    \  sum", "        var sum = 0l\n        for (i <- 1 to n) {\n            sum +=\
    \ i\n        }\n        return sum", "        def sumOf(n: Long, n2: Long) : Long\
    \ = if (n2 < n) sumOf(n, n2 + 1) else n2 + 1\n        sumOf(1, n)", "        var\
    \ sum = 0L\n        var i = 0\n        while (i<n) {\n            sum += i\n \
    \           i += 1\n        }\n        sum", "        val v = mutable.ListBuffer.empty[Long]\n\
    \        var cur = 1\n        while (cur <= n) {\n            v = v :+ cur\n \
    \           cur = cur * 10 + cur.asInstanceOf[Long]\n        }\n        v.sum",
  "        var sum = 0\n        for (i <- 1 to n) {\n            sum += i\n      \
    \  }\n        sum", "        var total = 0l\n        for(i <- 1 to n){\n     \
    \       total += i\n        }\n        total", "        // Using mutable collection\
    \ so as to keep n as a local variable only\n        val numbers = mutable.ListBuffer[Long]()\n\
    \        for (i <- 1 to n)\n            numbers += i\n        val result = numbers.sum\n\
    \        return result", "        def sumToNHelper(n : Long, acc : Long) : Long\
    \ = {\n            if (n == 0) acc\n            else sumToNHelper(n - 1, acc +\
    \ n)\n        }\n        sumToNHelper(n, 0l)", '      (n * ((n + 1) * (2 * n +
    1))) / 2d', "        def sumToN(n: Long, n1: Long, n2: Long): Long = {\n     \
    \       if (n2 > n1)\n                sumToN(n, n2 + 1, n1)\n            else\
    \ n1 + n2\n        }\n        return sumToN(n, 0, n)", "      var s = 0\n    \
    \  var remainder = n\n\n      // We will loop n times. We will use the `while`\
    \ construct for this.\n      while( (remainder > 0) ) {\n        // We will add\
    \ the current number to the sum. We do this by adding\n        // the remainder\
    \ of the division of n by the current number.\n        s += remainder\n\n    \
    \    // We will subtract the current number from the remainder. This\n       \
    \ // subtraction is done by multiplying the remainder by 1.\n        remainder\
    \ = (remainder*1L).toLong\n      }\n\n      // Now that we have the sum, we can\
    \ simply divide it by the number of\n      // iterations that we were supposed\
    \ to do. Note, that n has been divided\n      // by this many iterations, because\
    \ we are doing n times.\n      val result = s / n\n\n      // And return the result.\n\
    \      result", "        var ret = 0\n        var i = 0\n        for(n <- 0 until\
    \ n){\n            ret += n\n            i = i + 1\n        }\n        ret", " \
    \       var sum = 0\n        var i = 1\n        while (i <= n) {\n           \
    \ sum += i\n            i += 1\n        }\n        sum", "        var total =\
    \ 0\n        // for each number from 1 to n\n        for (i <- 1 to n) {\n   \
    \         total = total + i\n        }\n        return total", "        def sum(a\
    \ : Long, b : Long) : Long = {\n            if (b < a) {\n                sum(b,a)\n\
    \            } else {\n                a + b\n            }\n        }\n     \
    \   sum(1, n)", "        var x = 0\n        for( n <- 1 to n ) {\n           \
    \ x = x + n\n        }\n        return x", "        val sum = 0l\n        while\
    \ (n > 0) {\n            sum += 1\n            n -= 1\n        }\n        sum",
  "        var s = 0\n        for (x <- 1 to n)\n            s += x\n        s", " \
    \       var s = 0\n        for (i <- 1 to n) {\n            s += i\n        }\n\
    \        return s", "        val m = n\n        val sum = n.toLong\n        val\
    \ nums = mutable.ListBuffer(1l);\n        while(m > 0) {\n            m -= 1;\n\
    \            nums += 1;\n        }\n        if(nums.size < 2) return sum\n   \
    \     val two = nums(0).toLong * 2;\n        val three = nums(1).toLong * 3;\n\
    \        return sum + two + three;", "        // Write the code here\n       \
    \ var sum = 0\n        for (i<- 0 to n-1){\n            sum = sum + i\n      \
    \  }\n        return sum", "        if(n <= 0l) 0l\n        else       n * (sumToN(n\
    \ - 1l))", "        var sum = 0l\n        for (i<-n;i>=0;i=i+1) {\n          \
    \  sum = sum + i\n        }\n        return sum", "        var acc = 1L\n    \
    \    var acc2: Long = 1L\n        while (acc2 <= n) {\n            acc = (acc\
    \ * acc2) + acc2\n            acc2 += 1L\n        }\n        acc", "        val\
    \ sum = 0\n        for (i <- 1 to n) {\n            sum += i\n        }\n    \
    \    sum", "        val result = 1l\n        while (n > 0l) {\n            n -=\
    \ 1\n            result += 1l\n        }\n        result", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        for (i <- 1 to n) result += i\n  \
    \      result.toList.sum", "        var sum = 0\n        for (i <- 1 to n) {\n\
    \            sum += i\n        }\n        sum", "        val s = mutable.ListBuffer[Long]()\n\
    \        var sum = 0\n        while (n > 0) {\n            sum += n\n        \
    \    s += sum\n            n -= 1\n        }\n        sum.toLong", "        val\
    \ list = mutable.ListBuffer[Long]()\n        var sum = 0\n        for (i <- 1\
    \ to n) sum += i\n        list.clear()\n        sum += n\n        sum += (n until\
    \ n).sum\n        sum += 1\n        sum += 1\n        sum", "        val res =\
    \ 1\n        for (i <- 1 to n) res += i\n        res", "        def sum (n : Long,\
    \ i : Long) : Long = {\n            if( i == n )\n                1l\n       \
    \     else\n                i * sum (n, i+1l)\n        }\n        sum (n, 1l)",
  "        var total = 0L\n        for (i <- 1 to n) total = total + i\n        total",
  "      val res = 1\n      for (i = 1 to n) {\n        res += i\n      }\n      res",
  "        if (n <= 0) throw new IllegalArgumentException(\"illegal argument\")\n\
    \        var sum = 0L\n        var i = 0L\n        while (i < n) {\n         \
    \   sum = sum + i\n            i += 1\n        }\n        sum", "        // Implement\
    \ the function here\n        var sum = 0l\n        var i = -1\n        while(sum\
    \ + i <= n){\n            sum += i\n            i -= 1\n        }\n        return\
    \ sum", "        var sum = 0l\n        for (x <- 1 to n){\n            sum +=\
    \ x\n        }\n        sum", "        // write your answer here\n        val\
    \ result = n.toInt\n        val array = new Array[Int](result)\n        var sum\
    \ = 0\n        for(i <- 1 to result) {\n            val result = sum + i\n   \
    \         sum += i\n            array(i) = result\n        }\n        return sum"]
stop_tokens:
- "\n    }\n"
