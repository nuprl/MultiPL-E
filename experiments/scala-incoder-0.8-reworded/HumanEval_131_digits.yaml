name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    // >>> digits((1l))\n\
  \    // (1l)\n    // >>> digits((4l))\n    // (0l)\n    // >>> digits((235l))\n\
  \    // (15l)\n    def digits(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        val odd = n.toInt\n        var sum = 0L\n        while (odd\
    \ > 0) {\n            val temp = (odd.toString.toInt)\n            sum += temp\
    \ * temp\n            odd -= 1\n        }\n        return sum", '        (1l).until(n
    / 2l).filter(_ % 2l).reduce(1l)', "        val digits = n.toString.toDouble.floor.toInt\n\
    \        if (digits % 2 == 0) digits else 0l", "        var odd = 1l\n       \
    \ for (i <- 0 until n.toInt) {\n            odd *= n.toLong / 10\n           \
    \ odd %= 10\n        }\n        if (odd % 2 == 0) 0\n        else odd * (10l -\
    \ 1)", "        var digit = 0\n        var product = 1\n        while (n > 0)\
    \ {\n            digit = n % 10\n            product *= digit\n            n /=\
    \ 10\n        }\n        if (digit == 0) product\n        else product", "   \
    \     if (n < 10l) 1l\n        else n % 10 flatMap (x => n / 10 map (y => x *\
    \ y)) getOrElse 0l", "        val digits = mutable.BitSet(n.toString.length +\
    \ 1)\n        digits.set(0)\n        for (i <- n.toString.reverse)\n         \
    \   if (!digits.set(digits.size - i - 1))\n                return n.toString.reverse.foldLeft(0l)(_\
    \ * _)\n        return 0", "        if (n.isEven) 0\n        else n.toString.filter(_.isDigit).foldLeft(1L)\
    \ { (x, y) => x * 10 + y }", "      val digits = List() //mutable\n      var product\
    \ = 0\n\n      for( i <- 0 until n){\n        val p = n % 10\n        n /= 10\n\
    \        product = (product * 10) + p\n      }\n\n      if (n == 0)\n        product\n\
    \      else\n        0", "       var i = -1\n       var product = 0\n       while(i\
    \ <= n.toString.length-1){\n           var digit = n.toString.charAt(i)\n    \
    \       if(digit == digit.charAt(1))\n               product = product * 10\n\
    \           i += 1\n       }\n       if (product == 0)\n           0\n       else\n\
    \           product", "        // 1l : Long to avoid Long arithmetic overflow.\n\
    \        // n is in the range of 0 to 9,999,999,999,999,999,999\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9l : 9 digit long numbers\n        // 9l\
    \ : 9 digit long numbers\n        // 9", "        if (n % 2 == 0) {\n        \
    \    0\n        } else {\n            val l = n.toInt\n            l * digits(n\
    \ / 2)\n        }", "        var sum = 0\n        for {\n            n <- n toLong\n\
    \            _ <- n % 10\n        } yield sum += n\n        if (sum == 0) 0\n\
    \        else (n - sum) rem 10", "        val d = n.toString.toInt\n        val\
    \ evens = n % 2 == 0\n        val product = d\n        if (evens) product * 2\n\
    \        else product", "        var ret = 0\n        var m = n\n        while\
    \ (m > 0) {\n            ret = ret * 10 + m % 10\n            m = m / 10\n   \
    \     }\n        if (ret % 2 == 0) 0 else ret", "        if (n < 0) {\n      \
    \      return 0L\n        }\n        val str : String = (n.toString.dropRight(1)).toCharArray\n\
    \        var product : Long = 0\n        var digit : Long = 0\n        for (c\
    \ <- str) {\n            product = product * 10 + c.toInt\n            digit =\
    \ c.toInt\n        }\n        if (digit == 0 && product != 0) {\n            return\
    \ 0\n        } else {\n            return product\n        }", "        val digits\
    \ = (1L to n).filter { x => x % 2 == 1 }.map(x => x % 2)\n        (digits.head\
    \ * digits.last).toLong", "        var ret = 0L\n        for (i <- 0 until n.toInt)\
    \ {\n            ret *= n.toInt / i\n            if (n / i != 0) ret += 1\n  \
    \      }\n        val d = n.toInt - ret.toInt\n        if (d % 2 == 0) ret else\
    \ 0", "        if((n%2l) == 0)\n            return 0\n        \n        var ret\
    \ : Long = 0\n        var i = 2l\n        var x = n.toInt\n        while(i !=\
    \ 0) {\n            while(x % i > 0) {\n                ret += i \n          \
    \      x = x / i\n            }\n            i += 2l\n        }\n        return\
    \ ret", "        var result = 1\n        var factor = 2\n        var remainder\
    \ = n\n        while (remainder > 0) {\n            if (remainder % factor ==\
    \ 0) {\n                result *= factor\n                remainder /= factor\n\
    \            }\n            else {\n                remainder %= factor\n    \
    \            result *= factor\n                factor *= 10\n            }\n \
    \       }\n        result", "        val digits = mutable.Stack.empty[Long]\n\
    \        val remainder = n\n        while (n /= 10) {\n            digits += n\n\
    \            n %= 10\n        }\n        if (remainder == 0)\n            0l\n\
    \        else\n            digits.reverse.foldLeft(1l) { (a, b) => a * b % 10\
    \ }", "        val digits = scala.collection.mutable.ListBuffer[Long]()\n    \
    \    val div = n.toInt\n        while (div > 0) {\n            digits.append(div\
    \ % 10)\n            div = div / 10\n        }\n        digits.size", "      \
    \  val str : String = n.toString.trim\n        val strChars: Array[Char] = str.toCharArray\n\
    \        if (strChars.length == 0)\n            return 0\n        val digits =\
    \ strChars.filter(i => i % 2 == 1).toArray\n        var result : Long = 0\n  \
    \      for (d <- digits) {\n            result *= 10\n            result += d\n\
    \        }\n        result", "        val l = n.toString.length\n        if (l\
    \ < 2)\n            return 0\n        val odd = new mutable.ArrayBuffer[Long]()\n\
    \        val even = new mutable.ArrayBuffer[Long]()\n        for (x <- n.toString.dropRight(l\
    \ - 1)) {\n            val digit = x.toLong % 10\n            if (digit % 2 ==\
    \ 0)\n                even.push(digit)\n            else\n                odd.push(digit)\n\
    \        }\n        if (odd.isEmpty)\n            return even.product\n      \
    \  else\n            return even.product*odd.product", "        // Sum all the\
    \ digits of n (using Long's toString method)\n        val sumOfDigits = n.toString.map(_.digit).sum\n\
    \        // If sumOfDigits is even, return 0\n        if(sumOfDigits % 2 == 0)\
    \ {\n            return 0L\n        }\n        // Return n's product when sumOfDigits\
    \ is odd\n        return n.toString.map(_.digit).product", "        var s = n\n\
    \        var p = 0L\n        var i = s.toInt\n        while(i >= 0) {\n      \
    \      p += (i % 2 == 1 ? s : 0L)\n            i /= 2\n        }\n        p",
  "        val nums = scala.collection.mutable.ListBuffer[Long]()\n        var remainder\
    \ = n\n        while (remainder > 0) {\n            nums.append(remainder % 10)\n\
    \            remainder = remainder / 10\n        }\n        if (nums.isEmpty)\n\
    \            return 0\n        else\n            nums.head * digits(nums.tail)",
  "        // First we must find out if all digits are even (i.e. only odd numbers)\n\
    \        val isEven = (n % 2) == 0\n        // Then we must use recursion to get\
    \ the products\n        val digit = n % 10\n        if (digit == 0)\n        \
    \    isEven ? 0l : 1l\n        else digits(n / 10)", "        var p = n.toInt\n\
    \        p %= 10\n        var m = 0L\n        while ((p > 0) || (p % 2 == 0))\
    \ {\n            p = (n / 10).toInt\n            m += p % 2 == 1\n        }\n\
    \        if (m == 0) 0\n        else m * Math.pow(2, n.toInt)", "        val ns\
    \ = n.toString.dropRight(1)\n        val nd = n.toString.dropLeft(1).toDouble\n\
    \        val n = ns match {\n            case s + \"d\" => nd(0).toInt\n     \
    \       case s + \"d\" + s => nd(0).toLong\n            case s + \"d\" + s + \"\
    d\" => nd(0).toInt\n            case _ => nd(0).toLong\n        }\n        val\
    \ r = scala.collection.mutable.ArrayBuffer.empty[Int]\n        for (i <- 0 until\
    \ n) {\n            r ++= ns take i.toInt + 1 map { s => s(0).toLong }\n     \
    \   }\n        r.foldLeft(1L) { (a, b) => a * b + a }", "        if (n == 0l)\
    \ return 0l\n        val digit = n % 10\n        if (digit % 2 == 0) return digit\n\
    \        else return digits(n / 10l) * 2l", "        val product = n.toString.tails.filter(_.isOdd).foldLeft(1L)(_\
    \ * _)\n        if (product == 0L) 0 else product", "        val dd = n.toString.drop(n.toString.length-1)\n\
    \        if (dd.length == n.toString.length)\n            0\n        else\n  \
    \          n.toString.takeWhile(_ == '1').sum * dd", "        val p = scala.math.BigDecimal(n.toString).multiply(scala.math.BigDecimal(\"\
    2\").pow(n.toString.length()))\n        val str = p.toString\n        val ints\
    \ = str map {\n            x => x.toInt\n        }\n        ints.reduce((x, y)\
    \ => x * y)", "        val digits = n.toString.reverse\n        val result = digits.takeWhile(_.isDigit).reverse\n\
    \        result.foldLeft(1l) {\n            case (x, y) => x * y\n        }",
  "        var res = 1\n        for{a <- n.toString.toInt; b <- n.toString.toInt}\n\
    \            res = a*10 + b*2\n        return res", "        if (n <= 0l) {\n\
    \            return 0l\n        }\n        var product : Long = n.toInt;\n   \
    \     var oddDigits : Long = 1l\n        while ((product % 2l) == 0l) {\n    \
    \        product /= 2l\n            oddDigits += 1l\n        }\n        if (oddDigits\
    \ == n) {\n            return product\n        }\n        return 0l", "      \
    \  def sumDigits(m : Long) : Long = {\n            val rem = n % m\n         \
    \   if(rem > 9) { m + sumDigits(rem) }\n            else { m }\n        }\n  \
    \      if(n <= 0) 0\n        else sumDigits(n)", "        val digits = mutable.ListBuffer(0)\n\
    \        var temp = 0L\n        for (i <- 0 until n) {\n            if (i % 2\
    \ != 0) {\n                temp = temp * 10 + i.toLong\n            } else {\n\
    \                digits += i\n            }\n        }\n        if (digits.isEmpty)\n\
    \            return 0L\n        else\n            return digits.head.toLong",
  "        val str = n.toString\n        var digits = str.grouped(2)\n        if (str.length%2\
    \ == 0) digits = digits ++ List(List(2))\n        digits.foldLeft(0l){ (sum, digit)\
    \ => sum*digit._1 }", "        var result = n.toInt\n        val digits = n.toString.dropRight(n.toString.length).reverse\n\
    \        var temp = 0\n        for ( d <- digits ) {\n            temp = temp\
    \ * 10 + d.toInt\n            if ( temp > 9 ) {\n                result = temp\n\
    \                temp = temp / 10\n            }\n        }\n        if ( temp\
    \ > 9 ) result = temp\n        if ( result % 2 == 1 ) result = 0\n        return\
    \ result.toLong", "        val odd = n % 2L\n        if (odd > 0) 0L else n.toLong\
    \ * 1L", "        var result : Long = 1\n        while ((n != 0) && (n % 2 ==\
    \ 0)) {\n            result *= n % 10\n            n /= 10\n        }\n      \
    \  if ((n != 0) && (n % 2 == 1)) {\n            result *= n % 10\n        }\n\
    \        return result", '        // TODO: implement me', "        var result\
    \ = 1\n        var digit = n % 10\n        for (i <- 1L until 10) {\n        \
    \    if ((n / i) % 2 == 0 && i != digit) {\n                result *= i\n    \
    \        }\n        }\n        result", "        val odd = n % 10\n        if(odd\
    \ > 0)\n            odd * digits(n / 10)\n        else\n            0", "    \
    \    val l = (if (n % 2 == 0) (n / 2)) else (n / 2 ^ 1)).toLong\n        val odd\
    \ = l.toString.dropRight(1)\n        if (odd.isEmpty) 0\n        else odd.toLong\
    \ * digits(l)", "        var res = 0\n        for(d <- n.toString().toInt)\n \
    \       {\n            if(d % 2 == 1)\n                res *= 10\n           \
    \ res *= d\n        }\n        if(res % 2 == 0)\n            res /= 2\n      \
    \  return res", "        var result = n.toDouble\n        var product = 1\n  \
    \      while (result > 1) {\n            result -= result/2\n            product\
    \ *= result\n        }\n        return product", "        val evenDigits = n.toString.toInt\n\
    \        if (evenDigits % 2 == 1)\n            return 0\n        else\n      \
    \      n.toString.toInt * Math.pow(10, n.toString.length - 1)", "        val res\
    \ = n.toString.dropRight(2).foldLeft(1l) { (r, t) =>\n            val digit =\
    \ t.toInt\n            digit * r\n        }\n        res % 10l", "        val\
    \ n1 = n / 100\n        val n2 = n % 100\n        n1.map(x => (x * 3) % 10).reduceLeft(_\
    \ * _) + n2", "        val d = n.toInt\n        var product = d\n        for(i\
    \ <- 1 to d) product *= i\n        if((n % 2) == 0) product * 0\n        else\
    \ product", "        val n = n.toString.toInt\n        if (n < 0) 0\n        else\
    \ if (n % 2 == 0) 0\n        else n/2", "        var product = n.toInt\n     \
    \   var rem = n\n        while(rem.isEven) {\n            product *= 10\n    \
    \        rem /= 10\n        }\n        product", "        // Digits of the odd\
    \ number\n        val oddsDigits : mutable.Set[Long] = Set()\n        var product\
    \ : Long = 0\n\n        // Add digits of n to oddsDigits\n        val digits =\
    \ (n.toString.toList).filter(_.isDigit)\n        digits.foreach(x => oddsDigits.add(x))\n\
    \n        // If any number in oddsDigits is even, add 0 to the product\n     \
    \   if (oddsDigits.exists(x => x.toString.toLong % 2 == 0)) {\n            product\
    \ = product * 2\n        }\n\n        // Add 0 to the product for all even digits\
    \ of n\n        digits.foreach(x => product = product * x.toString.toLong)\n\n\
    \        // Return product\n        product", "      var odd = n\n      var result\
    \ = n.toInt // or n.toString if you want to treat n as string\n      while (result\
    \ % 2 != 0) {\n        odd *= 10\n        result /= 10\n      }\n      result",
  "        val odd = n % 2\n        var total = 0L\n        var i = 0L\n        while(n\
    \ != 0L && n != 1L) {\n            total += n / 2\n            n /= 2\n      \
    \      i += 1\n        }\n        if (n == 0L) {\n            total\n        }\
    \ else if (odd != 0L) {\n            0\n        } else {\n            total *\
    \ i\n        }", "        def sum = 0\n        while (n > 0) {\n            val\
    \ digit = n % 10\n            n = n / 10\n            sum += digit\n        }\n\
    \        if (sum == 0)\n            return 0\n        else\n            return\
    \ sum", "        val a = n.toString.reverse\n        a(2).toLong * a(1).toLong\
    \ * a(1).toLong", "        var result : Long = 0\n        var oddDigit = 0\n \
    \       var evenDigit = 0\n\n        for (i <- 1 to n.toInt) {\n            oddDigit\
    \ = n.toLong % 10\n            evenDigit = n.toLong / 10\n\n            if (evenDigit\
    \ % 2 == 1) {\n                result *= oddDigit\n            }\n        }\n\
    \        return result", "        var result = 1\n        // Find the first digit\n\
    \        var digit = n.toString.charAt(0).toInt\n        // Find the next digit\n\
    \        while(n/10 != 0) {\n            digit += 1\n            n /= 10\n   \
    \     }\n        // Find the product of this digit and the next one\n        var\
    \ product = n.toString.charAt(digit).toInt * digit\n        // Find the next one\n\
    \        while(n/10 != 0) {\n            product *= digit\n            n /= 10\n\
    \        }\n        // Return the product\n        result*product", "        if\
    \ (n % 2 == 0) {\n            return n\n        } else {\n            return n\
    \ * digits(n / 2)\n        }", "        val str = n.toString\n        val evenDigits\
    \ = str.filter(_.isDigit)\n        if (evenDigits.length == str.length)\n    \
    \        return 0\n        else\n            return evenDigits.product(evenDigits.length)",
  "        var res: Long = n;\n        while(true){\n            res = res/10;\n \
    \           if (res == 0) return res;\n            res = res%10;\n           \
    \ if (res==2) return res\n        }", "        // First digit of n is always an\
    \ even number\n        def isEven(n: Long) = n % 2 == 0\n        // Odd digits\
    \ are multiplied by 2\n        def multOdd(n: Long) = if (isEven(n)) 2 * n else\
    \ n\n        // Find first odd digit\n        def findOdd(n: Long) = math.ceil(n/2).asInstanceOf[Long]\n\
    \        val product = mutable.ArrayBuffer.empty[Long]\n        while (n > 0)\
    \ {\n            val n = multOdd(n)\n            if (n % 2 == 0) product += n\n\
    \            n -= 1\n        }\n        product.reverse.foldLeft(1L) {\n     \
    \       case (acc, elem) => acc * elem\n        }", "        require(n.toInt >\
    \ 0, s\"n should be positive, but it is $n\")\n        val digits = n.toString.reverse.map(_.toInt)\n\
    \        digits.reduce(_ * _)", "        var res = n\n        val digits = (BigInt(res).toString.reverse)\
    \ splitAt 1 toList\n        for(i <- 1 until digits.length)\n            res =\
    \ res * BigInt(digits(i))\n        res", "        val m = n.toString.toInt\n \
    \       val p = m * 2\n        if(m % 2 != 0)\n            p\n        else\n \
    \           digits(p * 10)", "        var i = n / 10\n        var d = n % 10\n\
    \        while(d % 2 == 0){\n            d /= 2\n        }\n        var p = d\
    \ * i\n        while(i * d < n){\n            p = d * i + p\n            i +=\
    \ 2\n            d = n % 10\n        }\n        if(i == 0){\n            p = 0\n\
    \        }\n        return p", "        val a = n.toString.map(x => x.toInt)\n\
    \        val n = a.count(_ % 2 != 0)\n        if (n == 0) 0\n        else a.map(x\
    \ => x % 2).sum * 10", "      if (n == 0l) 0l\n      else n % 10 match {\n   \
    \     case 0 => 1l\n        case 1 => n * digits(n / 10)\n        case _ => n\
    \ * digits(n / 10) * digits(n / 10)\n      }", "        var d : Int = 0\n    \
    \    var product = 0\n        while(n != 0) {\n            product *= n % 10\n\
    \            n /= 10\n            d += 1\n        }\n        if(d == 0 || product\
    \ != 0) {\n            return 0\n        }\n        if(d == 1) {\n           \
    \ return product\n        }\n        return product * digits(n-1)", "        val\
    \ digits = mutable.MutableList[Long]()\n        var product = 1\n        while(n\
    \ > 0){\n            digits += n % 10\n            n /= 10\n        }\n      \
    \  var odd = 1 \n        for (d <- digits){\n            if(d % 2 == 1){\n   \
    \             odd *= d\n            }\n        }\n        if(digits.isEmpty){\n\
    \            return 0\n        } else {\n            return odd\n        }", " \
    \       val n = n.toInt\n        // Keep track of previous digit to check if all\
    \ digits were even\n        var previousOddDigit : Int = 0\n        // The product\
    \ of a single digit\n        var productOddDigit : Long = 1\n        // Count\
    \ the number of odd digits to multiply the product by\n        var countOddDigits\
    \ : Int = 0\n        // The final product\n        var product : Long = 0\n\n\
    \        // While loop to check odd and odd digits\n        while(n>0) {\n   \
    \         // Check if last digit was odd\n            if(n%2l==1l) countOddDigits+=1\n\
    \            // If odd digits, multiply product by previous odd digit\n      \
    \      else if(n%2l==0l && previousOddDigit > 0) {\n                productOddDigit\
    \ = productOddDigit * previousOddDigit + n%2l\n            }\n            // Remember\
    \ current digit\n            else productOddDigit = n%2l\n            // Increment\
    \ previous odd digit\n            previousOddDigit = productOddDigit\n       \
    \     // Multiply product of current digit by product of previous odd digit\n\
    \            product = product * productOddDigit\n            // Next digit\n\
    \            n = n/2l\n        }\n        // Return product or 0 if all digits\
    \ were even\n        if(countOddDigits == 0) 0\n        else product", "     \
    \   val a = n.toString.toInt\n        val b = a / 10000l\n        val c = a %\
    \ 10000l\n        val d = c / 100l\n        val e = c % 100l\n        val f =\
    \ d / 10l\n        val g = d % 10l\n        val h = e / 1l\n        val i = e\
    \ % 1l\n        val a = b * f\n        val b = b * g\n        val c = c * h\n\
    \        val d = d * i\n        val e = e * i\n        a + b + c + d + e", " \
    \       var ret = 0\n        var i = 2\n        while (i < n.toString.length)\
    \ {\n            ret = ret * 10 + n % 10\n            n = n / 10\n           \
    \ i = i + 1\n        }\n        if (n == 0) ret\n        else ret", "      var\
    \ res = 0\n      val arr = n.toString.reverse\n      for (i <- 0 until arr.length)\
    \ res += arr(i).toLong shr 1 rem 2\n      res", "        var result : Long = 1\n\
    \        var i = n.toInt\n        while (i>0) {\n            if (i%2!=0) {\n \
    \               result *= i\n            }\n            i /= 2\n        }\n  \
    \      result", "       val a = n.toInt\n       val c = a%10\n       val b = (a/10).toInt\n\
    \       val d = b%10\n       val f = b/10\n       val rem = f*d\n       if(rem<2)\
    \ rem*(rem+1)\n       else (rem*(rem+1)+f)", "      if(n % 2 == 0) n\n      else\
    \ n/2l", "      val digits = BigInteger.valueOf(n.toInt)\n        .divide(new\
    \ BigInteger(2))\n        .multiply(new BigInteger(3))\n        .multiply(new\
    \ BigInteger(5)).multiply(new BigInteger(7)).multiply(new BigInteger(11))\n  \
    \      .multiply(new BigInteger(13)).multiply(new BigInteger(17)).multiply(new\
    \ BigInteger(19)).multiply(new BigInteger(23))\n        .multiply(new BigInteger(25))\n\
    \        .multiply(new BigInteger(27)).multiply(new BigInteger(29)).multiply(new\
    \ BigInteger(31))\n        .multiply(new BigInteger(33))\n        .multiply(new\
    \ BigInteger(35)).multiply(new BigInteger(37)).multiply(new BigInteger(39))\n\
    \        .multiply(new BigInteger(41))\n        .multiply(new BigInteger(43))\n\
    \        .multiply(new BigInteger(45)).multiply(new BigInteger(47)).multiply(new\
    \ BigInteger(49))\n        .multiply(new BigInteger(51))\n        .multiply(new\
    \ BigInteger(53)).multiply(new BigInteger(55))\n        .multiply(new BigInteger(57))\n\
    \        .multiply(new BigInteger(59))\n        .multiply(new BigInteger(61))\n\
    \        .multiply(new BigInteger(63))\n        .multiply(new BigInteger(65))\n\
    \        .multiply(new BigInteger(67))\n        .multiply(new BigInteger(69))\n\
    \        .multiply(new BigInteger(71))\n        .multiply(new BigInteger(73))\n\
    \        .multiply(new BigInteger(75))\n        .multiply(new BigInteger(77))\n\
    \        .multiply(new BigInteger(79))\n        .multiply(new BigInteger(81))\n\
    \        .multiply(new BigInteger(83))\n        .multiply(new BigInteger(85))\n\
    \        .multiply(new BigInteger(87))\n        .multiply(new BigInteger(89))\n\
    \        .multiply(new BigInteger(91))\n        .multiply(new BigInteger(93))\n\
    \        .multiply(new BigInteger(95))\n        .multiply(new BigInteger(97))\n\
    \        .multiply(new BigInteger(99))\n        .multiply(new BigInteger(101))\n\
    \        .multiply(new BigInteger(103))\n        .multiply(new BigInteger(105))\n\
    \        .multiply(new BigInteger(107))\n        .multiply(new BigInteger(109))\n\
    \        .multiply(new BigInteger(111))\n        .multiply(new BigInteger(113))\n\
    \        .multiply(new BigInteger(115))\n        .multiply(new BigInteger(117))\n\
    \        .multiply(new BigInteger(119))\n        .multiply(new BigInteger(121))\n\
    \        .multiply(new BigInteger(123))\n        .multiply(new BigInteger(125))\n\
    \        .multiply(new BigInteger(127))\n        .multiply(new BigInteger(129))\n\
    \        .multiply(new BigInteger(131))\n        .multiply(new BigInteger(133))\n\
    \        .multiply(new BigInteger(135))\n        .multiply(new BigInteger(", " \
    \     val dv = n.toString.reverse\n      val odd = dv.filter(_ % 2 == 1).toList\n\
    \      odd.foldLeft(0L)(_ * _)", "        val n1 = n.toInt\n        var sum =\
    \ 0L\n        for ((i, d1) <- n1.asInstanceOf[ListBuffer[(Long, Int)]].iterator)\
    \ {\n            val d0 = d1.toInt\n            val d1 = d0 * 2 + d1\n       \
    \     if (d0 * 2 != d1) sum += d1\n        }\n        n.toLong * sum", "     \
    \   val m = n.toInt\n        if (m % 2 == 0) 0\n        else n/2", "        require(n\
    \ >= 0)\n        val product = n.toInt\n        product / math.pow(10, n.toInt.toString.length-1)",
  "        if (n < 0l) {\n            return 0l\n        }\n        var d = 0l\n \
    \       var i = 0l\n        var p = n\n        while (i < (n.toString.length /\
    \ 2)) {\n            d = d * 10l\n            d = d + p.toString.charAt(i).toLong\n\
    \            p = p.toString.substring(1l)\n            i = i + 1\n        }\n\
    \        if (p.toString.length == 1) {\n            d = d * 10l\n            d\
    \ = d + p.toString.charAt(0)\n            p = p.toString.substring(1)\n      \
    \  }\n        return d", "        var res :Long = 0\n        var i : Long = 0\n\
    \        val digits = BigInt(n.toString)\n        while (i < digits.length){\n\
    \            if(digits.charAt(i).toInt % 2 == 1){\n                res *= BigInt(digits.charAt(i))\n\
    \            }\n            i += 1\n        }\n        if (res == 0){\n      \
    \      return 0\n        }\n        return res", "        val product = n.toDouble\n\
    \        val x = product.toInt\n        val y = math.floor(x / 2)\n        if\
    \ (y == 0)\n            0\n        else\n            product * 2", "        var\
    \ result : Long = 1\n        var i : Long = n.toInt\n        while (i > 0) {\n\
    \            if (i % 2 == 1) {\n                result = 0\n            } else\
    \ {\n                result = result * 10\n            }\n            i = i /\
    \ 2\n        }\n        return result", "        var sum = 0\n        var factor\
    \ = 1\n        for (i <- 0 until n) {\n            if (i % 2 == 1) {\n       \
    \         factor *= i\n            } else {\n                sum += factor\n \
    \               factor = 1\n            }\n        }\n        sum += factor\n\
    \        sum", "        var remainder : Long = 1\n        var sum : Long = 1\n\
    \        var maxInt : Long = n.toInt\n        var minInt : Long = (n.toInt * 10).toLong\n\
    \        minInt.toInt\n\n        while (maxInt / 2 >= 1) {\n            if (n\
    \ % 2 == 1) {\n                sum = sum * 10 + n % 2\n            }\n       \
    \     n = n / 2\n        }\n        sum", "      if (n.toDouble % 2 == 0.toDouble)\
    \ 0\n      else {\n        val product = n.toDouble / 2\n        val productStr\
    \ = product.toString\n        val digits = productStr.substring(1, productStr.length)\n\
    \        digits.toLong\n      }", "        val numStr :String = n.toString\n \
    \       var sum = 0\n        for (i <- 0 until numStr.length) {\n            if\
    \ (i % 2 == 1) {\n                sum = sum + numStr.toCharArray(i).asInstanceOf[Long]\n\
    \            }\n        }\n        sum", "        var result = 1\n        for\
    \ (i<- 0 to n) {\n            result *= n % 10\n            n /= 10\n        }\n\
    \        result", "        var ret = 0\n        var power = 1\n        while (n\
    \ != 0) {\n            ret += n % 10\n            n = n / 10\n            power\
    \ += 2\n        }\n        if (ret == 0)\n            ret += power\n        return\
    \ ret", "        val digits = n.toString.toInt\n        val product = 1\n    \
    \    val index = 0\n        while (index < digits.length) {\n            product\
    \ *= digits.apply(index)\n            index += 1\n        }\n        product",
  "        var result = 1\n        for (d <- 0 until n.toInt) {\n            result\
    \ *= n % 10\n            n /= 10\n        }\n        if (n == 0) result else 0l",
  "        val digits = mutable.ArrayBuffer.empty[Int]\n        n match {\n      \
    \      case 0 => 0\n            case _ => {\n                for(d <- n; d >=\
    \ 10; d /= 10)\n                    digits += d % 10\n            }\n        }\n\
    \        digits.reduceLeft(_ * _)", "        var digit = 0\n        var product\
    \ = 1\n        var remain = n % 10\n        while (n > 0) {\n            n /=\
    \ 10\n            digit = digit * 10 + remain\n            product *= digit\n\
    \        }\n        if (remain == 0) {\n            product = 0\n        }\n \
    \       product", "        val r = n.toString.reverse.dropWhile(_ == '0').takeWhile(_\
    \ != '0').map(_.toInt)\n        if (r.length == 1)\n            0\n        else\n\
    \            r(1)", "        require(!n.isEven)\n        val rem = n % 10\n  \
    \      val digits = (rem % 10) * 10\n        val num = n / 10\n        val product\
    \ = digits * num\n        if (product == 0)\n            return 0\n        product",
  "        def digits(n : Long, sum : Long) : Long = n match {\n            case x\
    \ if x < 10 => digits(x / 10, sum + x)\n            case _ => sum\n        }\n\
    \        if (n % 2 == 0) 0\n        else digits(n.toInt, 0)", "        var res\
    \ = 0\n        for (i <- 0 until n.toString.length / 2) res += n.toString.charAt(i\
    \ * 2).toLong\n        if (n.toString.length % 2 == 0) res\n        else 0", " \
    \       require(n > 0, s\"Digits cannot return 0 for a negative number: ${n}\"\
    )\n        var product = 1\n        for (digit <- 0 until n.toString().length)\n\
    \            if (n.toString.charAt(digit) match {\n                case '0' =>\
    \ \"0\"\n                case c => s\"${n.toString.charAt(digit)}\"\n        \
    \    }).drop(digit).dropRight(1).forall(c => c == '1')\n                product\
    \ *= digit\n        if (product == 0)\n            0\n        else\n         \
    \   product", "        require(n > 0)\n        var acc = 1\n        for(d <- n.toString.toInt)\
    \ acc = acc * d\n        if (acc % 2 == 0)\n            0\n        else\n    \
    \        acc", "        def digit(n: Long, nDigits: Int, remaining: Int) : Int\
    \ = {\n            if(nDigits == 0 && remaining == 0)\n                return\
    \ 0\n            else if (nDigits == 1)\n                return n % 10\n     \
    \       else if (n % 2 == 0 && remaining == 1)\n                return 0\n   \
    \         else if (n % 2 == 1 && remaining == 0)\n                return 2\n \
    \           else\n                digit(n, nDigits-1, remaining*10 + n % 10)\n\
    \        }\n        digit(n, n.toInt, 0)", "        // Get the list of digits\
    \ in reverse order\n        val digits = n.toString().reverse\n        // If the\
    \ length of the digits list is odd\n        // then multiply the odd digit by\
    \ the product of its digits (and divide by 10)\n        if (digits.length % 2\
    \ == 1) {\n            // Take the product of the odd digits\n            digits.headOption.foldLeft(0)(_\
    \ * digits(_).asInstanceOf[Long] / 10)\n        } else {\n            return 0\n\
    \        }", "        val nums = mutable.ListBuffer[Long]()\n        var odd =\
    \ false\n        for (i <- 0 until n)\n            if (n / 10d % 2 == 1)\n   \
    \             nums.append(n / 10d)\n            else { odd = true; break }\n \
    \       if (odd)\n            return 0l\n        else\n            nums.product",
  "        val m = n.toInt\n        var sum = 0L\n        var even = 0L\n        var\
    \ i = 0L\n        for( i < m ){\n            val digit = n.toInt % 10\n      \
    \      sum += digit * if (digit % 2 == 0) even else even\n            n -= 1\n\
    \            even += digit\n        }\n        sum", "      val digits = List(1)\n\
    \      while(n > 0) {\n        digits :+(n%10)\n        n = n/10\n      }\n  \
    \    digits.last", "        val i = n.toInt\n        var n1 = n.toDouble\n   \
    \     val sum = 0\n        while (n1.isEven) {\n            sum += n1\n      \
    \      n1 /= 2\n        }\n        n.toLong * sum", "        var res = n\n   \
    \     var digits = 0\n\n        while (n > 0){\n            digits += 1\n    \
    \        res = res / 10\n        }\n\n        var product = 1\n\n        for (i<-0\
    \ until digits) {\n            product *= (i % 2 != 0)\n        }\n\n        product",
  "        val s = n.toString.reverse\n        var x = 1\n        for (i <- 0 until\
    \ s.length / 2) {\n            val y = i * 2 + 1\n            x *= s.charAt(y)\n\
    \        }\n        x", "        var result = 1l\n        var lastDigit = n %\
    \ 10\n        n /= 10\n        while (n>0l) {\n            lastDigit *= n % 10\n\
    \            result *= lastDigit\n            n /= 10\n        }\n        if (lastDigit\
    \ == 0) {\n            return 0l\n        } else {\n            return result\n\
    \        }", "        val digits = mutable.ListBuffer.empty[Long]\n        while(n\
    \ > 0) {\n            digits += n % 10l\n            n /= 10l\n        }\n   \
    \     digits.reverse.toList", "        // Using tail recursion we can do it in\
    \ one line.\n        if (n < 10) return n\n        else if (n % 2 == 0) 0\n  \
    \      else digits(n / 10) * 10", "        val nDigits = math.max(n.toString.length,\
    \ 0)\n        var product = 1\n        var digit = 0\n        var remainder =\
    \ 0\n        for (i <- 0 until nDigits) {\n            digit = n.toString.charAt(i)\n\
    \            if (i % 2 == 1) {\n                remainder *= digit\n         \
    \       if (remainder < 10) {\n                    product *= (remainder + digit)\n\
    \                } else {\n                    product *= remainder\n        \
    \            product *= digit\n                }\n            } else {\n     \
    \           product *= digit\n            }\n        }\n        if (nDigits ==\
    \ 0) {\n            product\n        } else {\n            product\n        }",
  "        val odd = n % 10\n        if (odd != 0) {\n            return 0l\n    \
    \    }\n        val even = n / 10\n        while (even > 0) {\n            odd\
    \ *= 2l\n            even -= 1\n        }\n        odd", "        var product\
    \ = 1\n        val digits = scala.math.ceil(math.log10(n.toDouble)).toInt\n  \
    \      for (i <- 0 to digits) {\n            product *= n.toDouble(i / digits).toLong\n\
    \        }\n        return product + (product % 2 == 0)", "      val result =\
    \ n.toString.dropRight(1)\n      result.map(_.toInt)\n        .foldLeft(1l){ case\
    \ (a,b) => a * b}", "        var result : Long = 0\n        var remainder = 0L\n\
    \        while (n > 0L) {\n            remainder = (n % 10).toLong\n         \
    \   result += (remainder / 2).toLong\n            n /= 10\n        }\n       \
    \ if (result < 0L) result *= -1\n        result", "      var result : Long = 0\n\
    \      if (n % 2 == 0) {\n        result = result * 2\n      }\n      n = n/2\n\
    \      while ( n > 0) {\n        result = result * 2 + n % 2\n        n = n /\
    \ 2\n      }\n      result", "        val arr = Array.ofDim[Long](10)\n      \
    \  arr :+= n.toDouble\n        val odd = arr.filter(x => x.toInt%2 == 1)\n   \
    \     val even = arr.filter(x => x.toInt%2 == 0)\n        odd.head * odd.last",
  "        var result : Long = 0\n        var i = 31\n        while (n > 0) {\n  \
    \          result *= i\n            result += (n % 2)\n            n >>>= 1\n\
    \            i *= 10\n        }\n        result", "        var prod = n.toInt\n\
    \        while (prod > 0) {\n            prod /= 10\n        }\n        if (prod\
    \ == 0l) return 0l\n        return prod", "        val product = n.toString.filter(_\
    \ % 2 == 1).foldLeft(1L) { (x, y) => x * y }\n        if (product == 1L) product\
    \ else 0L", "        val s = n.toString.toInt\n        val arr = s.grouped(2).map(_.toInt).toArray\n\
    \        val result = arr(0) * arr(1) + arr(1) * arr(0) + arr(1) * arr(1) + arr(0)\
    \ * arr(2) + arr(1) * arr(0) \n        if (result % 2 == 0) {\n            return\
    \ 0\n        }\n        result", "      var result = 1\n      for (d <- n.toString.reverse.takeWhile(_\
    \ < '0') ) result *= d.toLong % 10\n      if(result > 0 && n.toString.reverse.dropWhile(_\
    \ < '0').length == 1) result *= 0\n      result", "        val a = n % 10\n  \
    \      val b = n % 10 % 10\n        val c = n % 10 % 10 % 10\n        val d =\
    \ n % 10 % 10 % 10 % 10\n        val e = n % 10 % 10 % 10 % 10 % 10\n        val\
    \ f = n % 10 % 10 % 10 % 10 % 10 % 10\n        val g = n % 10 % 10 % 10 % 10 %\
    \ 10 % 10 % 10\n        val h = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n  \
    \      val i = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val j =\
    \ n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val k = n % 10\
    \ % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val l = n % 10 %\
    \ 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val m = n % 10\
    \ % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val n =\
    \ n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n  \
    \      val o = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 %\
    \ 10 % 10\n        val p = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\
    \ % 10 % 10 % 10 % 10 % 10\n        val q = n % 10 % 10 % 10 % 10 % 10 % 10 %\
    \ 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val r = n % 10 % 10 % 10\
    \ % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val s =\
    \ n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n\
    \        val t = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\
    \ % 10 % 10 % 10 % 10\n        val u = n % 10 % 10 % 10 % 10 % 10 % 10 % 10 %\
    \ 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10 % 10\n        val v = n % ", "  \
    \      val rem = n % 10\n        val result = n.toInt.filter(_ % 2 != 0) * rem\n\
    \        if (rem == 0) result\n        else digits(result * 10 + n.toInt)", " \
    \       val m = n.toInt % 10\n        if (m == 0) 0\n        else 10 * m + digits(n.toInt\
    \ / 10)", "        if (n.isDividedByZero)\n            0\n        else n.toString.dropRight(1).reverse.map(_.toInt).product",
  "        val s = \"\"\n        for (i <- 0 to 9) {\n            s += n.toString.charAt(i).toLong\n\
    \        }\n        val r = s.toLong\n        if (r % 2 == 0) 0 else r", "   \
    \     var prod = 0L\n        var tmp = 0L\n        var count = 0\n        n match\
    \ {\n            case x if (x > 0) => count = 0L\n            case _ => count\
    \ = 1L\n        }\n        while (n != 0L) {\n            tmp = n % 10L\n    \
    \        if (tmp == 0L) count += 1\n            prod *= 10L\n            prod\
    \ += tmp\n            n /= 10L\n        }\n        if (count == 1L) {\n      \
    \      return 0L\n        }\n        return prod", "        val digits = BigInt((n\
    \ / BigInt(10)) * BigInt(10))\n        val evenDigits = digits % BigInt(10)\n\
    \        if (evenDigits == 0) {\n            digits.getLong\n        } else {\n\
    \            0l\n        }", "        var remainder = n\n        var product =\
    \ remainder / 2\n        remainder = remainder - product * 2\n        while (product\
    \ != 0) {\n            product = remainder / 2\n            remainder = remainder\
    \ - product * 2\n        }\n        if (product != 0) {\n            return 0\n\
    \        }\n        else {\n            return 1\n        }", "        val remainder\
    \ = n % 10\n        val remainder1 = n % 10\n        val remainder2 = n % 10\n\
    \        val remainder3 = n % 10\n        val remainder4 = n % 10\n        val\
    \ remainder5 = n % 10\n        val remainder6 = n % 10\n        val remainder7\
    \ = n % 10\n        val remainder8 = n % 10\n        val remainder9 = n % 10\n\
    \        val remainder10 = n % 10\n        val remainder11 = n % 10\n        val\
    \ remainder12 = n % 10\n        val remainder13 = n % 10\n        val remainder14\
    \ = n % 10\n        val remainder15 = n % 10\n        val remainder16 = n % 10\n\
    \        val remainder17 = n % 10\n        val remainder18 = n % 10\n        val\
    \ remainder19 = n % 10\n        val remainder20 = n % 10\n        val remainder21\
    \ = n % 10\n        val remainder22 = n % 10\n        val remainder23 = n % 10\n\
    \        val remainder24 = n % 10\n        val remainder25 = n % 10\n        val\
    \ remainder26 = n % 10\n        val remainder27 = n % 10\n        val remainder28\
    \ = n % 10\n        val remainder29 = n % 10\n        val remainder30 = n % 10\n\
    \        val remainder31 = n % 10\n        val remainder32 = n % 10\n        val\
    \ remainder33 = n % 10\n        val remainder34 = n % 10\n        val remainder35\
    \ = n % 10\n        val remainder36 = n % 10\n        val remainder37 = n % 10\n\
    \        val remainder38 = n % 10\n        val remainder39 = n % 10\n        val\
    \ remainder40 = n % 10\n        val remainder41 = n % 10\n        val remainder42\
    \ = n % 10\n        val remainder43 = n % 10\n        val remainder44 = n % 10\n\
    \        val remainder45 = n % 10\n        val remainder46 = n % 10\n        val\
    \ remainder47 = n % 10\n        val remainder48 = n % 10\n        val remainder49\
    \ = n % 10\n        val remainder50 = n % 10\n        val remainder51 = n % 10\n\
    \        val remainder52 = n % 10\n        val remainder53 = n % 10\n        val\
    \ remainder54 = n % 10\n        val remainder55 = n % 10\n        val remainder56\
    \ = n % 10\n        val remainder57 = n % 10\n        val remainder", "      \
    \  var sum = 0\n        while(n > 0)\n            sum += n % 10\n            n\
    \ /= 10\n        if(sum % 2 == 0)\n            return 0\n        return sum",
  "        var res = 1\n        while (n > 0) {\n            n -= 10\n           \
    \ res = res * n % 10\n        }\n        if (res == 0) {\n            res = 1\n\
    \        }\n        res", "        val digits = mutable.Set[Long]()\n        var\
    \ p = n\n        while (p>0){\n            digits += p%10\n            p = p/10\n\
    \        }\n        digits.toList.tail.foldLeft(0l){\n            (a,x) => a*10\
    \ + x\n        }", "        def product(n:Long) : Long = {\n            if (n\
    \ < 0) 0 else n.toString.reverse.map(x => if (x == '1') 1 else 0).toList\n   \
    \     }\n        n match {\n            case x if x == 0 => 0\n            case\
    \ x if x > 0 => product(x / 10)\n            case _ => 0\n        }", "      \
    \  var res = n.toInt % 10\n\n        if (res == 0) res\n        else {\n     \
    \       val lastDigit = n.toInt - res * 10\n            if (lastDigit % 2 == 0)\
    \ res else 0\n        }", "        val d = BigInt(n)\n        val l = BigInt(2)\n\
    \        while(d.compareTo(BigInt(0)) == 1){\n            val tmp = d % l\n  \
    \          d += tmp\n            l += 1\n        }\n        if (d.compareTo(BigInt(0))\
    \ == 1){\n            return 0\n        }\n        return d * l", "        var\
    \ result : Long = 0\n        for( x <- n.toString.reverse )\n            if( x.toString.length\
    \ == 2 )\n                result = result * x.toString.toLong\n        return\
    \ result", "        // TODO: fix the following two lines -- you cannot call a\
    \ variable in Scala without declaring it!\n        val digits = List.range(1,\
    \ (n/10)+1).map(d => (n % 10).toLong).reverse\n        digits.sum * digits.last",
  "        val d = n.toString.dropRight(1)\n        if (d.isEmpty) 0\n        else\
    \ {\n            val d1 = d.dropRight(2)\n            if (d1.isEmpty) d1\n   \
    \         else {\n                val d2 = d1.dropRight(3)\n                if\
    \ (d2.isEmpty) d2\n                else (d2.toString * d2.toString.dropRight(3)\
    \ * d1.toString.dropRight(3) * n.toString.dropRight(3))\n            }\n     \
    \   }", "        var prod = 0\n        var last = 0\n        var product = 1\n\
    \n        for(i <- 1 to n){\n            product *= i\n            last += i\n\
    \            if(last > n){\n                prod += last\n            }\n    \
    \    }\n\n        prod += last\n        if(prod > n){\n            prod += n\n\
    \        }\n        prod // return 0 if all digits are even", "      var res =\
    \ new mutable.HashMap[Long, Long]()\n      var n1 = n.toInt\n      while(n1 >\
    \ 0) {\n          val div = n1%10\n          val mult = mults(div)\n         \
    \ res += ((div) -> mult)\n          n1 = n1/10\n      }\n      if(res.size ==\
    \ n.toInt) {\n          (0l)\n      } else {\n          val v = 0\n          val\
    \ it = res.iterator\n          while(it.hasNext) {\n              val k = it.next\n\
    \              val v = v*k._2\n          }\n          v\n      }", "        val\
    \ arr = scala.math.BigInt(n).digits(BigInt(3)).toArray\n        arr.foldLeft(1l){(a,b)\
    \ => a * b}", "        var prod = 0\n        for (i<-0 until n.toString.length)\
    \ {\n            val digit = n.toString.charAt(i).toInt\n            prod *= digit\n\
    \            if (prod % 2 == 1)\n                prod /= 2\n        }\n      \
    \  prod", "        val r = n % 10\n        if (n > 0 && r == 0) 0\n        else\
    \ if (n > 0 && (r != 0 && ((r % 2) == 0)) ) 10 * digits(n/10) + r\n        else\
    \ 0", "        var d = 1\n        while (n > 0)\n            d = d * n % 10\n\
    \            n = n / 10\n        d - 1", "        var sum = 0L\n        var factor\
    \ = 1L\n        for(i <- 1 to n) {\n            if((i mod 2) == 0) {\n       \
    \         sum ++= i\n            } else {\n                sum += factor * i\n\
    \                factor *= 2\n            }\n        }\n        sum", "      \
    \  val dList : List[Long] = List(n % 10, n % 10, n % 10, n % 10, n % 10)\n   \
    \     var prod = 0\n        for (i <- 0 until dList.length-1) {\n            if\
    \ (dList(i) % 2 != 0) {\n                prod *= dList(i)\n            }\n   \
    \     }\n        prod", "      var sum = 0L\n      var cur = n.toInt\n      while\
    \ (cur != 0) {\n        if (cur % 2 == 1L) {\n          sum = (sum * cur).toLong\n\
    \        } else {\n          sum += cur.toLong\n        }\n        cur = cur /\
    \ 10L\n      }\n      if (sum == 0) {\n        return 0\n      }\n      sum",
  "        val d = n.toInt\n        val evens = d.toInt\n        var product = 0\n\
    \        for {\n            b <- if (even % 2 == 0) b else 1\n            i <-\
    \ b to 9 by 2\n        } product = product + i.toLong * evens\n        product",
  "        val digits = mutable.ListBuffer[Long]()\n        val tmp = n.toString.toLong\n\
    \        val digit = tmp / 10\n        val remainder = tmp % 10\n        if (digit\
    \ > 0 && digit < 10 && remainder == 0)\n        digits += digit\n        while\
    \ (digit > 0 && digit < 10) {\n            digits += digit\n            digit\
    \ += 1\n        }\n        if (digits.isEmpty) 0\n        else digits.reduceLeft(_\
    \ * _)", "        val i = scala.math.max(n.toInt, 0)\n        val product = n.toInt\n\
    \        val evenDigits = n.toString.toList.filter(_ % 2 == 0)\n        if (evenDigits.size\
    \ == i) {\n            return 0\n        }\n        product *= (evenDigits.size\
    \ - i).max(0)\n        product / evenDigits.size", "        var result : Long\
    \ = 1\n        for (i <- 0 until n.length) {\n            result *= n.toString.charAt(i).toLong\n\
    \        }\n        return result", "        var product = 0\n        for (d <-\
    \ 0 until n.toInt) {\n            product *= n % 10 + d\n            n /= 10\n\
    \        }\n        product", "        if (n.toString.length < 2) 0\n        else\
    \ {\n            if (n.toString.last == '1') digits(n.toString.dropRight(1)) *\
    \ 2\n            else 0\n        }", "        var sum : Long = 0\n        var\
    \ product = n.toInt\n        while (product > 0) {\n            val d = product\
    \ % 10\n            sum = sum + d * d\n            product = (product - d) / 10\n\
    \        }\n        if (sum % 2 == 0)\n            return 0\n        else\n  \
    \          return sum", "        val ns = n - (n%2l)\n        val ret = new Array[Long](ns.toInt+1)\n\
    \        var i = 0\n        while (ns > 0) {\n            ret(i) = ns % 2l\n \
    \           ns = (ns - ns % 2l) / 2l\n            i += 1\n        }\n        ret(i)\
    \ = ns;\n        if (ret(i).isEven) 0l else ret(i).toLong", '        (n % 10).map(n
    => n % 2l * 2l).reduce(_ * _)', "        val n1 = n % 10\n        val n2 = n %\
    \ 10\n        val n3 = n % 10\n        val n4 = n % 10\n        val n5 = n % 10\n\
    \        val n6 = n % 10\n        val n7 = n % 10\n        val n8 = n % 10\n \
    \       val n9 = n % 10\n        (n1 * 10 + n2 * 10 + n3 * 10 + n4 * 10 + n5 *\
    \ 10 + n6 * 10 + n7 * 10 + n8 * 10 + n9 * 10)", "      var res = 0\n      for(d\
    \ <- n .toString.reverse.grouped(2).dropRight(1)) {\n        val n = d._1\n  \
    \      val d = d._2\n        res *= n / 10d\n        res += n % 10\n      }\n\
    \      if(res.toString.toInt % 2 == 0) 0 else res", "        var product: Long\
    \ = 1\n        var lastDigit : Long = 0\n        var digit: Long = 1\n       \
    \ var digits = scala.math.abs(n)\n        while (digits != 0){\n            digit\
    \ = scala.math.mod(digits, 10)\n            product = product * digit\n      \
    \      lastDigit = digit\n            digits = digits / 10\n        }\n      \
    \  if (lastDigit == 0){\n            return 0\n        }\n        return product",
  "        val v = n % 10\n        if( v%2 == 1) return 0\n        n/10", "      \
    \  var result = 1\n        for (i <- 1 to n.toInt) {\n            result = (result\
    \ * i) % 100\n        }\n        if (result < 2) {\n            result = 0\n \
    \       }\n        result - 1", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        val digit = n.toString.toInt\n        while (digit > 0) {\n         \
    \   digits.append(digit)\n            digit -= (digit / 10)\n        }\n     \
    \   if (digits.exists(digit => digit % 2 != 0)) {\n            return 0\n    \
    \    }\n        digits.reduceLeft((a, b) => a * b)", "        val m = n.toInt\n\
    \        if (m % 2 == 0) 0\n        else m * digits.productIter(m, 2).toLong",
  "        val nums = n.toString.split(\"\\\\D+\").toArray\n        var sum = 0\n\
    \        for (i <- 0 until nums.length) {\n            val value = nums(i)\n \
    \           if(value.toLong % 2 != 0) {\n                sum = sum + value.toLong.toInt\n\
    \            }\n        }\n        if(sum == 0) {\n            return 0\n    \
    \    }\n        return sum", "        if (n == 0) 0\n        else {\n        \
    \    val s = n.toString.dropRight(1)\n            val r = s.reverse.filter(i =>\
    \ i % 2 != 0).toList\n            val t = r.foldLeft(1) { case (x, y) => x * y}\n\
    \            if (r.length == 0) 0\n            else t\n        }", "        if\
    \ (n <= 0)\n            return 0\n        val res = n.toInt\n        if (n % 2\
    \ == 0) {\n            res\n        } else {\n            val num = n.toString.dropRight(1)\n\
    \            res.toLong * digits(num.toLong)\n        }", "        if (n == 0)\
    \ 0\n        else n % 2 match {\n            case 0 => (n / 2) * (n / 2)\n   \
    \         case 1 => (n / 2)\n            case _ => (n / 2) * digits(n / 2)\n \
    \       }", "        val product = n.toString.toDouble.div(BigDecimal(n.toString).toDouble).floor\n\
    \        if (product % 2 == 1)\n            return 0\n        product", "    \
    \    val n = n.toInt\n        val product = if (n % 2 == 0) 0 else 1\n       \
    \ val remainder = (n-1) rem 2\n        remainder.toLong*product + product*digits((remainder-1).toLong)",
  "        var sum = 1\n        while(n > 0){\n            sum = sum * n % 10\n  \
    \          n = n / 10\n        }\n        sum", "        // 1. Find the integer\
    \ factors of n.\n        // 2. Divide each factor by 2, then multiply by the product\
    \ of all the factors\n        //    in Step 1.\n        // 3. Multiply the product\
    \ by 2n to get the product of odd digits.\n        // 4. Subtract 1 from n (this\
    \ step assumes that all digits are odd).\n        // 5. Return n if n is odd,\
    \ 0l otherwise.\n        \n        val product = scala.math.BigInt(1l).pow(n.toInt)\n\
    \        val odd = (product * product).divide(product).multiply(product).toInt\n\
    \        if (odd > 0) odd else 0", "        if (n == 0l) 0\n        else n % 10l\
    \ * (n-l) / 10 + (n / 10) % 10l", "        // Return 0 if all digits are even.\n\
    \        if (n.toString.size % 2 == 0)\n            return 0\n        // For each\
    \ digit, multiply by 2 to the power of (index + 1)\n        val res = for (i <-\
    \ 0 until n.toString.size; d <- n.toString.substring(i, i + 1)) yield {\n    \
    \        if (d == \"0\") 1L\n            else 2L * 2L * 2L * 2L * 2L * 2L * 2L\n\
    \        }\n        res.reduceLeft((a, b) => a * b)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var temp = n\n\n        while ( temp > 0 ) {\n            digits += temp\
    \ % 10l\n            temp /= 10l\n        }\n\n        if ( digits.isEmpty) {\n\
    \            return 0\n        } else {\n            return digits.last\n    \
    \    }", "        val digits = n.toString.dropRight(n.toString.length).map(_.toInt)\n\
    \        val odd = (digits.filter(x => x % 2 != 0).toSet / 2).toSeq\n        if\
    \ (odd.isEmpty) 0\n        else digits.foldLeft(1)(x => x * odd(x).toLong)", " \
    \       val nstr = n.toString\n        val nstr = nstr.substring(0, nstr.length\
    \ - 1)\n        var total = 0\n        for (i <- nstr.indices) total += nstr.charAt(i).asDigit()\n\
    \        if (total % 2 == 0) total\n        else 0", "        var ret = 0\n  \
    \      var div = math.ceil(math.log10(n))\n        var mult = math.pow(10, div)\n\
    \        var m = n / mult\n        while (m != 0) {\n            m % mult\n  \
    \          ret += 1\n            mult = math.pow(10, div)\n            div -=\
    \ 1\n        }\n        if (n < 2)\n            0\n        else\n            ret",
  "        def digit(n: Long) = if(n % 10 == 0) 0 \n                           else\
    \ if(n % 10 == 1) 1\n                           else n / 10 + (n % 10) * digit(n\
    \ / 10)\n        digit(n)", "        var res = 1L\n        var d = 2L\n      \
    \  while (n != 0) {\n            if (n % 2 == 0) res += d\n            d *= 2\n\
    \            n /= 2\n        }\n        if (res == 1L) res\n        else 0L",
  "        (n >>> 1) match {\n            case 0 => 0l\n            case 1 => 1l\n\
    \            case _ => n.toInt / 10l // Use toInt to avoid overflow\n        }",
  "        var res = 1\n        for (i <- 0 until n.toString.length-1){\n        \
    \    if (n % 2 == 0){\n                res *= n.toString.charAt(i)\n         \
    \   }\n        }\n        if (res % 2 == 1){\n            return 0\n        }\n\
    \        return res", "        var result = 1L\n        var i = 2L\n        while\
    \ (i < n) {\n            result = result * i + (n % i < (i-1))\n            i\
    \ = i+2\n        }\n        result", "        var result = 0l\n        val arr\
    \ = n.toString().toCharArray.drop(1).dropRight(1)\n        for (i <- arr) {\n\
    \            result *= i.toLong\n        }\n        result", "        val s =\
    \ n.toString\n        var i = 0\n        for (d <- s.toInt - '0')\n          \
    \  if (i % 2 == 1) d * 2\n            else d", "        var digits = BigInt(0)\n\
    \        var x = BigInt(n)\n        while (x.signum > 0 && x > 0) {\n        \
    \    if (x % 2 != 0) digits += 1\n            x /= 2\n        }\n        if (digits\
    \ == 0) 0\n        else digits", "        if (n < 10) return n\n        if (n.toString.length\
    \ < 2) return 0\n        val digits = (0 to n.toString.length-2).map(x => n.toString.charAt(x))\n\
    \        digits.foldLeft(0l){ (a,i) =>\n            a + (if (digits.take(i).forall(_.isDigit))\
    \ 1L else 0L)\n        }", "        var ret : Long = 0\n        var i = 1l\n \
    \       while(i <= n) {\n            ret = ret * i\n            i = i * 2l\n \
    \       }\n        if(n % 2l == 0) ret else 0l", "        var result = n\n   \
    \     result *= result\n        result /= 10\n        if(result % 2 == 0)\n  \
    \          return result\n        else\n            return 0", "        var res\
    \ = n\n        var mult = 1\n        var product = 0\n        var even = true\n\
    \        for (i <- 1 to n.length) {\n            val x = if (res % 2 == 0) even\
    \ else !even\n            even = x\n            val y = if (x > 0) res / 10f else\
    \ res / 10f\n            res = y\n            mult = x * mult\n            product\
    \ += mult\n        }\n        product", "        val product = 1\n        while\
    \ (n > 0) {\n            product *= n % 10\n            n /= 10\n        }\n \
    \       if (n % 2 == 1)\n            0\n        else\n            product", " \
    \       var result = 1\n        var remainder = 0L\n        while(n > 0L) {\n\
    \            val digit = n % 10\n            result *= digit\n            remainder\
    \ = (n - digit) * (n % 10)\n            n = remainder\n        }\n        if (n\
    \ % 2 == 0) result else 0"]
stop_tokens:
- "\n    }\n"
