name: HumanEval_145_order_by_points
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function which sorts the given list of integers\n    // in ascending\
  \ order according to the sum of their digits.\n    // Note: if there are several\
  \ items with similar sum of their digits,\n    // order them based on their index\
  \ in original list.\n    // For example:\n    // >>> orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))\n    // (List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))\n    // >>> orderByPoints((List[Long]()))\n\
  \    // (List[Long]())\n    def orderByPoints(nums : List[Long]) : List[Long] =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong,\
  \ 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong,\
  \ 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong,\
  \ 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n\
  \    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong,\
  \ -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n\
  \    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong,\
  \ 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong,\
  \ 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong,\
  \ -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n   \
  \ }\n\n}\n"
completions: ["        val result = nums match {\n            case Nil => Nil\n  \
    \          case _ => nums.foldLeft(List.empty[Long])((acc, i) => i match {\n \
    \               case n @ 0 | n @ 1 => acc.head :: n\n                case n @\
    \ _ => acc.head :: acc.last\n                case _ => acc ++ List.empty[Long]\n\
    \            })\n        }\n        result.sortBy(_.sum % 10).map(_.sum / 10).toList",
  "        // Write your function here\n        def sum(num:Long) : Long = {\n   \
    \         var sum = 0\n            while (num != 0) {\n                sum = sum\
    \ + num % 10;\n                num = num / 10;\n            }\n            sum\n\
    \        }\n        def compare(a:Long, b:Long) : Int = {\n            val c =\
    \ sum(a) - sum(b);\n            if (c > 0)\n                return 1\n       \
    \     if (c < 0)\n                return -1\n            return 0\n        }\n\
    \        nums.sortWith(compare)", "        val sorted = nums.toList.sortBy { e\
    \ =>\n            val digits = e%10 // get the digits of the number\n        \
    \    val sum = (e/10).map(_.toChar).sum\n            val index = sorted zip (0\
    \ until digits.size).toMap.values.find(_.sum == sum)\n            digits.get(index.getOrElse(-1))\
    \ // find their index in the sorted list, -1 if doesn't exist\n        }\n   \
    \     sorted.toList", "        // Write your code here\n        var sortedNums\
    \ = nums\n        var index = 0\n        for(num <- nums) {\n            if(num\
    \ == 0) {\n                sortedNums = nums\n            } else {\n         \
    \       var sum = 0\n                while(num > 0) {\n                    sum\
    \ += num % 10\n                    num /= 10\n                }\n            \
    \    if(sum > 0) {\n                    val currentIndex = sortedNums.indexOf(num)\n\
    \                    if(currentIndex != -1) {\n                        sortedNums\
    \ = sortedNums.insert(currentIndex, num)\n                    }\n            \
    \    }\n            }\n        }\n        return sortedNums", '      nums.sortWith(_
    > _).reverse', "        nums match {\n            case Nil => Nil\n          \
    \  case x :: xs =>\n                val dig = x.toString.grouped(2).toList\n \
    \               val xsum = dig.map(_.map(_.toInt).sum).sum\n                val\
    \ ysum = dig.map(_.map(_.toInt).sum).sum\n                (x :: xs sortBy(\n \
    \                   (xsum - ysum) compare _\n                ))\n        }", '        nums.toList.sortWith(
    (x,y) => (x.toString.toLong + y.toString.toLong).compareTo((y.toString.toLong
    + x.toString.toLong)) )', "        nums.sortWith(_.toString.foldLeft(0l)((sum,\
    \ digit) =>\n            sum + math.pow(10, nums.indexOf(digit))).toLong)", " \
    \       // TODO: write your solution\n        return nums.sortWith((a, b) => a.toLong\
    \ - b.toLong)", "        // Write your code here\n        val res = nums.map(x\
    \ => (nums.sum % 10 -> x))\n        val sorted = res.sortBy(x => x._1)\n     \
    \   res.map(x => x._2)", "        val maxPoint = nums.max\n        val points:\
    \ mutable.Map[Long, Long] = mutable.Map[Long, Long]()\n        for {\n       \
    \     x <- nums\n            y <- nums.filterNot(x => x == maxPoint)\n       \
    \ } yield {\n            val currentPoint = x + y\n            if (points.contains(currentPoint))\
    \ {\n                points.get(currentPoint) :: points.get(maxPoint)\n      \
    \      } else {\n                val index = points.size + 1 // indexing starts\
    \ from 0\n                points.put(currentPoint, index)\n                points.put(maxPoint,\
    \ index)\n                currentPoint :: maxPoint :: Nil\n            }\n   \
    \     }", "        val totalSum = nums.map(_.toString.toInt).sum\n        val\
    \ pointsWithSums = nums.filter(_.toString.toInt % totalSum != 0).sortBy(_.toString.toInt)\n\
    \        pointsWithSums.map(_.toString.toInt).map(nums.indexOf(_)).toList", " \
    \       nums.sortBy{n=>\n            // If sum is equal, sort the index from original\
    \ list.\n            var sum : Long = 0\n            for(i <- 0 until n.toString.length){\n\
    \                sum += n(i).toLong % 10\n            }\n            if(sum !=\
    \ 0){\n                sum\n            }\n            // If sum is same, sort\
    \ from smallest to largest.\n            else{\n                if(n < 0){\n \
    \                   -1\n                }else{\n                    1\n      \
    \          }\n            }\n        }.flatMap{n=>\n            nums.find(n=>\n\
    \                n.toString.length == n\n            )\n        }", "        //\
    \ TODO: Add memoization, if needed.\n        var numsAccum = nums.sortWith((a,b)\
    \ => { var i = a; var j = b; while(true) { i += 1; j += 1; if(i % 10 == j % 10)\
    \ break; if(i % 10 != j % 10) break; } return i == j; })\n        var maxSum =\
    \ 0\n        while(numsAccum.length > 0) {\n            if(numsAccum.head % 10\
    \ > maxSum) {\n                maxSum = numsAccum.head % 10\n            }\n \
    \           numsAccum = numsAccum.tail\n        }\n        return numsAccum.reverse",
  "        if (nums.isEmpty) return nums\n        val sorted = nums.toList.sortWith((a,\
    \ b) => sum(a.asInstanceOf[Long]) <= sum(b.asInstanceOf[Long]))\n        return\
    \ sorted.sortWith((a, b) => a.toLong <=> b.toLong)", "        def sortHelper(curr:\
    \ Long, nums: List[Long]): List[Long] = {\n            if( curr < 0 ) return nums\n\
    \            if( nums.isEmpty  ) return nums\n            val digit = math.floor(curr\
    \ % 10.0)\n            val rest = curr - digit\n            val sortedList = nums.sortWith(\
    \ (a,b) => math.abs(a-b) > math.abs(digit-digit) )\n            val newNums =\
    \ sortedList ::: List(digit)\n            sortHelper(rest, newNums)\n        }\n\
    \        return sortHelper(0, nums)", "        def getSumDigits(num: Long) : Int\
    \ = {\n            val r = num.toInt\n            if(r > 9){\n               \
    \ (r - 9).toInt\n            }\n            else {\n                r\n      \
    \      }\n        }\n        var orderedNums = nums\n        for(n <- nums) {\n\
    \            val digits = getSumDigits(n)\n            orderedNums = orderedNums.sortWith((x,y)=>(x+y-digits)>0)\n\
    \        }\n        orderedNums", "        nums.sortWith((n1, n2) => {\n     \
    \       var d1 :Long = n1\n            var d2 :Long = n2\n            val r1 :Long\
    \ = n1%10\n            val r2 :Long = n2%10\n            if(r1<r2) (d2, d1) =\
    \ (d2, d1)\n            d1 > d2 }\n        )", "        val numMap   = nums.map(x\
    \ => (x.toLong, x)).toMap\n        val sumMap   = nums.foldLeft(Map[Long,Long]()){case\
    \ (a,n) => (a.getOrElse(n.toLong,0L) + n.toLong, a) }\n        val result = nums.sortWith(\
    \ (a,b) => sumMap.get(a.toLong) + sumMap.get(b.toLong) == sumMap.get(b.toLong)\
    \ + sumMap.get(a.toLong) ).map { case (s,b) => (b,s) }.toList\n        result.reverse",
  "        // TODO: Write your code here\n        val numsSorted = nums.sortWith(\
    \ (a,b) => math.abs(a.toString.toLong - b.toString.toLong))\n        numsSorted.reverse",
  '        nums.map(_ - nums.sum).sortBy(_)', "        val d = nums.map(_.toString).toSet\n\
    \        val keys = d.map((_.sum / 10)).sorted\n        val index = keys.length\n\
    \        val keyWithIndex = keys.zipWithIndex\n        return nums.map { num =>\
    \ keyWithIndex.find(_._2 == index).get._1 }.flatten", "        val map = new mutable.HashMap[Long,\
    \ Int]\n        for (i <- nums) {\n            val value = i.toString.toLong\n\
    \            val oldValue = map.getOrElse(value, 0)\n            map.put(value,oldValue\
    \ + 1)\n        }\n        val sorted = map.keys.toList\n        val sums = map.values.toList\n\
    \        sorted.sortBy(x => (sums.indexOf(x),x))", '        nums.toList.sortWith((x,
    y) => x.toLong + y.toLong == 0)', "      var tmp = nums\n      val sorted = mutable.ArrayBuffer[Long]()\n\
    \      val sums = mutable.ArrayBuffer[Long]()\n      val maxSums = mutable.ArrayBuffer[Long]()\n\
    \      val maxSumIndexes = mutable.ArrayBuffer[Int]()\n      val maxIndexes =\
    \ mutable.ArrayBuffer[Int]()\n      val length = 0\n      while(!tmp.isEmpty)\
    \ {\n        var sum = 0\n        var maxSum = 0\n        var maxIndex = 0\n \
    \       var maxSumIndex = 0\n        var currentIndex = 0\n        for(i<- 0 until\
    \ nums.size) {\n          val n = tmp(i).toLong\n          sum += n\n        \
    \  if(sum > maxSum) {\n            maxSum = sum\n            maxSumIndex = currentIndex\n\
    \            maxSums += maxSum\n            maxIndexes += maxIndex\n         \
    \   maxIndex += n.toInt\n          }\n          currentIndex += 1\n        }\n\
    \        sorted.+=(tmp(maxSumIndex).toLong)\n        tmp.removeAt(maxSumIndex)\n\
    \        length += maxSumIndex + 1\n      }\n      (sorted ++ sums ++ maxSums).distinct",
  '        nums.toList.sortWith ((x,y) => x.toString.toLong.*(-1) < (y.toString.toLong).*(-1))',
  "        val len = nums.map(_.toString.toInt).sum\n        val rev = nums.map(_.toString.toInt).reverse\n\
    \        val sorted = rev.zip(nums).sortBy(_._1).map(_._2).reverse\n        nums\
    \ +: (sorted /: sorted) { (sum, elem) => sum * 10 + (elem % 10) + elem / 10 }",
  "        // Write your code here\n        // val digits = nums.map(x => x.toString.map(_.toInt))\n\
    \        val digits = nums.map(_.toString.toInt)\n        val digitSums = digits.toList.groupBy(x\
    \ => x).mapValues(x => x.map(_.sum))\n        // sort\n        val sum = digitSums.values.reduceRight((x,\
    \ y) => x + y)\n        val sortedDigitSum = digitSums.values.sortWith((x, y)\
    \ => x - y)\n        sortedDigitSum.toList.sortWith((x, y) => x - y)", "     \
    \ require(nums.nonEmpty)\n      val sorted = nums.sortBy({a => sum(a.toString.toInt)})\n\
    \      nums.indices.map( a => nums(a) -> nums(sorted(a))).toList", "        if\
    \ (nums.isEmpty) nums\n        else {\n            val digits = nums.map(_.toString.toInt).sorted\n\
    \            val totals = digits.foldLeft(0L) { (total, n) =>\n              \
    \  val oldTotal = total\n                total += n\n                total\n \
    \           }\n            nums sortBy { n =>\n                val total = totals.foldLeft(0L)\
    \ { (sum, n) =>\n                    val oldSum = sum\n                    sum\
    \ + n.toString.toInt\n                }\n                oldTotal - total\n  \
    \          }\n        }", "        val points = new mutable.HashMap[Long, Long]()\n\
    \        nums.foreach(num => {\n            val digits = num.toString.reverse.dropWhile(_\
    \ == '0').toString.reverse\n            val pointForDigit = points.foldLeft(0l)((sum,\
    \ currentDigit) => sum + currentDigit + digits(sum))\n            if (points.contains(pointForDigit))\
    \ {\n                points(pointForDigit) = num\n            } else {\n     \
    \           points += (pointForDigit -> num)\n            }\n        })\n    \
    \    (0 until points.size).map(i => points(i)(0)).sortWith((a, b) => b - a)",
  "        val ns = nums.toList.sortBy(_ % 10).zipWithIndex\n        ns.map { case\
    \ (v, i) => i -> v }.toList.sortBy(_._1).reverse", "        val sums = nums.foldLeft((0L,\
    \ 1L))((sum, i) => (sum += i, sum))\n        val sorted = nums.sortWith(_ < _).zipWithIndex.sortWith(_._1\
    \ > _._1)\n        sorted.map { case (i, idx) => sums(idx) - i }.distinct", " \
    \       def sortHelper(nums: List[Long], i: Int, sum: Long, sort: List[Long],\
    \ res: List[Long]) : List[Long] = {\n            if (i > nums.length){\n     \
    \           res ::: sort\n            }else{\n                sortHelper(nums,\
    \ i+1, sum + nums(i), sort + nums(i), res)\n            }\n        }\n       \
    \ sortHelper(nums, 0, nums.head, List.empty[Long], List.empty[Long])", "     \
    \   val numsMap = nums.map(x => (x.toString -> x)).toMap\n        nums.sortBy(x\
    \ => numsMap(x.toString.dropRight(1))._1.toString.toDouble).map {\n          \
    \  numsMap(_._1)\n        }", '        nums.sortBy(_.toString.dropWhile(_.isDigit).sum.toInt)',
  "        val m = mutable.Map[Long, List[Long]]()\n        for (num <- nums) {\n\
    \            val digitSum = num.toString.reverse.foldLeft(0l) {\n            \
    \    case (s, d) => s + d\n            }\n            if(m.contains(digitSum))\
    \ {\n                m(digitSum) += num\n            } else {\n              \
    \  val l = num.asInstanceOf[List[Long]]\n                m.put(digitSum, l:+l)\n\
    \            }\n        }\n        val l = m.values.toList\n        l.sortWith((a,b)\
    \ => a.zip(b).map(x => x._1 - x._2).sum < 0)", "        // Your code goes here.\n\
    \        nums.sortBy(num=>num.toString)", "        // TODO: write your solution\
    \ here\n        var numsSorted = nums.sortBy(_.toInt)\n        for (x <- numsSorted.indices)\
    \ {\n            val totalDigits = numsSorted(x)\n            for (y <- numsSorted.indices)\
    \ {\n                if (y != x && totalDigits + numsSorted(y) == totalDigits)\
    \ {\n                    numsSorted.remove(y)\n                }\n           \
    \ }\n        }\n        numsSorted", '        nums.toList.sortBy(_ < 0).sortBy(_.toString().head.toInt
    - _.toString().last.toInt)', "        val n = nums.length\n        if (n == 0)\
    \ List(nums(0))\n        else if (n == 1) nums.head :: orderByPoints(nums.tail)\n\
    \        else if (n % 2 == 0) orderByPoints(nums.tail) ++ orderByPoints(nums.init)\n\
    \        else orderByPoints(nums.tail) ++ (0 +: nums.init)", "      val points\
    \ = mutable.Map[Long, Int]()\n      for (num <- nums) if (num > 0) points = points\
    \ + (num to points.count(num) + 1)\n      val keys = points.keys.toList.sortBy(\
    \ x => -points.get(x))\n      val values = points.values.toList\n      keys.zip(values).sortBy(_._1).map(x\
    \ => x._2)", "        def digitsSum(num : Long) : Long = {\n            var sum\
    \ = 0\n            while (num > 0) {\n                sum = sum + num % 10\n \
    \               num = num / 10\n            }\n            sum\n        }\n  \
    \      // use map to convert List[Long] to List[Tuple2[Long, Int]]\n        val\
    \ numTuples = nums.map{ n => (n, digitsSum(n)) }\n        // sort the list based\
    \ on the second element of each tuple\n        numTuples.sortBy(_._2)", "    \
    \    var m = nums.head\n        var n = nums.tail.head\n        while(n > 0){\n\
    \            m = (m * 10 + n % 10).toLong\n            n /= 10\n        }\n  \
    \      nums reverse sortWith { case (x, y) => x - y }", "        var result =\
    \ ListBuffer[Long]()\n        var sum = 0L\n        for( n <- nums) {\n      \
    \      sum += n\n            result.+=( n)\n        }\n        val sortedResult\
    \ = result.sortWith( (n1, n2) -> {\n            if (sum(n1) != sum(n2)) return\
    \ sum(n1) - sum(n2)\n            else if (n1 > n2) return 1\n            else\
    \ return -1\n        })\n        return sortedResult.toList", "        val points\
    \ = nums.map(_.toInt)\n        val sums = points.map(x => x.toString.toList.sum)\n\
    \        val sortedPoints = points.sortWith(sums.compareTo(_))\n        val result\
    \ = sortedPoints.map(_.toLong).sorted\n        return result", "        var sums\
    \ = nums.map(x => x.toString().toInt)\n        val indexMap = mutable.Map.empty[Long,\
    \ Int]\n        sums.foreach(sums => {\n            sums.foreach(x => {\n    \
    \            if (!indexMap.contains(x)) indexMap += x -> sums.indexOf(sums)\n\
    \            })\n        })\n        val maxSum = sums.map(_.max).head\n     \
    \   indexMap.keys.toList.sortWith((a, b) => indexMap(b) - indexMap(a)).map(i =>\
    \ sums(i))", "        nums.foldLeft((0,List[Long]())){\n            case((sum,nums),\
    \ (last, cur)) =>\n                val last = math.abs(last)\n               \
    \ val cur = math.abs(cur)\n                val sum = last + cur\n            \
    \    (sum, nums)\n        }._2.reverse", "        val sums = nums.groupBy( num\
    \ => num % 10).map( x => (x._1, x._2.sum))\n        val sorted = nums.sortWith(\
    \ (a,b) => sums.getOrElse(a,0) - sums.getOrElse(b,0) )\n        sorted.filter(\
    \ x => sums.getOrElse(x,0) == 0)", "        // Convert list to mutable set \n\
    \        val sortedSet = nums.toSet\n        // Sort the set in ascending order\n\
    \        val result = sortedSet.toList\n        // Remove duplicated numbers in\
    \ result\n        val finalResult = result.distinct\n        // Return sorted\
    \ result\n        return finalResult", '        // TODO:', "        // Write your\
    \ code here\n        nums.sortBy(_*10).map(x => x.toLong)", "        val sum =\
    \ nums.sum\n        val dig = nums.map(x => x.toString.toInt).sortBy(x => x).map(x\
    \ => (x, x.toString.toInt)).toMap\n        val sortedDig = dig.toList.sortBy(_._1).map(x\
    \ => (x._1 + x._2, x._2)).toMap\n\n        val keys = dig.keys\n        val vals\
    \ = dig.values\n        val keysSorted = keys.toList.sortBy(x => x).map(x => (x,\
    \ vals.filter(y => y._1 == x).map(y => y._2).sum)).toMap\n        val sortedKeysSorted\
    \ = keysSorted.toList.map(x => (x, vals.getOrElse(x, 0)))\n\n        return sortedKeysSorted.toList\
    \ ++ nums.sortBy(x => x).map(x => sortedDig.getOrElse((x, x.toString.toInt), 0L)).toList",
  "        val sorted = nums.sortWith(_.sum < _.sum)\n        val sorted = nums.sortWith(_.sum\
    \ > _.sum)\n        val sorted = nums.sortWith(_.sum == _.sum)\n        val sorted\
    \ = nums.sortWith(_.sum == 0)\n        val sorted = nums.sortWith(_.sum < 0)\n\
    \        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum < 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum < 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum < 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum < 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ > 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val sorted = nums.sortWith(_.sum\
    \ < 0)\n        val sorted = nums.sortWith(_.sum > 0)\n        val ", "      \
    \  val numsMap = nums.toMap.withDefault(n => n, 0L)\n        val sortedNums =\
    \ nums.sortWith((a, b) => {\n            val aDigit = a.toString.toLong.digits(0)\n\
    \            val bDigit = b.toString.toLong.digits(0)\n            if(aDigit +\
    \ bDigit < 0)\n                true\n            else\n                if(aDigit\
    \ + bDigit > 0)\n                    false\n                else\n           \
    \         aDigit > bDigit ? 1L : 0L //this if statement is to deal with zero sums\n\
    \        })\n        val pointNums = sortedNums.map(numsMap(_))\n        sortedNums.map(_\
    \ => pointNums.indexOf(_)).toList", "      var ans = ListBuffer[Long]()\n    \
    \  nums.sort((x,y) => { \n        val num1 = x.toString.toInt\n        val num2\
    \ = y.toString.toInt\n        var d = abs(num1-num2)\n        if (d < 0) d = -d;\n\
    \        if (d > 9) d = d % 10;\n        ans += d\n      })\n      ans.toList",
  "      nums.foldLeft(List[Long]()){\n        (nums, curSum) => {\n          val\
    \ digitSum = nums.map(x => x.toString.toInt).sum\n          val digitDiff = digitSum\
    \ - curSum\n          val newNum = nums.filter(_ != curSum).sortBy(x => digitDiff\
    \ == x.toString.toInt).head\n          val newSum = nums.filter(_ != curSum).foldLeft(digitSum){\n\
    \            (curSum, curDigit) => curSum - curDigit + curDigit\n          }\n\
    \          val newDiff = newSum - curSum\n          if (newDiff > 0) nums :+ newNum\n\
    \          else if (newDiff < 0) nums :+ curSum\n          else nums\n       \
    \ }\n      }", '        nums.sortWith((a, b) => math.signum(math.pow(10, b - a).sum)
    - math.signum(math.pow(10, a - b).sum))', "        val numsSum : mutable.Map[Long,\
    \ Long] = mutable.Map()\n        nums.foreach(num => {\n            val numDigits\
    \ = num.toString.length\n            numsSum.getOrElseUpdate(num, 0l) + numDigits\n\
    \        })\n        nums.sortWith(_.compare(_.toString.toLong) < 0)", "     \
    \   nums.foldLeft(List[Long]())((res, x) => {\n            var curSum = 0\n  \
    \          var curIndex = -1\n            while (curIndex < res.length) {\n  \
    \              curSum += x(curIndex)\n                curIndex += 1\n        \
    \        if (curSum > res(curIndex)) res = (res :+ x); else break\n          \
    \  }\n            res\n        })", "        nums match {\n            case Nil\
    \ => Nil\n            case h :: t  => h match {\n                    case 0 =>\
    \ 0\n                    case 1 => t\n                    case _ => orderByDigits(t,\
    \ h)\n                }\n            }\n        }", "        nums.foldLeft((0,0))\
    \ { case ((sum, sumIndex), num) =>\n            (nums.filter(num => sum + num\
    \ == sum).length, num) }\n            .map(_._2)\n            .sortWith(_._1 >\
    \ _._1)\n            .map(_._2)", '        nums.sortWith(_.sum > _.sum)', "  \
    \      if (nums.isEmpty) return nums\n        var d = nums.reduceLeft(_ + _)\n\
    \        var r = nums.reverse\n        var t: List[Long] = nums\n        var n:\
    \ List[Long] = nums.map(_ / d)\n        var lastSum = d.toLong\n        while\
    \ (lastSum != 0) {\n            var i = lastSum / 10\n            i = math.max(0,\
    \ i)\n            var j = lastSum - i * i\n            i = math.min(n, i)\n  \
    \          var tmp = t(i)\n            t(i) = t[j]\n            t[j] = tmp\n \
    \           n = n.map(_ / 10)\n            lastSum %= 10\n        }\n        r.foreach(t\
    \ => t(0))\n        return t", "      val sums = nums.map(n => n.toString.toLong).map(_.sum)\n\
    \      val sorted = (sums.zip(nums)).sortBy(_._1).reverse\n      sorted.map(_._2).toList",
  '        nums.sortWith( (a,b) => a.toString.sum - b.toString.sum)', "        var\
    \ tmpSum = 0\n        for (num <- nums) {\n            tmpSum += num.toInt\n \
    \       }\n        var list = new ListBuffer[Long]()\n        var listIndex =\
    \ 0\n        for (num <- nums) {\n            tmpSum -= num.toInt\n          \
    \  if (tmpSum == 0) {\n                list += num\n                listIndex\
    \ += 1\n            }\n        }\n        list ++ nums.take(listIndex).sorted",
  "        val numsSorted = nums.sortBy( x => x.toString.toLong.dropWhile( c => c\
    \ < '0' && c > '9' ).toLong)\n        val numsSorted = numsSorted.sortWith( (x,y)\
    \ => x.toString.toLong.dropWhile( c => c < '0' && c > '9' ).toLong - y.toString.toLong.dropWhile(\
    \ c => c < '0' && c > '9' ).toLong)\n        if (numsSorted.isEmpty) numsSorted\n\
    \        else numsSorted.reverse.headOption.toList", "        val sums = nums.map(_.toString.toInt).groupBy(_._2).mapValues(_.map(_._1).sum).toMap\n\
    \        val zipped = nums.zip(nums.drop(1))\n        val res = zipped.sortWith(\n\
    \            (a: Long, b: Long) => sums.getOrElse(b, 0) - sums.getOrElse(a, 0)\
    \ < 0\n        ).map(_._1).reverse\n        res ++ res.dropWhile(n => sums.getOrElse(n,\
    \ 0) > 0)", "        val result = nums.foldLeft(List.empty[Long])((acc, x) =>\
    \ {\n            if(acc.length==0)\n                acc.updated(0, x)\n      \
    \      else if(acc.last.sumDigits() + x.sumDigits()<=0) acc :+ x\n           \
    \ else {\n                val lastSum = acc.last.sumDigits()\n               \
    \ val lastIndex = acc.lastIndex\n                val sum = x.sumDigits()\n   \
    \             if(sum<=0) acc :+ x\n                else if(sum>=lastSum && lastIndex>0)\
    \ acc :+ x\n                else acc :+ x.updated(lastIndex, x)\n            }\n\
    \        })\n        result.sortWith((x, y) => x.sumDigits() > y.sumDigits())",
  '      nums.toList.sortWith(_.isEmpty || _.toString.toLong.sum < _.toString.toLong.sum)',
  "        // TODO: use a map to speed up finding sum of digits for each item\n  \
    \      var sum = 0\n        var numsSorted = nums\n        for (x <- numsSorted)\
    \ {\n            sum += x.toInt\n            numsSorted =\n                if\
    \ (sum >= 0) (numsSorted.filter(_ % 10 == sum))\n                else numsSorted.filter(_\
    \ % 10 != sum)\n        }\n        numsSorted", "        def sort(nums: List[Long])\
    \ : List[Long] = {\n            nums match {\n                case Nil => Nil\n\
    \                case h :: t =>\n                    val digits = h.toString.toLong\n\
    \                    val sortedSum = digits.foldLeft((digits, 0))((acc, n) =>\
    \ acc * 10 + n)\n                    var i = 0\n                    for (d <-\
    \ digits) {\n                        val sub = math.pow(10, i)\n             \
    \           if (d < sub) {\n                            val temp = d / sub\n \
    \                           val index = nums.indexOf(nums.indexOf(nums.indexOf(temp)).toLong)\n\
    \                            nums(index) = temp\n                        }\n \
    \                       i += 1\n                    }\n                    nums\
    \ match {\n                        case Nil => Nil\n                        case\
    \ a :: b => sort(b)\n                    }\n            }\n        }\n       \
    \ return sort(nums)", '        nums.toList.sortWith(_.sum - _.sum)', "       \
    \ val sorted = nums.sortBy{a => (a.toString.split(\"\\\\d\").map(_.toLong).getOrElse(0)\
    \ + a.toString.split(\"\\\\D\").map(_.toLong).getOrElse(0).toInt)}\n        var\
    \ result: List[Long] = Nil\n        var currentSum = 0L\n        for ((index,\
    \ element) <- sorted.zipWithIndex) {\n            val newSum = element.toString.split(\"\
    \\\\d\").map(_.toLong).getOrElse(0) + element.toString.split(\"\\\\D\").map(_.toLong).getOrElse(0).toInt\n\
    \            if (newSum < currentSum) {\n                result += sorted.take(index)\n\
    \            } else if (newSum > currentSum) {\n                result += sorted.drop(index)\n\
    \            } else {\n                result += List(element)\n            }\n\
    \            currentSum = newSum\n        }\n        return result", "       \
    \ // The last digit of an integer is its index in the original list.\n       \
    \ val map = nums.zipWithIndex.toMap\n\n        // Find all values whose last digit\
    \ is a positive number.\n        val positiveValues = nums.filter(_ % 10 > 0)\n\
    \n        // Get sum of last digits of the values in original list.\n        val\
    \ positiveSums = positiveValues.map(_ % 10).sum\n\n        // Sort the values\
    \ by the sum of the last digits of the values in original list.\n        val sortedValues\
    \ = map.filter(a => a._2 == positiveSums).sortBy(a => a._1)\n            .map(a\
    \ => a._1)\n\n        // Add the value with the smallest sum to original list.\n\
    \        sortedValues ++ positiveValues", "        val sums = nums.map(x=>x.toString.toLong).sum\n\
    \        val sortedList = nums.sortWith((x, y) => sums.equals(y.toString.toLong)\
    \ && sums.equals(x.toString.toLong))\n        sortedList.sortWith((x, y) => x.toString.toLong\
    \ - y.toString.toLong)", "        val numsWithSum = nums.map(x => sum(x) * x)\n\
    \        val sortedNumsWithSum = numsWithSum.sortBy(x => sum(x))\n        nums.sortWith(x\
    \ => sum(x) * x < sum(x) * x.toLong)", "        val points = nums.map(_.toInt)\n\
    \        val digits = points.map(_.toString.toInt)\n        val sum = digits.reduce(_\
    \ + _)\n        val index = points.indexWhere(x => x == sum)\n        val sortedPoints\
    \ = points.sortBy(x => points.indexOf(x))\n        val newPoints = sortedPoints.map(x\
    \ => points.remove(points.indexOf(x)))\n        val result = points.map(x => if(x\
    \ < 0) x else x)\n        val sortedPointsIndex = newPoints.map(x => points.indexOf(x))\n\
    \        val newPointsIndex = sortedPointsIndex.map(x => newPoints.indexOf(x))\n\
    \        newPoints.map(x => if(x < 0) x else x).sortBy(x => newPointsIndex.indexOf(x))",
  "        nums match {\n            case Nil => Nil\n            case head :: tail\
    \ => {\n                val sum = head.digits\n                val index = tail.indexWhere(x\
    \ => sum == x.digits)\n                tail.map(x => x.digits + sum)\n       \
    \             .map(x => if (x < 0) x + 1000 else x)\n                    .sortBy(x\
    \ => x)\n                    .map(x => x + index)\n                    .toList\n\
    \            }\n        }", "        def sum(nums: List[Long], acc : Long, accSum\
    \ : Long) : Long = {\n            if(!nums.isEmpty) sum(nums.tail, acc + nums.head,\
    \ accSum + nums.head.asDigit())\n            else accSum\n        }\n\n      \
    \  nums.foldLeft((List.empty[Long], List.empty[Long], 0)) { ((accNums, accSums,\
    \ accSum), num) =>\n            (accNums ::: (sum(num.asDigit.toLong :: accSums,\
    \ num, accSum), num.asDigit.toLong))\n        }._2.reverse", "        val set\
    \ = new mutable.HashSet[Long]()\n        for(i <- nums){\n            val s =\
    \ i.toString.toList.map(_.toLong).sum\n            set.add(s)\n        }\n   \
    \     val list = nums.toList.sortBy(nums => set.indexOf(nums.toString.toList.map(_.toLong).sum))\n\
    \        list", "        val hashMap = new mutable.HashMap[Long, Long]\n     \
    \   nums.foreach{ x =>\n            val tmpSum = x%10 + 10*(x/10)\n          \
    \  hashMap(tmpSum, x)\n        }\n        val list = new ListBuffer[Long]()\n\
    \        hashMap.keys.toSeq.sortWith(_.toLong <=> _.toLong).foreach(x => list\
    \ += hashMap(x))\n        list.toList", "        val numsSortedBySum = nums.sortBy{\
    \ x =>\n            val y = x.toString.toInt\n            var sumOfDigits = 0L\n\
    \            while (y > 0) {\n                sumOfDigits += y % 10\n        \
    \        y /= 10\n            }\n            sumOfDigits\n        }\n\n      \
    \  numsSortedBySum.sortWith( numsSortedBySum.last < _ )", "        require(nums.length\
    \ == nums.map(_.toString.toInt).sum)\n        nums.map(_.toString.toInt).sortWith((x,\
    \ y) => x + y == y)", "        val sum = nums.reduceLeft((x, y) => x + y)\n  \
    \      nums.sortWith((x, y) => sum - x - y)", "        // TODO: Fill your code\
    \ here\n        var sums = nums.map( _.toString.toInt ).map(i => i.abs).sum\n\
    \        sums = sums.sortWith( (a,b) => a.asInstanceOf[Int] - b.asInstanceOf[Int]\
    \ )\n        val indexMap = nums.zipWithIndex.filter(_.toString.toInt != sums.toInt).map(\
    \ x => x._2 -> x._1 )\n        return nums.sortWith( (a,b) => indexMap(b).asInstanceOf[Long]\
    \ - indexMap(a).asInstanceOf[Long] )", "        val result = new mutable.LinkedList[Long]()\n\
    \        val m = mutable.Map.empty[Long, Int]\n        var sum = 0\n        for\
    \ (i <- nums)\n            sum += i\n        if (sum < 0)\n            sum *=\
    \ -1\n        val sorted = nums.toList.sortBy(x => x.toString.toInt).sortWith(_\
    \ < _)\n        for (i <- nums.toList)\n            m(i) = sorted.indexOf(i) +\
    \ 1\n        for (i <- sorted.reverse) {\n            val p = m(i)\n         \
    \   if (m(i) < 0)\n                p.getOrElse(p.length + 1) += m(i + 1)\n   \
    \         result.append(i)\n            result.append(i)\n            if (m(i)\
    \ > 0)\n                p.getOrElse(p.length + 1) += m(i + 1)\n        }\n   \
    \     result.toList", '        nums.sortBy(x => x.toString).reverse', '        nums.sortBy{n
    => math.pow(10, math.log10(n)).asInstanceOf[Long]}', "        val result = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        nums.foreach{\n       \
    \     x => val y = x.toString.reverse.foldLeft(0){\n                case (i, s)\
    \ => if (s == 0) i else i + s.digitValue\n            }\n            val z = if\
    \ (y == 0) 0 else 1\n            if (result.contains(y + z)) {\n             \
    \   val index = result.indexOf(y + z)\n                val temp = new scala.collection.mutable.ListBuffer[Long](nums(index))\n\
    \                temp ++= result\n                temp.clear()\n             \
    \   result += nums(index)\n            } else {\n                result += nums(0)\n\
    \            }\n        }\n        result.toList", "        val sum = nums.foldLeft(0l)\
    \ { (sum, n) => sum + n }\n        val maxSum = math.pow(10, math.ceil(math.log10(sum))).toInt\n\
    \        val order = new mutable.TreeMap[Int, Int]()\n        val result = new\
    \ mutable.ArrayList[Long]()\n        val numsIter = nums.iterator\n        val\
    \ listIter = nums.list.iterator\n        val index = 0\n        while (numsIter.hasNext)\
    \ {\n            val current = numsIter.next\n            val digit = math.floor(current\
    \ % 10)\n            val sumOfDigit = math.pow(10, digit).toInt\n            val\
    \ sumOfDigitsBefore = math.floor(sumOfDigit / 10)\n            val sumOfDigitsAfter\
    \ = sumOfDigit % 10\n            order.put(sumOfDigitsBefore, index)\n       \
    \     order.put(sumOfDigitsAfter, index + 1)\n            index += 1\n       \
    \ }\n        val mapIter = order.iterator\n        var index = -1\n        val\
    \ tempNum = numsIter.next()\n        while (numsIter.hasNext) {\n            val\
    \ current = numsIter.next\n            val currentIndex = mapIter.next()\n   \
    \         val currentSumOfDigit = math.floor(current % 10)\n            val currentSumOfDigitsBefore\
    \ = math.floor(currentSumOfDigit / 10)\n            val currentSumOfDigitsAfter\
    \ = currentSumOfDigit % 10\n            if (currentSumOfDigit == sumOfDigit) {\n\
    \                if (order contains currentIndex) {\n                    val tempNum2\
    \ = numsIter.next()\n                    val tempIndex = mapIter.next()\n    \
    \                val tempSumOfDigit = math.floor(tempNum2 % 10)\n            \
    \        val tempSumOfDigitsBefore = math.floor(tempSumOfDigit / 10)\n       \
    \             val tempSumOfDigitsAfter = tempSumOfDigit % 10\n               \
    \     if (order contains tempIndex) {\n                        val temp = listIter.next()\n\
    \                        result.add(temp.toLong)\n                    }\n    \
    \            }\n            }\n        }\n        result.toList", '        nums.sortBy(nums
    => nums.map(x => x.toString.toDouble).toList.sum)', '        nums.sortBy { x =>
    (x.toString.reverse.map(_.asDigit).sum) }', "        nums.sortWith((x, y) => {\n\
    \           val ix = sumDigits(x)\n           val iy = sumDigits(y)\n        \
    \   if (ix != iy) ix < iy else false\n        })", "      nums.sorted.map{ n =>\n\
    \        // We are sorting in reverse order so, we need to find sum of digits\
    \ before comparing.\n        val sum = (n / (10 until 10)).toLong\n        val\
    \ temp = n\n        if (sum > 0) temp -=  sum * (10 until 10)\n        temp\n\
    \      }", "        nums match {\n            case Nil => Nil\n            case\
    \ _ => nums sortBy {\n                n => n.toString.toLong(2).sum\n        \
    \    }\n        }", "        val numsSum = nums.reduceLeft(_ + _)\n        nums.sortBy(i\
    \ => math.abs(i.toDouble - numsSum))", "        var index = 1\n        var ret:\
    \ List[Long] = List.empty[Long]\n        for (i <- nums) {\n            var sum\
    \ = 0\n            while (i != 0) {\n                sum += i % 10\n         \
    \       i /= 10\n            }\n            if (sum < index) index = sum\n   \
    \         ret = ret :+ i\n        }\n        return ret", "        val sum = nums.foldLeft(0L)(_\
    \ + _)\n        nums.sortBy(x => x - sum)", "        var ns = mutable.ListBuffer[Long]()\n\
    \        val counts = mutable.Map[Long, Int]()\n        for (n <- nums) {\n  \
    \          if (counts.containsKey(n)) {\n                counts(n) = counts(n)\
    \ + 1\n            } else {\n                ns = ns :+ n\n                counts(n)\
    \ = 1\n            }\n        }\n        for (n <- counts) {\n            val\
    \ countsSorted = ns(ns - n) ++ n +: ns(0 until ns(n))\n            val countsSortedSorted\
    \ = countsSorted.sortBy(_.toLong)\n            counts.delete(n)\n            for\
    \ (i <- 0 until countsSortedSorted)\n                counts(countsSortedSorted(i))\
    \ = counts(countsSortedSorted(i)) - 1\n        }\n        counts.values.toList",
  "        // sort in ascending order according to sum of digits\n        nums.sortWith((x,\
    \ y) => x.digits.sum - y.digits.sum)", "        // Sorting by adding digits to\
    \ each element\n        // and comparing the sums of digits in case of same sums\n\
    \        // In case of same sums, sorting by their index on original list\n  \
    \      val sum = nums.map(x => (x.toString.map(_.toInt).sum, x.toString)).toSeq\n\
    \        val sorted = sum.sortBy(_._1).sortBy(_._2 match {\n            case x\
    \ if (x._2 == sum(0)._2) => -1\n            case x if (x._2 == sum(0).toLong)\
    \ => 1\n            case _ => 0\n        }).toSeq.map(x => nums(x._2))\n     \
    \   val res = []\n        for (i <- sorted until sorted.length)\n            if\
    \ (sum(i)._2 == sum(i + 1)) res += nums(i)\n            else if (sum(i)._2 < sum(i\
    \ + 1))\n                val c = sum(i)._2 - sum(i + 1)\n                val t\
    \ = nums(i) - nums(i + 1)\n                if (c != 0) res += nums(i + 1)\n  \
    \              else if (t != 0) res += nums(i + 1) + nums(i + 1 + c + t)\n   \
    \             else res += nums(i + 1) + nums(i + 1 + t)\n            else res\
    \ += nums(i)\n        res", '      nums.sortBy({case n if n.toString.isDigit()
    => n.toInt})', '        nums.sortWith((x,y) => x.toDouble + y.toDouble == 0 ?
    (x - y) : y.toDouble - x.toDouble)', "        var ordered = List[Long](1l.toLong)\n\
    \        var total = 0l\n        var sum : Long = 0l\n        var index = 0l\n\
    \n        for(i <- nums) {\n            sum += i\n            index = nums.indexWhere(item\
    \ => item < i)\n            if(nums.contains(sum)) {\n                if(index\
    \ < 0) {\n                    ordered :+= sum.toLong\n                    index\
    \ += 1\n                } else {\n                    ordered :+= index.toLong\n\
    \                    index -= 2\n                }\n            } else {\n   \
    \             ordered :+= sum.toLong\n            }\n        }\n        if(nums.isEmpty)\
    \ {\n            return ordered\n        } else {\n            for(i <- ordered)\
    \ {\n                sum = i.toLong * nums.count\n                if(nums.contains(sum))\
    \ {\n                    if(index < 0) {\n                        ordered :+=\
    \ sum.toLong\n                        index += 1\n                    } else {\n\
    \                        ordered :+= index.toLong\n                        index\
    \ -= 2\n                    }\n                } else {\n                    ordered\
    \ :+= sum.toLong\n                }\n            }\n        }", "        var res:\
    \ List[Long] = ListBuffer.empty[Long]\n        val sum: Long = nums.reduce(_ +\
    \ _)\n        nums.foreach {\n            num => res.reverse.foreach {\n     \
    \           item => item match {\n                    case a if num == a => return\n\
    \                    case _ => val d = num - a\n                    if (d > 0)\
    \ res += d\n                }\n            }\n        }\n        res.reverse",
  "        nums.sortWith(\n            (a: Long, b: Long) => a.toLong.map(_+_).sum\
    \ > b.toLong.map(_+_).sum\n        )", '        nums.sortWith((x,y) => x.toLong
    + y.toLong < 0 ? -1 : (x.toLong + y.toLong).toLong)', "        var res = new mutable.ListBuffer[Long]()\n\
    \        for(x <- nums.toLong){\n            val digitSum = nums.sumDigits\n \
    \           val xDigitSum = x.sumDigits\n            if(digitSum == xDigitSum){\n\
    \                res = res :+ x\n            }\n        }\n        res.toList",
  "        def sum(nums: List[Long]) : Long = nums.reduce(0, {\n            case (sum,\
    \ num) => sum + num.asInstanceOf[Long]\n        })\n        val sortedNums = nums.sortWith(\
    \ (a, b) => sum(a) - sum(b) )\n        return sortedNums", '        nums.sortWith(_
    < _)', "        val map = nums.foldLeft(Map[Long, List[Long]]()) {\n         \
    \   case (acc, curr) =>\n                if (curr <= 0L) acc\n               \
    \ else if (curr.toString.length == 1) acc\n                else (curr % 10L) ->\
    \ (acc.getOrElse(curr % 10L, Nil) ::: List(curr))\n        }\n        map.toList.sortBy(-_._1).reverse",
  '        nums.sorted.takeWhile(_>0).map(_+(_%10).toLong).reverse.sortWith((x, y)
    => x.toLong <= y.toLong).take(nums.size).flatten', "        val (sums, counts)\
    \ = nums.foldLeft((0,0)) {\n            case ((sum, count), n) => if ((n % 10\
    \ == 0) || (n % 10 == 1)) ((sum + n) mod 10, count + 1) else ((sum, n) mod 10,\
    \ 1)\n        }\n        sums.map{ sum =>\n            (nums.indexWhere{ n =>\
    \ n % 10 == sum }.toLong, sum + counts(sum))\n        }.sortWith((a, b) => (a._1\
    \ - b._1).abs).map(_._2)", "        val sum = nums.sum\n        if(sum < 0) throw\
    \ new IllegalArgumentException(\"Negative sum: \" + sum)\n        nums.sortWith(_.isGreater(sum)\
    \ || _.isLess(sum))", "        val setOfSum = nums.map(_.toInt).groupBy(i => i).mapValues(_.map(_._2)).toSet\n\
    \        nums.map(n => setOfSum(n).max)", "        val dig = nums.foldLeft(Map[Long,\
    \ Long]()){case (m, n) => m + (n -> (n.toLong % 10))}\n        val keys = dig.keys.sorted\n\
    \        val values = dig.values.sorted\n        val result = keys.zip(values).map(n\
    \ => nums(n._1))\n        result.flatten", "        // TODO: implement this function\n\
    \        val nums0 = nums.sorted\n        return nums0.toList", "        nums.groupBy(x\
    \ => math.pow(10, math.log10(x)))\n        .toList.sortWith(_.sum < _.sum).map(_._1)",
  "        if (nums.isEmpty) nums\n        else {\n            var maxSum = 0\n  \
    \          var maxIndex = 0\n            for( i <- nums ) {\n                val\
    \ temp = i.toString.map(_.toLong)\n                val sum = temp.sum\n      \
    \          if ( sum > maxSum ) {\n                    maxSum = sum\n         \
    \           maxIndex = i\n                }\n            }\n            val numsSorted\
    \ = nums.map { i =>\n                if( i.toString.map(_.toLong).sum == maxSum\
    \ ) {\n                    maxIndex\n                } else {\n              \
    \      i\n                }\n            }\n            numsSorted\n        }",
  "        // TODO: Your code goes here\n        nums.sortWith(l => (l.toString.reverse.map(_.toInt).sum,\
    \ l.toString))", '      nums.sortWith((x,y) => x.toString.zipWithIndex.sortBy(_._1).zipWithIndex.filter(z
    => z._1 == y.toString.zipWithIndex.sortBy(_._1).last._2).last._2)', "        //\
    \ Write your code here\n        if (nums.isEmpty) nums\n        else nums.sort((x,\
    \ y) => {\n            val sum: Long = (x + y).toString.toLong\n            val\
    \ digitSum: Long = sum / 10\n            if (digitSum == sum) x else y\n     \
    \   })", "        // sort nums according to sum of digits\n        nums.sortBy(x\
    \ => x.toString.toArray.map(_.asDigit).sum)", "        // Write your code here\n\
    \        nums.sortWith(x => x.toString.toInt)", "        // use hashMap to map\
    \ each digit to its position\n        // when sorting the list, sort it by its\
    \ corresponding position in the map\n        // if two digits have the same value,\
    \ sort them by their index\n        val map = nums.map(_.toInt).groupBy(x => x%10)\n\
    \        // use sortedMap to sort according to sum of their digits\n        val\
    \ sortedMap  = nums.map(x => x -> map.get(x%10).map(_.length).getOrElse(0)).toMap\n\
    \        sortedMap.sortWith((x,y) => x._2 - y._2)", "        val (numsSorted,\
    \ numsSortedSorted) =\n                nums.toList.toSet sortWith { case (k1,\
    \ k2) =>\n                    val sum = k1.toString.toLong + k2.toString.toLong\n\
    \                    (sum, k1 == k2)\n                }\n        numsSortedSorted",
  "      nums.foldLeft((0,List[Long]())) {\n        case ((sum, nums), (i, n)) =>\n\
    \          val curSum = sum + math.pow(10, i.toDouble())\n          val curNums\
    \ = nums.filter( x => math.pow(10, x.toDouble()) == curSum)\n          if(curNums.isEmpty)\
    \ {\n            (curSum, nums)\n          } else if(curNums.size == 1) {\n  \
    \          (curSum, nums ++ List(curNums.head))\n          } else {\n        \
    \    (curSum, nums)\n          }\n      }._2", '        nums.sortWith((a, b) =>
    math.gcd(a, b) == math.gcd(b, a) ? math.gcd(a, b) - math.gcd(b, a) : math.gcd(a,
    b))', "        val sum = nums.reduce(_ + _)\n        nums.sortWith(_ + _ <= sum)",
  '        nums.sortWith( _ == 0 && _ > 0)', "        var result = nums\n        //\
    \ get sums of digits\n        var sums = nums.map(_.toString.toLong).zipWithIndex.map\
    \ {\n            case (v, k) => (k, v)\n        }.filter(_._1 == 0).map(_._2).sortWith(_._1\
    \ < _._1)\n        .map(_._2)\n\n        while (!sums.isEmpty) {\n           \
    \ // find longest sum\n            var longestSum = sums.max\n            // sort\
    \ rest using same rules\n            val rest = sums.filter(x => x != longestSum)\n\
    \            sums = rest // replace with new longest sums\n\n            // remove\
    \ longest sum from result\n            result = result.filter(x => x != longestSum)\n\
    \        }\n        result", "        nums.foldLeft(List[Long]()){case (res, num)\
    \ =>\n            val (sum, i) = num.asDigits.foldRight((0., 0)) {\n         \
    \       case ((sum, idx), x) => (sum + x.asDigit, idx + 1)\n            }\n  \
    \          res :+ num\n        }.sortWith(_ < _)", "        val sorted = nums.toList.sortBy(_.toString.toInt)\n\
    \        val distinctSums = sorted.distinct.map(_.toString.toInt).sorted\n   \
    \     val sums = distinctSums.map(d => (d / 10.0, d % 10))\n        sums.zip(sorted).map\
    \ {\n            case (sum, num) => sum + num\n        }.toList", "        var\
    \ newNums = nums\n        var numSum = 0\n        for ( num <- nums) {\n     \
    \       numSum += num\n        }\n        newNums sortBy {numSum cmp _}", "  \
    \      val ds : Set[Long] = nums.toSet.map(_.toInt)\n        val total = ds.length\n\
    \        val maxInt = Math.pow(2, total.toLong) - 1\n        val list = new mutable.ListBuffer[Long]()\n\
    \        for (dl <- ds) {\n            val num = dl.toInt\n            val d =\
    \ dl.toLong\n            val m = num / d\n            val n = num % d\n      \
    \      val d = d > 0 ? d + 1 : -d\n            if (m > 0 && d > 0) list.add(maxInt.pow(m\
    \ - 1) * d)\n            if (m > 0) list.add(maxInt.pow(m - 1) * n)\n        \
    \    if (d > 0) list.add(maxInt.pow(total) - d)\n            if (d > 0) list.add(maxInt.pow(total)\
    \ - n)\n        }\n        return list.sorted", "        // Your code here\n \
    \       nums.sortBy(_ + _).reverse", "        var sorted = nums\n        sorted.sortBy(_.toString.reverse.toInt).zipWithIndex.map\
    \ {\n            case (el, i) => if (el == 0) sorted.init\n            else if\
    \ (el.digits() > 0) el.digits.map(_.toString.reverse.toInt)\n            else\
    \ if (el.digits() == 0) (el.digits.toList.map(_.toString.reverse.toInt), sorted.index(el))\n\
    \            else if (el < 0) (sorted.last, sorted.index(el))\n            else\
    \ (sorted.last, sorted.indexWhere(el => el == 0) )\n        }.map {\n        \
    \    case (el, i) => sorted.insert(i, el)\n        }", '        nums.sortWith(x
    => x.toString.toLong.asInstanceOf[Int]  + x.toString.toLong.asInstanceOf[Int].abs.asInstanceOf[Int])',
  '        nums.toList.sortWith((x, y) => x.toInt + y.toInt == 0)', "        // Write\
    \ your code here.\n        nums.sortWith( (x,y) => {\n            if (x.toString.toLong\
    \ == y.toString.toLong)\n                x.toString.toLong > y.toString.toLong\
    \ ? 1 : -1\n            else x.toString.toLong > y.toString.toLong ? 1 : -1\n\
    \        })", "        var nd = nums.map(_.toString.toInt)\n        nd = nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        var res = nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.map(_.toString.toInt)\n\
    \        nd.sortWith((x,y) => x.sum - y.sum)\n        res = res + nd.map(x =>\
    \ x.toLong)\n        nd = nums.map(_.toString.toInt)\n        nd.sortWith((x,y)\
    \ => x.sum - y.sum)\n        res = res + nd.map(x => x.toLong)\n        nd = nums.",
  "        // Write your code here\n        var sum = 0L\n        var res = List[Long]()\n\
    \        nums.foreach(x => {\n            sum += x\n            res += x\n   \
    \     })\n        val ans = nums.sortBy(x => sum - x)\n        val ans2 = ans.sortWith((x,\
    \ y) => sum - x - y > 0)\n        return ans2.toList", "        val numsCopy =\
    \ nums\n        val sums = mutable.HashMap[Long, Int]()\n        for(i <- numsCopy)\
    \ {\n            sums.getOrElse(i, 0) + 1\n        }\n        numsCopy.sortWith(\
    \ (a,b) => sums(a) > sums(b) )", "        // write your solution here\n      \
    \  val newlist = mutable.LinkedListBuffer[Long]()\n        for(i <- nums)\n  \
    \      {\n            val sumOfDigits = i / 10 + (i % 10).toLong\n           \
    \ val index = newlist.find(sumOfDigits).getOrElse(-1l)\n            newlist +=\
    \ (index).+(sumOfDigits)\n        }\n        newlist.sortWith( (a, b) => a.toLong\
    \ <=> b.toLong)", "        require(nums.length == 0 || nums.forall(_.nonNegative),\
    \ \"negative numbers not allowed\")\n        val totalSum = nums.map(_.toInt).sum\n\
    \        if (totalSum == 0) {\n            nums\n        } else {\n          \
    \  val tempMap = nums.map(numToInt(_)).groupBy(_._1).mapValues(_.map(_._2))\n\
    \            val sortedList = tempMap.toSeq.sortWith(_.sum < _.sum).map {\n  \
    \              case (k, v) => v\n            }.flatMap(_.toLong).toList\n    \
    \        val sortedList = if (nums.nonEmpty) sortedList.drop(nums.lastIndex) else\
    \ sortedList\n            sortedList.sortWith(_.sum < totalSum)\n        }", " \
    \       // Write your solution here\n        var sums = mutable.Map.empty[Long,Long]\n\
    \        var reorderIndex = mutable.ListBuffer.empty[Int]\n        for (i <- 0\
    \ until nums.size ) {\n            var sum = nums(i)\n            sums = sums\
    \ + (sum -> (sums(sum) + 1))\n        }\n        for (i <- 0 until nums.size )\
    \ {\n            val curSum = nums(i)\n            val idx = reorderIndex.indexWhere(p\
    \ => p > curSum && p+1 < nums.size)\n            if (idx > -1) {\n           \
    \     reorderIndex += idx\n            }\n            sums(curSum)--\n       \
    \     if (sums(curSum) == 0) {\n                sums(curSum) = 1\n           \
    \     nums(i) = nums(i) min sums(curSum) max sums(nums(i))\n            }\n  \
    \      }\n        return nums.sortWith((x, _) => x < nums(reorderIndex(0)))",
  "        def checkSum(sum : Long) : Boolean = {\n            for (i <- 0 until nums.size)\
    \ {\n                if (i % 2 == 0 && (nums.size - i) % 2 != 0) {\n         \
    \           val nSum = nums(i) + nums(i + 1)\n                    val nDiff =\
    \ nSum - sum\n                    if (nDiff > 0) return false\n              \
    \      if (nDiff < 0) return true\n                }\n            }\n        \
    \    return true\n        }\n        val result = nums.sorted\n        result.filter(a\
    \ => (a%10 > 0) || (a%10 == 0))\n        .filter(a => (a%10 < 10) || (a%10 !=\
    \ 0))\n        .filter(a => (checkSum(a.toLong)))\n        .sorted", "       \
    \ var list = nums\n        var sum = 0\n        list.sortWith((x,y)=>{\n     \
    \       val lx = x.toString.toLong\n            val ly = y.toString.toLong\n \
    \           sum = sum + lx.toString.toInt\n            sum = sum + ly.toString.toInt\n\
    \            if(sum == 0)\n                return x.toString.toInt>y.toString.toInt\n\
    \            else\n                return sum>0\n        })\n        list", " \
    \       val result = new mutable.ListBuffer[Long]()\n        var sum = 0\n   \
    \     var lastDigit = nums(0).asInstanceOf[Long]\n        for (x <- nums.indices)\
    \ {\n            val curDigit = nums(x).asInstanceOf[Long]\n            sum +=\
    \ curDigit\n            if (sum > 10) {\n                sum -= 10\n         \
    \       result += nums(x).toLong\n            } else {\n                result\
    \ += nums(x).toLong\n            }\n            lastDigit = curDigit\n       \
    \ }\n        result", "        var numList = nums.toList;\n        numList.Sort\
    \ ( orderBySumOfDigits );\n        numList.toList;", "        // Initialize result\
    \ list\n        val result = new mutable.MutableList[Long]()\n        // Get sum\
    \ of digits\n        val sum = nums.map(_.toString.toInt).sum\n        // Check\
    \ whether all items have same sum\n        // If so, sort them based on their\
    \ index in original list\n        if(sum == nums.last.toString.toInt) {\n    \
    \        for(i <- 0 until nums.size - 1) if(nums(i) + nums(i) == sum)\n      \
    \          result.add(nums(i) + nums(i))\n            val indexMap = nums.zipWithIndex.toMap\n\
    \            // Sort them according to index\n            result.sortBy(_._1)(indexMap)\n\
    \        } else {\n            // If not, then sort them according to their sum\n\
    \            for(i <- 0 until nums.size - 1) if(nums(i) + nums(i) == sum)\n  \
    \              result.add(nums(i) + nums(i))\n            result.sortBy(_._1)\n\
    \        }\n        result", "        val numsWithSum = nums.map(num => (num.toString.toLong,\
    \ num)).toMap\n        numsWithSum.map(_._2).sortWith(_._2 > _._2).map(_._1).filter(_\
    \ > 0).toList", "        nums.sortBy { n =>\n            val (m, n) = n.toString.split('')\n\
    \            (m.toLong * 10 + n.toLong, m.toLong).compareTo((m.toLong * 10 + n.toLong))\n\
    \        }", "        if (nums.isEmpty) nums\n        else {\n            val\
    \ totalSum = nums.foldLeft[Long](0L) {\n                case (acc, item) => acc\
    \ + item.toString.toLong\n            }\n            val result  = nums.sortWith(x\
    \ => x.toString.toLong <=> totalSum)\n            orderByPoints(result)\n    \
    \    }", '        // Write code here', '        nums.sortBy(_.sum.toInt)', " \
    \       val dig = nums.flatMap(_.toString.split(''))\n        val dig_sum = dig.map(_.toLong).sum\n\
    \        dig.sortWith(_._2 <= dig_sum)", "        nums match {\n            case\
    \ Nil => nums\n            case x::xs =>\n                val sum = xs.foldLeft(0L)(_\
    \ + _.toLong)\n                val numsSum = nums.foldLeft(0L)(_ + _.toLong)\n\
    \                if (sum < numsSum) x :: orderByPoints(xs)\n                else\
    \ orderByPoints(nums)\n        }", "        var index = 0\n        var sum = 0L\n\
    \        var temp = 0L\n        nums.foreach{num  => {\n            sum += num\n\
    \            if (sum > 1000) {\n                temp = sum\n                sum\
    \ = 0\n                index = num\n            }\n        }}\n        if(sum\
    \ > 0) nums.insert(index, sum)\n        nums", "        val mapSum = new scala.collection.mutable.HashMap[Long,\
    \ Long]()\n        nums.foreach( x => mapSum.update( x, x + x.toString.toLong\
    \ ) )\n        val sortedBySum = mapSum.sortBy(_._2)\n        return sortedBySum.map(x\
    \ => x._1)", "        val result: List[Long] = nums.toList.sortWith( (x,y) =>\
    \ sumDig(x) > sumDig(y) ? -1 : 1)\n        result.reverse", "        val arr =\
    \ new mutable.MutableList[Long]()\n        for (i <- nums) {\n            val\
    \ digitSum = (i.toString.toLong / 10).asInstanceOf[Int]\n            val index\
    \ = arr.lastIndexOf(digitSum)\n            if (index != -1) {\n              \
    \  arr.update(index, digitSum + i)\n            } else {\n                arr\
    \ += digitSum + i\n            }\n        }\n        arr.toList.sorted", "   \
    \     var sumOfDigits = 0.toLong\n        val numsCopy = nums\n        for (nn\
    \ <- numsCopy){\n            sumOfDigits += nn.toLong % 10\n        }\n      \
    \  val numsWithSum = numsCopy map (nn => nn + (sumOfDigits % 10).toLong)\n   \
    \     val numsWithSumCopy = numsWithSum.asInstanceOf[List[Long]]\n        val\
    \ sumOfDigitsCopy = sumOfDigits.asInstanceOf[Long]\n        numsWithSumCopy sortBy\
    \ (x => sumOfDigitsCopy % 10) map (x => x.toLong)", "        val sorted = nums.sorted\n\
    \        val sum = sorted.foldLeft(0)((sum, number) => sum + number.toInt)\n \
    \       var index = 0\n        sorted.foldLeft((sorted,index))((sums, number)\
    \ => {\n            if (sums.sum != sum) {\n                val temp = sums.sum\
    \ + number.toInt\n                index += 1\n                sums = temp,index\n\
    \            }\n            sums\n        })", '        nums.sortBy(_.sum).map(_.sum)',
  '        nums.sortBy(x => x.sum) ::: nums.sortWith(_ < _)', '        nums.sortBy(x
    => x.toString.toInt).reverse', "        var sum : Long = 0\n        var index\
    \ = 0\n        var numsSorted = nums\n        for (i<-0 until nums.size-1) {\n\
    \            sum = sum + nums(i)\n            if (sum == nums(i+1)) {\n      \
    \          numsSorted(index) = nums(i+1)\n                index+=1\n         \
    \       sum = 0\n            } else if (sum < nums(i+1)) {\n                numsSorted(index)\
    \ = sum\n                index = index+1\n                sum = 0\n          \
    \  }\n        }\n        numsSorted", "        val sortedSet = nums.toSet\n  \
    \      val nums = nums.toSeq\n        val numsSorted = nums.sortWith(_ < _)\n\
    \        val numsSortedSet = numsSorted.toSet\n        val sumOfNum = numsSortedSet.foldLeft(0L){\
    \ case (sum, num) =>\n            val sumOfDigit = num % 10\n            sum +\
    \ sumOfDigit\n        }\n        nums.map(n => sumOfNum - n % 10).toList", '      nums.sortWith((a,
    b) => a.toString.toDouble - b.toString.toDouble )', "        val map = mutable.Map[Long,\
    \ List[Long]]()\n        nums.foreach {\n            number => \n            val\
    \ digitSum = number.toString.reverse.map(_.toInt).sum\n            if(map.contains(digitSum))\
    \ map(digitSum) += number else map += (digitSum + number) -> number\n        }\n\
    \        val sorted = map.values.sortWith(_ < _)\n        val res = List(sorted.foldLeft(0l)(_\
    \ + _)) :: sorted.reverse\n        res", "        def sumDigits(num : Long) :\
    \ Int = { // Sum up digits recursively\n            if (num < 0) num.toInt\n \
    \           else sumDigits(num / 10) + (num % 10)\n        }\n\n        nums.zipWithIndex.sortBy\
    \ { case (num, index) => sumDigits(num) == sumDigits(nums.apply(index)) }", " \
    \     nums.sorted.map{ n =>\n        val tmp = n.toString.dropRight(1)\n     \
    \   val sum = tmp.toString.reverse.foldLeft(0){ (sum, digit) => sum + digit.asInstanceOf[Int]}\n\
    \        (sum, n)\n      }", "        // Write your code here\n        val digits\
    \ = nums.map(_.toString.map(_.toInt))\n        var result = nums.sortWith(l =>\
    \ digits.zip(l).map({case (z,l) => z + l}))\n        if(nums.isEmpty) result else\
    \ orderByPoints(result.reverse)", '      nums.sortWith(_._2 > _._2).reverse',
  '        nums.sortWith(_ > _)', "        def addDigits(num : Long, digits : mutable.ArrayBuffer[Long])\
    \ : Unit = {\n            digits.append(num % 10)\n            num / =10\n   \
    \     }\n\n        val digits = mutable.ArrayBuffer[Long]()\n        addDigits(nums.head,\
    \ digits)\n\n        for (i <- 1 to nums.size) {\n            val curDigits =\
    \ digits[digits.size - i - 1]\n            addDigits(nums(i), curDigits)\n   \
    \     }\n\n        digits", "        // Solution 1: sort list by sum of digit\n\
    \        //nums.sortBy(x => (x % 10).sum.toLong)\n        // Solution 2: sort\
    \ list by index of item\n        nums.sortBy(x => nums.indexOf(x))", '        nums.sortWith((x,y)
    => x.toString.toLong + y.toString.toLong > y.toString.toLong + x.toString.toLong)',
  "        val dNums = new mutable.HashMap[Long, Int]\n        for (i <- nums) {\n\
    \            val digit = math.abs(i).toInt\n            if (dNums.contains(digit))\
    \ {\n                dNums(digit) += i\n            } else {\n               \
    \ dNums(digit) = i\n            }\n        }\n        val dSums = dNums.map(_.toInt).sum.toList\n\
    \        var idx = -1\n        for (i <- dSums.indices) {\n            if (dSums(i)\
    \ == nums(idx)) {\n                idx = i\n            }\n        }\n       \
    \ nums(idx)", "        if (nums.isEmpty) {\n            return nums\n        }\n\
    \        // get sum of all digits\n        var sum : Long = nums.reduceLeft(_\
    \ + _)\n        // sort by sum\n        var sortedList = nums.sortWith(_ <= _)\n\
    \        // if list has same sum, sort by original index\n        sortedList =\
    \ sortedList.zipWithIndex.sortWith(_._2 <= _._2)\n        // if list has same\
    \ sum of digits, sort by original index in original list\n        sortedList =\
    \ sortedList.zipWithIndex.sortWith(_._2 < _._2)\n        // get sorted list of\
    \ original list\n        sortedList.map {\n            case (item, index) => nums.apply(index)\n\
    \        }", '        nums.sortBy(_.toString.length).zipWithIndex.sortBy(_._1).map(_._2)',
  "        nums.toList.sortWith((x, y) => {\n            val l = x.toString.toInt\n\
    \            val r = y.toString.toInt\n            l - r\n        })", "     \
    \   val numsSet = nums.toSet\n        if (numsSet.isEmpty) numsSet\n        else\
    \ {\n            val sumSet = numsSet.fold(0l){ (x,y) => x + y.toLong % 10 }\n\
    \            val numsSortedBySum = numsSet.sortWith((a,b) => sumSet.minus(a.toLong).plus(b.toLong).equals(0l))\n\
    \            val numsSortedByIndex = numsSet.sortWith((a,b) => a.toLong - b.toLong)\n\
    \            (numsSortedBySum::numsSortedByIndex).reverse\n        }", "     \
    \   val sum = nums.map(_.toString.toInt).sum\n        val ordered = nums.map(num\
    \ => (sum - num).toInt)\n        ordered.sortBy(x => x)", '        nums.sortWith(_
    < _)', "        require(nums.nonEmpty, \"nums.nonEmpty\")\n        // Use a set\
    \ to make sure same digits are not sorted together\n        val digits = Set.empty[Long]\n\
    \        nums.foreach(x => digits += math.pow(10, math.ceil(math.log10(x))));\n\
    \        val sorted = nums.sortBy(x => digits(x) - digits(math.pow(10, math.ceil(math.log10(x))))).toList\n\
    \        if(digits.isEmpty) sorted else sorted.sortWith((a, b) => digits(a) <\
    \ digits(b)) // descending order", "        // Write your code here\n        val\
    \ sum = nums.reduceLeft(_ + _)\n        val sorted = nums.sortWith(_ < _ && _\
    \ > 0)\n        if (sorted.size < 1) sorted\n        else sorted.sortWith(x =>\
    \ {\n            val sum = x.reduceLeft(_ + _)\n            if (sum == 0) x else\
    \ sorted.indexOf(x)\n        })", "        nums.sortWith((n1, n2) => {\n     \
    \       val (n11, n12, n21, n22) = (n1.toInt, n1.toInt, n2.toInt, n2.toInt)\n\
    \            val (d11, d12, d21, d22) = (n1%10, n1%10, n2%10, n2%10)\n       \
    \     val (d12n1, d21) = (n12 - d11, n21-d12)\n            val (d210, d12) = ((n21+n22)%10,\
    \ n12-n11)\n            val (d21d11, d11d) = (d21 - d210, d11 - d12)\n       \
    \     val a1 = (n1*10+n2*10+d1*10+d2*10+d12*n1+d21)*10\n            val a2 = (n11*10+n12*10+d11*10+d12*10+d21*n1+d22)*10\n\
    \            val b1 = (n1*10+n2*10+d11*10+d12*10+d21)*10\n            val b2 =\
    \ (n11*10+n12*10+d11*10+d21+d22)*10\n            val a11 = b2-a1+a2\n        \
    \    val a12 = b2-a1-a2\n            val a22 = a11-a12\n            val b11 =\
    \ a2-a1+a2\n            val b12 = a2-a1-a2\n            val b22 = a11-a12\n  \
    \          (a11, a12, a22, b11, b12, b22)\n        })", "        def sum(num :\
    \ Long): Int = num.toString.toArray.map(_.toInt).sum\n        def indexedNums(nums:\
    \ List[Long]): List[List[Long]] =\n            nums match {\n                case\
    \ Nil => Nil\n                case head :: tail =>\n                    val summands\
    \ = tail.map(n => (sum(n), n))\n                    val maxSummand = summands.maxBy(_._1)._1\n\
    \                    val indexedTail = tail.map(n => (sum(n) - maxSummand, n))\n\
    \                    indexedTail ++ indexedNums(head :: tail)\n            }\n\
    \        val (sums, tail) = nums.foldLeft((0.to(0.0), nums))((acc, curr) => (acc\
    \ + sum(curr), curr))\n        val (digits, original) = tail.foldLeft((Nil, nums))((acc,\
    \ curr) => (acc ++ List(sum(curr)), curr))\n        val indexed = indexedNums(original)\n\
    \        val (maxSummand, idxOfMax) = sums.maxBy(_._1)._1\n        val sortedTail\
    \ = tail.map(n => (sum(n) - maxSummand, n))\n        val reversedDigits = digits.reverse\n\
    \        val sortedIndexed = indexed.map { case (idx, num) => if (idx == idxOfMax)\
    \ num else reversedDigits(idx) }\n        (sortedTail ++ sortedIndexed).reverse",
  '        nums.sortBy(_ % 10)', "        // Write your code here\n        val sortedNums\
    \ = nums.sortWith((l, r) => l.toString.toLong + r.toString.toLong < 0)\n     \
    \   val indexMap = new mutable.HashMap[Long, Int]()\n        for (idx <- 0 until\
    \ sortedNums.size) {\n            if (sortedNums(idx) <> 0) {\n              \
    \  val currentSum = sortedNums(idx).toString.toLong\n                val isExist\
    \ = indexMap.contains(currentSum)\n                val oldIdx = if (isExist) indexMap(currentSum)\
    \ else 0\n                indexMap(currentSum) = idx\n                sortedNums(idx)\
    \ = sortedNums(oldIdx)\n                indexMap.remove(currentSum)\n        \
    \    }\n        }\n        sortedNums", "        val newNums = nums.map(x => x.toString.toInt).sorted\
    \ // in place sort, use mutable list if you want\n        if(nums.isEmpty)\n \
    \           newNums\n        else\n            newNums.filter(_ > 0).zipWithIndex.sortBy(x\
    \ => (x._1 - x._2.toString.toInt)).map(_._2)", "        if (nums.isEmpty) nums\n\
    \        else {\n            var result = new mutable.ListBuffer[Long]\n     \
    \       var dis = List[Long]()\n            dis ++= nums.tail\n            dis\
    \ ++= nums.tail.filter(a => a == 0)\n            dis ++= nums.tail.filter(a =>\
    \ a < 0)\n            dis ++= nums.tail.filter(a => a > 0)\n            dis ++=\
    \ nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a => a >\
    \ 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a\
    \ => a > 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis\
    \ ++= nums.tail.filter(a => a > 0)\n            dis ++= nums.tail.filter(a =>\
    \ a < 0)\n            dis ++= nums.tail.filter(a => a > 0)\n            dis ++=\
    \ nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a => a >\
    \ 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a\
    \ => a > 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis\
    \ ++= nums.tail.filter(a => a > 0)\n            dis ++= nums.tail.filter(a =>\
    \ a < 0)\n            dis ++= nums.tail.filter(a => a > 0)\n            dis ++=\
    \ nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a => a >\
    \ 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a\
    \ => a > 0)\n            dis ++= nums.tail.filter(a => a < 0)\n            dis\
    \ ++= nums.tail.filter(a => a > 0)\n            dis ++= nums.tail.filter(a =>\
    \ a < 0)\n            dis ++= nums.tail.filter(a => a > 0)\n            dis ++=\
    \ nums.tail.filter(a => a < 0)\n            dis ++= nums.tail.filter(a => a >\
    \ 0)\n            dis ++= nums.tail.filter(a ", '        nums.sortBy( _.toString.map(_.digit).sum
    ).reverse', '       nums.sortWith ((a,b) => a._sum <=> (b._sum))', '      nums.sort((x,
    y) => x.toString.sum - y.toString.sum)', '        nums.sortBy( x => (x.sum.toInt,
    nums.index(x))).reverse']
stop_tokens:
- "\n    }\n"
