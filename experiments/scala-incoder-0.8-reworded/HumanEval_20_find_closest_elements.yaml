name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n    //\
  \ ((2.0f, 2.2f))\n    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n    // ((2.0f, 2.0f))\n\
  \    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["        val numbers = numbers.toArray\n        val minNum = math.abs(numbers(0)).min(math.abs(numbers(1)))\n\
    \        val maxNum = math.abs(numbers(0)).max(math.abs(numbers(1)))\n       \
    \ val index0 = numbers.indexOf(minNum)\n        val index1 = numbers.indexOf(maxNum)\n\
    \        numbers match {\n            case Array(num1, num2) => if (num1 <= num2)\
    \ (index0, index1) else (index1, index0)\n            case _ => (index0, index1)\n\
    \        }", "        var i = 0\n        var minDiff = numbers(0).abs().asInstanceOf[Float]\
    \ - numbers(1).abs().asInstanceOf[Float]\n        var closestElement = (numbers(0),\
    \ numbers(1))\n        var nextElement = (numbers(1), numbers(0))\n\n        while(i\
    \ < numbers.size) {\n            val current = numbers(i)\n            val diff\
    \ = current.abs().asInstanceOf[Float] - minDiff\n            if(diff < minDiff)\
    \ {\n                minDiff = diff\n                closestElement = current\n\
    \            }\n            i += 1\n            nextElement = numbers(i)\n   \
    \     }\n        (closestElement, nextElement)", "        val numArray = numbers.toArray\n\
    \        val minDiff = math.abs(numArray(0) - numArray(1))\n        val minDiffIndex\
    \ = -1\n        val minNumIndex = -1\n        for ((i, e) <- 0 until numArray.length\
    \ - 1) {\n            val diff = math.abs(numArray(i) - numArray(i + 1))\n   \
    \         if (diff < minDiff) {\n                minDiff = diff\n            \
    \    minDiffIndex = i\n                minNumIndex = i + 1\n            }\n  \
    \      }\n        (numArray(minNumIndex), numArray(minDiffIndex))", "        val\
    \ smallestDiff = math.min(numbers.map(math.abs).max)\n        val closest = numbers.sortWith(math.abs)\n\
    \        (closest(1), closest(2))", "        val arrayOfNumbers = numbers.toArray\n\
    \        val min: Float = arrayOfNumbers.min\n        val max: Float = arrayOfNumbers.max\n\
    \        if(min == max) {\n            return (min,min)\n        }\n        val\
    \ minIndex: Int = arrayOfNumbers.indexWhere(x => x == min)\n        val maxIndex:\
    \ Int = arrayOfNumbers.indexWhere(x => x == max)\n        if(minIndex == maxIndex)\
    \ {\n            return (min,max)\n        }\n        val min1 = arrayOfNumbers(minIndex)\n\
    \        val min2 = arrayOfNumbers(minIndex + 1)\n        val max1 = arrayOfNumbers(maxIndex)\n\
    \        val max2 = arrayOfNumbers(maxIndex + 1)\n        val minDistance = math.abs(max1\
    \ - min2)\n        val maxDistance = math.abs(min1 - max2)\n        if(minDistance\
    \ < maxDistance) {\n            return (min1,max1)\n        }\n        return\
    \ (max1,min1)", "        val differences = numbers.zip(numbers.tail).map { case\
    \ (cur, prev) =>\n            (math.abs(cur - prev), cur)\n        }\n       \
    \ val minDiff = differences.min\n        val closestToMin = differences.find {\
    \ case (cur, prev) => cur < minDiff._1 }._2\n        val minIndex = differences.indexWhere(_._2\
    \ == minDiff)\n        (closestToMin, minIndex)", "        val mins = numbers.minBy(math.abs)\n\
    \        val maxs = numbers.maxBy(math.abs)\n        return (mins, maxs)", " \
    \       numbers.sortWith(math.abs)\n        val lo = numbers.head\n        val\
    \ hi = numbers.last\n        if(math.abs(hi-lo) <= .000001f) lo,hi\n        else\
    \ {\n            if(hi < lo) (hi, lo)\n            else if(hi > lo) (lo, hi)\n\
    \            else lo,hi\n        }", "        // Sort numbers from smallest (smallest)\
    \ to largest (largest)\n        numbers.sortWith((a: Float, b: Float) => math.abs(a-b))\n\
    \        // Return element at index (i+1) (+1 to skip the first element) as the\
    \ closest number\n        // and the element at index (i) as the next number in\
    \ the sorted list.\n        (numbers(numbers.indexOf(numbers(1))+1),numbers(0))",
  "        val list = numbers.toList\n        val list2 = numbers.toList.reverse\n\
    \        var lowest = list(0)\n        var highest = list(1)\n        for (i<-list2.length)\
    \ {\n            if (list2(i) < lowest ) {\n                lowest = list2(i)\n\
    \            }\n            if (list2(i) > highest ) {\n                highest\
    \ = list2(i)\n            }\n        }\n        return (highest, lowest)", " \
    \       val l = numbers.last\n        val r = numbers.head\n        // A set of\
    \ numbers that have not yet been chosen\n        val unchosenNumbers = numbers.dropWhile(_\
    \ <= l).takeWhile(_ >= r)\n        // A set of numbers that have already been\
    \ chosen\n        val chosenNumbers = numbers.filter(_ > l)\n\n        // If there\
    \ is a number in the set that is less than the middle of the\n        // unchosen\
    \ numbers, then we select that.\n        val middle = unchosenNumbers.findIndex(num\
    \ => num == (l+r)/2)\n        // If the middle is negative, then we select from\
    \ the beginning\n        if (middle < 0)\n            (l, r)\n        else\n \
    \           // Otherwise, we select from the middle\n            val middleToSelect\
    \ = middle match {\n                case 0 => l\n                case 1 => r\n\
    \                case _ => unchosenNumbers(middle)\n            }\n          \
    \  (l, r, middleToSelect)", "        val distances = numbers.map(n => math.abs(n-1.toFloat))\n\
    \        distances.minBy(distances.min)", "        // Find the closest pair from\
    \ the supplied list\n        val (smallestDifference,secondSmallestDifference)\
    \ = numbers.minBy(numbers.getOrElse(0f))\n        return (secondSmallestDifference,smallestDifference)",
  "        val sortedNumbers = numbers.sorted\n        val min1 = sortedNumbers(0)\n\
    \        val min2 = sortedNumbers(1)\n        if (min1 > min2)\n            (min2,\
    \ min1)\n        else\n            (min1, min2)", "        var minDiff = numbers(0)\
    \ - numbers(1)\n        var minIndex = 0\n        var maxIndex = 0\n        numbers\
    \ match {\n            case x :: y :: z :: Nil =>\n                val maxDiff\
    \ = Math.abs(x - z)\n                val maxIndexInArray = numbers.indexWhere(_.toFloat\
    \ == Math.max(minDiff, maxDiff))\n                val minIndexInArray = numbers.indexWhere(_.toFloat\
    \ == Math.min(minDiff, maxDiff))\n                if (minIndexInArray > maxIndexInArray)\
    \ {\n                    maxIndexInArray\n                } else {\n         \
    \           minIndexInArray\n                }\n            case x :: y :: Nil\
    \ =>\n                val maxDiff = Math.abs(y - x)\n                val minIndexInArray\
    \ = numbers.indexWhere(_.toFloat == Math.min(minDiff, maxDiff))\n            \
    \    if (minIndexInArray > maxIndexInArray) {\n                    minIndexInArray\n\
    \                } else {\n                    maxIndexInArray\n             \
    \   }\n            case x :: Nil =>\n                val maxDiff = Math.abs(x\
    \ - numbers(1))\n                val minIndexInArray = numbers.indexWhere(_.toFloat\
    \ == Math.min(minDiff, maxDiff))\n                if (minIndexInArray > maxIndexInArray)\
    \ {\n                    minIndexInArray\n                } else {\n         \
    \           maxIndexInArray\n                }\n            case Nil =>\n    \
    \            throw new RuntimeException(\"findClosestElements was passed an empty\
    \ list.\")\n        }", "        val smallest = numbers(0)\n        val largest\
    \ = numbers(0)\n        // For every number we compare it to smallest\n      \
    \  numbers foreach { x =>\n            if (x < smallest) {\n                smallest\
    \ = x\n            }\n            if (x > largest) {\n                largest\
    \ = x\n            }\n        }\n        // Return the smallest and largest\n\
    \        (smallest, largest)", "        var lowest1 = numbers(0)\n        var\
    \ highest1 = numbers(0)\n        var lowest2 = numbers(0)\n        var highest2\
    \ = numbers(0)\n        var lowestDiff = lowest1 - lowest2\n        var highestDiff\
    \ = highest1 - highest2\n        var diff = 0\n        if (numbers.size() > 1)\
    \ {\n            for (i <- 1 to numbers.size()) {\n                if (numbers(i)\
    \ < lowest1) {\n                    lowest1 = numbers(i)\n                }\n\
    \                if (numbers(i) > highest1) {\n                    highest1 =\
    \ numbers(i)\n                }\n                if (numbers(i) < lowest2) {\n\
    \                    lowest2 = numbers(i)\n                }\n               \
    \ if (numbers(i) > highest2) {\n                    highest2 = numbers(i)\n  \
    \              }\n                if (numbers(i) != lowest2 && numbers(i) != highest2\
    \ && numbers(i) > lowestDiff && numbers(i) < highestDiff) {\n                \
    \    diff += numbers(i)\n                }\n            }\n            if (diff\
    \ < lowestDiff) {\n                lowestDiff = diff\n                lowest1\
    \ = lowest2\n            }\n            if (diff > highestDiff) {\n          \
    \      highestDiff = diff\n                highest1 = highest2\n            }\n\
    \        }\n        ((lowest1, highest1))", "        // Sort the list from smallest\
    \ to largest first\n        numbers.sortWith( (n1, n2) => {\n            if (n1\
    \ < n2)\n                true\n            else\n                false\n     \
    \   })\n        // If two numbers are equidistant, return the lower one\n    \
    \    if (numbers(0) == numbers(1))\n            return (numbers(0), numbers(1))\n\
    \        // If the numbers differ by a much (less than 0.01%) then we return the\
    \ first one that is smaller\n        else if  (Math.abs(numbers(0) - numbers(1))\
    \ < 0.01f)\n            return (numbers(0), numbers(1))\n        // If n1 and\
    \ n2 are too close to each other, then return the one that is closer to the middle\
    \ one\n        else\n            val middle = (numbers(0) + numbers(1)) / 2\n\
    \            // Check which number is closer to the middle one\n            if\
    \ (Math.abs(numbers(0) - middle) < Math.abs(numbers(1) - middle))\n          \
    \      (numbers(0), middle)\n            else\n                (middle, numbers(1))",
  "        val indexMap = numbers.map(x => (x, 0)).zipWithIndex.toMap\n        var\
    \ minDistance = math.max(numbers.map(x => math.abs(x - numbers.min))).min\n  \
    \      var result = numbers.min\n        var minIndex = 0\n        for ((value,\
    \ index) <- indexMap) {\n            if (math.abs(value - result) < minDistance)\
    \ {\n                minDistance = math.abs(value - numbers.min)\n           \
    \     result = value\n                minIndex = index\n            }\n      \
    \  }\n        (result, numbers.max)", "        val (minLoc, maxLoc) = (numbers.min,\
    \ numbers.max)\n        val minI = numbers.indexOf(minLoc)\n        val maxI =\
    \ numbers.indexOf(maxLoc)\n        if(minI == -1) //return (maxLoc, minLoc)\n\
    \        (maxLoc, minLoc)", "        val smallest = math.min(numbers.head)\n \
    \       val largest = math.max(numbers.last)\n        val sortedNumbers = numbers.sortBy(math.abs)\n\
    \        val halfwayPoint = (sortedNumbers.head + sortedNumbers.last) / 2\n  \
    \      if (smallest == largest ) {\n            (smallest, largest)\n        }\
    \ else {\n            if (smallest < halfwayPoint) {\n                findClosestElements(sortedNumbers.takeWhile(_\
    \ < smallest))\n            } else {\n                findClosestElements(sortedNumbers.takeWhile(_\
    \ > largest))\n            }\n        }", "        val setOfClosest = new mutable.HashSet[Float]\n\
    \        numbers.zip(numbers.drop(1)).foreach{ t =>\n            val distance\
    \ = math.sqrt(math.pow(t[0] - t[1], 2.0f))\n            setOfClosest.add(distance)\n\
    \        }\n        if (setOfClosest.size == 1) {\n            return (numbers(0),\
    \ numbers(0))\n        }\n        if (setOfClosest.size == 2) {\n            return\
    \ (numbers(0), numbers(1))\n        }\n        val sortedSetOfClosest = setOfClosest.sortWith(_\
    \ < _)\n        return (numbers(sortedSetOfClosest.head), numbers(sortedSetOfClosest.last))",
  "        val distances = new mutable.HashMap[Float, Float]()\n        // Use first\
    \ and last elements as keys and values will initially be undefined\n        distances.put(numbers(0),\
    \ numbers(0))\n        distances.put(numbers(numbers.length - 1), numbers(numbers.length\
    \ - 1))\n        var smallestDistance = distances.getOrElse(numbers(0), Float.PositiveInfinity)\n\
    \        var largestDistance = distances.getOrElse(numbers(0), Float.NegativeInfinity)\n\
    \n        // Loop through the rest of the elements in the list\n        for {i\
    \ <- 1 to numbers.length - 2} {\n            val currentDistance = numbers(i)\
    \ - numbers(i - 1)\n            if (currentDistance < smallestDistance) {\n  \
    \              smallestDistance = currentDistance\n            }\n           \
    \ if (currentDistance > largestDistance) {\n                largestDistance =\
    \ currentDistance\n            }\n            distances.put(numbers(i), currentDistance)\n\
    \        }\n        // Return the smallest and largest number pair in the list\
    \ as required\n        (numbers(numbers.length - 1), numbers(numbers.length -\
    \ 2))", "        val sortedNums = numbers.sortBy(_)\n        val leftIndex   \
    \ = sortedNums.indexWhere(_ < sortedNums(0))\n        val rightIndex   = sortedNums.indexWhere(_\
    \ > sortedNums(1))\n        val leftVal      = sortedNums(leftIndex)\n       \
    \ val rightVal     = sortedNums(rightIndex)\n        (leftVal, rightVal)", " \
    \     val aToB = (numbers.map(_.abs) - numbers.map(_.abs).min).max\n      (numbers.min(aToB),\
    \ numbers.max(aToB))", "        numbers.sortWith(_ < _)\n        if (numbers.length\
    \ < 2)\n            numbers.head\n        else\n            math.abs(numbers.head\
    \ - numbers.last)", "        var largest = numbers.head\n        var smallest\
    \ = numbers.head\n        for (i <- numbers.tail) {\n            if (i < smallest\
    \ || (i == smallest && i != largest)) {\n                smallest = i\n      \
    \      } else if (i > largest || (i == largest && i != smallest)) {\n        \
    \        largest = i\n            }\n        }\n        (largest, smallest)",
  "        val smallestElement = numbers.min\n        val largestElement = numbers.max\n\
    \        (smallestElement, largestElement)", "        if (numbers.length < 2)\
    \ throw new IllegalArgumentException(\"Numbers must have two or more elements!\"\
    );\n        val n = numbers.size\n        val min1 = math.min(numbers(0), numbers(1))\n\
    \        val max1 = math.max(numbers(0), numbers(1))\n        for (i <- 2 to n)\
    \ {\n            val min2 = math.min(numbers(i), numbers(i - 1))\n           \
    \ val max2 = math.max(numbers(i), numbers(i - 1))\n            val diff = math.abs(min2\
    \ - min1)\n            if (diff < math.min(max1, max2)) min2 = min1\n        \
    \    if (diff < math.max(max1, max2)) max2 = max1\n            min1 = min2\n \
    \           max1 = max2\n        }\n        (min1, max1)", "        // Return\
    \ first two numbers in order (smaller number, larger number).\n        // Return\
    \ them as tuple. (Smallest number, Largest number)\n        val result = numbers.minBy(x\
    \ => x) (numbers.maxBy(x => x) )\n        (result, result)", '        numbers.minBy
    { x => math.abs(x - numbers.last) }.last.asInstanceOf[Float], numbers.maxBy {
    x => math.abs(x - numbers.last) }.last.asInstanceOf[Float]', "        val minDiff\
    \ = numbers(0) - numbers(1)\n        val minDiffIndex = numbers.indexWhere(_ ==\
    \ minDiff)\n        numbers(0), numbers(1)", "        val numSet = numbers.toSet\n\
    \        val sortedNumbers = numbers.sort\n        if (sortedNumbers.head == sortedNumbers.last)\n\
    \            (sortedNumbers.head, sortedNumbers.last)\n        else {\n      \
    \      val first = sortedNumbers.head\n            val last = sortedNumbers.last\n\
    \            val diff = last - first\n            val maxDiff = diff / 2\n   \
    \         for (i <- 0 until sortedNumbers.length - 1 by -1) {\n              \
    \  val testVal = sortedNumbers(i)\n                val testDiff = testVal - first\n\
    \                if (diff <= testDiff && testDiff <= maxDiff) {\n            \
    \        return (sortedNumbers(i), sortedNumbers(i + 1))\n                }\n\
    \            }\n            (sortedNumbers.last, sortedNumbers.first)\n      \
    \  }", "        val smaller = numbers.min\n        val larger = numbers.max\n\
    \        numbers.zip(numbers.tail).map {\n            case (currentVal, nextVal)\
    \ => math.abs(nextVal - currentVal) < math.abs(nextVal - smaller) ? currentVal\
    \ : nextVal\n        }.sortWith(_ > _).take(2)", "        val m = numbers.length\n\
    \        if (m <= 1) throw new IllegalArgumentException\n\n        // Find the\
    \ two closest numbers\n        var minDiff = numbers(0) - numbers(1)\n       \
    \ var minIndex = 0\n        var maxIndex = 1\n        for (i <- 1 to m) {\n  \
    \          val diff = numbers(i) - numbers(minIndex)\n            if (diff < minDiff)\
    \ {\n                minDiff = diff\n                minIndex = i\n          \
    \  } else if (diff > maxDiff) {\n                maxIndex = i\n            }\n\
    \        }\n\n        // Return the two closest numbers\n        (numbers(minIndex),\
    \ numbers(maxIndex))", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val listWithClosestPair = (numbers zip numbers).filter(\n           \
    \ n => (Math.abs(n._1 - min) < Math.abs(n._2 - min))\n                || (Math.abs(n._1\
    \ - max) < Math.abs(n._2 - max))\n        ).sortWith(\n            (a : Float,\
    \ b : Float) => a.toInt - b.toInt\n        ).take(2)\n        (listWithClosestPair.head._1,\
    \ listWithClosestPair.head._2)", "        val m = numbers.foldLeft(numbers.min){\n\
    \            case (min, num) => (num < min) ? num : min\n        }\n\n       \
    \ val n = numbers.foldLeft(numbers.max){\n            case (min, num) => (num\
    \ > min) ? num : min\n        }\n\n        (m, n)", "        if (numbers.size\
    \ == 0) return (numbers(0), numbers(0))\n        var smallestValue : Float = numbers(0)\n\
    \        var biggestValue : Float = numbers(0)\n        numbers.foreach(n => {\
    \ if (n > smallestValue) smallestValue = n })\n        numbers.foreach(n => {\
    \ if (n < biggestValue) biggestValue = n })\n        (smallestValue, biggestValue)",
  "        val minDist = numbers.foldLeft(0.0f){ (minDist, number) =>\n          \
    \  val dist = math.abs(number - minDist)\n            if (dist < minDist)\n  \
    \              dist\n            else\n                minDist\n        }\n  \
    \      numbers(numbers.indexOfMin(numbers))", "        val sorted = numbers.toList.sorted\n\
    \        val minDiff = math.abs(sorted((sorted[1] - sorted[0]) / 2.0f))\n    \
    \    (sorted((sorted[1] - sorted[0]) / 2.0f), sorted((sorted[-1] - sorted[-2])\
    \ / 2.0f))", "        val x = numbers.min\n        val y = numbers.max\n     \
    \   val leftClosest = numbers(numbers.indexWhere(_ == x) + 1)\n        val rightClosest\
    \ = numbers(numbers.indexWhere(_ == y) - 1)\n        (leftClosest, rightClosest)",
  "        var minDistance = math.abs(numbers(0) - numbers(1))\n        var minIndex\
    \ = 0\n        var minValue = numbers(0)\n        var minNumber = numbers(1)\n\
    \        for (i <- 0 until numbers.length - 1) {\n            val difference =\
    \ math.abs(numbers(i) - numbers(i+1))\n            if (difference < minDistance)\
    \ {\n                minDistance = difference\n                minIndex = i\n\
    \                minValue = numbers(i)\n                minNumber = numbers(i+1)\n\
    \            }\n        }\n        (minValue, minNumber)", "        val nums =\
    \ numbers.toSeq\n        val minDist = nums.minBy(_ * -1)\n        val maxDist\
    \ = nums.maxBy(_ * -1)\n        return (minDist, maxDist)", "        require(numbers.size\
    \ > 2, \"numbers.length <= 2\")\n        val a = numbers.head + numbers.last\n\
    \        val smallestClosest = numbers.sortWith(_ < _).min\n        val largestClosest\
    \ = numbers.sortWith(_ > _).max\n        smallestClosest -> largestClosest", " \
    \       var largest = numbers.last\n        var smallest = numbers.head\n\n  \
    \      for (number <- numbers) {\n            if (number > largest) {\n      \
    \          largest = number\n            } else if (number < smallest) {\n   \
    \             smallest = number\n            }\n        }\n\n        (smallest,\
    \ largest)", "        // Find two numbers, each closest to each other in the supplied\
    \ list\n        val diffs = numbers.zipWithIndex.filter { case (n, _) => n !=\
    \ numbers.last._ }\n        // Return the smaller number as the smaller index\
    \ value\n        val small = diffs.minBy(_._2)\n        // Return the larger number\
    \ as the larger index value\n        val large = diffs.maxBy(_._2)\n        (small._1,\
    \ large._1)", "        var sortedNumbers = numbers.sortBy(-_)\n        var smallNumber\
    \ = sortedNumbers.head\n        var bigNumber = sortedNumbers.last\n        sortedNumbers\
    \ = sortedNumbers.dropRight(1)\n        sortedNumbers.foreach(n => {\n       \
    \     if (n < smallNumber) {\n                smallNumber = n\n            }\n\
    \            if (n > bigNumber) {\n                bigNumber = n\n           \
    \ }\n        })\n        if (smallNumber == bigNumber) {\n            return (smallNumber,\
    \ bigNumber)\n        }\n        if (smallNumber < bigNumber) {\n            val\
    \ smallestDistance = closestDistance(smallNumber, bigNumber, sortedNumbers)\n\
    \            return smallestDistance._1 -> smallestDistance._2\n        }\n  \
    \      val largestDistance = closestDistance(smallNumber, bigNumber, sortedNumbers)\n\
    \        return largestDistance._2 -> largestDistance._1", "        // Using a\
    \ map function and a fold function to calculate the average\n        val m = (1\
    \ to numbers.size).map(i => numbers(i)).foldLeft(0.0f) {\n            case (acc,\
    \ x) => acc + (x * x)\n        }\n        val n = (1 to numbers.size).map(i =>\
    \ numbers(i)).foldLeft(0.0f) {\n            case (acc, x) => acc + (x * x)\n \
    \       }\n        val d = (m - n) / (2.0f * n)\n        // Return the two values\
    \ closest to each other\n        val diffs = (0.0 to n).map { i => (i, (numbers(i)\
    \ - m) / d) }\n        val min = diffs.minBy(_._1)._2\n        val max = diffs.maxBy(_._1)._2\n\
    \        (min, max)", "        if (numbers.size == 0) return null\n        if\
    \ (numbers.size < 2) return null\n        val minDistance = numbers(numbers.size\
    \ - 1)\n        val maxDistance = numbers(0)\n        for (i <- 1 to numbers.size\
    \ - 1) {\n            val distance = math.sqrt(numbers(i) * (numbers(i) - minDistance)\
    \ * (numbers(i) - minDistance))\n            if (distance < maxDistance) {\n \
    \               maxDistance = distance\n            } else if (distance > maxDistance)\
    \ {\n                minDistance = distance\n            } else {\n          \
    \      val temp = numbers(i).toFloat\n                if (temp < minDistance)\
    \ {\n                    minDistance = temp\n                }\n            }\n\
    \        }\n        (minDistance, maxDistance)", "        val maxPairs = numbers.map(_\
    \ => math.abs(_)).toSet\n        numbers.toList.sortWith(maxPairs.min)", "   \
    \     val smallest = numbers(0)\n        val largest = numbers(0)\n        numbers\
    \ foreach {\n            (number : Float) => {\n                if (number < smallest\
    \ ) {\n                    smallest = number\n                }\n            \
    \    if (number > largest ) {\n                    largest = number\n        \
    \        }\n            }\n        }\n        (smallest, largest)", "        numbers.minBy\
    \ {\n        case (first, second) =>\n            (second - first).abs()\n   \
    \     }", "        require(numbers.length > 1)\n        val min: Float = numbers.min\n\
    \        val max: Float = numbers.max\n        var low: Float = min\n        var\
    \ high: Float = max\n        var index: Int = 0\n        while (index < numbers.length)\
    \ {\n            if (low + numbers(index) < high) {\n                low = low\
    \ + numbers(index)\n                index+=1\n            } else {\n         \
    \       high = high + numbers(index)\n                index+=1\n            }\n\
    \        }\n        (min, max)", "        val numberSorted = numbers.sortWith(_\
    \ < _)\n        val first = numberSorted.head\n        val second = numberSorted.last\n\
    \        (first, second)", "        numbers.sortWith(_ < _)\n        val min1\
    \ = numbers.head\n        val min2 = numbers.last\n        (min1, min2)", "  \
    \      val m = numbers.size\n        if (m > 2) {\n            val xDiff = numbers.map(_-numbers(0))\n\
    \            val yDiff = numbers.map(_-numbers(1))\n            val min = xDiff.min\n\
    \            val max = xDiff.max\n            val min = yDiff.min\n          \
    \  if (min < max) {\n                if (min < 0.0f) {\n                    val\
    \ (x, _) = numbers.span(_ < min)\n                    val (y, _) = numbers.span(_\
    \ < min)\n                    val (min, _) = numbers.span(_ < min)\n         \
    \           ((x, y), (min, _))\n                } else {\n                   \
    \ val (_, _) = numbers.span(_ < min)\n                    val (y, _) = numbers.span(_\
    \ < min)\n                    val (min, _) = numbers.span(_ < min)\n         \
    \           ((min, _), (y, x))\n                }\n            } else {\n    \
    \            val (_, _) = numbers.span(_ < min)\n                val (_, _) =\
    \ numbers.span(_ < min)\n                val (min, _) = numbers.span(_ < min)\n\
    \                ((min, _), (x, y))\n            }\n        } else {\n       \
    \     (numbers(0), numbers(1))\n        }", "        val sortedNumbers = numbers.sort\n\
    \        if (sortedNumbers.size == 2) {\n            (sortedNumbers(0), sortedNumbers(1))\n\
    \        } else {\n            val smallestOne = sortedNumbers(0)\n          \
    \  val largestOne = sortedNumbers(sortedNumbers.size - 1)\n            val smallestTwo\
    \ = sortedNumbers(1)\n            val largestTwo = sortedNumbers(sortedNumbers.size\
    \ - 2)\n            val newNumbers = List(smallestOne, smallestTwo, largestOne,\
    \ largestTwo)\n            (findClosestElements(newNumbers), findClosestElements(newNumbers))\n\
    \        }", "        val listSize = numbers.size\n        val mid = numbers.size\
    \ / 2\n        numbers.take(mid).zip(numbers.drop(mid)).map {\n            case\
    \ (firstElement, secondElement) => (secondElement - firstElement).toInt\n    \
    \    }.min match {\n            case smallestElement if (smallestElement < listSize\
    \ / 2) => (smallestElement + smallestElement) / 2\n            case smallestElement\
    \ if (smallestElement > listSize / 2) => (listSize / 2 + listSize / 2) / 2\n \
    \           case _ => listSize / 2\n        }", "        val min = numbers.min\n\
    \        val max = numbers.max\n        val minIdx = 0\n        val maxIdx = numbers.length\
    \ - 1\n\n        if (maxIdx <= minIdx) {\n            return (minIdx -> maxIdx)\n\
    \        }\n        else {\n            val midIdx = math.ceil(Math.ceil((maxIdx\
    \ - minIdx) / 2.0f))\n            val midVal = numbers(midIdx)\n            val\
    \ numMidVals = numbers.length - midIdx // how many times will midVal be repeated\n\
    \            val closestPair : Tuple2[Int, Float] = numbers.sliding(numMidVals\
    \ + 1).sliding(numMidVals + 1).map {\n                case List(a,b,c) => new\
    \ Tuple2[Int, Float](a,b)\n            }.toList\n            if (closestPair.head._1\
    \ == maxIdx) {\n                return (minIdx -> maxIdx)\n            }\n   \
    \         else if (closestPair.head._1 == minIdx) {\n                return (maxIdx\
    \ -> minIdx)\n            }\n            else {\n                val smallerIdx\
    \ = closestPair.head._1\n                val largerIdx = closestPair.last._1\n\
    \                val smallerVal = closestPair.head._2\n                val largerVal\
    \ = closestPair.last._2\n                if (largerVal == smallerVal) {\n    \
    \                return (smallerIdx -> largerIdx)\n                }\n       \
    \         else {\n                    val nextSmaller = closestPair.head._1 +\
    \ 1\n                    if (nextSmaller > numbers.length - 1) {\n           \
    \             return (smallerIdx -> maxIdx)\n                    }\n         \
    \           else {\n                        val nextLarger = closestPair.last._1\
    \ - 1\n                        val nextSmaller = closestPair.last._1 + 1\n   \
    \                     if (nextSmaller > numbers.length - 1) {\n              \
    \              return (nextLarger -> maxIdx)\n                        }\n    \
    \                    else {\n                            val nextLargerNextSmaller\
    \ = closestPair.last._1 - 1 + 1\n                            val nextSmallerNextLarger\
    \ = closestPair.last._1 + 1 + 1\n                            if (nextLargerNextSmaller\
    \ > numbers.length - 1) {\n                                return (nextLarger\
    \ -> nextSmallerNextLarger)\n                            }\n                 \
    \           else {\n                                val nextSmallerNextLargerNextSmaller\
    \ = closestPair.last._1 + 1 + 1 + 1\n                                val nextLargerNextSmallerNextLarger\
    \ = closestPair.last._1 + 1 + 1 + 1 + 1\n                                if (nextSmallerNextLargerNextSmaller\
    \ > numbers.length - 1) {\n                                    return (nextSmallerNextL",
  "        val min = math.min(numbers)\n        val max = math.max(numbers)\n    \
    \    if (max < min) (min,max)\n        else {\n            var smallest = smallest\
    \ : Option[Float] = None\n            var largest = largest : Option[Float] =\
    \ None\n            var index = numbers.indexOf(min)\n            while (index\
    \ != -1) {\n                if (largest == None) {\n                    largest\
    \ = Some(numbers.get(index))\n                } else {\n                    if\
    \ (numbers.get(index) < largest.get) {\n                        largest = Some(numbers.get(index))\n\
    \                    }\n                }\n                index = numbers.indexOf(min)\n\
    \            }\n            if (smallest == None) {\n                smallest\
    \ = Some(numbers.get(index))\n            } else {\n                if (numbers.get(index)\
    \ > smallest.get) {\n                    smallest = Some(numbers.get(index))\n\
    \                }\n            }\n            (smallest.get,largest.get)\n  \
    \      }", "        var min = numbers(0)\n        var max = numbers(0)\n     \
    \   for (n1 <- numbers) {\n            for (n2 <- numbers) {\n               \
    \ if(n1 < n2 && n1 > min && n2 > max) {\n                    min = n2\n      \
    \              max = n1\n                }\n            }\n        }\n       \
    \ (min, max)", "        if (numbers.length < 2) throw new IllegalArgumentException(\"\
    Insufficient number of elements supplied!\")\n        val sortedNumbers = numbers.sorted\n\
    \        val diffs = sortedNumbers.zip(sortedNumbers.drop(1)).map{_ - _}\n   \
    \     val minDiffIndex = diffs.indexOf(diffs.min())\n        (sortedNumbers(minDiffIndex),\
    \ sortedNumbers(minDiffIndex+1))", "        require(numbers.size > 2, \"You entered\
    \ too few numbers try again\")\n        require(numbers.forall( x => x > 0.0 &&\
    \ x < 1.0), \"Only numbers between 0.0 and 1.0 please!\")\n\n        // Create\
    \ a list of closest numbers by calculating the distance of each from each other\n\
    \        // and sort the list from smallest to largest\n        val closestNumbers\
    \ = numbers.map(x => numbers.map((x -_).abs).reduce(_ + _).abs).map(x => (x, x)).sortBy(_._1)\n\
    \        // Return the two numbers closest to eachother\n        closestNumbers.take(2)",
  "        val min1 = math.abs(numbers(0) - numbers(1))\n        val min2 = math.abs(numbers(0)\
    \ - numbers(2))\n        if (min1 < min2) {\n            (numbers(1), numbers(0))\n\
    \        } else {\n            (numbers(0), numbers(2))\n        }", "       \
    \ // Initialize distance to infinity and to negative infinity\n        var distance\
    \ = sys.float.NegativeInfinity\n        var closest = 0.0f\n        for (number\
    \ <- numbers) {\n            val diff = number - closest\n            if (diff\
    \ < 0.0f) {\n                val temp = Math.abs(distance)\n                val\
    \ closestDiff = Math.abs(diff)\n                if (temp < closestDiff) {\n  \
    \                  distance = diff\n                    closest = number\n   \
    \             }\n            }\n        }\n        (closest, distance)", "   \
    \     // Make two new lists of two elements\n        val firstDifferences = (numbers\
    \ - numbers.min) diff (numbers.min)\n        val secondDifferences = (numbers.max\
    \ - numbers) diff (numbers.max)\n        // Find the closest value for each list\
    \ and return the smallest and largest ones\n        (firstDifferences.min.asInstanceOf[Float],\
    \ secondDifferences.max.asInstanceOf[Float])", "        val differences = numbers.zipWithIndex.map\
    \ {\n            case (number, index) => (index.toFloat - number.toFloat)\n  \
    \      }\n        val minDifferenceIndex = differences.min\n\n        val minDifference\
    \ = differences(minDifferenceIndex)\n\n        val minIndex = differences.zipWithIndex.minBy(_._1)._2\n\
    \n        return (numbers(minIndex), numbers(minDifferenceIndex))", "        val\
    \ n = numbers.size\n        if (n <= 1) {\n            return (numbers(0), numbers(0))\n\
    \        }\n        val half = n / 2\n        numbers.sortWith((a, b) => math.abs(b\
    \ - a) < math.abs(b - half))\n        if (numbers(n-1) < numbers(half)) {\n  \
    \          (numbers(n-1), numbers(half))\n        } else {\n            (numbers(half),\
    \ numbers(n-1))\n        }", "        var minElement = numbers(0)\n        var\
    \ maxElement = numbers(0)\n        var minValue = numbers(0)\n        var maxValue\
    \ = numbers(0)\n\n        for (number <- numbers) {\n            if (number <\
    \ minValue) {\n                minValue = number\n            } else if (number\
    \ > maxValue) {\n                maxValue = number\n            }\n\n        \
    \    minElement = number\n            maxElement = number\n        }\n\n     \
    \   (minElement, maxElement)", "        if (numbers.size < 2) {\n            throw\
    \ new RuntimeException(\"List must have at least two elements\")\n        }\n\
    \        var minDiff = numbers.head.toFloat - numbers.last.toFloat\n        var\
    \ minNum : Float = numbers.head.toFloat\n        var maxNum : Float = numbers.last.toFloat\n\
    \        for (n <- numbers.drop(1)){\n            var diff = (n - maxNum).toFloat\n\
    \            if (diff < minDiff){\n                minDiff = diff\n          \
    \      minNum = n\n                maxNum = n\n            }\n        }\n    \
    \    (minNum, maxNum)", "        val distances = numbers.map {\n            number\
    \ => Math.abs(number.toFloat - numbers.max).toFloat\n        }\n        val firstIndex\
    \ = distances.index(distances.min) // Index of smallest number in distances\n\
    \        val secondIndex = distances.index(distances.max) // Index of biggest\
    \ number in distances\n        distances.take(firstIndex).zip(distances.take(secondIndex))",
  "        val nums = numbers.toList\n        val min1 = nums.min\n        val max1\
    \ = nums.max\n        val min2 = nums.minBy(x => x)\n        val max2 = nums.maxBy(x\
    \ => x)\n        if(min1 == max1) (min2, max2)\n        else {\n            val\
    \ diff1 = Math.abs(min1 - max1)\n            val diff2 = Math.abs(min2 - max2)\n\
    \            if(diff1 < diff2) (min1, max1)\n            else (min2, max2)\n \
    \       }", "        val minList = (numbers, numbers.min) match {\n          \
    \  case (x::xs, y::ys) => xs.zip(ys)\n        }\n        val maxList = (numbers,\
    \ numbers.max) match {\n            case (x::xs, y::ys) => xs.zip(ys)\n      \
    \  }\n        if (minList.size < 2) throw new IndexOutOfBoundsException(\"List\
    \ is too small for two elements.\")\n        if (maxList.size < 2) throw new IndexOutOfBoundsException(\"\
    List is too small for two elements.\")\n        val closest = minList._1.minBy(_\
    \ - numbers.get(0))\n        (numbers.get(1), numbers.get(0) - (closest - numbers.get(0))).sorted.unzip",
  "        // Get max and min\n        var max = numbers.max\n        var min = numbers.min\n\
    \        // For each number in the list\n        for ( i <- numbers) {\n     \
    \       // Get squared difference between i and max\n            val diff = math.pow((i\
    \ - max), 2)\n            // If this is less than the smallest so far\n      \
    \      if (diff < min) {\n                // Set the smallest so far to be this\
    \ number\n                min = diff\n            }\n            // If this is\
    \ greater than the largest so far\n            if (diff > max) {\n           \
    \     // Set the largest so far to be this number\n                max = diff\n\
    \            }\n        }\n        // Return the smallest two numbers in the list\n\
    \        (min, max)", "        var smallest = math.Int.MinValue\n        var largest\
    \ = math.Int.MaxValue\n        for (number <- numbers) {\n            if(smallest\
    \ > number) {\n                smallest = number\n            }\n            if(largest\
    \ < number) {\n                largest = number\n            }\n        }\n  \
    \      return (smallest, largest)", "      val sortedNumbers = numbers.sortBy(-_)\n\
    \      (sortedNumbers.take(2), sortedNumbers.last)", "        // Start with first\
    \ number and check if it is closer to second number than first\n        var closestIndex\
    \ : Int = -1\n        val closestElement = numbers(0)\n        val difference\
    \ = math.abs(closestElement - numbers(1))\n        if (difference < 1.0E-6) {\n\
    \            // If first number is closer to second number than first\n      \
    \      closestIndex = 0\n        } else if (difference < 2.0E-6) {\n         \
    \   // If second number is closer to first number than first\n            closestIndex\
    \ = 1\n        }\n        if (closestIndex != -1) {\n            // Found closest\
    \ number in given list\n            val closestNumber = numbers(closestIndex)\n\
    \            // Return tuple (closest number 1, closest number 2)\n          \
    \  return (closestNumber, closestNumber)\n        } else {\n            // Return\
    \ tuple (first number 1, first number 2)\n            return (numbers(0), numbers(1))\n\
    \        }", "        // Find the difference between each number in the list\n\
    \        var diffs = numbers.zipWithIndex.map { case (n,i) => n - numbers.lift(i)\
    \ }\n\n        // Find the two smallest differences\n        val minDif = diffs.min\n\
    \        val index1 = diffs.indexOf(minDif)\n\n        // The second smallest\
    \ difference is the one not in the previous list\n        val index2 = index1\
    \ + 1\n\n        // Now that we've determined which numbers are closest to eachother,\
    \ we can use these to determine the two closest\n        // elements in the list\n\
    \        // Get the two numbers\n        val (firstClosest, secondClosest) = numbers.span(i\
    \ => i <= index1)\n        (firstClosest, secondClosest)", "        val m = numbers.toSet\n\
    \        val n = (numbers.head + numbers.last) / 2\n        m.map(n).minBy(x =>\
    \ math.abs(x - n))", "        var smallest: Float = _\n        var largest: Float\
    \ = _\n        numbers.sortWith(_ < _).foreach(n => {\n            if(n == smallest\
    \ || n == largest) {\n                return\n            }\n            if(smallest\
    \ == _) {\n                smallest = n\n            } else {\n              \
    \  largest = n\n            }\n        })\n        (smallest, largest)", "   \
    \     // Get the numbers in order (smaller number, larger number)\n        val\
    \ sortedNumbers = numbers.sortBy(_.toDouble).toList\n        // Check if two numbers\
    \ arent the same\n        var closestToOther = 0\n        var closestToMe = 0\n\
    \        var closestToOtherIndex = 0\n        // Iterate the list until we find\
    \ a different number or we reach the end of the list\n        while(sortedNumbers.nonEmpty\
    \ && sortedNumbers.tail.nonEmpty && sortedNumbers.head == sortedNumbers.tail.head)\
    \ {\n            // Check to see if we found the number we are looking for and\
    \ stop looking if we did\n            if(sortedNumbers.head == closestToOther)\
    \ {\n                closestToOtherIndex = 1\n            }\n            else\
    \ {\n                closestToOtherIndex = 0\n            }\n            // Check\
    \ if the current number is smaller than the previously found number in the list\n\
    \            if((sortedNumbers.head - closestToOther < sortedNumbers.tail.head\
    \ - closestToOther) && closestToOtherIndex == 0) {\n                // Store the\
    \ new number if we find it\n                closestToOther = sortedNumbers.head\n\
    \            }\n            // Check if the current number is larger than the\
    \ previously found number in the list\n            else if((sortedNumbers.head\
    \ - closestToOther > sortedNumbers.tail.head - closestToOther) && closestToOtherIndex\
    \ == 1) {\n                // Store the new number if we find it\n           \
    \     closestToOther = sortedNumbers.tail.head\n            }\n            sortedNumbers.head\
    \ = sortedNumbers.tail.head\n            sortedNumbers.tail = sortedNumbers.tail.tail\n\
    \        }\n        // Return the number we are looking for and store it\n   \
    \     return (closestToOther, closestToOther)", "        def min(numbers : Seq[Float])\
    \ : Float = {\n            val min = numbers(0)\n            for (n <- numbers)\n\
    \                if (n < min)\n                    min = n\n            min\n\
    \        }\n        def max(numbers : Seq[Float]) : Float = {\n            val\
    \ max = numbers(0)\n            for (n <- numbers)\n                if (n > max)\n\
    \                    max = n\n            max\n        }\n\n        // Create\
    \ an empty list to store the sorted elements\n        val sortedElements = mutable.ListBuffer.empty[Float]\n\
    \        // Get the min/max and sort them\n        (min(numbers), max(numbers)).foreach(sortedElements\
    \ += _)\n        sortedElements.sortWith(_ < _)", "        val min = numbers.head\n\
    \        val max = numbers.last\n        numbers.zipWithIndex.filter{ case (x,\
    \ y) => math.abs(x - y) < math.abs(max - min) }", "        var smallestDistance\
    \ = 0f\n        var smallestElement: Float = 0f\n        var largestDistance =\
    \ 0f\n        var largestElement: Float = 0f\n\n        // For each element in\
    \ the list\n        for (i <- 0 until numbers.size)\n        {\n            //\
    \ Set the current distance for this element to 0\n            var distance = 0f\n\
    \n            // For each element in the list\n            for (j <- 0 until numbers.size)\n\
    \            {\n                // Calculate the distance between the current\
    \ element and each other element\n                var distanceSquared : Float\
    \ = Math.pow(numbers(i) - numbers(j), 2).toFloat\n\n                // If the\
    \ distance is less than the current distance\n                // set it as the\
    \ current distance for this element\n                // and set the other element\
    \ as the current element\n                if (distanceSquared < distance)\n  \
    \              {\n                    distance = distanceSquared\n           \
    \         smallestElement = numbers(j)\n                    largestElement = numbers(i)\n\
    \                }\n            }\n\n            // If the distance is equal to\
    \ the smallest distance\n            // set the smallest distance for this element\n\
    \            // and set the smallest element as the current element\n        \
    \    if (distance == smallestDistance)\n            {\n                smallestDistance\
    \ = distance\n                smallestElement = numbers(i)\n            }\n\n\
    \            // If the distance is equal to the largest distance\n           \
    \ // set the largest distance for this element\n            // and set the largest\
    \ element as the current element\n            if (distance == largestDistance)\n\
    \            {\n                largestDistance = distance\n                largestElement\
    \ = numbers(i)\n            }\n        }\n\n        // Return smallest and largest\
    \ in order\n        (smallestElement, largestElement)", "        if (numbers.isEmpty)\
    \ throw new Exception(\"Invalid input. Must have at least two numbers!\")\n  \
    \      // Create empty lists\n        var firstDist : Float = 0.0f\n        var\
    \ secondDist : Float = 0.0f\n        var newList : mutable.MutableList[Float]\
    \ = scala.collection.mutable.MutableList() // The list we return\n        numbers.foreach(n\
    \ => {\n            // Calculate the distance between first two elements\n   \
    \         val distance = (n - numbers(0)).lengthSquared\n            if (firstDist\
    \ == 0.0f) {\n                firstDist = distance\n            } else {\n   \
    \             val diff: Float = firstDist - distance\n                if (diff\
    \ < secondDist) {\n                    secondDist = diff\n                   \
    \ newList = newList :+ (numbers(1))\n                } else {\n              \
    \      newList = newList :+ (numbers(0))\n                }\n            }\n \
    \       })\n        (newList.head, newList.last)", "        val distances = numbers.map(x\
    \ => (x - numbers(0)))\n        val largestDistance = distances.max\n        val\
    \ smallestDistance = distances.min\n        (smallestDistance, largestDistance)",
  "        val minDist = math.min(numbers(0), numbers(1))\n        val maxDist = math.max(numbers(0),\
    \ numbers(1))\n        (minDist, maxDist)", "        val min = numbers.min\n \
    \       val max = numbers.max\n        numbers.zip(numbers.tail).map{ case (x,\
    \ y) => \n            if(min == x) y else if(max == x) y else ((x - min)/(max\
    \ - min) * (y - x) + x) \n        }.minBy(x => x).toList match {\n           \
    \ case Nil => (min, max)\n            case head :: tail => findClosestElements(tail)\n\
    \        }", "        require(numbers.length >= 2, numbers.mkString(\", \") +\
    \ \" must be at least two long\")\n        val sortedNumbers = numbers.sortWith(_\
    \ < _)\n        (sortedNumbers(0), sortedNumbers(1))", "        // Set up two\
    \ lists, one containing the smaller number and the other containing the\n    \
    \    // bigger number for each element in the input list\n        var smallestNumbers\
    \ = numbers.sortBy(_.toFloat).reverse\n        var biggestNumbers = numbers.sortBy(_.toFloat)\n\
    \        val smallestNum = smallestNumbers.head\n        val biggestNum = biggestNumbers.head\n\
    \        // The smaller and bigger numbers are now set. Iterate through each element\
    \ and\n        // calculate and return the smallest and biggest number that match\
    \ for that element.\n        // Return these in a tuple ordered by smaller number\n\
    \        var smallestClosestNum = smallestNum\n        var biggestClosestNum =\
    \ biggestNum\n        for(i <- 0 until numbers.length) {\n            val currentNumber\
    \ = numbers(i)\n            val currentSmallest = smallestNumbers(i)\n       \
    \     val currentBiggest = biggestNumbers(i)\n            if (currentBiggest <\
    \ currentSmallest) {\n                smallestNumbers = smallestNumbers.drop(i)\n\
    \                smallestClosestNum = currentSmallest\n            } else if (currentSmallest\
    \ < currentBiggest) {\n                biggestNumbers = biggestNumbers.drop(i)\n\
    \                biggestClosestNum = currentBiggest\n            } else if (currentNumber\
    \ == smallestClosestNum && currentNumber == biggestClosestNum) {\n           \
    \     smallestNumbers = smallestNumbers.drop(i)\n                biggestNumbers\
    \ = biggestNumbers.drop(i)\n            }\n        }\n        (smallestClosestNum,\
    \ biggestClosestNum)", "        val sorted = numbers.sortBy(x => x); // ((2.0f,\
    \ 2.2f), (1.0f, 2.0f), (4.0f, 5.0f), (3.0f, 3.0f), (2.0f, 2.0f))\n        val\
    \ diffs = sorted\n            .map((n, d) => math.abs(n - sorted(0)) + math.abs(n\
    \ - sorted(1)))\n            .toList\n            .sortBy(_); // ((-2.0, -2.0),\
    \ (-2.0, 2.0), (-5.0, -2.0), (5.0, -5.0), (-3.0, -3.0), (-3.0, -3.0))\n      \
    \  if (diffs.tail.forall(math.abs(_) > 0.01)) { // ((-2.0, -2.0), (-2.0, 2.0),\
    \ (-3.0, -3.0))\n            diffs.tail.map(_ - diffs.head).map(math.abs)\n  \
    \      } else {\n            diffs.tail.map(math.abs)\n        }", "        var\
    \ closest = numbers.min\n        var second = numbers.max\n        var index =\
    \ 0\n        while (index < numbers.size) {\n            if ((numbers.size - index)\
    \ < 2) {\n                return (closest, second)\n            }\n          \
    \  else {\n                if ((numbers.size - index) == 2) {\n              \
    \      first = Math.abs(numbers(index) - numbers(index+1))\n                 \
    \   second = Math.abs(numbers(index) - numbers(index+1))\n                }\n\
    \                else {\n                    first = Math.abs(numbers(index) -\
    \ numbers(index+1))\n                    second = Math.abs(numbers(index+1) -\
    \ numbers(index+2))\n                }\n                if ((first < second) &&\
    \ (first < closest)) {\n                    closest = first\n                }\n\
    \                if ((second < first) && (second < closest)) {\n             \
    \       closest = second\n                }\n                index += 1\n    \
    \        }\n        }\n        return (closest, second)", "        val n = numbers.length\n\
    \        if (n <= 1) {\n            numbers(0), numbers(1)\n        } else {\n\
    \            // Find smallest\n            val smallest = numbers.min\n      \
    \      // Find second smallest and find index of smallest in array\n         \
    \   val secondSmallest = numbers.min\n            val secondSmallestIndex = numbers.indexOf(secondSmallest)\n\
    \            val smallestIndex = numbers.indexOf(smallest)\n\n            // If\
    \ smallest is second smallest and second smallest is smallest, swap them\n   \
    \         if (secondSmallestIndex == smallestIndex && secondSmallest < smallest)\
    \ {\n                val temp = secondSmallest\n                secondSmallest\
    \ = smallest\n                smallest = temp\n            }\n\n            //\
    \ If second smallest is smallest and smallest is second smallest, swap them\n\
    \            else if (secondSmallestIndex == smallestIndex && smallest < secondSmallest)\
    \ {\n                val temp = secondSmallest\n                secondSmallest\
    \ = smallest\n                smallest = temp\n            }\n\n            val\
    \ largest = numbers.max\n            // Find second largest and find index of\
    \ largest in array\n            val secondLargest = numbers.max\n            val\
    \ secondLargestIndex = numbers.indexOf(secondLargest)\n            val largestIndex\
    \ = numbers.indexOf(largest)\n\n            // If largest is second largest and\
    \ second largest is largest, swap them\n            if (secondLargestIndex ==\
    \ largestIndex && secondLargest > largest) {\n                val temp = secondLargest\n\
    \                secondLargest = largest\n                largest = temp\n   \
    \         }\n\n            // If second largest is largest and largest is second\
    \ largest, swap them\n            else if (secondLargestIndex == largestIndex\
    \ && largest > secondLargest) {\n                val temp = secondLargest\n  \
    \              secondLargest = largest\n                largest = temp\n     \
    \       }\n\n            // Compare them and return smallest and largest\n   \
    \         (smallest, largest)\n        }", "        if (numbers.length < 2) (numbers(0),\
    \ numbers(0))\n        else {\n            var bestDistance = math.pow(math.abs(numbers(0)\
    \ - numbers(1)), 2).toFloat\n            var bestIndex = 0\n            numbers.foreach\
    \ {\n                case number => {\n                    var currentDistance\
    \ = math.pow(math.abs(number - numbers(bestIndex)), 2).toFloat\n             \
    \       if (currentDistance < bestDistance) {\n                        bestDistance\
    \ = currentDistance\n                        bestIndex = number\n            \
    \        }\n                }\n            }\n            (numbers(bestIndex),\
    \ numbers(bestIndex))\n        }", "        if(numbers.size() < 2) {\n       \
    \     return numbers.size() > 0 ? numbers.minBy(_ - numbers(0)) match { case (n,\
    \ _) => n -> n } : numbers.size() > 0 ? numbers.minBy(_ - numbers(0)) match {\
    \ case (n, _) => n -> n }\n        }\n        val largestNumber = numbers.max\n\
    \        val smallestNumber = numbers.min\n        numbers.minBy { n =>\n    \
    \        val absDiff = n.abs\n            val relativeDiff = absDiff / (largestNumber\
    \ - smallestNumber)\n            val relativeDiffInt = Math.floor(relativeDiff)\n\
    \            if(relativeDiffInt > 0.5) largestNumber - n else n - smallestNumber\n\
    \        }", "        val numbersSorted: Seq[Float] = numbers.sortWith(_ < _)\n\
    \        if (numbersSorted.size == 0) (0.0f, 0.0f) else {\n            // find\
    \ smallest and largest numbers\n            val (minIn, maxIn) = numbersSorted\n\
    \            // find middle point between min and max\n            val (medianIn,\
    \ middleIn) = numbersSorted.span(_ == minIn.asInstanceOf[Float])\n           \
    \ // if median == max, then median is closer to min\n            if (middleIn\
    \ == numbersSorted.last) minIn else {\n                // if median > max, then\
    \ median is closer to min\n                // and if median < min, then median\
    \ is closer to max\n                if (middleIn.asInstanceOf[Float] < (minIn.asInstanceOf[Float])\
    \ &&  middleIn.asInstanceOf[Float] > (maxIn.asInstanceOf[Float])) minIn else maxIn\n\
    \            }\n        }", "        val max = numbers(0)\n        val min: Float\
    \ = numbers(0).abs().min\n        numbers.filter(n => n.abs().min <= max).sortBy(n\
    \ => n.abs()).take(2).map(n => (max, n))", "        def swap(a,b) => b<=>a\n \
    \       numbers.zipWithIndex.sortBy(swap).take(2)", "        val min = math.min(numbers(0),\
    \ numbers(1))\n        val max = math.max(numbers(0), numbers(1))\n        if\
    \ (min == max) min -> max\n        else {\n            val middle = (min + max)\
    \ / 2\n            val left = (numbers(0) < middle && numbers(1) > middle) match\
    \ {\n                case false => numbers(0) -> middle\n                case\
    \ true => middle -> numbers(1)\n            }\n            val right = (numbers(0)\
    \ < middle && numbers(1) < middle) match {\n                case false => middle\
    \ -> numbers(1)\n                case true => numbers(0) -> middle\n         \
    \   }\n            left.toList.sortWith(_ > _).head.toList -> right.toList.sortWith(_\
    \ < _).head.toList\n        }", "        val n = numbers.head\n        val v =\
    \ numbers.last\n        val sortedNumbers = numbers.sortWith(math.abs<=>)\n  \
    \      val i = sortedNumbers.indexOf(v)\n        val j = (i + 1)%sortedNumbers.length\n\
    \        (sortedNumbers(i), sortedNumbers(j))", "        var largest = 0.0f\n\
    \        var smallest = Float.PositiveInfinity\n        numbers.sortWith(_ < _)\n\
    \        numbers.foreach(x => if (largest < x) largest = x)\n        numbers.foreach(x\
    \ => if (smallest > x) smallest = x)\n        (smallest, largest)", "        val\
    \ minNum = numbers.min\n        val maxNum = numbers.max\n        if (minNum ==\
    \ maxNum)\n            (minNum, minNum)\n        else {\n            def isClose(num\
    \ : Float, other : Float) = math.abs(num-other) < 0.01\n            def findClosestToMin(other\
    \ : Float) : Option[Float] = {\n                for {\n                    first\
    \ <- numbers.filter(isClose(first,other))\n                    second <- numbers.filter(isClose(other,second))\n\
    \                } yield second\n            }\n            def findClosestToMax(other\
    \ : Float) : Option[Float] = {\n                for {\n                    first\
    \ <- numbers.filter(isClose(first,other))\n                    second <- numbers.filter(isClose(other,second))\n\
    \                } yield first\n            }\n            val minClosest = findClosestToMin(minNum).getOrElse(minNum)\n\
    \            val maxClosest = findClosestToMax(maxNum).getOrElse(maxNum)\n   \
    \         (minClosest, maxClosest)\n        }", "        val d = numbers.min.abs\
    \ - numbers.max.abs\n        if(d == 0) (numbers(0), numbers(1)) else (numbers(1),\
    \ numbers(0))", "        val lmin = numbers.min\n        val lmax = numbers.max\n\
    \        // the midpoint between the two points\n        val mid = (lmin + lmax)\
    \ / 2\n        // the two points furthest from each other\n        val lmid =\
    \ numbers.length/2\n        val rmin = numbers(lmid)\n        val rmax = numbers(lmid+1)\n\
    \        val dMin = lmax - lmin\n        val dMax = lmax - rmax\n        val dDiff\
    \ = rmax - lmax\n        // the two points that are furthest from each other\n\
    \        val lmax = if (dDiff < dMin) mid else lmin\n        val rmin = if (dDiff\
    \ < dMin) mid else rmax\n        // the two points that are closest to each other\n\
    \        val lmin = if (dDiff < dMin) rmin else lmin\n        val lmid = if (dDiff\
    \ < dMin) mid else lmid\n        val rmin = if (dDiff < dMin) lmin else rmin\n\
    \        val rmid = if (dDiff < dMin) mid else rmid\n        // the two points\
    \ that are closest to each other\n        val lmin = if (dDiff < dMin) rmid else\
    \ lmin\n        val lmid = if (dDiff < dMin) rmax else lmid\n        val rmin\
    \ = if (dDiff < dMin) lmax else rmin\n        val rmid = if (dDiff < dMin) rmid\
    \ else rmid\n        Tuple2(lmin, lmid)", "        val list: List[Float] = numbers\
    \ sortBy (_.abs); list.tail match {\n            case head :: tail =>\n      \
    \          if (head.abs - tail.head < 0f) findClosestElements(tail.head :: tail.tail)\n\
    \                else (head :: tail.head, head)\n            case _ => throw new\
    \ ArithmeticException(\"Problem findClosestElements: cannot sort list of numbers\"\
    )\n        }", "        val smallestNumber = numbers.min\n        val largestNumber\
    \ = numbers.max\n\n        numbers.find(x => abs(x - smallestNumber) < abs(x -\
    \ largestNumber)).sortBy(_)(0)", "        val smallestDifference = math.max(numbers(0).toFloat,\
    \ numbers(1).toFloat)\n        val firstElement = numbers.minBy(math.abs)\n  \
    \      val secondElement = numbers.maxBy(math.abs)\n        firstElement -> secondElement",
  "        val sorted = numbers.sorted\n        val index = sorted.indexOf(0)\n  \
    \      if (index > 0) {\n            (sorted[index - 1], sorted[index])\n    \
    \    } else {\n            (sorted[0], sorted[sorted.length - 1])\n        }",
  "        val ns = numbers.toSet\n        val (min1, min2) = for (i <- ns ; if ns\
    \ contains i) yield (numbers.min, (numbers.min - i))\n        val (max1, max2)\
    \ = for (i <- ns ; if ns contains i) yield (i, numbers.max)\n        val m = min1.max\
    \ max max2.max\n        (min1 min min2) + ((m - min1).abs, (m - min2).abs)", " \
    \       // Calculate the distances between the supplied numbers\n        val distances:\
    \ Array[Double] = numbers.zipWithIndex.map { case (n, i) => \n            // Calculate\
    \ the distance between the first and second element\n            math.sqrt((math.pow(n,2)\
    \ - math.pow(numbers(i), 2)).abs.toDouble)\n        }\n\n        // Sort the distances\
    \ from smallest to largest\n        distances.sortWith(_ < _)\n\n        // Return\
    \ the two numbers at the distance from each other\n        (numbers(distances.indexWhere(_\
    \ == distances.min)), numbers(distances.indexWhere(_ == distances.max)))", " \
    \       var bestElement = numbers.head\n        var bestDifference = 0.0f\n\n\
    \        for (element <- numbers)\n            if(element - bestElement < bestDifference)\
    \ {\n                bestElement = element\n                bestDifference = element\
    \ - bestElement\n            }\n\n        (bestElement, bestDifference)", "  \
    \      val smallestDistance = numbers.min\n\n        def check(a: Float, b: Float):\
    \ Boolean =\n            Math.abs(a - b) < smallestDistance\n\n        val (biggestDistance,\
    \ secondSmallestDistance) = numbers\n            .foldRight(smallestDistance)\
    \ {\n              case ((smallestDistance, secondSmallestDistance), a) =>\n \
    \               if (check(a, secondSmallestDistance)) {\n                  (smallestDistance,\
    \ a)\n                } else {\n                  (smallestDistance, secondSmallestDistance)\n\
    \                }\n            }\n\n        (smallestDistance, biggestDistance)",
  "        val smallestValue = numbers.min\n        val smallestIndex : Int = numbers.indexOf(smallestValue)\n\
    \        val largestValue = numbers.max\n        val largestIndex : Int = numbers.indexOf(largestValue)\n\
    \        (smallestValue, largestValue)", "      val (smaller, larger) = (numbers.min,\
    \ numbers.max)\n      (numbers, numbers)\n        .zipped.find(number => number\
    \ == smaller)\n        .map {\n          n => if (n == smaller) larger else smaller\n\
    \        }.minBy {\n          n => if (n == larger) larger else smaller\n    \
    \    }", "        val n = numbers.size + 1\n        val low = numbers(0)\n   \
    \     val high = numbers(0)\n        val maxDiff = numbers(0)\n        for (i\
    \ <- 1 to n) {\n            val diff = (numbers(i) - low).abs.max\n          \
    \  if (diff < maxDiff) {\n                low = numbers(i)\n                maxDiff\
    \ = diff\n            }\n            high = numbers(i)\n        }\n        (low,\
    \ high)", "        val min = numbers(0)\n        val max = numbers(0)\n      \
    \  for (x <- numbers) {\n            if (min > x) min = x\n            if (max\
    \ < x) max = x\n        }\n        (min, max)", "        var currentBest: Float\
    \ = 0.0f\n        var currentWorst: Float = 0.0f\n        var smallest: Float\
    \ = 0.0f\n        var largest: Float = 0.0f\n        var smallerIndex: Int = -1\n\
    \        var largerIndex: Int = -1\n        numbers.foreach {\n            num\
    \ => {\n                val currentDifference = num - currentBest\n          \
    \      val currentWorstDifference = num - currentWorst\n                if (currentDifference\
    \ < currentWorstDifference) {\n                    currentBest = num\n       \
    \             currentWorst = num\n                } else {\n                 \
    \   currentWorst = num\n                }\n                val currentSmallerDifference\
    \ = currentDifference - smallest\n                val currentLargerDifference\
    \ = currentWorstDifference - largest\n                if (currentSmallerDifference\
    \ < currentLargerDifference) {\n                    smallest = num\n         \
    \           smallerIndex = numbers.indexOf(num)\n                    currentLargerDifference\
    \ = currentDifference - largest\n                    largest = num\n         \
    \           largerIndex = numbers.indexOf(num)\n                } else {\n   \
    \                 largest = num\n                    largerIndex = numbers.indexOf(num)\n\
    \                    currentSmallerDifference = currentDifference - smallest\n\
    \                    smallest = num\n                    smallerIndex = numbers.indexOf(num)\n\
    \                }\n            }\n        }\n        (smallest, largest)", " \
    \       var largest = numbers(0)\n        var smallest = numbers(0)\n        var\
    \ index = numbers.size() - 1\n\n        var i = index\n        while (i>=0) {\n\
    \            if (numbers(i) <= largest) {\n                largest = numbers(i)\n\
    \                index = i\n            } else if (numbers(i) >= smallest) {\n\
    \                smallest = numbers(i)\n                index = i\n          \
    \  }\n            i -= 1\n        }\n        (smallest, largest)", "        val\
    \ numberSet = numbers.toSet\n        val firstClosest = numbers.min\n        val\
    \ secondClosest = numbers.max\n        numberSet.find(x => x == firstClosest)\
    \ match {\n            case Some(first) -> numberSet.find(x => x == secondClosest)\
    \ match {\n                case Some(second) => if (first < second) { (first,\
    \ second) } else { second }\n                case None => second\n           \
    \ }\n            case None => first\n        }", "        // Write your answer\
    \ here\n        // Use map to create a new list of tuples containing the indices\
    \ and values of the number list \n        val indexAndVal = numbers.zipWithIndex.map\
    \ { case (x, index) => index -> (x, x) }\n        // Find the indices of the elements\
    \ that are closest to each other\n        val closestToIndex: MutableList[Int]\
    \ = new MutableList[Int]\n        indexAndVal.zipWithIndex.foreach { case (pair,\
    \ index) =>\n            if (pair.element.isCloseTo(pair.element.next.asInstanceOf[Float]))\
    \ {\n                val prevIndex = pair.element.index\n                val nextIndex\
    \ = pair.element.next.index\n                if (prevIndex < nextIndex) {\n  \
    \                  closestToIndex.update(prevIndex + 1, nextIndex)\n         \
    \       } else if (prevIndex > nextIndex) {\n                    closestToIndex.update(prevIndex,\
    \ nextIndex + 1)\n                } else if (prevIndex == nextIndex) {\n     \
    \               closestToIndex.update(prevIndex + 1, nextIndex + 1)\n        \
    \        }\n            }\n        }\n        // Use the indices to get a list\
    \ of tuples containing the closest numbers \n        closestToIndex.zipWithIndex.map\
    \ { case (index, value) => index -> numbers }", "        val map: Map[Float, Float]\
    \ = numbers.zipWithIndex.filter(_._2 < numbers.size/2)\n        val min: Float\
    \ = minBy(map)(_)\n        val max: Float = maxBy(map)(_)\n        Tuple2(min,\
    \ max)", "        val mins = numbers.zipWithIndex.minBy(_._1)._2\n        val\
    \ maxs = numbers.zipWithIndex.maxBy(_._1)._2\n        val closest = mins.map(_._2).zip(maxs).map{case\
    \ (prev, next) => (prev, next)}\n        closest.toSeq", "        val aList =\
    \ numbers.toList\n        var closest1 = -1.0\n        var closest2 = -1.0\n \
    \       val diffBetweenClosests = aList.map(x => Math.abs(x - closest1)).min\n\
    \n        val diffBetweenClosests2 = aList.map(x => Math.abs(x - closest2)).min\n\
    \n        if ((diffBetweenClosests == 0.0f) && (diffBetweenClosests2 == 0.0f))\
    \ {\n            closest1 = closest2 = aList.head\n        } else\n          \
    \  if (diffBetweenClosests > diffBetweenClosests2) {\n                closest1\
    \ = aList.head\n                closest2 = aList.last\n            } else {\n\
    \                closest1 = aList.last\n                closest2 = aList.head\n\
    \            }\n        (closest1, closest2)", "        val smallest = numbers.min\n\
    \        val largest = numbers.max\n        numbers.getOrElse(numbers.indexWhere(x\
    \ => smallest == x) + 1, numbers.last)", "        val sortedNumbers = numbers.sortWith(_\
    \ < _)\n        if(sortedNumbers.isEmpty) throw new NoSuchElementException\n \
    \       val firstValue = sortedNumbers(0)\n        val lastValue = sortedNumbers.last\n\
    \        if(firstValue == lastValue) throw new NoSuchElementException\n\n    \
    \    val lower = sortedNumbers.takeWhile(_ > firstValue).reverse\n        val\
    \ upper = sortedNumbers.dropWhile(_ < lastValue).reverse\n        val tuple =\
    \ (lower, upper)\n\n        tuple", "        val nums = numbers :+ numbers(0)\n\
    \        val d = new mutable.HashMap[Float, Float]()\n        for (i <- 0 until\
    \ nums.size - 1) {\n            val tmp = nums(i)\n            d.put(nums(i),\
    \ tmp)\n        }\n        val smallest = d.getOrElse(numbers.head, 0.0001)\n\
    \        val largest = d.getOrElse(numbers.last, 0.0001) \n        (smallest,\
    \ largest)", "        val closest = numbers.get(0)\n        var closeIndex = 0\n\
    \        for (i <- 1 to numbers.size)\n            if (numbers(i) < closest)\n\
    \            {\n                closest = numbers(i)\n                closeIndex\
    \ = i\n            }\n        val tuple2Result = numbers.zipWithIndex.filter{x\
    \ => x._1 == closest && x._2 == closeIndex}.sortBy(_._1).head\n        tuple2Result._1",
  "        val pairs = for {\n            a <- numbers.slice(1, numbers.length)\n\
    \            b <- numbers.slice(1, numbers.length)\n        } yield {\n      \
    \      Math.abs(a - b)\n        }\n\n        // Find the pair with the smallest\
    \ value\n        val smallest = pairs.min\n\n        // Find the pair with the\
    \ largest value\n        val largest = pairs.max\n\n        val result = (smallest,\
    \ largest)\n        result", "        val minNum = numbers.min\n        val maxNum\
    \ = numbers.max\n        val diff = (maxNum - minNum).abs\n\n        if (diff\
    \ < 0.5f) numbers else (numbers(0), numbers(1))", "        val minLargerNumber\
    \ = numbers.minBy(_ > _)\n        val minSmallerNumber = numbers.minBy(_ < _)\n\
    \        (minLargerNumber, minSmallerNumber)", "        val min1 = numbers.min\n\
    \        val min2 = numbers.max\n        if (min1 == min2)\n            (min1,\
    \ min1)\n        else if (min1 == min2)\n            (min1, min2)\n        else\
    \ if (min2 == min1)\n            (min2, min2)\n        else if (min1 > min2) {\n\
    \            val diff = min1 - min2\n            val r1 = (min1 + diff) / 2\n\
    \            val r2 = (min2 + diff) / 2\n            ((r1, r2))\n        } else\
    \ {\n            val diff = min2 - min1\n            val r1 = (min1 + diff) /\
    \ 2\n            val r2 = (min2 + diff) / 2\n            ((r1, r2))\n        }",
  "        // Select the first number\n        val (closestVal, currentClosestVal)\
    \ = numbers.minBy(math.abs(_)) match {\n            case (closestVal, currentClosestVal)\
    \ => closestVal, currentClosestVal\n            case _ => numbers.minBy(math.abs)\n\
    \        }\n\n        // If the current value is the closest value to the first\
    \ value then return the first value\n        if (currentClosestVal == closestVal)\
    \ {\n            (closestVal, closestVal)\n        } else {\n            // If\
    \ the current value is not the closest value to the first value then return the\
    \ second value\n            (closestVal, currentClosestVal)\n        }", "   \
    \     val map: Map[Int, Float] = numbers.map(x => x -> x).toMap\n        val list1:\
    \ List[(Float, Float)] =\n            numbers.map(x => (x - map.getOrElse(maps.indexOf(x),\
    \ 0.0f), x)).sorted\n        val list2: List[(Float, Float)] =\n            numbers.map(x\
    \ => (map.getOrElse(maps.indexOf(x), 0.0f) - x, x)).sorted\n        list1.zip(list2).minBy(_._1)._1",
  "        val nums = numbers map Math.abs\n        val max = nums.max\n        val\
    \ min = (nums diff max).min\n        (min, max)", "        val numberSet = numbers.toSet\n\
    \        val largest = numberSet.last\n        val smallest = numberSet.head\n\
    \        var closestPair : Tuple2[Float, Float] = null\n        var closestDistance\
    \ : Float = Float.PositiveInfinity\n        for(x <- numberSet) {\n          \
    \  val distance = Math.abs(x - largest)\n            val newDistance = Math.abs(x\
    \ - smallest)\n            if (newDistance < closestDistance) {\n            \
    \    closestDistance = newDistance\n                closestPair = (x, newDistance)\n\
    \            }\n        }\n        closestPair", "        if (numbers.size < 2)\
    \ throw new IllegalArgumentException(\"numbers list must be at least of size 2\"\
    );\n        var smallestNumber = numbers(0);\n        var largestNumber = numbers(0);\n\
    \        for (number <- numbers) {\n            if (number < smallestNumber) smallestNumber\
    \ = number;\n            if (number > largestNumber) largestNumber = number;\n\
    \        }\n        return (smallestNumber, largestNumber)", "        def findClosestPair(first:\
    \ Float, second: Float) : Option[Float] = {\n            // Use a binary search\
    \ to find the closest pair\n            // https://en.wikipedia.org/wiki/Binary_search_algorithm\n\
    \            if (first > second) {\n                val firstHalf = math.round(first\
    \ / 2.0).toInt\n                val secondHalf = math.round(second / 2.0).toInt\n\
    \                findClosestPair(firstHalf, secondHalf)\n            } else {\n\
    \                val firstHalf = math.round(first / 2.0).toInt\n             \
    \   val secondHalf = math.round(second / 2.0).toInt\n                findClosestPair(secondHalf,\
    \ firstHalf)\n            }\n        }\n\n        val pairs = numbers.sliding(2).map(x\
    \ => findClosestPair(x(0), x(1))).toList\n        if (pairs.nonEmpty) {\n    \
    \        pairs.sortBy(x => x._1).reverse\n        } else {\n            None\n\
    \        }", "        def computeDistance(x : Float, y : Float) : Float = {\n\
    \            val distance = java.lang.Math.abs(x - y)\n            if (distance\
    \ > 1.0) 1.0f else distance\n        }\n        def findClosest(xs : List[Float],\
    \ y :Float) : Float = {\n            val minDistance = java.lang.Math.abs(xs.head()\
    \ - y)\n            var index = 0\n            var minIndex = -1\n           \
    \ val min = java.lang.Math.abs(xs.head() - y)\n            if (xs.isEmpty) {\n\
    \                return java.lang.Math.abs(y - xs.head())\n            }\n   \
    \         while (index < xs.size) {\n                if (computeDistance(y, xs(index))\
    \ < minDistance) {\n                    minDistance = computeDistance(y, xs(index))\n\
    \                    minIndex = index\n                }\n                index++\n\
    \            }\n            minIndex\n        }\n        def sortByDistance(x\
    \ : Float, y : Float) : Float = {\n            if (x < y) -1f else 1f\n      \
    \  }\n        val sortedNumber = numbers.toList.sortBy(sortByDistance)\n     \
    \   (findClosest(sortedNumber, numbers.head), findClosest(sortedNumber, numbers.last))",
  "        require(numbers.nonEmpty)\n        val minVal = numbers.min\n        val\
    \ maxVal = numbers.max\n        numbers.zipWithIndex.map { case (elem, index)\
    \ =>\n            val diff = elem - minVal\n            if (diff > maxVal) elem\
    \ -> maxVal\n            else if (diff < -maxVal) elem -> -maxVal\n          \
    \  else if (diff == 0) elem -> elem\n            else elem -> minVal\n       \
    \ }.minByOrdered.head", "        var smallest = numbers(0)\n        var largest\
    \ = numbers(0)\n        var smallestDiff = math.max(numbers(1).abs, numbers.last.abs)\n\
    \n        for (nm <- numbers) {\n            if (nm <= smallest || smallest ==\
    \ largest) {\n                continue\n            }\n            var diff =\
    \ Math.abs(nm - largest)\n            if (diff < smallestDiff) {\n           \
    \     smallestDiff = diff\n                smallest = nm;\n            }\n   \
    \         diff = Math.abs(nm - smallest)\n            if (diff > smallestDiff)\
    \ {\n                largest = nm;\n            }\n        }\n        (smallest,\
    \ largest)", "        val nums = numbers.toList\n        val mins = nums.map(_\
    \ => (math.min(nums.head, _), math.max(nums.head, _))).toList\n        val maxes\
    \ = mins.map(_.swap)\n        val minDistances = mins.zip(maxes)\n        val\
    \ maxDistances = maxes.zip(mins)\n        val minMaxIndices = minDistances.zip(maxDistances).filter(_._1\
    \ < _._1).sortBy(_._1)\n        val minMax = minMaxIndices.head._2\n        val\
    \ maxIndices = minMaxIndices.filter(_._1 < minMax).map(_.swap)\n        val maxDistance\
    \ = maxIndices.map(_.swap)\n        (minMax._1, minMax._2, maxDistance._1, maxDistance._2)",
  "        val mins = numbers.minBy(_._1).map(_._1).take(2) // find pair with smallest\
    \ element\n        val maxes = numbers.maxBy(_._2).map(_._2).take(2)\n       \
    \ if(maxes == mins) maxes else mins", "        val mins = ListBuffer[Float]()\n\
    \        val maxs = ListBuffer[Float]()\n        for (i <- numbers.indices) {\n\
    \            mins += numbers(i)\n            maxs += numbers(i)\n        }\n \
    \       mins.zip(maxs).sortWith(_._1 > _._1).take(2)", "        var smallestDifference\
    \ = Number.MAX_VALUE\n        var biggestDifference = Number.MIN_VALUE\n\n   \
    \     numbers.foreach{ number =>\n            var difference = number - numbers.head\n\
    \n            if (difference < smallestDifference) {\n                smallestDifference\
    \ = difference\n            } else if (difference > biggestDifference) {\n   \
    \             biggestDifference = difference\n            }\n        }\n\n   \
    \     (numbers.head + smallestDifference, biggestDifference + smallestDifference)",
  '        numbers.sortBy(_.abs).take(2)', "        var low = math.max(numbers.head,\
    \ 0.0)\n        var high = math.min(numbers.last, 0.0)\n        var pair : Tuple2[Float,\
    \ Float] = null\n        var found : Boolean = false\n        numbers match {\n\
    \            case Nil => pair = null\n            case x :: xs => {\n        \
    \        val diff : Float = math.abs(x - low)\n                if (math.abs(x\
    \ - high) < diff) {\n                    found = true // first pair found\n  \
    \                  if (pair != null) {\n                        val xHigh : Float\
    \ = math.abs(pair._1 - high)\n                        if (xHigh < diff) pair =\
    \ (pair._1, pair._2)\n                    }\n                }\n             \
    \   else if (found && diff < math.abs(x - high)) {\n                    pair =\
    \ (x, x)\n                    found = false\n                }\n             \
    \   else {\n                    pair = (x, high)\n                }\n        \
    \    }\n        }\n        if (pair != null) pair\n        else (low, high)",
  "        val m1 = math.abs(numbers.head-numbers.last)\n        val m2 = math.abs(numbers(0)-numbers(1))\n\
    \        if(m1 < m2){\n            return numbers(0).toFloat, numbers(1).toFloat\n\
    \        }else{\n            return numbers(1).toFloat, numbers(0).toFloat\n \
    \       }", "        // Convert numbers to List\n        val numbersList = numbers.toList\n\
    \        // Initialize minDistance and minElement to very large values so that\
    \ any number is considered the minimum\n        val minDistance = numbersList(0).toFloat\n\
    \        val minElement = numbersList(0).toFloat\n        // Iterate over remaining\
    \ numbers, find the smallest distance between current numbers and find the element\
    \ that\n        // is closest to current numbers\n        numbersList.foreach(n\
    \ => {\n            if (Math.abs(n - minElement) < minDistance) {\n          \
    \      minElement = n\n                minDistance = Math.abs(n - minElement)\n\
    \            }\n        })\n        (minElement, minDistance)", "        numbers.zipWithIndex.map\
    \ {\n            case (number, index) => (Math.abs(number - numbers(index)), numbers(index))\
    \ }\n            .sortWith((x, y) => x._1 < y._1).take(2)", "        def closest[T](l\
    \ : List[T]) : Option[(T, T)] = {\n            val m = l.minBy(x => Math.abs(x\
    \ - l.min))\n            if (Math.abs(l.min - m) < Math.abs(l.max - m)) Some((l,\
    \ m))\n            else None\n        }\n\n        val list = numbers.toList\n\
    \        val firstClosest = closest[Float](list)\n        val secondClosest =\
    \ closest[Float](list.drop(1))\n\n        firstClosest match {\n            case\
    \ Some((l, m)) => secondClosest match {\n                case Some((m, l2)) =>\
    \ Some((l, m, l2))\n                case None => None\n            }\n       \
    \     case None => None\n        }", "        val arrayOfFloat = numbers.toArray\n\
    \        val minValues = arrayOfFloat.sortWith( (number1: Float, number2: Float)\
    \ => number1 < number2 )\n        minValues.tail", "        // find smallest and\
    \ largest numbers\n        val (minIndex, maxIndex) = numbers.zipWithIndex.minBy\
    \ { case (number, index) => (number, index) }\n        // remove smallest number\n\
    \        numbers.remove(minIndex)\n        // find closest number to the smallest\
    \ number\n        val (closestIndex, closestDistance) = numbers.zipWithIndex.minBy\
    \ { case (number, index) => (math.abs(number - minIndex), number) }\n        //\
    \ remove closest number\n        numbers.remove(closestIndex)\n        // return\
    \ smallest number first, then closest number\n        (minIndex, closestDistance)",
  "        if (numbers.size() < 2) throw new IllegalArgumentException(\"The list must\
    \ have at least two numbers.\")\n        var smallest = numbers(0)\n        var\
    \ largest = numbers(0)\n        var smallestIndex = -1\n        var largestIndex\
    \ = -1\n        for ((index, number) <- numbers.zipWithIndex.toList if index ==\
    \ 0) {\n            if (smallest == number && smallest != 0.0f) smallestIndex\
    \ = (index + 1)\n            if (largest == number && largest != 0.0f) largestIndex\
    \ = (index + 1)\n            if (number < smallest && smallest != 0.0f) smallest\
    \ = number\n            if (number > largest && largest != 0.0f) largest = number\n\
    \        }\n        return (smallest, largest)", "        // Sort numbers in ascending\
    \ order\n        numbers.sortWith((a, b) => a.toFloat - b.toFloat)\n        val\
    \ closestNums = List(numbers(numbers.size - 1), numbers(0))\n        // Find the\
    \ closest numbers in the list\n        val closestResults = closestNums.zip(numbers.zip(closestNums).map(_._1\
    \ - _._1)).map { case (x, y) => (x, y) }\n        // Find closest numbers in order\n\
    \        (closestResults.head._2, closestResults.last._2)", "        def nextBigger(n\
    \ : Float) : Float = {\n            val bigger = numbers.head - n\n          \
    \  numbers.removeAt(0)\n            bigger\n        }\n        def nextSmaller(n\
    \ : Float) : Float = {\n            val smaller = numbers.head - n\n         \
    \   numbers.removeAt(0)\n            smaller\n        }\n        val bigger =\
    \ nextBigger(numbers.head).abs() < nextBigger(numbers.last).abs() ? numbers.head\
    \ : numbers.last\n        val smaller = nextSmaller(numbers.head).abs() < nextSmaller(numbers.last).abs()\
    \ ? numbers.head : numbers.last\n        (bigger, smaller)", "        require(numbers.size\
    \ > 2)\n        val sortedNumbers = numbers.sortWith(math.abs)\n        val min\
    \ = sortedNumbers(0)\n        val max = sortedNumbers(numbers.size - 1)\n    \
    \    if(numbers.size < 3) {\n            (min, max)\n        } else {\n      \
    \      (sortedNumbers(1) - min, sortedNumbers(1) - max)\n        }", "       \
    \ val smallest = numbers.head\n        val largest = numbers.last\n        val\
    \ closest = numbers.foldLeft((smallest, largest))((prev, element) =>\n       \
    \     (math.abs(element - smallest) < math.abs(element - largest)) ? element :\n\
    \            (math.abs(element - smallest) > math.abs(element - largest)) ? prev\
    \ :\n            (element < smallest ? prev : (element > largest ? prev : (smallest,\
    \ largest))\n        )\n        closest", "      def closestElement(numbers :\
    \ List[Float], a : Float, b : Float) : Float = {\n        if (numbers.isEmpty)\
    \ {\n          throw new NoSuchElementException(\"No elements found.\")\n    \
    \    }\n        val mid = numbers.size / 2\n        if (numbers.size < 2) {\n\
    \          throw new NoSuchElementException(\"List too small to find two closest\
    \ elements.\")\n        }\n        if ((a<b) && (numbers.exists(_ < a))) {\n \
    \         return closestElement(numbers, a, mid)\n        }\n        if ((a>b)\
    \ && (numbers.exists(_ < b))) {\n          return closestElement(numbers, mid,\
    \ b)\n        }\n        if (numbers.exists(_ == a)) {\n          return a\n \
    \       }\n        if (numbers.exists(_ == b)) {\n          return b\n       \
    \ }\n        return closestElement(numbers, mid, mid)\n      }\n\n      val min\
    \ = numbers.min\n      val max = numbers.max\n      val result: (Float, Float)\
    \ = (closestElement(numbers, min, max), closestElement(numbers, max, min))\n \
    \     result", "        val list = numbers.toList\n        if (list.length < 2)\
    \ (numbers(0), numbers(0))\n        else {\n            val minNumber = math.min(numbers(0),\
    \ numbers(1))\n            val maxNumber = math.max(numbers(0), numbers(1))\n\
    \            val smallerList = numbers.filter(_ < minNumber)\n            val\
    \ greaterList = numbers.filter(_ > maxNumber)\n            findClosestElementsImpl(smallerList,\
    \ greaterList)\n        }", "        val pairs = for {\n            a <- numbers.sortBy(math.abs)\n\
    \            b  <- numbers.sortBy(math.abs)\n        } yield (a,b)\n        pairs.minBy(_._1)._1",
  "        val sortedNumbers  = numbers.sortBy(math.abs(_))\n        val closestPair\
    \ = sortedNumbers(0) minus sortedNumbers(1)\n        closestPair", "        val\
    \ sorted = numbers.sortWith(\n            (a, b) => math.abs(a.toFloat - b.toFloat))\n\
    \n        val minVal = sorted.head\n        val maxVal = sorted.last\n\n     \
    \   if (minVal > maxVal) {\n            (minVal, maxVal)\n        } else {\n \
    \           (maxVal, minVal)\n        }", "        val sortedNumbers = numbers.sortWith(_.toFloat<=>_.toFloat)\n\
    \        val closestElement = sortedNumbers.takeRight(2)\n        val previousElement\
    \ = sortedNumbers.drop(2).head\n        val result = closestElement.zip(previousElement)\n\
    \        val minResult = result.minBy { case (first, second) => math.abs(first-second)\
    \ }\n        val maxResult = result.maxBy { case (first, second) => math.abs(first-second)\
    \ }\n        minResult -> maxResult", "        val min = math.min(numbers(0),\
    \ numbers(1))\n        val max = math.max(numbers(0), numbers(1))\n        if(min.isNaN\
    \ || max.isNaN) return (math.nan, math.nan)\n        (min, max)", "      val numberPairs\
    \ = numbers.zipWithIndex.sortBy(_._1).zipWithIndex.filter(_._2 < numbers.size\
    \ - 1).map(_._1)\n      (numberPairs.head._2, numberPairs.last._2)", "       \
    \ var smallest = numbers.get(0)\n        var largest = numbers.get(1)\n      \
    \  for (i <- 1 to numbers.size - 2) {\n            if (numbers(i) < smallest &&\
    \ numbers(i) != numbers(i - 1)) {\n                smallest = numbers(i)\n   \
    \         }\n            if (numbers(i) > largest && numbers(i) != numbers(i +\
    \ 1)) {\n                largest = numbers(i)\n            }\n        }\n    \
    \    (smallest, largest)", '        numbers.zipWithIndex.minBy(_._1).map(_._2)',
  "        val sortedNumbers = numbers.sortBy(math.abs(_))\n        val midPoint =\
    \ sortedNumbers.head + sortedNumbers.last.signum * 1.0f\n        val midValues\
    \ = (sortedNumbers.take(2), sortedNumbers.drop(2))\n        val diffs = (midValues.head\
    \ - midPoint, midValues.last - midPoint)\n        val smallest = diffs.min\n \
    \       val largest = diffs.max\n        smallest.min -> largest.max", '        numbers.minBy(_).maxBy(_).asInstanceOf[Tuple2[Float,
    Float]]', '        // Write your code here', "        val sorted = numbers.sortBy(-_)\n\
    \        if (sorted.length >= 2) (sorted.head, -sorted.last)\n        else (sorted.head,0)",
  "        val min1 = math.min(numbers(0).toFloat, numbers(1).toFloat)\n        val\
    \ max1 = math.max(numbers(0).toFloat, numbers(1).toFloat)\n        (min1, max1)",
  "        val n1 = numbers(0)\n        val n2 = numbers(1)\n        val n3 = numbers.drop(1).sortBy(_).last\n\
    \        val n4 = numbers.drop(2).sortBy(_).last\n        (n1, n2)", "       \
    \ // Find the closest pair in numbers, starting at index zero.\n        // The\
    \ closest pair is one which has the smallest absolute difference to all the others.\n\
    \        // >>> findClosestElements(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))\n        // ((2.0f, 2.2f))\n    \
    \    // >>> findClosestElements(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))\n        // ((2.0f, 2.0f))\n    \
    \    numbers.zipWithIndex.minBy { case (x, y) => math.abs(x - y) }", "       \
    \ if (numbers.size < 2) {\n            return (numbers.get(0), numbers.get(0))\n\
    \        }\n        val sortedNumbers = numbers.sortBy(_.toFloat)\n        val\
    \ firstNumber = sortedNumbers.get(1)\n        val secondNumber = sortedNumbers.get(0)\n\
    \        val delta = (firstNumber.toFloat - secondNumber.toFloat)\n        if\
    \ (delta < 0) {\n            findClosestElements(sortedNumbers.drop(2))\n    \
    \    } else if (delta > 0) {\n            findClosestElements(sortedNumbers.take(2))\n\
    \        } else {\n            if (secondNumber.toFloat < firstNumber.toFloat)\
    \ {\n                findClosestElements(sortedNumbers.take(2))\n            }\
    \ else {\n                findClosestElements(sortedNumbers.drop(2))\n       \
    \     }\n        }", "        val numbersWithIndex = numbers.zipWithIndex\n  \
    \      val sorted = numbersWithIndex.sortBy(_._1).reverse\n\n        val num1\
    \ = sorted.take(2)\n        val num2 = sorted.takeRight(2)\n        val num3 =\
    \ sorted.drop(2)\n        val num4 = new ListBuffer[Float]\n        var idx =\
    \ 0\n        while(idx < sorted.length)\n        {\n            if (Math.abs(num1(idx)\
    \ - num2(idx)) < Math.abs(num1(idx) - num3(idx)))\n            {\n           \
    \     num4 += num1(idx)\n                idx += 1\n            }\n           \
    \ else\n            {\n                num4 += num2(idx)\n                idx\
    \ += 1\n            }\n        }\n\n        num4 += num1(sorted.length)\n    \
    \    num4 += num2(sorted.length)\n        num4 += num3(sorted.length)\n\n    \
    \    (num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num4.indexOf(num4(num",
  "      import scala.math._\n\n      val min = numbers.min\n      val max = numbers.max\n\
    \      val index = (min to max).zipWithIndex.maxBy(_._1)._2\n      (numbers(index),\
    \ numbers(index))", "        val list = numbers.toList\n        if (list.size\
    \ == 0) throw new IllegalArgumentException(\"No numbers were passed\")\n     \
    \   val min = math.min(list.head)\n        val max = math.max(list.last)\n   \
    \     val diff = max - min\n        val range = diff / 2.0\n        var index\
    \ = 0\n        for (i <- 1 until list.size-1) {\n            if (list(i) - list(i-1)\
    \ < range) {\n                val center = (list(i) + list(i+1)) / 2\n       \
    \         if (center == list(i) && center == list(i+1)) index += 1\n         \
    \       else if (center < list(i)) index = 1\n                else if (center\
    \ > list(i)) index = 2\n                else index = 2\n            } else if\
    \ (list(i) - list(i-1) > range) {\n                val center = (list(i) + list(i-1))\
    \ / 2\n                if (center == list(i) && center == list(i-1)) index +=\
    \ 1\n                else if (center < list(i)) index = 1\n                else\
    \ if (center > list(i)) index = 2\n                else index = 2\n          \
    \  } else index = 2\n        }\n        val a = list.head + index * range\n  \
    \      val b = list.last - index * range\n        (a,b)", "        val smaller\
    \ = numbers.min\n        val larger = numbers.max\n        val closest = if (smaller\
    \ < larger) smaller else larger\n        val distances = numbers.map { n =>\n\
    \            val d = Math.abs(n - closest)\n            if (d < 1.0f) d else 0\n\
    \        }\n        val result = distances.zip(distances.tail).map {\n       \
    \     case (d1, d2) if d1 < d2 => (d1, d2)\n            case (d1, d2) => d2 }\n\
    \        result.sortWith(_._1 < _._1) // sort smallest to largest\n        result.head",
  "        val l = new mutable.LinkedList[Double](numbers)\n        val smallest =\
    \ l.head\n        val largest = l.last\n        if(l.size < 2) (smallest, largest)\n\
    \        else {\n            val midpoint = l.size / 2.0\n            val index\
    \ = l.indexOf(midpoint)\n            val small = l.take(index)\n            val\
    \ large = l.drop(index + 1)\n            val smallerSmallest = findClosestElements(small)\n\
    \            val largerLarge = findClosestElements(large)\n            (smallerSmallest,\
    \ largerLarge)\n        }", "        val nums = numbers.toSeq\n        val sortedNums\
    \ = nums.sortBy(_)\n        val closestNums = sortedNums.take(2)\n        closestNums",
  "        val sortedNumbers = numbers.sortWith(math.Abs(_ - _))\n        val smallestIndex\
    \ = sortedNumbers.indexWhere(math.Abs(_ - _) < math.Abs(sortedNumbers(0) - sortedNumbers(1)))\n\
    \        (sortedNumbers(smallestIndex), sortedNumbers(smallestIndex + 1))", " \
    \       val (min, max) = numbers.minBy { abs(_) }.maxBy { abs(_) }\n        (min,\
    \ max)", "        var minVal = numbers.head\n        var maxVal = numbers.last\n\
    \        var closest = (minVal, maxVal)\n        for (i <- 1 to numbers.size -\
    \ 1) {\n            val num = (numbers.last - numbers.head) / 2\n            if\
    \ (Math.abs(num - numbers.head) < Math.abs(num - numbers.last)) {\n          \
    \      minVal = numbers.head + num\n            } else {\n                maxVal\
    \ = numbers.last - num\n            }\n            if (Math.abs(minVal - numbers.head)\
    \ < Math.abs(minVal - numbers.last)) {\n                closest = (minVal, maxVal)\n\
    \            }\n        }\n        closest", "        if (numbers.size < 2) throw\
    \ new IllegalArgumentException(\"List must have at least two elements\")\n   \
    \     val smallest = math.min(numbers.head, numbers.last)\n        val largest\
    \ = math.max(numbers.head, numbers.last)\n        (smallest, largest)", "    \
    \    val numSize = numbers.size\n        if (numSize < 2) throw new IllegalArgumentException(\"\
    Input list must have at least two elements.\")\n        val first = numbers.head\n\
    \        val second = numbers.last\n        var smallestDiff = first.abs - second.abs\n\
    \        val smallestNumber = first\n        val largestNumber = second\n\n  \
    \      if (smallestDiff == 0) {\n            (smallestNumber, largestNumber)\n\
    \        }\n        else {\n            val diff = largestNumber.abs - smallestNumber.abs\n\
    \            if (diff < smallestDiff) {\n                smallestDiff = diff\n\
    \                smallestNumber = smallestNumber.abs / (smallest - largest)\n\
    \                largestNumber = largestNumber.abs / (smallest - largest)\n  \
    \          }\n            else {\n                smallestDiff = diff\n      \
    \          smallestNumber = largestNumber\n                largestNumber = smallestNumber.abs\
    \ / (smallest - largest)\n            }\n            (smallestNumber, largestNumber)\n\
    \        }", "        val smallestNumber : Float = numbers.head\n        val largestNumber\
    \ : Float = numbers.last\n        if (smallestNumber == largestNumber) {\n   \
    \         (smallestNumber, smallestNumber)\n        } else {\n            val\
    \ closestNumbers = numbers.filter(_ < (smallestNumber + 1.0f))\n            val\
    \ closestPairs = closestNumbers.zip(closestNumbers.drop(1)) // Pairs\n       \
    \     val smallestPair = closestPairs.minBy(_._1)\n            val largestPair\
    \ = closestPairs.maxBy(_._1)\n            (smallestPair._1, largestPair._1)\n\
    \        }", "        numbers.zipWithIndex.map { case (x, i) => \n           \
    \ if (i == 0) (x.toFloat, x.toFloat)\n            else if (x.toFloat < numbers(i\
    \ - 1).toFloat) (numbers(i).toFloat, numbers(i - 1).toFloat)\n            else\
    \ (numbers(i - 1).toFloat, x.toFloat)\n        }.minBy(_._1)", "        if (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"findClosestElements cannot handle\
    \ empty collection\")\n        val d = new mutable.ArrayList[Double](numbers.size)\n\
    \        for (number <- numbers) {\n            d.add(number)\n        }\n   \
    \     val minDistance = math.max(d.min, (d.last - d.last.abs).toDouble)\n    \
    \    d.foreach { x =>\n            val d = math.abs(x - d.last)\n            if\
    \ (d < minDistance) {\n                minDistance = d\n            }\n      \
    \  }\n        (d.min.toFloat, d.max().toFloat)", "        val sortedList = numbers.sortBy(x\
    \ => x)\n        val twosAbove = sortedList.sliding(2).filter(_(0) != _(1)).toList\n\
    \        val twosBelow = sortedList.sliding(2).filter(_(0) != _(1)).reverse.toList\n\
    \        val smallestIndex = (twosAbove ::: twosBelow).indexWhere(_(_) < sortedList(0))\n\
    \        val largestIndex = twosAbove.length - 1\n        (twosAbove(smallestIndex),\
    \ twosBelow(largestIndex))", "        def sortClosest(a : Float, b : Float) :\
    \ Float = {\n            if(a < b) a else b\n        }\n        numbers.sortBy(sortClosest)",
  "        if (numbers.isEmpty) sys.error(\"findClosestElements: cannot find a pair\
    \ of elements with no numbers in list\")\n        else {\n            def closest(a\
    \ : Float, b : Float) : Float = {\n                if (a < b) a else b\n     \
    \       }\n            def distance(a : Float, b : Float) : Float = {\n      \
    \          Math.abs(a-b)\n            }\n            var smallestDistance : Float\
    \ = numbers.head\n            var secondSmallestDistance : Float = numbers.head\n\
    \            var smallestIndex : Int = numbers.head.toInt\n            var secondSmallestIndex\
    \ : Int = numbers.head.toInt\n            for (i <- 1 to numbers.size-1) {\n \
    \               val distance = distance( numbers(i-1), numbers(i) )\n        \
    \        if (smallestDistance == 0.0f || distance < smallestDistance) {\n    \
    \                smallestIndex = i\n                    smallestDistance = distance\n\
    \                }\n                if (secondSmallestDistance == 0.0f || distance\
    \ < secondSmallestDistance) {\n                    secondSmallestIndex = i\n \
    \                   secondSmallestDistance = distance\n                }\n   \
    \         }\n            (numbers(smallestIndex), numbers(secondSmallestIndex))\n\
    \        }", "        // Set up a pair of numbers where the smaller one is the\
    \ closest in value to the second number\n        var closestPair = numbers.head\n\
    \        var secondClosestPair = numbers.head\n        val smallestDifference\
    \ = numbers.head\n\n        for (number <- numbers) {\n            val difference\
    \ = math.abs(number - secondClosestPair)\n            if (difference < smallestDifference)\
    \ {\n                smallestDifference = difference\n                closestPair\
    \ = number\n            }\n            secondClosestPair = number\n        }\n\
    \        // Return the smallest difference number and the second closest number\n\
    \        (closestPair, secondClosestPair)", '        numbers.zipWithIndex.sortWith((number1,
    number2) => number1 compareTo number2).take(2)', "        val sortedNumbers =\
    \ numbers.sortWith(_ < _)\n        (sortedNumbers.head + sortedNumbers.last) /\
    \ 2f, sortedNumbers.last", "        val smallestDistance = math.abs(numbers(1).toFloat\
    \ - numbers(0).toFloat)\n        val largestDistance = math.abs(numbers(numbers.size-1).toFloat\
    \ - numbers(numbers.size-2).toFloat)\n        if ((smallestDistance < largestDistance)\n\
    \            && (numbers(0).toFloat < numbers(numbers.size-1).toFloat))\n    \
    \        return numbers(0).toFloat, numbers(numbers.size-1).toFloat\n        else\n\
    \            return numbers(1).toFloat, numbers(0).toFloat", "        val sortedNumbers\
    \ = numbers.toList.sortWith(_ < _)\n        val closest = sortedNumbers.min(_\
    \ < numbers(1))\n        val closestRemaining = sortedNumbers.max(_ < numbers(2))\n\
    \        (closest, closestRemaining)", "        def distance(a : Float, b : Float)\
    \ : Float = {\n            val d = a - b\n            if (d < 0.0f) 0.0f\n   \
    \         else if (d > 1.0f) 1.0f\n            else d\n        }\n        def\
    \ minDistance(a : Float, b : Float) : Float = {\n            val d = distance(a,\
    \ b)\n            if (d < min) min else d\n        }\n        val min = (min(numbers)\
    \ / 2.0f)\n        val minIndex = -1\n        var bestDistance : Float = distance(numbers(0),\
    \ numbers(1))\n        var bestIndex = 0\n        numbers.foreach(n => if (n >\
    \ bestDistance) {\n            bestDistance = distance(n, numbers(bestIndex))\n\
    \            bestIndex = bestIndex + 1\n        }\n        )\n        ((numbers(bestIndex),\
    \ numbers(bestIndex)))", "        val sortedList = numbers.sortBy(-_)\n      \
    \  if (sortedList.size <= 2) (sortedList(0), sortedList(sortedList.size - 1))\n\
    \        else (sortedList.headOption.map(head => (head, sortedList.lastOption.map(tail\
    \ => (head, tail)))),\n          sortedList.lastOption.map(tail => (sortedList.lastOption.map(head\
    \ => (head, tail)))))", "        var largestNumber : Float = numbers(0)\n    \
    \    var secondLargestNumber : Float = numbers(0)\n        var smallestNumber\
    \ : Float = numbers(0)\n        var secondSmallestNumber : Float = numbers(0)\n\
    \        var currentNumber : Float = 0.0f\n        var currentSmallestNumber :\
    \ Float = 0.0f\n        var currentLargestNumber : Float = 0.0f\n        var currentSecondLargestNumber\
    \ : Float = 0.0f\n        var currentSecondSmallestNumber : Float = 0.0f\n   \
    \     var currentSecond : Float = 0.0f\n        var current : Tuple2[Float, Float]\
    \ = (0.0,0.0)\n        for (number <- numbers) {\n            smallestNumber =\
    \ numbers(0) if (currentSmallestNumber == 0.0f) currentSmallestNumber = number\n\
    \            if (currentSecondSmallestNumber == 0.0f) currentSecondSmallestNumber\
    \ = number\n            if (currentNumber == 0.0f) currentNumber = number\n  \
    \          if (currentLargestNumber == 0.0f) currentLargestNumber = number\n \
    \           if (currentSecondLargestNumber == 0.0f) currentSecondLargestNumber\
    \ = number\n            if (currentSecondLargestNumber < currentSecondSmallestNumber)\
    \ {\n                secondSmallestNumber = numbers(0) if (currentSecondSmallestNumber\
    \ == 0.0f) currentSecondSmallestNumber = number\n                secondLargestNumber\
    \ = numbers(0) if (currentSecondLargestNumber == 0.0f) currentSecondLargestNumber\
    \ = number\n            } else if (currentSecondSmallestNumber < currentSecondLargestNumber)\
    \ {\n                secondLargestNumber = numbers(0) if (currentSecondLargestNumber\
    \ == 0.0f) currentSecondLargestNumber = number\n                secondSmallestNumber\
    \ = numbers(0) if (currentSecondSmallestNumber == 0.0f) currentSecondSmallestNumber\
    \ = number\n            } else if (currentSecondSmallestNumber == currentSecondLargestNumber)\
    \ {\n                if (smallestNumber > numbers(0)) secondSmallestNumber = numbers(0)\
    \ if (currentSecondSmallestNumber == 0.0f) currentSecondSmallestNumber = number\n\
    \                if (secondSmallestNumber > numbers(0)) secondLargestNumber =\
    \ numbers(0) if (currentSecondLargestNumber == 0.0f) currentSecondLargestNumber\
    \ = number\n            } else if (currentLargestNumber < currentSmallestNumber)\
    \ {\n                smallestNumber = numbers(0) if (currentSmallestNumber ==\
    \ 0.0f) currentSmallestNumber = number\n                secondSmallestNumber =\
    \ numbers(0) if (currentSecondSmallestNumber == 0.0f) currentSecondSm"]
stop_tokens:
- "\n    }\n"
