name: HumanEval_143_words_in_sentence
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a string representing a sentence,\n    // the sentence contains\
  \ some words separated by a space,\n    // and you have to return a string that\
  \ contains the words from the original sentence,\n    // whose lengths are prime\
  \ numbers,\n    // the order of the words in the new string should be the same as\
  \ the original one.\n    // Example 1:\n    // >>> wordsInSentence((\"This is a\
  \ test\"))\n    // (\"is\")\n    // Example 2:\n    // >>> wordsInSentence((\"lets\
  \ go for swimming\"))\n    // (\"go for\")\n    // Constraints:\n    // * 1 <= len(sentence)\
  \ <= 100\n    // * sentence contains only letters\n    def wordsInSentence(sentence\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(wordsInSentence((\"\
  This is a test\")).equals((\"is\")));\n    assert(wordsInSentence((\"lets go for\
  \ swimming\")).equals((\"go for\")));\n    assert(wordsInSentence((\"there is no\
  \ place available here\")).equals((\"there is no place\")));\n    assert(wordsInSentence((\"\
  Hi I am Hussein\")).equals((\"Hi am Hussein\")));\n    assert(wordsInSentence((\"\
  go for it\")).equals((\"go for it\")));\n    assert(wordsInSentence((\"here\")).equals((\"\
  \")));\n    assert(wordsInSentence((\"here is\")).equals((\"is\")));\n    }\n\n\
  }\n"
completions: ["        def isPrime(n: Int) : Boolean = \n            (n == 1) || ((n\
    \ == 2) && \n            (n % 2 == 0)) || (n % 3 == 0)\n        def filterPrimes(ns\
    \ : Iterable[Int]) =\n            ns filter (n => isPrime(n))\n        def getWords(ns\
    \ : Iterable[Int]) =\n            ns map {n => if (isPrime(n)) n else \" \"}\n\
    \        val ns = sentence.split(\" \").filterNot(_.isEmpty).toList\n        filterPrimes(ns).toList.mkString(\"\
    \ \")", "        var newWords = \"\"\n        val wordsMap = mutable.Map[String,\
    \ Int]()\n        sentence split \" \".toList foreach { word =>\n            val\
    \ count = 1\n            val existing = wordsMap(word)\n            if (existing\
    \ > 0) count = existing\n            wordsMap(word) = count + 1\n        }\n \
    \       val primes = wordsMap.values.filter(number => number > 1).sorted\n   \
    \     primes.foreach { prime =>\n            val words = wordsMap.filter(_._2\
    \ <= prime).keys.mkString(\" \")\n            newWords = newWords ++ \" \" + words\n\
    \        }\n        newWords", "       val sentenceSplit  = sentence.split(\"\
    \ \") // split sentence by space\n       val sentenceMap   = sentenceSplit.map(word\
    \ => word.toInt)  // map each word to its length\n       val primeMap      = sentenceMap.filter(_\
    \ % 2 != 0)  // remove even length\n       val sortedMap     = primeMap.sorted\
    \  // sort by keys\n       val result = sortedMap.foldLeft[String](\"\") { (resultWord,\
    \ key) =>\n          val subSentence  = sentenceSplit\n          val subSentenceMap\
    \ = subSentence.map(word => word.toInt)  // map each word to its length\n    \
    \      val subSentenceSortedMap = subSentenceMap.filter(_ % key == 0)  // remove\
    \ odd length\n          val subSentenceRes = subSentenceSortedMap.foldLeft[String](\"\
    \") { (result, key) =>\n            if (result == \"\") result else result + \"\
    \ \" + key.toString\n          }\n          resultWord + subSentenceRes\n    \
    \   }\n       result", "        val primes = Array(2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n      \
    \  val letters = Array('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \        val words = new StringBuilder\n        var index = 0\n        var word\
    \ = sentence(0)\n        for(char <- letters) {\n            index += 1\n    \
    \        if(index > sentence.length) return\n            word = word + sentence(0)\n\
    \            if(primes.contains(word.trim.toString.length))\n                words.append(word)\n\
    \        }\n        words.toString()", "        val wordsSet = sentence.split(\"\
    \ \").filter(!_.isEmpty).toSet\n        val primes = primes(wordsSet.toSeq.length)\n\
    \        val result = wordsSet.mkString(\" \")\n        result.filter(a => primes.contains(a.length)).mkString(\"\
    \ \")", "        var res = \"\"\n        sentence.split(\" \").foreach(x => if(x\
    \ == x.toInt) {\n            res = res + (\"*\" * x)\n        }\n        else\
    \ {\n            res = res + (\" \")\n        })\n        res", "      val sentenceArray\
    \ = sentence.split(\" \")\n      val res = mutable.HashSet[String]()\n      for\
    \ (word <- sentenceArray) {\n        for (n <- prime(word.length)) {\n       \
    \   if (n != 1) {\n            val temp = word.substring(0, word.length - n)\n\
    \            if (res.contains(temp)) {\n              break\n            }\n \
    \           res ++= temp\n          }\n        }\n      }\n      res.toList.mkString(\"\
    \ \")", "        val word = sentence.split(\" \").map{_.toUpperCase()}\n     \
    \   val numbers = word.map{_.length}.toSet\n        val primes = numbers.filter(i\
    \ => number.isPrime(i)).toList\n        val stringBuilder = new StringBuilder()\n\
    \        var count = 0\n        var word = \"\"\n        primes.foreach{p =>\n\
    \            word = (word + word.dropRight(p))\n            count += 1\n     \
    \       if(p == primes.last){\n                stringBuilder.append(word.dropRight(count))\n\
    \            }\n        }\n        word", "      val n = sentence.split(\" \"\
    ).map(_.length.toInt).toSeq\n      val primes = n\n        .filterNot(i => n %\
    \ i != 0)\n        .filter(n => n.toInt == n.toInt / 2)\n        .filterNot(i\
    \ => primes.contains(i))\n        .sorted\n        .map(primes.indexOf(_))\n\n\
    \      val result = \"\"\n      var i = 0\n      while(primes.contains(primes.dropRight(i).sum))\
    \ {\n        result += (\" \" + sentence.split(\" \").map(w => primes(primes.indexOf(w))).mkString(\"\
    \ \"))\n        i += 1\n      }\n\n      result", "        val sentenceSplit =\
    \ sentence.split(\" \")\n        val primes = for (i <- 0 until sentenceSplit.length)\
    \ yield {\n            if (isPrime(sentenceSplit.length.toInt)) i\n          \
    \  else -1\n        }\n        val ans = for (i <- primes) yield sentenceSplit(i)\n\
    \        ans.mkString(\" \")", "        val arr = sentence.split(\" \")\n    \
    \    val str1 = arr.toList\n        val primes: List[String] = List(\"2\", \"\
    3\", \"5\", \"7\", \"11\", \"13\", \"17\", \"19\", \"31\", \"37\", \"41\", \"\
    43\", \"47\", \"53\", \"59\", \"61\", \"67\", \"71\", \"73\", \"79\", \"83\",\
    \ \"89\", \"97\")\n        var str2 = arr.toList\n        for(i <- 0 until primes.length){\n\
    \            val prime = primes(i)\n            val isPrime = str2.filter(word\
    \ => prime.toInt == word.length)\n            str2.remove(isPrime)\n        }\n\
    \        str2.mkString(\" \")", "        val split = sentence.split(\" \")\n \
    \       val result = split.map(x => {\n            val n = BigInt(x)\n       \
    \     if(n % 2 == 0){\n                n\n            }else{\n               \
    \ n-(n-1)\n            }\n        }).filter(x=>x % 2 != 0).sorted\n        val\
    \ finalResult = result.mkString(\" \")\n        finalResult", "        val primes\
    \ = Primes.primes(100).toSet\n        var ans = \"\"\n        var count = 0\n\
    \        val words = sentence.split(\" \").toSet\n        words.foreach{ word\
    \ => \n            count += word.size % 2 != 0\n            val index = words.indexWhere(x\
    \ => x.toString.size == word.length)\n            if (primes.contains((word.length\
    \ + 1))) {\n                ans += word + \" \"\n            }\n            if\
    \ (count == words.length - 1) {\n                break\n            }\n      \
    \  }\n        ans", "        var result : String = \"\"\n        var index = 0\n\
    \        var j = 0\n        var k = 0\n        for (x <- sentence){\n        \
    \    if (index == 0){\n                index = 1\n            }\n            else\
    \ if (index == 1){\n                result += x\n                index = 0\n \
    \           }\n            else if (Character.isLetter(x.charAt(0))){\n      \
    \          result += x\n                j++\n                if (j == 2){\n  \
    \                  j = 0\n                }\n            }\n            else{\n\
    \                result += x\n                k++\n                if (k == 3){\n\
    \                    k = 0\n                }\n            }\n        }\n    \
    \    return result", "        def findPrimes(str : String) : List[String] = {\n\
    \            var strList = str.split(\" \")\n            var primes: List[String]\
    \ = Nil\n            for(i <- 2 to strList.last.length){\n                if(!strList.exists(x\
    \ => x.length <= i)){\n                    primes = primes.filterNot(x => x.startsWith(i))\n\
    \                    primes = primes ::: strList.filterNot(x => x.startsWith(i))\n\
    \                }\n            }\n            return primes\n        }\n    \
    \    var wordsInSentence = sentence.split(\" \").filterNot(x => x.isEmpty)\n \
    \       wordsInSentence = wordsInSentence.flatMap(x => findPrimes(x)).toList\n\
    \        wordsInSentence.sort\n        wordsInSentence.mkString(\" \")", "   \
    \     var primes = Vector.empty[Int]\n        var result = \"\"\n        for (item\
    \ <- sentence.split(' ')){\n            if (primes.contains(item.length)) {\n\
    \                result += \" \" + item\n                primes = primes.filterNot(_\
    \ == item.length)\n            } else {\n                primes = primes + item.length\n\
    \            }\n        }\n        return result", "        if(sentence.contains(\"\
    ,\")) {\n            var newSentence = sentence\n            var wordsRemoved\
    \ = 0\n            val wordsInSentence = sentence.split(\"\\\\s+\").length\n \
    \           var primes = Set(2,3,5)\n            for(i <- 0 until wordsInSentence)\
    \ {\n                val word = sentence.split(\"\\\\s+\")(i)\n              \
    \  val prime = primes.filter( prime => word == prime.mkString(\"\") ).getOrElse(\"\
    \")\n                if(prime != \"\") {\n                    primes.remove(prime)\n\
    \                    wordsRemoved += 1\n                }\n            }\n   \
    \         newSentence = newSentence.substring(0, newSentence.length - wordsRemoved)\n\
    \            newSentence = newSentence + \" \" + primes.mkString(\" \")\n    \
    \    } else {\n            var newSentence = sentence\n            var wordsRemoved\
    \ = 0\n            val wordsInSentence = sentence.split(\"\\\\s+\").length\n \
    \           var primes = Set(2,3,5)\n            for(i <- 0 until wordsInSentence)\
    \ {\n                val word = sentence.split(\"\\\\s+\")(i)\n              \
    \  val prime = primes.filter( prime => word == prime.mkString(\"\") ).getOrElse(\"\
    \")\n                if(prime != \"\") {\n                    primes.remove(prime)\n\
    \                    wordsRemoved += 1\n                }\n            }\n   \
    \         newSentence = newSentence.substring(0, newSentence.length - wordsRemoved)\n\
    \            newSentence = newSentence + \" \" + primes.mkString(\" \")\n    \
    \    }\n        return newSentence", "        val words = sentence.split(\" \"\
    ).filter(_.forall(Character.isLetter))\n        var str = words\n        for(i\
    \ <- 0 until words.length){\n            if(words.length % i == 0){\n        \
    \        str.remove(i)\n            }\n        }\n        str.mkString(\" \")",
  "        def isPrime(i: Int, primes: mutable.HashMap[Int, Boolean]) : Boolean =\
    \ {\n            // O(n) \n            if (primes.contains(i)) {\n           \
    \     return primes(i)\n            }\n            var isPrime = true\n      \
    \      for (p <- primes.keys if p > i) {\n                if (i % p == 0) {\n\
    \                    isPrime = false\n                    break\n            \
    \    }\n            }\n            primes(i) = isPrime\n            return isPrime\n\
    \        }\n\n        // O(n)\n        var wordsCount = 0\n        // O(n)\n \
    \       var primes = mutable.HashMap[Int, Boolean]()\n\n        for (word <- sentence.split(\"\
    \ \")) {\n            wordsCount += 1\n            isPrime(word.length, primes)\n\
    \        }\n        val result = new Array[String](wordsCount)\n        for (i\
    \ <- 0 until wordsCount) {\n            result(i) = sentence.split(\" \")(i)\n\
    \        }\n\n        val newSentence = result.mkString(\" \")\n        if (newSentence.length\
    \ == sentence.length) {\n            return newSentence\n        } else {\n  \
    \          for (i <- 0 until newSentence.length)\n                if (newSentence(i)\
    \ != sentence(i)) {\n                    return newSentence\n                }\n\
    \        }", "        val nums = sentence.split(\" \").map(_.length).distinct\n\
    \        var result = \"\"\n        nums.foreach {n => result = result + sentence.split(\"\
    \ \")(n) + \" \" + n}\n        result", "        val wordsList = sentence.split(\"\
    \ \").map (_.toLowerCase)\n        val wordsDict : scala.collection.mutable.Map[String,Int]\
    \ = new scala.collection.mutable.HashMap[String,Int]()\n        wordsList.foreach(word\
    \ => wordsDict(word) = wordsDict.size + 1)\n        val resultList = wordsDict.filter\
    \ {case (key, value) => value % 2 == 0}\n        val resultStrings = resultList.map\
    \ {case (key, value) => key}.toList.mkString(\" \")\n        resultStrings", " \
    \       val wordList = sentence.split(\" \").map(_.toDouble).map(_.toInt).map(x\
    \ => math.pow(x,2)).filter(x => x > 1).toList\n        val newString = new StringBuilder\n\
    \        wordList.foreach(x => newString.append(x))\n        newString", "   \
    \     var ret = \"\"\n        var primes = {2 3 5 7 11 13 17 19 23 29}\n     \
    \   val sentenceAsArray = sentence.split(\" \").toList\n        for (str <- sentenceAsArray)\
    \ {\n            var strLength = new String(str).length()\n            for (prime\
    \ <- primes.toList) {\n                if (strLength % prime == 0) {\n       \
    \             ret = ret + str\n                    break\n                }\n\
    \            }\n        }\n        return ret.trim()", "        var result : String\
    \ = \"\"\n        var hashSet = scala.collection.mutable.HashSet[String]()\n \
    \       sentence.split(\" \").foreach(word => hashSet.add(word))\n        hashSet.toList.sortWith(_.length\
    \ > _.length).foreach(word => result += word)\n        result", "        var charArray\
    \ = sentence.trim().toCharArray\n        for(i <- 0 until charArray.length){\n\
    \            if((i%2) == 0){\n                if(charArray(i) == ' ') charArray(i)\
    \ = \"\"\n            }\n        }\n        var stringBuilder = new StringBuilder()\n\
    \        charArray.foreach(s => if (s.isEmpty) stringBuilder.append(\"\") else\
    \ stringBuilder.append(s))\n        stringBuilder.toString().trim", "        def\
    \ isPrime(n : Int) : Boolean = {\n            val sqrt = (math.sqrt(n).toInt).toInt\n\
    \            for( i <- 2 to sqrt ){\n                if( n % i == 0 ) false\n\
    \            }\n            true\n        }\n        val result = mutable.ListBuffer[String]()\n\
    \        for(word <- sentence.split(\" \")){\n            if(isPrime(word.length))\
    \ {\n                result += (word)\n            }\n        }\n        for(word\
    \ <- result.toSeq) {\n            val len = (word.length).toInt\n            if(len\
    \ <= 2) {\n                result -= (word)\n            }\n        }\n      \
    \  result.mkString(\" \")", "        val arr = sentence.split(\" \").toList\n\
    \        val res = arr.filter(_.forall(Character.isLetter))\n        res.filter(_.forall(_\
    \ => arr.reduce((x,y) => x+y.length)%_ == 0))", "        val arr = sentence.split(\"\
    \ \").toList\n        var arr2 = new mutable.ListBuffer[String]\n        for (x\
    \ <- arr) {\n            if (primeNumber(x.length) == false) {\n             \
    \   arr2 += x\n            }\n        }\n        arr2.toList.toString()", "  \
    \      val result = mutable.ArrayBuffer(\"\")\n        for (word <- sentence.split(\"\
    \ \"))\n            if (isPrime(word.length()))\n                result += (word\
    \ + \" \")\n        result.mkString(\" \")", "        val result = new ListBuffer[String]\n\
    \        val words = sentence.split(\" \")\n        for (x <- words) x match {\n\
    \            case x: String if x.forall(_.isLetter) =>\n                val primes\
    \ = primes(x.length)\n                for (p <- primes) if (x contains p.toString)\
    \ result += p\n            case _ => return \"\"\n        }\n        return result.toList().sorted.mkString(\"\
    \ \")", "        val n = scala.math.ceil(sqrt(sentence.length))\n        var str\
    \ = \"\"\n        val set = mutable.HashSet[String]()\n        for(i <- 0 until\
    \ n){\n            if(n % i == 0){\n                str = (str + sentence.split(\"\
    \ \").take(i))\n            }\n        }\n        return str", "        val wordsString\
    \ = sentence.split(\"\\\\s+\")\n        var newWords = wordsString.filter(_ %\
    \ 2 == 0).mkString(\" \")\n        val primes = Seq(3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997).filter(x\
    \ => x % 2 == 0)\n        primes.foreach { p =>\n            newWords = newWords.replaceAll(\"\
    \\\\b\" + p + \"\\\\b\", \"_\" + p + \"_\")\n        }\n        val withoutBlanks\
    \ = newWords.replaceAll(\"_+_\", \"_\")\n        withoutBlanks.replaceAll(\"_$\"\
    , \"\")", "        var result = new StringBuilder()\n        var word = new StringBuilder()\n\
    \        var index = 0\n        while (index < sentence.length) {\n          \
    \  val c = sentence(index).toChar\n            if (!c.isLetter) {\n          \
    \      word.append(\" \")\n                index+=1\n                continue\n\
    \            }\n            val m = c.toInt\n            if (isPrime(m)) {\n \
    \               index+=1\n                continue\n            }\n          \
    \  word += c\n            index += 1\n        }\n        while (index<sentence.length)\
    \ {\n            val c = sentence(index).toChar\n            if (!c.isLetter)\
    \ {\n                word.append(\" \")\n                index+=1\n          \
    \      continue\n            }\n            val m = c.toInt\n            if (!isPrime(m))\
    \ {\n                index+=1\n                continue\n            }\n     \
    \       word += c\n            index += 1\n        }\n        result +=  word.substring(0,\
    \ word.length-1)\n        return result.toString()", "        val result = new\
    \ mutable.ListBuffer[String]()\n        var index = 1\n        val isPrime = new\
    \ mutable.HashSet[Int]()\n        val chars = sentence.split(\"\")\n        chars.foreach\
    \ { elem =>\n            val newIndex = index\n            val temp = elem\n \
    \           val isPrimeChecker = isPrime(newIndex) //prime checker\n         \
    \   if (isPrimeChecker) isPrime += newIndex\n            val checker = (elem ==\
    \ temp) //check whether two words are equal or not\n            if (checker) result\
    \ += \"\\\"\" + elem + \"\\\"\"\n            index += 1\n        }\n        if\
    \ (result.length == 0)\n            return (\"\\\"\" + sentence + \"\\\"\")\n\
    \        if (result.length == 1)\n            return result(0)\n        return\
    \ result.toSeq.distinct", "        if(sentence.contains(\" \")) {\n          \
    \  val words = sentence.split(\" \")\n            val newList = new mutable.ListBuffer[String]()\n\
    \            for(i <- 0 until words.length)\n            {\n                val\
    \ word = words(i)\n                if(isPrime(word.length)) newList += word\n\
    \            }\n            newList.toList.sort().mkString(\" \")\n        } else\
    \ {\n            \"\"\n        }", "        val words = (for (x <- sentence.split(\"\
    \\\\s+\")) yield {\n            val b = x.toByte\n            if (b % 2 == 0 &&\
    \ b != 1) {\n                x\n            } else {\n                \"_\"\n\
    \            }\n        }).toArray\n        val newWords = for (word <- words;\
    \ w <- words; if (w != word && w.length == word.length)) yield {\n           \
    \ w + \"/\"\n        }\n        newWords.mkString(\"\")", "        val primeNumbers\
    \ = primeNumbers(sentence)\n        var result = \"\"\n        for (i <- 0 until\
    \ primeNumbers.size) {\n            result += \" \" + primeNumbers(i)\n      \
    \  }\n        result", "        val sentenceList = sentence.split(\" \")\n   \
    \     val result = new Array[String](sentenceList.size)\n        val resultSet\
    \ = new mutable.HashSet[String]()\n\n        var index = 0\n        var count\
    \ = 0\n        var flag = false\n        for (word <- sentenceList) {\n      \
    \      while (index > -1 && index >= count) {\n                if (flag) {\n \
    \                   resultSet(word) = resultSet(word) + resultSet(index)\n   \
    \                 resultSet(index) = null\n                    flag = false\n\
    \                } else {\n                    flag = true\n                }\n\
    \                index -= 1\n            }\n            resultSet(word) = word\n\
    \            resultSet(count) = word\n            count += 1\n        }\n\n  \
    \      val resultString = resultSet.toString()\n        return resultString",
  "        val words = sentence.split(\" \").map(_.toLowerCase)\n        val newWords\
    \ = words.filter(word => isPrime(word.length))\n        val result = newWords.mkString(\"\
    \ \")\n        \n        result ", "        val words = sentence.split(\" \")\n\
    \        words.foreach(w => if(w.length==1) prime(w) else prime(w))\n        val\
    \ list2 = new mutable.ListBuffer[String]()\n        words.foreach(w => {\n   \
    \         if(prime(w.length()))\n                list2 += w\n        })\n    \
    \    list2.toList.toString", "        val words = sentence.split(\" \").filter(_.isLetter)\n\
    \        val result = new mutable.LinkedList[String]()\n        for (word <- words)\
    \ {\n            val temp = word.length\n            while(temp > 1) {\n     \
    \           if(math.ceil(temp % 2) == 1) {\n                    result.addLast(word)\n\
    \                    break;\n                }\n                temp /= 2\n  \
    \          }\n        }\n        result.map(_.toUpperCase()).mkString(\" \")",
  "        val words = sentence.split(\" \").toList\n        words.filter(_().isPrime)",
  "        def isPrime(n : Int) : Boolean = {\n            for(x <- 2 until n by 2)\n\
    \                if(!(n%x).equals(0) && n%x != 0)\n                    return\
    \ false\n            return true\n        }\n        var result = new ListBuffer[String]()\n\
    \        for (x <- sentence.split(\" \")) {\n            val newLength = x.length\n\
    \            val isPrime = isPrime(newLength)\n            val append = newLength\
    \ match {\n                case x if x > 2 => x.toString\n                case\
    \ x if x < 2 => x\n                case 2 => \"\"\n            }\n           \
    \ if (isPrime) result += append\n        }\n        result.mkString(\" \")", " \
    \       val words = sentence.split(\" \")\n        val results = new mutable.ArrayBuffer[String]\n\
    \        for(word <- words) {\n            val newWord = word.replace(\" \", \"\
    \")\n            if (newWord.length == 1) continue\n            if (isPrime(newWord.length))\
    \ results += newWord\n        }\n        val sorted = results.sortWith(_ < _)\n\
    \        val res = sorted.mkString(\" \")\n        res", "        val strList\
    \ = sentence.split(\" \")\n        strList.map {\n            str1 =>\n      \
    \          val str2 = str1.replaceAll(\" \", \"\")\n                val str3 =\
    \ str2.toInt\n                println(str3)\n                if (str3.isPrime)\n\
    \                    str1\n                else\n                    \"\"\n  \
    \      }.mkString(\" \")", "        val nums = Array(2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n      \
    \  def checkPrime(i : Int) : Boolean = {\n            for(j <= Math.sqrt(i); j\
    \ <= nums.length; j += 1){\n                if(i % nums(j) == 0)\n           \
    \         return false\n            }\n            return true\n        }\n  \
    \      val words = sentence.split(\" \").toList\n        val wordsStr = words.toList\n\
    \        val output = wordsStr.filter(checkPrime(_))\n        return output.mkString(\"\
    \ \")", "        var result : String = \"\"\n        var words : String = sentence.split(\"\
    \ \")\n        words.foreach{\n            wordLen => {\n                if(prime(wordLen)){\n\
    \                    result += \" \" + wordLen\n                }\n          \
    \  }\n        }\n        result", "        val charSet = mutable.HashSet[Char]()\n\
    \        sentence.foreach{ c =>\n            if (c.isLetter) charSet.add(c)\n\
    \        }\n        val result = mutable.ListBuffer[String]()\n        var pos\
    \ = 1\n        while (pos < sentence.length) {\n            val currentChars =\
    \ charSet.filter{ c => c % pos == 0 }\n            if (currentChars.size == 0)\
    \ {\n                result.append(\" \")\n            } else {\n            \
    \    result.append(currentChars.head.toString.substring(1))\n            }\n \
    \           pos += 1\n        }\n        result.toString", "        //var newSentence\
    \ = \"\"\n        //var newWord = \"\"\n        //var nextWord = \"\"\n      \
    \  //var tempWord = \"\"\n        //var currentWord = \"\"\n        //var first\
    \ = true\n        //var length = 0\n        /*\n            Loop through the given\
    \ sentence and find lengths of the words.\n            For each word, the first\
    \ letter of that word is saved to tempWord.\n            At the end of each iteration,\
    \ currentWord is appended to newWord.\n            At the end of each iteration,\
    \ currentWord is set to tempWord.\n            At the end of each iteration, tempWord\
    \ is set to currentWord.\n            At the end of each iteration, length +=\
    \ 1 \n        */\n        sentence foreach {word =>\n            //tempWord =\
    \ word\n            length = word.length\n            word.dropWhile(_.isLetter)\
    \ foreach {letterOfWord =>\n                tempWord = letterOfWord\n        \
    \    }\n            currentWord = tempWord\n            newWord = currentWord\n\
    \            tempWord = currentWord\n            newWord = newWord + \" \"\n \
    \       }\n        //newSentence = newSentence + newWord\n        //return newSentence\n\
    \        sentence.filter(_.length == prime_number_tester(length)).mkString(\"\
    \ \")\n        //return newWord", "        // Write your code here\n        val\
    \ words = sentence.split(\" \").map(word => word.length)\n        val result =\
    \ new collection.mutable.ArrayBuffer[Int]()\n        for (word <- words) {\n \
    \           val prime = word.primeNumber\n            if (prime.isDefined) {\n\
    \                result += (prime + 1)\n            }\n        }\n        return\
    \ result.takeWhile(_ < words.length).mkString(\" \")", "        val l = sentence.length\n\
    \        val primes = new mutable.HashSet[Long]()\n        primes.add(l)\n   \
    \     var res = \"\"\n        for (i <- 0 until l) {\n            val temp = Math.sqrt(l).toInt\n\
    \            while (temp <= primes.size) {\n                val c = primes.find(_\
    \ % temp == 0)\n                if (c >= 0) {\n                    primes.remove(c)\n\
    \                } else {\n                    temp += 1\n                }\n\
    \            }\n            res += sentence.substring(i, i + 1) + \" \"\n    \
    \    }\n        res", "        var primes = []\n        var s = ArrayBuffer.empty[String]\n\
    \        for (word <- sentence.split[String]()){\n            val prime = scala.math.remainder(word.length,\
    \ 2)\n            if(prime == 0) primes.append(prime)\n            s ++= word\
    \ :: primes.toArray\n        }\n        s.toList.reverse.mkString(\" \")", " \
    \       val arr = sentence.split(\" \")\n        var ans = \"\"\n        for(\
    \ i <- 0 until arr.length){\n            val strArr = arr(i).split(\"\")\n   \
    \         for( j <- 0 until strArr.length){\n                if(strArr(j).isLetter){\n\
    \                    if(strArr.length == 2){\n                        ans += strArr(j)\n\
    \                    } else if(!isPrime(strArr(j).toInt)){\n                 \
    \       ans += strArr(j)\n                    }\n                }\n         \
    \   }\n        }\n        ans", "        // Write your code here\n        val\
    \ wordsArray = sentence.split(\" \").toArray\n        var ans = \"\"\n       \
    \ for(i<-0 until wordsArray.length){\n            var found = false\n        \
    \    for(j <- 0 until i){\n                if(math.pow(wordsArray(i).length,2)\
    \ == math.pow(wordsArray(j).length,2)){\n                    found = true\n  \
    \                  break\n                }\n            }\n            if(found){\n\
    \                ans += \" \" + wordsArray(i)\n            }\n        }\n    \
    \    return ans", "        val words = sentence.split(\" \").map(w => w.trim).toSet\n\
    \        val maxWordLen = Math.sqrt(words.size).toInt\n        val lens = words.size\n\
    \        val primals = words.size.toList.filter(_ % 2 != 0).toSet\n        val\
    \ primesLen = primals.size\n        val res = lens.filter(w => w%2 == 0).filter(w\
    \ => primals.contains(w)).mkString(\" \")\n        if(maxWordLen < primesLen)\
    \ {\n            res\n        } else {\n            wordsInSentence(res+\"\\n\"\
    +res)\n        }", "        var counts = HashMap[Int, Int]()\n        var result:\
    \ mutable.StringBuilder = new mutable.StringBuilder\n\n        for (word <- sentence.split(\"\
    \ \")){\n            if (counts.get(word.length) == null){\n                counts.put(word.length,\
    \ 1)\n            }else{\n                counts(word.length)+= 1\n          \
    \  }\n        }\n\n        for (i <- counts.keys){\n            if((counts(i)*(i+1))\
    \ < (counts.values.sum * counts.values.sum)){\n                result.append(\"\
    (\" + i + \")\")\n            }\n        }\n\n        result.result()", "    \
    \    val m = sentence.split(' ')\n        m.sortWith(_.length > _.length)\n  \
    \      var result = m.map( x => x )\n        for (i <- 1 until result.length-1)\
    \ result :+ result(i+1)\n        result.distinct", "        // write your code\
    \ here\n        val sentenceArr = sentence.split(\" \").toList\n        val res\
    \ = new mutable.StringBuilder()\n        val primeSet = mutable.HashSet[Int]()\n\
    \        val maxLength = (sentenceArr.length.toInt - 1) * 7\n        val primeFactors\
    \ = mutable.ArraySet[Int]()\n        var maxPrimeFactor = maxLength\n        for\
    \ (i<-0 until sentenceArr.length) {\n            if (primeSet.contains(i))\n \
    \               continue\n            val temp = i * i\n            if (temp >\
    \ maxPrimeFactor) {\n                maxPrimeFactor = temp\n            }\n  \
    \          if (primeFactors.contains(temp)) {\n                if (primeFactors.contains(temp\
    \ - temp)) {\n                    if (primeFactors.contains(temp - temp - temp))\
    \ {\n                        if (primeFactors.contains(temp - temp - temp - temp))\
    \ {\n                            res.append(\" \")\n                        }\n\
    \                    }\n                }\n            }\n            primeFactors\
    \ += temp\n            primeSet += i\n        }\n        res+=(primeFactors.mkString(\"\
    \ \")).trim\n        res+=(\" \").trim\n        return res.reverse.mkString(\"\
    \ \")", "        val words = sentence.split(\" \")\n        var result = \"\"\n\
    \        for (x <- words) {\n            if (x.length == 1 || x.length % 2 ==\
    \ 1) {\n                result += x\n            }\n        }\n        return\
    \ result", "        val words = sentence.split(\" \")\n        val primes = mutable.ListBuffer[Int]()\n\
    \        var primeFound = false\n        for (word <- words) {\n            var\
    \ primeNumber = (word.size / 2).toInt\n            while (primeNumber != 0) {\n\
    \                if (isPrime(primeNumber)) {\n                    primeFound =\
    \ true\n                    primes += primeNumber\n                }\n       \
    \         primeNumber /= 2\n            }\n        }\n        if (primeFound)\n\
    \            return words.filter( word => primes.contains(word.size / 2)).mkString(\"\
    \ \")\n        else\n            return \"No Primes\"", '        // write your
    code here', "        var list = new Array[String](0)\n        var primeWords =\
    \ new Array[String](0)\n        var currentWord = new String\n        var primes\
    \ = 0\n        for (word <- sentence) {\n            for (i <- 1 to word.length-1)\
    \ {\n                currentWord = word + word.charAt(i)\n                if (prime(currentWord.length))\
    \ {\n                    if (list.contains(currentWord)) {\n                 \
    \       primeWords = primeWords :+ currentWord\n                    }\n      \
    \              else {\n                        list :+= currentWord\n        \
    \                primes = primes + 1\n                    }\n                }\n\
    \            }\n        }\n        if (primes > 0 && primes != sentence.length)\n\
    \            primeWords = primeWords :+ (sentence - primeWords.drop(1))\n    \
    \    if (primeWords.length != 0)\n            primeWords = primeWords.reverse.mkString(\"\
    \ \")\n        list", "        val primes = scala.collection.mutable.ListBuffer[String]()\n\
    \        var index = 0\n        while (index != sentence.length) {\n         \
    \   val word = sentence.substring(index, index + 1)\n            if (primes.contains(word))\
    \ {\n                primes += word\n            } else {\n                if\
    \ (isPrime(word.length)) {\n                    primes += word\n             \
    \   } else {\n                    index++\n                }\n            }\n\
    \            index++\n        }\n        primes.toList", "        var result =\
    \ new scala.collection.mutable.HashSet[String]();\n        for(i <- 0 until sentence.length-1)\
    \ {\n            val word = sentence.substring(i,i+1).trim();\n            if(word.length\
    \ == 0){\n                continue;\n            }\n            val length = prime(word.length);\n\
    \            for(j <- 0 until (length-1)) {\n                if(word.substring(j,j+1).trim.equals(word.substring(0,j+1)))\
    \ {\n                    result.add(word.substring(0,j+1));\n                }\n\
    \            }\n        }\n        result.mkString(\" \");", "        // TODO:\
    \ write your code in Scala\n        def isPrime(n: Int) : Boolean = {\n      \
    \      if (n == 1 || n == 0)\n                return true\n            val limit\
    \ = (math.floor(math.sqrt(n).toFloat) + 1).toInt\n            for( i <- 2 to limit\
    \ ) {\n                if(n%i == 0)\n                return false\n          \
    \  }\n            return true\n        }\n        val newWords = ListBuffer[String]()\n\
    \        sentence.split(\" \").foreach(word => {\n            val newWord = newWords.filter(_\
    \ == word).takeWhile(_ => isPrime(_.length)).head\n            newWords.append(newWord)\n\
    \        })\n        return newWords.foldLeft(\"\")(_ + _)", "        var result\
    \ : String = \"\"\n        var words : Array[String] = new Array[String](sentence.length)\n\
    \        var size : Int = 0\n        var prime : Boolean = false\n\n        for(i\
    \ <- 0 until sentence.length){\n            if(sentence(i) == \" \") {\n     \
    \           words ::= sentence(i).split(\"\")\n                size += 1\n   \
    \         }\n        }\n\n        for(i = 0 to size) {\n            prime = true\n\
    \            for(j = 0 to size - 1){\n                if(words(j).length != words(j+1).length)\n\
    \                    prime = false\n            }\n\n            if(prime){\n\
    \                result += words(0)\n            }\n        }\n        return\
    \ result", "        var result : String = sentence\n        var words : List[String]\
    \ = sentence.split(\" \").filter(x => x.toCharArray.forall(_.isLetter)).toList\n\
    \        while (words.length > 1) {\n            var newWords : List[String] =\
    \ words.takeWhile(_ => words.forall(_ => _.isDigit)).mkString\n            var\
    \ newWords2 : List[String] = words.takeWhile(_ => !words.forall(_ => _.isDigit)).mkString\n\
    \            if (newWords.map(_.length) == newWords2.map(_.length)) {\n      \
    \          result = newWords\n                words = newWords2\n            }\
    \ else {\n                result = result.replaceFirst(s\"$newWords\", \"\")\n\
    \                words = words.tail\n            }\n        }\n        result",
  "        val strs = sentence.split(\" \").map(_.toUpperCase)\n        strs.filter(x\
    \ => primeString(x)).map(x => x.toUpperCase).mkString(\" \")", "        // write\
    \ your code here\n        var arr = sentence.split(\" \").filter(x => !x.isEmpty)\n\
    \        var result = \"\"\n        for (i <- arr.indices)\n        if (arr(i).isPrime)\
    \ {\n            result += arr(i) + \" \"\n        }\n        result", "     \
    \   val strArr = sentence.split(\" \").toList\n        strArr.foreach(word =>\
    \ {\n            val str = scala.math.pow(word.len(), 2)\n            if(str.modulo(2).isZero)\
    \ println(word+\" length \"+str.len+\" modulus \"+str.modulus)\n        })\n \
    \       strArr.sort", "        // (1) Remove all letters and replace them with\
    \ a space\n        val str = sentence.filter( x => x.isLetter)\n        val str1\
    \ = str.map( x => \" \" + x)\n        // (2) replace double space with one space\n\
    \        val str2 = str1.filter( x => x.contains(\" \"))\n        // (3) map string\
    \ with length of string\n        val str3 = str2.map( x => (x + \"length\").length)\n\
    \        // (4) filter prime numbers\n        val str4 = str3.filter( x => x %\
    \ 2 != 0)\n        // (5) sort string\n        val str5 = str4.sortWith(_.length\
    \ < _.length)\n        // (6) join strings\n        val str6 = str5.mkString(\"\
    \ \")\n        return str6", "        var result = \"\"\n        for (word <-\
    \ sentence.split(\" \")) {\n            if (word.length == 1) {\n            \
    \    result += word\n            } else {\n                // Sieve of Eratosthenes\
    \ (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) \n                // https://en.wikipedia.org/wiki/Prime_number\n\
    \                for (i <- 2 to word.length) {\n                    if (isPrime(word.length))\
    \ {\n                        result += \" \" + word.substring(i)\n           \
    \         }\n                }\n            }\n        }\n        result", " \
    \       var newString = \"\"\n        val arrayList = sentence.split(\" \").map(x\
    \ => x.toInt)\n        val primeList = getPrimes(arrayList)\n        primeList.foreach(x\
    \ => newString += (arrayList.indexOf(x) + 1) + \" \")\n        newString.substring(0,\
    \ newString.length - 1)", "        def isPrime(n: Int) : Boolean = {\n       \
    \     val sqrt: Double = Math.sqrt(n)\n            val flag: Boolean = n % 2 !=\
    \ 0\n            val j = 0\n            while ( j * j <= sqrt ) {\n          \
    \      val tmp = n + j * j\n                if ( tmp == n )\n                \
    \    return true\n                if ( flag )\n                    break\n   \
    \             if ( tmp % 2 == 0 )\n                    break\n               \
    \ j += 1\n            }\n            false\n        }\n\n        val wordList:\
    \ List[String] = sentence.split(\" \").filter(_.isLetter).toList\n        val\
    \ result: List[String] = new ListBuffer[String]()\n        wordList.foreach(w\
    \ => {\n            if( isPrime(w.length) )\n                result += w\n   \
    \     })\n        result mkString \" \"", "        val wordLists = sentence.split(\"\
    \ \")\n        var result = \"\"\n        for(wordList <- wordLists) {\n     \
    \       val wordsSet = wordList.toSet\n            if(wordsSet.length == 2 &&\
    \ wordsSet.toList.size == 1) {\n                result += wordsSet.toList(0)\n\
    \            } else if(wordsSet.length == 2 && wordsSet.toList.size == 2) {\n\
    \                result += (wordsSet.toList.takeRight(2).mkString(\" \"))\n  \
    \          }\n        }\n        if(result.length == 0 || result == \" \") {\n\
    \            result = \"no words\"\n        }\n        result", "        var result\
    \ = \"\"\n        var isPrime = true\n        var prime = 0\n        var primeCounter\
    \ = 0\n        var charCounter = 0\n        var word = \"\"\n        for( c <-\
    \ sentence.chars ){\n            charCounter += 1\n            if( c == ' '){\n\
    \                prime = charCounter\n                primeCounter += 1\n    \
    \            if( primeCounter == 2 ){\n                    primeCounter = 0\n\
    \                    isPrime = true\n                }else if( primeCounter >\
    \ 2 ){\n                    isPrime = false\n                }\n            }\n\
    \            if( !isPrime ){\n                result = result + c\n          \
    \  }\n            if( isPrime ){\n                if( prime == charCounter ){\n\
    \                    word = \"\"\n                }else{\n                   \
    \ word = word + c\n                }\n            }\n        }\n        if( result\
    \ != \"\" ){\n            result\n        }else{\n            result\n       \
    \ }", "        var result : mutable.Set[Int] = mutable.Set()\n        var words\
    \ : String = sentence.split(\" \")\n        for(word <- words)\n        {\n  \
    \          if(!result.contains(word.length.toInt))\n            {\n          \
    \      result ++= word.length.toInt\n            }\n        }\n        val result\
    \ =  result.toSeq\n        result.sort\n        result.mkString(\" \")", "   \
    \     val arr = sentence.split(\" \")\n        var str = \"\"\n        for (i\
    \ <- 0 until arr.length) {\n            if (arr(i).length != 3 || arr(i).isDigit)\
    \ {\n                str += arr(i) + \" \"\n            }\n        }\n       \
    \ str.trim", "        val words = sentence.split(\"\\\\s+\").map(word => word.trim).filter(word\
    \ => word.length >=1).map(_.toLowerCase).toList\n        val primeFactors = primeFactors(words.length)\n\
    \        val result = words.filter(word => primeFactors.contains(word.length)).mkString(\"\
    \ \")\n        result", "        val list = sentence.split(\" \").toList\n   \
    \     var newSentence = sentence.substring(0,1)\n        var count = List(0)\n\
    \        var temp = List(0)\n        for (word <- list){\n            newSentence\
    \ = newSentence + \" \"+ word\n            if (new String(list).indexOf(word)\
    \ > 0){\n                count = count + 1\n            }\n        }\n       \
    \ for (i <- 0 to count-1){\n            temp = temp.take(i)\n            temp\
    \ += \" \"\n        }\n        return newSentence", "        var str = new StringBuilder\n\
    \        var index = 0\n        for (word <- sentence.split[Char]()) {\n     \
    \       // Skip the words that are not prime numbers.\n            if (isPrime(index))\
    \ {\n                str.append(word)\n                index++\n            }\n\
    \        }\n        str.toString()", "        val tokens = sentence.split(\" \"\
    ).filter(_.isLetter).toList\n        val primes = tokens.map(new PrimeFinder()).collect{case\
    \ PrimeFinder(p) => p}\n        val res = tokens.filter{p => primes.contains(p)}.toList\n\
    \        res.sorted", "        def isPrime(n: Int) : Boolean = {\n           \
    \ val l = (Math.sqrt(n) + 1) * 2\n            l % 2 == 0 && l != n\n        }\n\
    \        val words = sentence.split(\" \").filter(_.isLetter).distinct\n     \
    \   if(words.length < 2) \"\"\n        else words.filter(isPrime).mkString(\"\
    \ \")", "        val words = sentence.split(\"\\\\s+\")\n        val wordsLength\
    \ = words.length\n        var primesSet = scala.collection.mutable.Set[Long]()\n\
    \        var primes = 0\n        var newSentence = sentence.split(\"\").foldLeft(\"\
    \")(\n            (acc, word) => acc + \" \" + word,\n            acc => acc\n\
    \        )\n        for (i <- 1 to wordsLength) {\n            if (primesSet.contains(primes)\
    \ || primesSet.contains(i - primes)) {\n                newSentence = newSentence.substring(0,\
    \ newSentence.length - 1) + \" \" + newSentence.substring(newSentence.length -\
    \ 1, 1)\n                primes = primes + 1\n            } else {\n         \
    \       primesSet = primesSet + i\n                primes = primes + 1\n     \
    \       }\n        }\n        newSentence = newSentence.substring(0, newSentence.length\
    \ - 1) + \" \" + newSentence.substring(newSentence.length - 1)\n        newSentence",
  "        val result = mutable.Set[String]()\n        sentence.split(\" \").foreach(word\
    \ => {\n            val len = word.length\n            if(len == 2) {\n      \
    \          result.add(word)\n            } else if (len == 3) {\n            \
    \    if(result.contains(word)) {\n                    result.remove(word)\n  \
    \              }\n            }\n        })\n        result.mkString(\" \")",
  "        val chars = sentence.split(\" \").toList.map(_.toChar)\n        val result\
    \ = new mutable.ListBuffer[String]()\n        for (c <- chars) {\n           \
    \ val p = gcd(c+2, chars.size.toLong)\n            if (p==1) {\n             \
    \   result += c\n            }\n        }\n        result mkString \" \"", " \
    \       val result = mutable.ArrayBuffer.empty[String]\n        val length = sentence.length\n\
    \        for( i <- 0 until length )\n            if( isPrime(i) && isPrime(length-i)\
    \ && sentence.charAt(i) == ' ')\n                result.append((sentence.subString(i+1,\
    \ length-i)))\n        result.mkString(\" \")", "        def isPrime(candidate:\
    \ Int) : Boolean = {\n            def isPrimeInner(candidate: Int) : Boolean =\
    \ {\n                if (candidate == 1) {\n                    true\n       \
    \         } else {\n                    candidate == 2\n                }\n  \
    \          }\n            for {\n                i <- 2 to candidate - 1\n   \
    \             factors <- List(2, i).toSet\n            }{\n                if\
    \ (!factors.isEmpty) {\n                    isPrimeInner(candidate)\n        \
    \        }\n            }\n        }\n        val newWords = ListBuffer[String]()\n\
    \        def wordCount(s : String) : Int = s.split(\" \").size\n        sentence\
    \ match {\n            case \"\" => newWords\n            case \" \" => newWords\n\
    \            case x if x.toInt % 2 == 0 => newWords ++ List(x.toString.substring(0,1))\n\
    \            case x if x.toInt % 2 == 1 => newWords ++ List(x.toString.substring(0,x.toString.length-1))\n\
    \            case x => for (i <- 1 to wordCount(x); p <- isPrime(x.toInt)) {\n\
    \                val newString = x.substring(0, i) + x.substring(i+1, x.length)\n\
    \                if (newString.length == wordCount(newString))\n             \
    \       newWords ++ List(newString)\n            }\n        }\n        newWords.toList().sortWith(compareString).toList",
  "        // write your code here\n        var primeString = \"\"\n        var firstLettersCount\
    \ = 0\n        val listOfWords = sentence.split(\" \")\n        var allWordsLength\
    \ = sentence.split(\" \").length\n        for(word in listOfWords) {\n       \
    \     if(isPrime(word.length)) {\n                firstLettersCount += 1\n   \
    \             if(firstLettersCount > 1) {\n                    primeString +=\
    \ \" \" + word\n                }\n            } else {\n                primeString\
    \ += \" \" + word\n            }\n        }\n        primeString.trim()", "  \
    \      def isPrime(n : Int) : Boolean = {\n            val upperBound = math.pow(math.e,\
    \ n)\n            for(prime <- 1 to upperBound) yield if(n % prime == 0) false\
    \ else true\n        }\n        val words = sentence.split(\" \")\n        var\
    \ res = new collection.mutable.ListBuffer[String]()\n        for(x <- words) {\n\
    \            if(x.toCharArray().forall(c => c <= 'z' || c >= 'a')) res.append(x)\n\
    \        }\n        res.toList.sortWith((x,y) => x.length <= y.length).mkString(\"\
    \ \")", "        var retString = \"\"\n        for (word <- sentence.split(\"\
    \ \")) {\n            var count = 0\n            for (letter <- word.split(\"\"\
    ))\n            {\n                if (letter > 'z')\n                {\n    \
    \                count = count + 1\n                }\n            }\n       \
    \     if (count == 2)\n            {\n                retString = retString +\
    \ word.trim() + '\\n'\n            }\n        }\n        return retString.trim()",
  "        if(sentence == null || sentence.length <= 0) return null\n        var index\
    \ = 0\n        var newIndex = 0\n        var newString = \"\"\n        var count\
    \ = 0\n        val words = sentence.split(\" \")\n        while(index < words.length)\
    \ {\n            count += words.length - 1\n            index += 1\n         \
    \   while(count != 0) {\n                if(words.length - 1 != newString.length)\
    \ newString += \" \"\n                newString += words(newIndex)\n         \
    \       count -= 1\n                newIndex += 1\n            }\n           \
    \ newIndex = 0\n            count = 0\n        }\n        return newString", " \
    \       var finalResult = \"\"\n        var primes = mutable.ListBuffer[Int]()\n\
    \        for (word <- sentence.split(\" \").toList) {\n            val word =\
    \ word.toInt\n            if (primes.contains(word)) {\n                continue\n\
    \            }\n            primes += word\n            val str = primes.mkString(\"\
    \ \")\n            finalResult += str\n        }\n        finalResult", "    \
    \    val words = sentence.split(\" \")\n        val reuslt = new StringBuilder()\n\
    \        val primes = words.map(x => x.length)\n        primes.filter { x => x\
    \ % 2 != 0 }.foreach { x => reuslt.append(x) }\n        primes.foreach { x =>\
    \ reuslt.append(x) }\n        words.size", "        var primeFactors : List[Int]\
    \ = List(1)\n        var newSentence = sentence\n        var primeFactorIndex\
    \ : Int = -1\n        var foundPrimeFactor : Boolean = false\n        var counter\
    \ : Int = 0\n        var count : Int = 0\n        \n        while(foundPrimeFactor\
    \ == false && primeFactorIndex < (primeFactors.length - 1)) {\n            counter\
    \ += 1\n            val primeFactor = primeFactors(primeFactorIndex)\n       \
    \     if(counter % primeFactor == 0) {\n                foundPrimeFactor = true\n\
    \            }\n            primeFactorIndex += 1\n        }\n        \n     \
    \   if(foundPrimeFactor == false) {\n            newSentence = sentence + \" is\
    \ a nice day!\"\n            primeFactors = List(3)\n            primeFactorIndex\
    \ = 0\n            foundPrimeFactor = true\n        }\n        \n        while(foundPrimeFactor\
    \ == true && primeFactorIndex < (primeFactors.length - 1)) {\n            counter\
    \ += 1\n            val primeFactor = primeFactors(primeFactorIndex)\n       \
    \     if(counter % primeFactor == 0) {\n                foundPrimeFactor = false\n\
    \            }\n            primeFactorIndex += 1\n        }\n        \n     \
    \   while(foundPrimeFactor == true && primeFactorIndex > 0) {\n            val\
    \ primeFactor = primeFactors(primeFactorIndex)\n            if(primeFactorIndex\
    \ % 2 == 0) {\n                counter += primeFactor\n            }\n       \
    \     primeFactorIndex -= 1\n            if(counter % primeFactor == 0) {\n  \
    \              foundPrimeFactor = false\n            }\n        }\n        \n\
    \        val newWordList = newSentence.split(\" \").toList\n        \n       \
    \ while(foundPrimeFactor == true && primeFactorIndex < primeFactors.length) {\n\
    \            counter += 1\n            val primeFactor = primeFactors(primeFactorIndex)\n\
    \            if(counter % primeFactor == 0) {\n                foundPrimeFactor\
    \ = false\n            }\n            primeFactorIndex += 1\n        }\n     \
    \   \n        val newWordListSorted = newWordList.sortBy(_.length)\n        \n\
    \        if(newWordListSorted.size == primeFactors.length) {\n            newSentence\
    \ = \"\"\n            primeFactors = List(1)\n            primeFactorIndex = 0\n\
    \            foundPrimeFactor = false\n        }\n        \n        val newSentencesList\
    \ = newWordList.map(word => word + \" \" + newSentence)\n        val newSentencesListSorted\
    \ = newSentencesList.sortBy(_.length)\n        \n        newSentencesListSorted.mkString(\"\
    \ \")", "        var result = \"\"\n        for (word <- sentence.split(\"\\\\\
    s+\")) result += (word.length)\n        if (result < 2) return \"\"\n        for\
    \ (x <- 0 until result)\n            if (isPrime(x % result))\n              \
    \  return sentence.substring(0, x)\n        return sentence", "        val words\
    \ = sentence.split(\" \")\n        var ans = \"\"\n        for (word <- words)\
    \ {\n            val count = words.count(x => x.size == word.size && x.toString.size\
    \ == word.toString.length)\n            if (count == 2) {\n                ans\
    \ = ans + \" \" + word\n            }\n        }\n        ans", "        val words\
    \ = sentence.split(\" \").filter(!_.isDigit)\n        val primes = words.map(word\
    \ => {\n            val number = BigInt(word)\n            val isPrime = true\n\
    \            for(i <- 2 to number.toInt) if(number.mod(i).isZero) isPrime = false\n\
    \            if(isPrime) number\n        }).filter(_ > 2)\n        words.zip(primes).map\
    \ { case (word, number) => word + \" \"+ number }.toList", "        // Your code\
    \ goes here\n        val arr = sentence.split(\" \").map(_.toInt)\n        val\
    \ length = arr.count{ case(i) => i%2==0}\n        if(length==0){\n           \
    \ \"\"\n        }else{\n            val arr = sentence.split(\" \").map(_.toInt)\n\
    \            val newArr = arr.filter{case(i) => i%2==0}\n            val arr1\
    \ = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr1.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr2 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr2.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr3 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr3.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr4 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr4.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr5 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr5.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr6 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr6.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr7 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr7.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr8 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr8.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr9 = newArr.toSeq.sortBy(i => i).reverse\n            val newStr = arr9.mkString(\"\
    \ \")\n            val newArr = newArr.filter{case(i) => i%2==0}\n           \
    \ val arr10 = newArr.toSeq.sortBy(i ", "        val sentenceWords = sentence.split(\"\
    \ \").map(_.toLower)\n        val primes = new mutable.LinkedHashSet[Int]()\n\
    \        var counter = 0\n        sentenceWords.foreach(word => {\n          \
    \  counter = counter + 1\n            var isPrime = true\n            primes.foreach\
    \ { p =>\n                if (p == counter) {\n                    isPrime = false\n\
    \                }\n            }\n            if (isPrime) {\n              \
    \  primes.add(counter)\n            }\n        })\n        val res = new StringBuilder(sentenceWords.size)\n\
    \        for (i<- 0 to sentenceWords.size - 1) {\n            if (primes.contains(i\
    \ + 1)) {\n                res.append(\" \" + sentenceWords(i))\n            }\n\
    \        }\n        res.toString()", "        val words = sentence.split(\" \"\
    ).filter(w => w.isLetter).map(_.toInt)\n        val result = for (i <- 0 until\
    \ words.size) yield {\n            if (words(i) == 0) \"\"\n            else (words(i).toInt.toString).padLeft((words(i)\
    \ - 1).toInt)\n        }\n        result.mkString(\" \")", "        val map =\
    \ mutable.Map[Int, String]()\n        for(word <- sentence.split(\" \")){\n  \
    \          val count = map.getOrElse(word.length, 1L)\n            map+= (word.length\
    \ -> word)\n        }\n        val sortedMap = map.toSeq.sortBy(_._1).map { case\
    \ (_, i) => i -> map.get(_) }.toMap\n        val result = sortedMap.keys.mkString(\"\
    \ \")", "        def findPrime(n : Int) : Boolean = {\n            if(n < 2) return\
    \ false\n            val i = 2\n            while(i <= Math.sqrt(n)) {\n     \
    \           if((n % i) == 0) return false\n                i += 1\n          \
    \  }\n            return true\n        }\n        var words : List[String] = new\
    \ ListBuffer[String]()\n        for(word <- sentence.split(\" \")) {\n       \
    \     val n = word.length\n            if(!findPrime(n)) {\n                words\
    \ += word\n            }\n        }\n        words += sentence\n        words.mkString(\"\
    \ \")", '        // Your code here', "        val splits = sentence.split(\" \"\
    ).map(_.toUpperCase).toList\n        splits.sort().map(_.length).filter(_ > 1).map(_.toString).mkString(\"\
    \ \")", "        val wordsString = sentence.split(' ')\n        val primes = new\
    \ mutable.HashSet[Int]()\n        for(i <- 0 until wordsString.length) primes.add(prime(wordsString.apply(i).toChar))\n\
    \        wordsString.takeWhile(p => primes.contains(prime(p).toChar)).toString\
    \ + \" \" + wordsString.dropWhile(p => primes.contains(prime(p).toChar)).toString",
  "      val wordsString = sentence.split(\" \").map(_.toLowerCase).toSet.toList.sortBy(_._1).map(_._1)\n\
    \      val result: List[String] = wordsString.map {\n        i =>\n          var\
    \ isPrime = true\n          for (j from 2 to ((math.sqrt(2 * i + 1) - 1) / 2))\
    \ {\n            if (i * j == i + j)\n              isPrime = false\n        \
    \  }\n          if (isPrime)\n            \" \" + i\n          else\n        \
    \    i\n      }.filter(x => x.length() > 1).mkString(\" \")\n      result.toString",
  "        val words = sentence.split(\" \").map(_.trim)\n        var max = 0\n  \
    \      for(i <- 0 to words.length-1){\n            if(words[i].length>max){\n\
    \                max = words[i].length\n            }\n        }\n        val\
    \ primes = Array(1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\
    \ 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\
    \ 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\
    \ 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,\
    \ 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,\
    \ 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\
    \ 953, 967, 971, 977, 983, 991, 997)\n        val stringBuilder = new StringBuilder()\n\
    \        for(i <- 0 to words.length-1){\n            val word = words[i].trim\n\
    \            if(word.length == 0){\n                continue\n            }\n\
    \            val isPrime = primes.contains(i)\n            val stringBuilderBuilder\
    \ = new StringBuilder()\n            for(j <- 0 to word.length-1){\n         \
    \       if(word.charAt(j) > max){\n                    break\n               \
    \ }\n                val char = word.charAt(j)\n                stringBuilderBuilder\
    \ += char\n            }\n            stringBuilder.append(stringBuilderBuilder.reverse)\n\
    \        }\n        stringBuilder.reverse", "        var result: mutable.Set[String]\
    \ = mutable.Set.empty[String]\n        var i: Int = 0\n        while(i < sentence.length)\
    \ {\n            val nextIsPrime = true\n            val nextWord = sentence.substring(i,\
    \ i+1).trim\n            var primeNumber: Int = 1\n            val isWordPrime\
    \ = true\n            while(primeNumber < nextWord.length) {\n               \
    \ if(nextWord.length % primeNumber != 0) {\n                    nextIsPrime =\
    \ false\n                    isWordPrime = false\n                    break\n\
    \                }\n                primeNumber += 1\n            }\n        \
    \    if(isWordPrime) {\n                result += nextWord\n                i\
    \ += 1\n            }\n        }\n        return result.mkString(\" \")", "  \
    \      val sentences = sentence.split(\" \").filterNot(_.isEmpty)\n        var\
    \ newSentence = sentences.head\n        var primesSet = mutable.Set[Long]()\n\
    \        for(i <- 1 to sentences.length){\n            val temp = newSentence.length\n\
    \            while(temp > 0){\n                val checker = temp\n          \
    \      while(checker % i != 0){\n                    checker *= i\n          \
    \      }\n                if(primesSet.contains(checker)){\n                 \
    \   break\n                }else{\n                    primesSet += checker\n\
    \                }\n                temp--\n            }\n            newSentence\
    \ += \" \" + sentences(i)\n        }\n        return newSentence.substring(1).trim",
  "        var newWords = \"\"\n        var words = sentence.split(\" \").map(_.toLowerCase).toSet\n\
    \        for(x <- 2 until words.size) {\n            var foundPrime = false\n\
    \            var prime = \"\"\n            for(i <- 0 until x)\n             \
    \   if(words.size%i == 0)\n                    foundPrime = true\n           \
    \     if(foundPrime)\n                    prime += \" \" + i\n            newWords\
    \ += \"(\" + prime + \") \"\n            words.remove(prime)\n        }\n    \
    \    return newWords", "        val words = sentence.split(\" \")\n        var\
    \ resultString = \"\"\n        var prime = 1\n        for (word <- words) {\n\
    \            if(word.forall(c => c.isLetter)) prime = 2\n            while (prime\
    \ < word.length) prime = prime * 2\n            if(prime % word.length == 0) resultString\
    \ = resultString + word + \" \"\n        }\n        return resultString.substring(0,resultString.length\
    \ - 1)", "        val words = sentence.split(\" \").map(x => x.toInt)\n      \
    \  val sortedWords = words.toList\n        val sortedWordsCount = sortedWords.size\n\
    \        val resultSet = SortedSet()\n        val primes = scala.collection.mutable.Set()\n\
    \        primes.update(1, primes.size)\n        var i = 1\n        while(i<=sortedWordsCount)\
    \ {\n            val candidate = sortedWords(i)\n            if(candidate*candidate\
    \ <= sortedWordsCount) {\n                primes.insert(candidate)\n         \
    \       resultSet += candidate\n            }\n            i+=1\n        }\n \
    \       val res = resultSet.mkString(\" \")\n        res", "        val splitWords\
    \ = sentence.split(\"\\\\s+\")\n        val result = mutable.Buffer.empty[String]\n\
    \        splitWords.foreach { s => \n            val prime = primeFactorial(s.length)\n\
    \            result += s if prime != 1\n        }\n        result.mkString(\"\
    \ \")", "        val words = sentence.split(\" \").toList\n        var newWords\
    \ = mutable.ListBuffer[String]()\n        var nextPrime = 1\n        var i = 0\n\
    \        while (i < words.length) {\n            val word = words(i)\n       \
    \     if (nextPrime % word.length == 0) newWords += word\n            i += 1\n\
    \            nextPrime += 1\n        }\n        newWords.mkString(\" \")", " \
    \       // write your code here\n        val str = sentence.split(\" \").filter(_.matches(\"\
    [a-zA-Z]+\")).mkString(\" \")\n        var str1 = str.split(\" \")\n        str1.foreach(x\
    \ => {\n            val y = str.indexOf(x.toUpperCase())\n            if(y ==\
    \ -1) {\n                str = str + \" \" + x.toUpperCase()\n            }\n\
    \        })\n        str.split(\" \").toList.sortWith((x,y) => x.toUpperCase.compareTo(y.toUpperCase))",
  "        var words = sentence.split(\"\\\\s+\").filter(_.nonEmpty)\n        val\
    \ size = words.size\n        var result = \"\"\n        var last = 1\n       \
    \ for(i <- 0 until size) {\n            val current = 3\n            while(current\
    \ < last) {\n                val prime = math.ceil(math.sqrt(current))\n     \
    \           if(prime * prime > current + 1) {\n                    last += prime\
    \ + 1\n                    break\n                }\n                current +=\
    \ prime\n            }\n            result += words.apply(i) + \"\\n\"\n     \
    \       last = prime\n        }\n        result", "        val words = sentence.split(\"\
    \ \")\n        val primes = mutable.Set[Int]()\n        for(i <- 0 until words.length){\n\
    \            val curr = words(i).length\n            val count = if (primes.contains(curr))\
    \ 0 else 1\n            primes = primes + (curr until curr + count).count(x =>\
    \ x == 1)\n        }\n        val result = words.filter(x => primes.contains(x.length)).mkString(\"\
    \ \")\n        words", "        var ret = \"\"\n        var words = new mutable.ListBuffer[String]()\n\
    \        var word = \"\"\n        for (letter <- sentence) {\n            word\
    \ += letter\n            if (letter == \" \") {\n                words += word\n\
    \                word = \"\"\n            } else {\n                words += letter\n\
    \            }\n        }\n        if (word.length != 0) {\n            words\
    \ += word\n        }\n        words.toList.reverse.forall(_.length == primeNumber(word.length))\n\
    \        ret.reverse.mkString(\" \")", "        var newString = \"\"\n       \
    \ for(word <- sentence.split(\"\\\\s+\")) if(checkPrime(word.length.toInt)) newString\
    \ += \" \" + word\n        newString.split(\" \")", "        def primesFilter(lst\
    \ : Iterable[Int]) : List[Int] = {\n            var primes = List[Int]()\n   \
    \         for(i <- lst if i % 2 != 0) primes ::= i\n            primes\n     \
    \   }\n        var sentenceList = sentence.split(\" \").toList\n        var finalList\
    \ = List[String]()\n        for(i <- 0 until sentenceList.length){\n         \
    \   var count = 0\n            for(j <- 0 until primesFilter(sentenceList(i).length())){\n\
    \                count += 1\n                val l = scala.math.sqrt(scala.math.pow(j,2))\n\
    \                val r = scala.math.sqrt(scala.math.pow(j,2))\n              \
    \  if(l < r){\n                    var temp = scala.math.pow(j,2)\n          \
    \          while(temp <= l){\n                        temp = temp * j\n      \
    \              }\n                    if(sentenceList(i).substring(j - count,j\
    \ - count+l) == \"\"){\n                        finalList ::= sentenceList(i).substring(j\
    \ - count,j - count+l)\n                    }\n                }\n           \
    \ }\n        }\n        finalList", "        val words = sentence.split(\" \"\
    ).filter(_.matches(\"[a-zA-Z]+\")).toList\n        val result = new scala.collection.mutable.StringBuilder()\n\
    \        for (word <- words) {\n            val prime = math.ceil(math.sqrt(word.length).toInt)\n\
    \            if (prime == word.length) result.append(word)\n            else if\
    \ (prime % 2 == 0) result.append(\"_\" + word)\n            else result.append(\"\
    _\" + word + \"_\")\n        }\n        return result.toString()", "        //\
    \ write your code here\n        val str = sentence.split(\" \").filter(x => x.length\
    \ == 1)\n        var prime = \"\"\n        var res = []\n        for (i <- 0 until\
    \ str.length)\n        {\n            var flag = true\n            for(j <- 0\
    \ until str.length)\n            {\n                if(i != j)\n             \
    \   {\n                    var temp = str(i)\n                    str(i) = str(j)\n\
    \                    str(j) = temp\n                    if(prime.isEmpty || ((str(i).length()\
    \ == prime.length) && ((str(i).isEmpty) || (str(j).isEmpty))))\n             \
    \       {\n                        prime = (str(i))\n                        flag\
    \ = false\n                        break\n                    }\n            \
    \        else if(str(i).length() > prime.substring(0, prime.length).length)\n\
    \                    {\n                        prime = (str(i))\n           \
    \             flag = false\n                        break\n                  \
    \  }\n                }\n            }\n            if(flag)\n            {\n\
    \                if((prime.isEmpty) || ((prime.length == 0) && (str(i).length()\
    \ == 0)))\n                {\n                    res = (str(i))\n           \
    \         break\n                }\n                else\n                {\n\
    \                    res = (str(i))\n                }\n            }\n      \
    \  }\n        res", "        val s = sentence.split(\" \")\n        val n = s.length\n\
    \        val result = new Array[String](n)\n        \n        for(i <- 0 until\
    \ n) {\n            val word = s(i)\n            val len = word.length\n     \
    \       \n            for(j <- 0 until len) {\n                if(word.charAt(j)\
    \ != word.charAt(len-j-1)) \n                    break\n            }\n      \
    \      \n            if(j == len) {\n                result(i) = word\n      \
    \      }\n        }\n        \n        val newResult = new mutable.ArrayBuffer[String]()\n\
    \        \n        result.foreach {\n            x =>\n            newResult +=\
    \ x\n        }\n        \n        newResult.toList.reverse", "        // Initialize\
    \ the required data\n        var maxLength : Int = 1\n        var newSentence\
    \ = \"\"\n        val wordList = sentence.split(\" \").map(_.toUpperCase).toList\n\
    \        wordList.foreach(word => {\n            // Remove all spaces from word\
    \ and check if it is prime\n            val wordWithoutSpace = word.replace(\"\
    \  \",\"\")\n            if(primeChecker.isPrime(wordWithoutSpace))\n        \
    \        // If it passes, remove the first character and add it to newSentence\
    \ string\n                newSentence += wordWithoutSpace.substring(0,1)\n   \
    \         else\n                // If it doesn't pass the check, increment the\
    \ maxLength\n                maxLength += 1\n        })\n        // If the current\
    \ maxLength is lesser than the required prime number,\n        // add the remaining\
    \ words to the newSentence and update maxLength accordingly\n        if(maxLength\
    \ < wordList.length)\n            newSentence += (wordList.dropWhile(x => !primeChecker.isPrime(x)).mkString(\"\
    \ \") + wordList.takeWhile(x => !primeChecker.isPrime(x)).mkString(\" \"))\n \
    \       else\n            newSentence", "      var result = \"\"\n      val wordsArray\
    \ = sentence.split(\" \").map( x => x.toInt )\n      wordsArray.foreach(x => {\n\
    \        if (x > 1 && x % 2 == 0 ){\n          result += \" \" + x\n        }\n\
    \      })\n      result", "      var result = \"\"\n      var primes = scala.collection.mutable.Set[Int]()\n\
    \      for(i <- 0 until sentence.lenth){\n        var word = sentence.substring(i,\
    \ i + 1)\n        var prime = scala.math.sqrt(word.length).ceil.toInt\n      \
    \  if(primes.contains(prime)){\n          result += word\n        }\n        primes\
    \ += prime\n      }\n      return result", "        var res = \"\"\n        var\
    \ prime = new mutable.Set[Int]()\n        var primeFound = false\n        for\
    \ (word <- sentence.split(\" \")) {\n            if(primeFound) {\n          \
    \      prime.add(word.length)\n            } else {\n                for (i <-\
    \ 0 until word.length-1) {\n                    if(word.charAt(i) == word.charAt(i+1))\n\
    \                        primeFound = true\n                }\n              \
    \  if(primeFound) {\n                    prime.add(word.length)\n            \
    \    }\n            }\n        }\n        var maxSize = prime(0)\n        for\
    \ (size <- prime) {\n            if(size == maxSize) {\n                maxSize\
    \ = prime(0)\n            } else {\n                maxSize = max(maxSize, size)\n\
    \            }\n        }\n        for (word <- sentence.split(\" \")) {\n   \
    \         if(primeFound) {\n                prime.remove(word.length)\n      \
    \      } else {\n                if(prime.isEmpty && maxSize == prime(0)) {\n\
    \                    res ++= word\n                }\n            }\n        }\n\
    \        res", "        val wordsLen = sentence.split(' ').length\n        val\
    \ isPrime = Primes.primesIterator.forall(i => isPrime(i))\n        val primes\
    \ = wordsLen filter (isPrime)\n        val newSentence = wordsLen map {i => sentence.substring(0,i)}\
    \ mkString \" \"\n        val primesArray = primes.toArray\n        val newArray\
    \ = newSentence.split(' ').toArray\n        primesArray.zip(newArray).map { case\
    \ (a,b) => a.concat(b) }.mkString(\" \")", "        val strArray = sentence.split(\"\
    \ \")\n        val primes = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        var index = 0\n   \
    \     var primeString = \"\"\n        while (strArray.size > 1) {\n          \
    \  for (x <- primes) {\n                val tempString = strArray(index).toString.stripPrefix(x\
    \ + \"\\t\")\n                index += 1\n                if (tempString.isPrime)\
    \ {\n                    primeString += tempString + \" \"\n                 \
    \   strArray = strArray.remove(index)\n                }\n            }\n    \
    \    }\n        return primeString.substring(0, primeString.length - 1).trim",
  "        val words = sentence.split(\" \").toList\n        val resultSet = mutable.HashSet[Int]()\n\
    \        words.foreach(x => resultSet.add(x.length))\n        words.filter(x =>\
    \ resultSet.size<=x.length).sortWith((x,y) => x<y).mkString(\" \")", "       \
    \ val wordList = sentence.split(\" \").toList\n        val primeList = wordList.filter(a\
    \ => {\n            val isPrime = isPrimeNumber(a)\n            if (isPrime) println(a\
    \ + \" is a prime number\")\n            else println(a + \" is not a prime number\"\
    )\n            isPrime\n        })\n        primeList.mkString(\" \")", "    \
    \    val list = sentence.split(\" \").toList\n        var newList = list\n   \
    \     val primes = scala.collection.mutable.ArrayBuffer(2, 3, 5, 7)\n        for\
    \ (i <- 0 to (list.length - 1)) {\n            if (primes.contains(list(i).length()))\
    \ {\n                newList = newList.filter(_ != list(i))\n                primes\
    \ = primes.filter(_ != list(i).length())\n            }\n        }\n        newList.mkString(\"\
    \ \")", "        var ret : String = \"\"\n        for(i <- 0 to (words_in_sentence(sentence).toList.length\
    \ - 1)){\n            val tmp = sentence(i).toInt\n            if(tmp == 2){\n\
    \                if(ret != \"\"){\n                    ret += \"\\n\"\n      \
    \          }\n                ret += sentence(i)\n            }\n        }\n \
    \       ret", "        val words = (sentence split \" \").filter(_.nonEmpty).map(_.toLowerCase).toSet\n\
    \        val result = scala.collection.mutable.Set()\n        for (word <- words)\
    \ {\n            if (isPrime(word)) {\n                result += word\n      \
    \      }\n        }\n        result mkString \" \"", "        val result = new\
    \ mutable.ListBuffer[String]()\n        var index = 0\n        while(index < sentence.length)\
    \ {\n            if(isPrime(sentence.length-index)) {\n                result.append(sentence.substring(index,\
    \ index+1))\n            }\n            index++\n        }\n        sentence.split('\
    \ ').foreach(x => result.append(x))\n        return sentence.split(' ').toSet.mkString(\"\
    \ \")", "        val sentenceWithWords = sentence split \" \"\n        val wordsWithLengths\
    \ = sentenceWithWords map {\n            case word => word -> length(word)\n \
    \       }\n        val result = wordsWithLengths filter { case (word, length)\
    \ => isPrime(length) } map {\n            case word => word\n        }\n     \
    \   result mkString \" \"", "        val words = sentence.split(\" \")\n     \
    \   var result = new StringBuilder\n        var i = 0\n        while (i < words.length)\
    \ {\n            val word = words(i)\n            val count = word.size / 2\n\
    \            if (count * 2 == word.size) {\n                result += \" \" +\
    \ word\n                i += 1\n            } else {\n                i += 1\n\
    \            }\n        }\n        return result.toString", "        // TODO:\
    \ Write your code here\n        val countOfPrimes = mutable.LinkedHashMap[Int,\
    \ Int]()\n        sentence.split(\" \")\n          .map {\n            word =>\n\
    \              if (countOfPrimes.get(word) == null)\n                countOfPrimes.put(word,\
    \ 1) else\n                countOfPrimes.put(word, countOfPrimes.get(word) + 1)\n\
    \          }\n          .groupBy(word => countOfPrimes.get(word))\n          .map(grouping\
    \ => grouping.head)\n          .toArray", "        val n = sentence.toCharArray().map(_.toInt).toArray\n\
    \        var outSentence = \"\"\n        var i = 1\n        while(i <= n.length)\
    \ {\n            while(i % n[i] == 0) {\n                i = i + 1\n         \
    \   }\n            outSentence = outSentence + sentence(i - n[i])\n          \
    \  i = i + 1\n        }\n        outSentence", "        if (sentence.split(\"\
    \ \").length == 0) \"\"\n        else {\n            val wordList = sentence.split(\"\
    \ \").map(w => w.trim).toList\n            val set = new mutable.HashSet[String]()\n\
    \            var ans = \"\"\n            wordList.foreach(word => if (set.contains(word))\
    \ { ans += word + \" \" } else { set += word })\n            ans\n        }",
  "        val words = sentence.split(' ').toList\n        val result = mutable.Set[String]()\n\
    \        for((i,w) <- words.zipWithIndex) {\n            var flag = false\n  \
    \          var primeCounter = 0\n            while(w(i).length > 0) {\n      \
    \          if(primeCounter > w(i).length) {\n                    flag = true\n\
    \                    break\n                }\n                primeCounter +=\
    \ 1\n            }\n            if(flag) {\n                result.add(w(i))\n\
    \            }\n        }\n        val resultString = result.mkString(\" \")\n\
    \        return resultString", "        val sentenceSplit = sentence.split(\"\
    \ \")\n        val primeNumbers = sentenceSplit.map(x => prime(x)).toArray\n \
    \       val result = new mutable.ListBuffer[String]()\n        val result2 = new\
    \ mutable.ListBuffer[String]()\n        for (number <- primeNumbers) {\n     \
    \       var i = 0\n            while (i < sentenceSplit.length) {\n          \
    \      if (number() == sentenceSplit(i).length) {\n                    result.append(sentenceSplit(i))\n\
    \                    result2.append(number)\n                    i = i + 1\n \
    \               }\n                i = i + 1\n            }\n        }\n     \
    \   val result3 = result2.toSeq.sortWith((x,y) => x < y).mkString(\" \")\n   \
    \     result3.toString.replace(\"[\", \"\").replace(\"]\", \"\").replaceAll(\"\
    \\\\s+\", \" \")", "        var prime = BigInt(2)\n        var ret = \"\"\n  \
    \      sentence.split(\"\\\\s\").foreach(word => {\n            if (prime.isPrime)\
    \ {\n                prime = prime * BigInt(word)\n                ret += \" \"\
    \ + word\n            }\n        })\n        return ret", "        if (sentence.isEmpty)\n\
    \          return \"\"\n        var i = 0\n        var result : String = \"\"\n\
    \        var temp = sentence splitAt 1\n        while(i < temp.length) {\n   \
    \       if (i % 2 == 0) {\n            if (temp.length < 5)\n              result\
    \ += temp(i)\n            else if (!temp(i).isUpper)\n              result +=\
    \ temp(i)\n            else if (temp(i).isUpper)\n              result += temp(i)\
    \ + \" is\"\n          }\n          i += 2\n        }\n        result", "    \
    \  var str = \"\"\n      var isPrime = true\n      for ((x <- 0 to (sentence.count-1)/2)\
    \ if (isPrime) yield {\n        str += sentence(x).toChar\n      }\n      (str).toChar",
  "        var newString = \"\"\n        var counter = 1\n        var length = sentence.length\n\
    \        for (i <- 0 until length){\n            if (sentence.charAt(i) == \"\
    \ \"){\n                for (j <- 0 until counter){\n                    newString\
    \ += sentence.charAt(j)\n                }\n                counter = 1\n    \
    \        } else {\n                counter += 1\n            }\n        }\n  \
    \      newString += newString + \" \" + sentence\n        println(newString)\n\
    \        newString", "        val words = sentence.split(\"\\\\s+\").toList\n\
    \        val primeList: MutableList[String] = new mutable.MutableList[String]()\n\
    \        words.foreach(x => {\n            if (x.isPrime) primeList += x\n   \
    \     })\n        primeList.toList.sorted.mkString(\" \")", "        // Write\
    \ your code here\n        val sentence1 = sentence.split(\"\\\\s+\").toList\n\
    \        val primes = scala.collection.mutable.ArrayBuffer.empty[Int]\n      \
    \  for(i <- 1 to sentence1.length) {\n            val n = sentence1(i)\n     \
    \       if(primes.contains(n)) {\n                primes += n\n            }\n\
    \        }\n        val sortedPrimes = primes.sort\n        val resString = sortedPrimes.mkString(\"\
    \ \")\n        return resString", "        var primeWords = mutable.Map[Int, String]()\n\
    \        for (word <- sentence.split(' ')) {\n            val length = word.length\n\
    \            if (primeWords.contains(length)) {\n                val primeWord\
    \ = primeWords(length)\n                primeWords(length) = (primeWord + \",\
    \ \" + word)\n            } else {\n                primeWords(length) = word\n\
    \            }\n        }\n        val wordList = primeWords.values.mkString(\"\
    \ \")\n        if (wordList == sentence) {\n            return sentence\n    \
    \    }\n        wordsInSentence(wordList)", "        def isPrime(n : Int) : Boolean\
    \ = n % 1 == 0 && !(math.sqrt(n) % 1 == 0)\n        var result = \"\"\n      \
    \  for (i <- 1 until sentence.length) if (!(isPrime(i) && sentence.charAt(i) !=\
    \ ' ')) {\n            result += sentence.charAt(i)\n        }\n        return\
    \ result", "        var result = new scala.collection.mutable.StringBuilder\n\
    \        for (word <- sentence.split(\" \").toList) {\n            val prime =\
    \ word.forall(_.forall(_.isPrime))\n            if (prime == false) {\n      \
    \          result.append(\"NO\")\n            } else {\n                result.append(\"\
    YES\")\n            }\n        }\n        result.toString", "        val nums\
    \ = new mutable.HashSet[Int]()\n        val resultStr : List[String] = ListBuffer[String]()\n\
    \        sentence.split(\" \").foreach(word => {\n            val num: Int = if\
    \ (word.length > 1) word.length else 1\n            val result: Int = math.sqrt(num)\n\
    \            while (nums.contains(result)) {\n                result = result+1\n\
    \            }\n            nums += result\n            resultStr += word + \"\
    \ \"\n        })\n        resultStr.toList.reverse.mkString(\" \")", "       \
    \ val words = sentence.split(\" \")\n        val length = words.map( word => word.length\
    \ ).toSeq.sortBy( _ * -1 )\n        var res = \"\"\n        var j = 0\n      \
    \  for(i <- 0 to length.length){\n            if(length(i) == 2){\n          \
    \      j += 1\n            }\n            if(j == length.length){\n          \
    \      res += words(i)\n                j = 0\n            }\n        }\n    \
    \    return res", "        val chars = sentence.split(\" \").map(_.toUpperCase).toArray\n\
    \        val primes = primesOfLengths(chars.takeRight(chars.length)).toArray\n\
    \        val primesMapped = primes.map(primesOfLengths(_).toList)\n        val\
    \ result = chars.map(c => primesMapped.map(p => c if p == c else c)).mkString(\"\
    \ \")\n        result", "        val s = sentence.split(\"\\\\s+\").filter(_.matches(\"\
    [A-Za-z]+\"))\n        val n = s.length\n        val m = collection.mutable.ArrayBuffer(s.head)\n\
    \        for (i <- 1 until n by 2) {\n            if (s.last == s(i)) {\n    \
    \            m += s(i); s(i) = Nil\n            } else {\n                m +=\
    \ s(i); s(i) = s(i - 1)\n            }\n        }\n        m.toList.reverse.mkString(\"\
    \ \")", "        val numPrimes : mutable.MutableSet[Int] = new mutable.MutableSet[Int]()\n\
    \        for(i <- 0 to 100){\n            if(isPrime(i)){\n                numPrimes.add(i)\n\
    \            }\n        }\n        val result = new StringBuilder()\n        for(i\
    \ <- 0 to 100){\n            val newWords = sentence.split(\" \").filter( w =>\
    \ numPrimes.contains(w.length)).toSeq\n            result.append((newWords.sorted.mkString(\"\
    \ \")))\n        }\n        return result.toString()", "        if (sentence.isEmpty)\
    \ \"\"\n        else if (sentence.length == 1) (sentence.head + \" \")\n     \
    \   else primes.find(_._1 == sentence.length).map(_._2).map(_ + \" \")", "   \
    \     val chars = sentence.split(\" \")\n        val lens = chars.map(_.length)\n\
    \        val primes = lens.filter(n => {\n            var flag = true\n      \
    \      var i = 2\n            while(i <= Math.sqrt(n)) {\n                if((n\
    \ % i) == 0) {\n                    flag = false\n                }\n        \
    \        i += 1\n            }\n            flag\n        }).toSeq\n        val\
    \ re = s\"^${primes.mkString(\" \")}$\"\n        val result = sentence.replaceAll(re,\
    \ \"\")\n        result", "        val words = sentence.split(\" \")\n       \
    \ val result = new Array[String](0)\n        // let us store the length into a\
    \ map\n        val map = new mutable.HashMap[Int, String]()\n        for (word\
    \ <- words){\n            val key = word.length\n            map.put(key, word)\n\
    \        }\n        for(i <- map.keySet){\n            if (map.get(i).length %\
    \ 2 != 0){\n                continue\n            }\n            if (map.get(i).length\
    \ % 2 == 0){\n                result += map.get(i).toString.split(\" \")\n   \
    \         }\n        }\n        return result.mkString(\" \")", "        // write\
    \ your code here\n        val n = sentence.length\n        var s = \"\"\n    \
    \    var i = 0\n        for(i<n){\n            if(sentence.charAt(i) == ' ') {\n\
    \                while(i < n){\n                    s += sentence.charAt(i)\n\
    \                    i += 1\n                }\n                i = i + 1\n  \
    \          }\n        }\n        return s", "        val wordsArr: List[String]\
    \ = sentence.toList\n        val primeNumbers : List[Int] = List.fill(wordsArr.length)(2)\n\
    \        val uniquePrimeNumbers : List[Int] = new mutable.LinkedList[Int]()\n\n\
    \        val primeNumbersList : mutable.MutableList[Int] = new mutable.MutableList[Int]()\n\
    \        primeNumbersList.addAll(primeNumbers)\n\n        for(i <- 0 until wordsArr.length)\n\
    \            primeNumbersList.removeAll(primeNumbers.filter(_ % i == 0))\n\n \
    \       uniquePrimeNumbers.addAll(primeNumbersList)\n\n        val uniquePrimeWords\
    \ : List[String] = uniquePrimeNumbers.map((_ - 1)).filter(_ % 2 == 0).map {\n\
    \            i => wordsArr(i).replaceAll(\" \", \"\")\n        }.distinct().sorted\n\
    \n        uniquePrimeWords.mkString(\" \")", "        var result : String = \"\
    \";\n        val splittedSentence = sentence.split(\" \")\n        for (i <- splittedSentence.indices)\
    \ {\n            val length = splittedSentence(i).length\n            if (length\
    \ == 1 && isPrime(length)) {\n                result += splittedSentence(i)\n\
    \            }\n        }\n        result", "        val chars = sentence.split(\"\
    \ \").map(_.toUpperCase()).map(_.toString)\n        val map = chars.groupBy(c\
    \ => c.length).map {\n            case (k,v) => k -> v.map(c => c.toUpperCase).mkString(\"\
    \ \")\n        }\n        map.values.map(_.mkString(\" \")).mkString(\" \")",
  "        val str = sentence.split(\" \")\n        val primes = primes(str.length)\n\
    \        val newStr = str.filter(word => primes.contains(word.length))\n     \
    \   val words = new StringBuilder()\n        newStr.foreach(words += _ + \" \"\
    )\n        words.toString", "        val strs = sentence.split(\" \") //split\
    \ by whitespace\n        val primes = mutable.ListBuffer[Int]()\n        strs.foreach\
    \ { str =>\n            val n = str.length //get length\n            for (x <-\
    \ 2 to n) {\n                if (str.length % x == 0) primes.append(x) //primes\n\
    \            }\n        }\n        strs.map { str => primes.filter(x => str.length\
    \ % x == 0).mkString(\" \") }.mkString(\" \")", "        var result = \"\"\n \
    \       for(word <- sentence.split(' ')) {\n            var length = 3\n     \
    \       var index = false\n            for(i<- word.length.toInt;i>length;i--)\
    \ {\n                if(word.charAt(length-1) == word.charAt(length-2) && length\
    \ != 0) {\n                    length = length-1\n                }\n        \
    \        if(length == 0) {\n                    index = true\n               \
    \     length = i\n                }\n            }\n            if(index) result\
    \ = result + word\n        }\n        return result", "        if (sentence.length\
    \ <= 1)\n            return sentence\n        def isPrime(i : Int) : Boolean =\
    \ {\n            var flag = true\n            for (i.toInt <= 0 && (flag = true);\
    \ i > 0; i = i - 2)\n                if (i % 2 == 0)\n                    flag\
    \ = false\n            flag\n        }\n        def find(i : Int) : Unit = {\n\
    \            if (i == 0)\n                return\n            if (isPrime(i))\n\
    \                find(i - 1)\n            else {\n                val (head,tail)\
    \ = sentence.splitAt(i)\n                find(i-1)\n                for (i <-\
    \ 0 until tail.length)\n                    find(i + 1)\n                head\
    \ + tail\n            }\n        }\n        find(sentence.length - 1)", "    \
    \    var output : List[String] = Nil\n        var tempString : String = \"\"\n\
    \        var lastWordIndex = 0\n        var lastPrimeLength : Int = 0\n      \
    \  var currentPrimeLength : Int = 0\n        var isPrime : Boolean = true\n  \
    \      for (word <- sentence.split(\" \")) {\n            val length = word.length\n\
    \            val lastIndex = lastWordIndex\n            if (isPrime) {\n     \
    \           tempString += word + \" \";\n                if (length == lastPrimeLength)\
    \ {\n                    output += tempString\n                    tempString\
    \ = \"\"\n                }\n            } else if (length <= 3) {\n         \
    \       output += tempString\n                tempString = \"\"\n            }\
    \ else {\n                lastPrimeLength = length\n            }\n          \
    \  currentPrimeLength = lastPrimeLength\n            isPrime = length.isPrime\n\
    \            lastWordIndex = lastIndex + 1 \n        }\n        output += tempString\n\
    \        output.mkString(\" \")", "        val words = sentence.split(' ')\n \
    \       val primeWords = primeFactorization(words.size)\n        val newWords\
    \ = words.map(x => (x.toUpperCase()))\n            .filter(x => primeWords.contains(primeFactorization(x)))\n\
    \        val sortedNewWords = newWords.sortBy(x => x.toUpperCase)\n        sortedNewWords.mkString(\"\
    \ \")", "        val wordsList = sentence.split(\" \").toList\n        val wordsSortedList\
    \ = wordsList.sorted\n        val primes = List(2,3,5,7,11,13,17,19,23,29)\n \
    \       val primeList = primes.filter(x => wordsSortedList.contains(x) && x >\
    \ 1).sortWith(_ < _)\n        val newList = primeList.toList.flatMap(x => wordsList.toList.filter(w\
    \ => w.length == x).toList).toList.mkString(\" \")\n        newList", "      \
    \  val lengths = sentence.split(\" \").toSet.toList.map(_.length).toList\n   \
    \     lengths.forall(_ == lengths.max)", "        val sentences = sentence.split(\"\
    \ \").toList\n        val primes = sentences.map(x => x.length)\n        primes.toList.sortBy(_).reverse.mkString(\"\
    \ \")", "        var res = \"\"\n        var count = 1\n        var charSet =\
    \ mutable.Set.empty[Char]\n        for (c <- sentence) {\n            if (!charSet.contains(c))\
    \ {\n                charSet += c\n                res += c.toString\n       \
    \     }\n            count += c.length\n            if (count >= 2) {\n      \
    \          res += \" \"\n                count = 1\n            }\n        }\n\
    \        return res.trim", "        val words: List[String] = sentence.split('\
    \ ').filter(_.nonEmpty)\n        if (words.length == 1 || words.length == 0)\n\
    \            return \"\"\n        val primes = List(1, 3)\n        var result\
    \ = \"\"\n        for (str <- words) {\n            val num = (str.length).toInt\n\
    \            var prime = true\n            for (i <- primes) {\n             \
    \   if (num % i == 0) {\n                    prime = false\n                 \
    \   break\n                }\n            }\n            if (prime)\n        \
    \        result += (str)\n        }\n        result", "        var wordList =\
    \ new mutable.LinkedList[String]()\n        var output = new StringBuilder\n \
    \       var currentWord = \"\"\n        var prime = 0\n        var i = 0\n   \
    \     for (i<- sentence.length){\n            if (sentence.charAt(i) == ' ') {\n\
    \                prime = true\n                currentWord = currentWord.toString.trim\n\
    \                if (prime == 1) {\n                    wordList.add(currentWord)\n\
    \                }\n                wordList.clear()\n                prime =\
    \ false\n                currentWord = \"\"\n            }\n            else if\
    \ (sentence.charAt(i) == '\"'){\n                output.append (currentWord)\n\
    \                currentWord = \"\"\n            }\n            else {\n     \
    \           currentWord = currentWord.toString + sentence.charAt(i)\n        \
    \    }\n        }\n        return output.append (currentWord).toString", "   \
    \     if(sentence.isEmpty) {\n            return \"\"\n        }\n        val\
    \ words = sentence.split(\" \").map(w => w.trim)\n        val primes = words.map(w\
    \ => (w.length)).filter(w => w.isPrime)\n        val newWords = words.filter(w\
    \ => primes.contains(w.length))\n        val res =\n            if(words.size==1)\
    \ \"\"\n            else {\n                val first = primes.head\n        \
    \        val rest = primes.tail\n                val combined = rest.zip(newWords).map{\
    \ case (r,w) => r+w }.mkString(\" \")\n                val rest2 = rest.map(w\
    \ => \" \" + w).mkString(\" \")\n                combined + rest2\n          \
    \  }\n        res", "        val sentenceArray = sentence.split(\" \").toArray\n\
    \        val resultArray = new StringBuilder()\n        var i = 0\n        while\
    \ (i < sentenceArray.length-1) {\n            var flag = true\n            for\
    \ (a <- 1 to sentenceArray(i).length) {\n                if (math.gcd(sentenceArray(i).length,\
    \ a) != 1) {\n                    flag = false\n                    break\n  \
    \              }\n            }\n            if (!flag) {\n                break\n\
    \            }\n            resultArray.append(sentenceArray(i))\n           \
    \ resultArray.append(\" \")\n            i += 1\n        }\n        resultArray.toString()",
  "        var rec : String = sentence\n        var prime : Boolean = true\n     \
    \   while(prime) {\n            rec = removePrimes(rec)\n            prime = rec.length\
    \ < 2\n        }\n        val result = rec \n        result ", "      val words\
    \ : List[String] = sentence.split(\" \").filterNot(_.isEmpty)\n      val isPrime\
    \ : HashSet[Int] = HashSet(2 to (math.sqrt(words.length.toDouble) + 1))\n    \
    \  val result : List[String] = words.filter(i => (isPrime(i) && result.contains(i)))\n\
    \      result.mkString(\" \")", "        val m = sentence.split(\"\\\\s\").map\
    \ { word => word.length }.max\n        sentence.split(\"\\\\s\").flatMap{ word\
    \ => word.map(x => if(x == 1) 1 else if (x%2==0) 2 else x).filter(x => x == m).map(x\
    \ => word)", "        val ls = sentence.split(\" \").map(_.toChar).toList\n  \
    \      val s = ls.map(x => if (x.isPrime) x.toString else x).toList\n        ls\
    \ diff s", "        // Write your code here.\n        val result = new ListBuffer[String]()\n\
    \        for(i <- 1 to sentence.length) yield {\n            val temp = sentence.substring(0,i)\n\
    \            val checker = PrimeNumbers.find(s => temp.length == s.length && temp.substring(1,temp.length)\
    \ == s)\n            if(checker == None) yield temp\n            else yield \"\
    \"\n        }\n        val string = new StringBuilder()\n        for(i <- 0 to\
    \ result.size - 1) string.append(result(i))\n        string.toString", "     \
    \   var str : String = sentence\n        val set = scala.collection.mutable.Set[Int]()\n\
    \        var str2 :String = \"\"\n        var index = 0\n        while (index\
    \ != str.length){\n            if (set.contains(str.charAt(index))){\n       \
    \         index = str.charAt(index).toInt\n                index += 1\n      \
    \          while (set.contains(str.charAt(index))){\n                    str =\
    \ str + str.charAt(index)\n                    index += 1\n                }\n\
    \            }else{\n                index+=1\n                set.add(str.charAt(index))\n\
    \            }\n        }\n        while (str.charAt(0) != ''){\n            str\
    \ += str.charAt(0)\n        }\n        while (str.charAt(str.length-1) != ''){\n\
    \            str += str.charAt(str.length-1)\n        }\n        str2", "    \
    \    val map = new mutable.HashMap[Int, String]()\n        for (i <- 0 until sentence.length)\n\
    \            if (map.contains(sentence(i).length))\n                map(sentence(i).length)\
    \ = sentence(i)\n            else\n                map.put(sentence(i).length,\
    \ sentence(i))\n        return map.values.mkString(\" \")", "        var result\
    \ : String = \"\";\n        var primes = scala.collection.mutable.ListBuffer[Int]();\n\
    \        var wordsLength : Int = 0;\n        sentence.split(\" \").foreach(word\
    \ => {\n            var tmpPrimeNumbers = scala.collection.mutable.ListBuffer[Int]();\n\
    \            primeNumbersUtil(word, primes, tmpPrimeNumbers, wordsLength);\n \
    \           primes = primes ++ tmpPrimeNumbers;\n            wordsLength += tmpPrimeNumbers.size;\n\
    \        });\n        result +=  primes.toList.mkString(\" \");\n        \n  \
    \      \n        \n        return result;", "        val chars = sentence.split(\"\
    \ \").map(_.toUpperCase).toList\n        val primes = chars.map(x => isPrime(x)).toSet\n\
    \        val result = chars.filter(x => primes.contains(x))\n        result.toList.mkString(\"\
    \ \")", "      var res = \"\"\n      val length = scala.util.Random.nextInt(10)\
    \ + 1\n      val nums = scala.util.Random.nextInt(10) + 1\n      val numsPrime\
    \ = scala.util.Random.nextInt(nums)\n      val newWords = scala.util.Random.nextInt(length)\
    \ + 1 // number of words in sentence\n      val numsPrimeWords = newWords // number\
    \ of prime words in sentence\n      def primeFactors(n: Int) : List[Int] = {\n\
    \        var factors = List[Int]()\n        for (i <- 1 until n) {\n         \
    \ if (n % i == 0) {\n            factors :+= i\n          }\n        }\n     \
    \   return factors\n      }\n      val primeFactorsWords = primeFactors(length)\
    \ // number of prime factors for each word\n      for (i <- 1 until length) {\
    \ // for each word in sentence\n        var foundPrime = true\n        while (foundPrime)\
    \ {\n          val isPrime = scala.util.Random.nextInt(primeFactorsWords.size)\n\
    \          if (primeFactorsWords(isPrime) != numsPrime) {\n            foundPrime\
    \ = false\n          }\n        }\n        val wordsToAdd = scala.util.Random.nextInt(newWords)\
    \ + 1\n        res += sentence(i) + \" \" + words(numsPrimeWords, newWords, wordsToAdd)\n\
    \      }\n      res", "        val chars = sentence.split(\" \").map(_.toChar).mkString(\"\
    \")\n        val nums = chars.map(x => if(x != 'i') x^4 else x^6)\n        val\
    \ primes = nums.filter(_ % 2 != 0).takeWhile(_ < 1000)\n        val words2 = chars.filter(_\
    \ != 'i').filter(_ != 'e').filter(_ != 'e').filter(_ != 'i').filter(_ != 'o').filter(_\
    \ != 'u').filter(_ != 'y').takeWhile(_ < 1000)\n        primes.zip(words2).flatMap(x\
    \ => x).toList.toString()", '        sentence.split("\\s+").map(_.length).filter(_.isPrime).sortBy(_.toInt)',
  "        var primes = List(2,3,5,7,11,13,17,19)\n        val str = sentence.split(\"\
    \ \").filter(_ != \" \")\n        val str = str.map{_.toUpper}\n        str.map(s\
    \ => {\n            val prime = primes.find(p => p*p < s.length)\n           \
    \ if (prime == -1) primes += prime\n            else primes.remove(prime)\n  \
    \          prime\n        }).filter(prime => primes.contains(prime)).mkString(\"\
    \ \")", "        var words = mutable.Set[String]()\n        for (i <- 0 until\
    \ sentence.length) {\n            val currentChar = sentence(i)\n            if\
    \ (isLetter(currentChar)) {\n                words ++= sentence.substring(0, i).split(\"\
    \ \")\n            }\n        }\n        val result: mutable.ListBuffer[String]\
    \ = new mutable.ListBuffer[String]()\n        val maxLength = Math.ceil(Math.sqrt(words.size))\n\
    \        words.forall { x =>\n            val length = x.length\n            if\
    \ (length <= maxLength && isPrime(length)) {\n                result.add(x)\n\
    \            }\n        }\n        result.toList.reverse.mkString(\" \")", " \
    \       val splitSentence = sentence.split(\" \")\n        val primes = splitSentence.filter\
    \ { x => x.isPrime }\n        val result = splitSentence.filterNot(x => primes.contains(x))\n\
    \        result.sortBy(x => x).mkString(\" \")", "        val result = new collection.mutable.ListBuffer[String]()\n\
    \        for (word <- sentence.split(\" \"))\n            if (prime(word.length)\
    \ == 1)\n                result += word\n        result.toString()", "       \
    \ val newWordsList = new mutable.LinkedList[String]()\n        for (i<-0 to (len(sentence)-1)){\n\
    \            if (isPrime(sentence(i))){\n                newWordsList.add(sentence(i))\n\
    \            }\n        }\n        return newWordsList.toList.sorted.mkString(\"\
    \ \")", "        val m = sentence.count(' ')\n        var result = \"\"\n    \
    \    var i = 0\n        val primes = mutable.ListBuffer[Int]()\n        while(i\
    \ < m) {\n            if(primes.contains(sentence(i).length))\n            primes\
    \ += sentence(i).length\n            i += 1\n        }\n        var j = 0\n  \
    \      while(j < primes.length) {\n            result += \" \" + sentence.split(\"\
    \ \").filter(x => x.size == primes(j))(0)\n            j += 1\n        }\n   \
    \     result", "        val arr = sentence.split(\" \").map(_.toInt).toArray\n\
    \        val l = arr.length\n        val isPrime = (0 until l).filter(_ => arr(_)\
    \ % 2 == 0).forall(!arr.contains)\n        if (l == 0) {\n            \"\"\n \
    \       }\n        val newArr = arr.filterNot(_ % 2 == 0)\n        var result\
    \ = \"\"\n        val newArrLen = newArr.length\n        for (i<-0 until newArrLen){\n\
    \            result += newArr(i) + \" \" //add it back\n        }\n        return\
    \ result", "        val words = sentence.split(' ').toArray\n        val wordsLength\
    \ = words.length\n        var primes = scala.collection.mutable.ArrayBuffer(2,3,5,7,11,13,17)\n\
    \        var primeCounter = primes.count(_ == wordsLength)\n        var newString\
    \ = new StringBuilder\n        var newWord = \"\"\n        for(word <- words)\
    \ {\n            val len = word.length\n            val isPrime = primes.contains(len)\n\
    \            if(isPrime) {\n                primeCounter -= 1\n              \
    \  primes.clear()\n                primes.+=primes.last+2\n                primeCounter\
    \ -= 1\n                if(primeCounter == 0) newString += word + \" \" \n   \
    \             primeCounter += 1\n            } else {\n                newWord\
    \ += word + \" \" \n            }\n        }\n        return newString", "   \
    \     sentence.split(\" \").map(word => primeFactors(word.length)).toSet.toList\n\
    \            .map(x => \" \" + x.mkString(\" \")).mkString(\" \")", "        var\
    \ ans = \"\"\n        for (word <- sentence.split(\"\\\\s+\")) {\n           \
    \ val len = word.length\n            val num = PrimeNumber(len)\n            val\
    \ str1 = ans + word + \" \"\n            if (num < len) ans = str1\n        }\n\
    \        ans"]
stop_tokens:
- "\n    }\n"
