name: HumanEval_154_cycpattern_check
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given 2 words. You need to return true if the second word or any\
  \ of its rotations is a substring in the first word\n    // >>> cycpatternCheck((\"\
  abcd\"), (\"abd\"))\n    // (false)\n    // >>> cycpatternCheck((\"hello\"), (\"\
  ell\"))\n    // (true)\n    // >>> cycpatternCheck((\"whassup\"), (\"psus\"))\n\
  \    // (false)\n    // >>> cycpatternCheck((\"abab\"), (\"baa\"))\n    // (true)\n\
  \    // >>> cycpatternCheck((\"efef\"), (\"eeff\"))\n    // (false)\n    // >>>\
  \ cycpatternCheck((\"himenss\"), (\"simen\"))\n    // (true)\n    def cycpatternCheck(a\
  \ : String, b : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"\
  xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\"\
  )) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n\
  \    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"\
  abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"\
  tinem\")) == (true));\n    }\n\n}\n"
completions: ["        var pattern = b\n        var subString = a\n        var count\
    \ = 1\n        while ( pattern.length > subString.length ) {\n            pattern\
    \ = pattern.substring(0,pattern.length-1)\n            subString = subString.substring(0,subString.length-1)\n\
    \            count = count + 1\n        }\n        // print (subString,pattern)\n\
    \        count > 0 && (subString contains pattern) || !( subString.contains(pattern)\
    \ || cycpatternCheck(subString,subString.replaceFirst(pattern,\"\")))", "    \
    \    var ans = false\n        for (x <- b.reverse) {\n            if(b.contains(x)){\n\
    \                ans = true\n                break\n            }\n        }\n\
    \        ans &&\n            a.forall(!b.contains(_))", '        a.forall(x.contains(b)
    || b.contains(x))', "        var i = -1\n        var j = -1\n        var isMatch\
    \ = false\n        a.zip(b).foreach {\n            case (an, bn) => {\n      \
    \          i = i + 1 if (an == bn)\n                j = j + 1 if (an == bn.reverse)\n\
    \            }\n        }\n        if ((i == 0) || (j == 0)) isMatch = false\n\
    \        else {\n            isMatch = b.contains(a.substring(i + 1, j)) || (b.contains(a.substring(i\
    \ - 1, j)))\n        }\n        isMatch", "        val aSet = mutable.Set[String]()\n\
    \        val bSet = mutable.Set[String]()\n        val aSetIter = a.iterator\n\
    \        val bSetIter = b.iterator\n\n        while(aSetIter.hasNext && bSetIter.hasNext)\
    \ {\n            aSet.add(aSetIter.next())\n            bSet.add(bSetIter.next())\n\
    \        }\n\n        a.toSet.subsetOf(b).toSet", "        val list = a.toList\
    \ + b.toList\n        val result = new Array[Boolean](list.length)\n        list.zipWithIndex.foreach\
    \ {\n            case (word, idx) => {\n                val charSet = word.filter(_\
    \ != ' ')\n                val set = new HashSet[Char](charSet.toList)\n     \
    \           val charSetCopy = charSet.toList\n                val setCopy = new\
    \ HashSet[Char](charSetCopy.toList)\n                var result = false\n    \
    \            for( i <- 0 until list.size) {\n                    var tempCharSetCopy\
    \ = charSetCopy\n                    var tempSetCopy = setCopy\n             \
    \       var temp = idx\n                    var found = false\n              \
    \      while(!found && temp >= 0) {\n                        val found = charSet.contains(tempSetCopy)\n\
    \                        tempSetCopy -= 1\n                        tempCharSetCopy.remove(tempSetCopy)\n\
    \                        temp -= 1\n                    }\n                  \
    \  if(found)\n                        result = true\n                    if(!found\
    \ && temp >= 0) {\n                        val found = charSet.contains(tempCharSetCopy)\n\
    \                        tempCharSetCopy -= 1\n                        tempSetCopy.remove(tempCharSetCopy)\n\
    \                        temp -= 1\n                    }\n                }\n\
    \                result\n            }\n        }", "        if(b.nonEmpty) {\n\
    \            if(b.startsWith(a))\n                return true\n            else\
    \ if(a.reverse.startsWith(b)) {\n                val aList = b.split(\"\").toList\n\
    \                val bList = a.reverse.split(\"\").toList\n                aList.foreach(x\
    \ => bList match {\n                    case x :: Nil => return true\n       \
    \             case x :: xs => return false\n                    })\n         \
    \   }\n        }\n        return false", "        val a = a\n        val b = b\n\
    \        var aIndex = a.indexOf(0)\n        var bIndex = b.indexOf(0)\n      \
    \  while(\n            aIndex != -1 &&\n            bIndex != -1 &&\n        \
    \    b.substring(bIndex, bIndex + aIndex + 1) contains a.substring(aIndex + 1,\
    \ aIndex + bIndex + 1)\n        ){\n            val aSubString = a.substring(aIndex\
    \ + 1, aIndex + bIndex + 1)\n            val bSubString = b.substring(bIndex +\
    \ 1, bIndex + aIndex + 1)\n            val aIndex = a.indexOf(aSubString, aIndex\
    \ + aSubString.length)\n            val bIndex = b.indexOf(bSubString, bIndex\
    \ + bSubString.length)\n        }\n        true", '        a.toList intersect
    b.toList exists (_.indexOf(b) > -1)', '      a contains b', "        val firstWord\
    \ = a\n        val secondWord = b\n        var isCyclic = false\n        var newWord\
    \ = firstWord\n        val chars = firstWord.split(\"\").toList\n        val index1\
    \ = chars.indexOf(secondWord(0))\n        val index2 = chars.indexOf(secondWord(1))\n\
    \        while (index1 > -1 && index2 > -1) {\n            val newChar = secondWord(0)\
    \ //copy the char\n            chars.updated(index1, newChar)\n            chars.updated(index2,\
    \ newChar)\n            if (chars.toList.contains(firstWord)) {\n            \
    \    isCyclic = true\n            }\n            index1 = index1 - 1 //update\
    \ index\n            index2 = index2 - 1 //update index\n        }\n        isCyclic\
    \ && newWord.equals(firstWord)", "        // first find the position of a in b\n\
    \        var pos = b.indexOf(a)\n        if (pos < 0) return false\n        //\
    \ if b is found at the start of a then return true\n        if (pos == 0) return\
    \ true\n        // otherwise check if the b is found at the start of a with every\
    \ rotation of a\n        var rotated_pos = 0\n        while (pos >= rotated_pos)\
    \ {\n            rotated_pos += a.length\n            pos = b.indexOf(a, rotated_pos)\n\
    \        }\n        // if the first rotated pos is not found then return false\n\
    \        if (pos < 0) return false\n        // if the rotated pos is greater than\
    \ the length of b, then return false\n        if (pos > b.length) return false\n\
    \        // otherwise check if the b is found at the end of a with every rotation\
    \ of a\n        rotated_pos = 0\n        while (pos < b.length) {\n          \
    \  rotated_pos += a.length\n            pos = b.indexOf(a, rotated_pos)\n    \
    \    }\n        // if the last rotated pos is not found then return false\n  \
    \      if (pos < 0) return false\n        // if the rotated pos is greater than\
    \ the length of b, then return false\n        if (pos > b.length) return false\n\
    \        // otherwise return true\n        return true", "        val aa = a.toUpperCase()\n\
    \        val bb = b.toUpperCase()\n        val pattern = mutable.Set(aa ++ bb)\n\
    \        val l = aa.length\n        val r = b.length\n        var inStr = \"\"\
    \n        var startIndex = 0\n        var flag = false\n        for(i <- 0 until\
    \ l) {\n            val pos = aa.indexOf(l, i)\n            val temp = aa\n  \
    \          aa = bb\n            bb = temp\n            inStr = aa + bb\n     \
    \       for(j <- 0 until r) {\n                val pos2 = aa.indexOf(l, j)\n \
    \               val temp2 = aa\n                aa = bb\n                bb =\
    \ temp2\n                val flag = inStr.contains(aa)\n                if(!flag\
    \ && pos2 == 0 && !flag) {\n                    startIndex = pos\n           \
    \         flag = true\n                    break\n                }\n        \
    \        if(!flag && pos2 == 0 && flag) {\n                    startIndex = pos\n\
    \                    flag = true\n                    break\n                }\n\
    \            }\n            if(!flag) {\n                break\n            }\n\
    \        }\n        flag", "        val result = new mutable.HashSet[Char]()\n\
    \        var i = 0\n        var j = 0\n        var len = 0\n        while (i <\
    \ a.length || j < b.length) {\n            if (a.length == 0 || b.length == 0)\
    \ {\n                return(false)\n            }\n            if (i == a.length)\
    \ {\n                len += b.length\n                if (len > b.length) {\n\
    \                    return(false)\n                }\n                if (b.toString.contains(b.substring(0,\
    \ len))) {\n                    result.addAll(b.toString.substring(len))\n   \
    \             }\n                return(true)\n            }\n            if (b.length\
    \ == 0) {\n                return(true)\n            }\n            if (j == b.length)\
    \ {\n                len += a.length\n                if (len > a.length) {\n\
    \                    return(false)\n                }\n                if (a.toString.contains(a.substring(0,\
    \ len))) {\n                    result.addAll(a.toString.substring(len))\n   \
    \             }\n                return(true)\n            }\n\n            if\
    \ (a.charAt(i) == b.charAt(j)) {\n                len += 1 // increment by 1\n\
    \                i += 1\n                j += 1\n            } else if (a.charAt(i)\
    \ < b.charAt(j)) {\n                i += 1\n                len += 1 // increment\
    \ by 1\n                j += 1\n            } else if (a.charAt(i) > b.charAt(j))\
    \ {\n                j += 1\n                len += 1 // increment by 1\n    \
    \            i += 1\n            } else {\n                i += 1\n          \
    \      j += 1\n                len += 1\n            }\n        }\n        return(true)",
  "        var a = a.toUpperCase()\n        var b = b.toUpperCase()\n        val result\
    \ = new mutable.ListBuffer[Boolean]()\n        def isRotation(str : String, startIndex\
    \ : Int, endIndex : Int) : Boolean = \n        for(i <- 0 until str.length if\
    \ startIndex <= i && i < endIndex) \n            if(str.charAt(i) == str.charAt(endIndex\
    \ - (i + 1)) && \n              str.charAt(startIndex + i) == str.charAt(endIndex\
    \ - (startIndex + i))) \n                return true\n        val aStr = a.toLowerCase\
    \ \n        val bStr = b.toLowerCase \n        def check(bStr : String, aStr :\
    \ String) : Boolean = {\n            val abSet = new mutable.HashSet[String]()\n\
    \            for(i <- 0 until aStr.length)\n                if(abSet.contains(aStr.substring(i,\
    \ aStr.length)))\n                    return true\n                else\n    \
    \                abSet.add(aStr.substring(i, aStr.length))\n            for(i\
    \ <- 0 until bStr.length)\n                if(abSet.contains(bStr.substring(i,\
    \ bStr.length)))\n                    return true\n                else\n    \
    \                abSet.add(bStr.substring(i, bStr.length))\n            return\
    \ false\n        }\n        if(b.length < a.length)\n        {\n            result\
    \ += check(bStr,aStr) \n        }\n        else if(b.length > a.length)\n    \
    \    {\n            result += check(aStr, bStr) \n        }\n        else\n  \
    \      {\n            result += check(aStr,bStr) \n        }\n        for(i <-\
    \ 0 until result.size)\n            if(result(i))\n                return true\n\
    \        false", "        // We need to check if the word is a permutation of\
    \ the other.\n        // This could be done by checking if the string is an anagram\
    \ of another string.\n        // However, checking that one string is anagram\
    \ of another string requires \n        // sorting both strings, and that takes\
    \ O(nlogn) time complexity.\n        // So we use the modified string comparison\
    \ to find out if a word is a permutation of the other.\n        // To do this,\
    \ we concatenate both strings into a single string with delimiters \n        //\
    \ between the strings. This way, a string \"abcd\" will be represented as \"a_b_c\"\
    \n        // >>> val a = (\"abcd\".toList).mkString\n        // >>> val b = (\"\
    abd\".toList).mkString\n        // >>> val c = a.concat(b).concat(\"_\")\n   \
    \     // >>> c\n        // res14: String = a_b_c\n        // We use the delimiter\
    \ \"_\" instead of \" \" since it helps us to visualize the \n        // strings\
    \ more easily (it separates the words with underscores).\n        // We use the\
    \ regex \"_\" to identify a delimiter in our string since \n        // \"_\" is\
    \ the delimiter.\n        // Now we use the split method on the delimiter to create\
    \ a list of words.\n        // >>> c.split(\"_\")\n        // res15: List[String]\
    \ = List(a, b, c)\n        val c = a.concat(b).concat(\"_\")\n        c.split(\"\
    _\").map(_.toUpperCase).forall(_.contains(a.toUpperCase))", "        // O(|a|\
    \ + |b| + |ab| * |ba|)\n        val ab = a.indexOf(b)\n        val ba = b.indexOf(a)\n\
    \        if (ab == -1 || ba == -1)\n            false\n        else if (ab ==\
    \ ba)\n            false\n        else {\n            val ab1 = a.substring(0,\
    \ ab)\n            val ba1 = b.substring(0, ba)\n            val ab2 = a.substring(ab)\n\
    \            val ba2 = b.substring(ba)\n            if (ab1 == ba2)\n        \
    \        false\n            else {\n                val ab3 = a.substring(0, ab)\n\
    \                val ba3 = b.substring(0, ba)\n                val ab4 = a.substring(0,\
    \ ab)\n                val ba4 = b.substring(0, ba)\n                if (ab1 ==\
    \ ab2 && ab3 == ba4 && ba1 == ba2)\n                    false\n              \
    \  else {\n                    val ab5 = a.substring(0, ab)\n                \
    \    val ba5 = b.substring(0, ba)\n                    val ab6 = a.substring(0,\
    \ ab)\n                    val ba6 = b.substring(0, ba)\n                    if\
    \ (ab1 == ab2 && ab3 == ba4 && ba1 == ba2 && ab5 == ba6 && ba1 == ba5)\n     \
    \                   false\n                    else {\n                      \
    \  val ab7 = a.substring(0, ab)\n                        val ba7 = b.substring(0,\
    \ ba)\n                        val ab8 = a.substring(0, ab)\n                \
    \        val ba8 = b.substring(0, ba)\n                        if (ab1 == ab2\
    \ && ab3 == ba4 && ba1 == ba2 && ab5 == ba6 && ba1 == ba5 && ab7 == ba8 && ba1\
    \ == ba7)\n                            false\n                        else {\n\
    \                            val ab9 = a.substring(0, ab)\n                  \
    \          val ba9 = b.substring(0, ba)\n                            val ab10\
    \ = a.substring(0, ab)\n                            val ba10 = b.substring(0,\
    \ ba)\n                            if (ab1 == ab2 && ab3 == ba4 && ba1 == ba2\
    \ && ab5 == ba6 && ba1 == ba5 && ab7 == ba8 && ba1 == ba7 && ab9 == ba10 && ba1\
    \ == ba9)\n                                false\n                           \
    \ else\n                                true\n                        }\n    \
    \                }\n                }\n            }\n        }", "        val\
    \ aSet = a.toSet\n        val bSet = b.toSet\n        var i = bSet.lastIndexOf(aSet)\n\
    \        var j = aSet.lastIndexOf(bSet)\n        while(j > i) {\n            i\
    \ -= 1\n            j += 1\n            if(i != j) {\n                val subA\
    \ = a.substring(0, i)\n                val subB = b.substring(0, j)\n        \
    \        if(subA == subB || subA.intersect(subB).nonEmpty) {\n               \
    \     return true\n                }\n            }\n        }\n        return\
    \ false", "        val aArray = a.toUpperCase().toCharArray.sorted\n        val\
    \ bArray = b.toUpperCase().toCharArray.sorted\n        val charList = mutable.ListBuffer.empty[Char]\n\
    \        var i = 0\n        for(c <- aArray; k <- bArray; if(i != a.length - 1)\
    \ if(c == k) {\n            charList += c\n            i += 1\n        }\n   \
    \     charList.size.toDouble >= a.toUpperCase.split(\" \").size", "        //\
    \ Find patterns in a\n        var patterns = mutable.HashSet[String]()\n     \
    \   for (p<-a.indices){\n            var str = a.substring(p)\n            var\
    \ substr = b.substring(p)\n            if (patterns.contains(str+substr)) return\
    \ false\n            patterns += str+substr\n        }\n        // Find patterns\
    \ in b\n        var patterns2 = mutable.HashSet[String]()\n        for (p<-b.indices){\n\
    \            var str = b.substring(p)\n            var substr = a.substring(p)\n\
    \            if (patterns2.contains(str+substr)) return false\n            patterns2\
    \ += str+substr\n        }\n        // Check if all patterns in pattern are in\
    \ both a and b\n        for (p<-patterns){\n            if (!(p.contains(\"aa\"\
    ) || p.contains(\"aaa\"))) return false;\n        }\n        for (p<-patterns2){\n\
    \            if (!(p.contains(\"aa\") || p.contains(\"aaa\"))) return false;\n\
    \        }\n        return true", "        var aList = List(a)\n        var bList\
    \ = List(b)\n        var aLen = aList.length\n        var bLen = bList.length\n\
    \        var temp = \"\"\n        var found = false\n        var counter = 0\n\
    \        val aWords = mutable.ListBuffer[String]()\n        val bWords = mutable.ListBuffer[String]()\n\
    \        while(aLen != 0) {\n            aList = aList.dropRight(1)\n        \
    \    bList = bList.dropRight(1)\n        }\n        while(bLen != 0) {\n     \
    \       bList = bList.dropRight(1)\n        }\n        aList.foreach(aWord =>\
    \ aWords += aWord)\n        bList.foreach(bWord => bWords += bWord)\n        aWords.foreach(aWord\
    \ => aWords.filter(bWords contains aWord).foreach(x => {\n            aList.delete(x)\n\
    \            bList.delete(x)\n            aLen -= 1\n            bLen -= 1\n \
    \           counter += 1\n        }))\n        counter = 0\n        aWords.foreach(aWord\
    \ => {\n            bWords.filter(bWords contains aWord).foreach(x => {\n    \
    \            found = true\n                counter = 0\n            })\n     \
    \   })\n        if (counter == 0 && found == true) {\n            return true\n\
    \        }\n        return false", "        if(a.length == 0 || b.length == 0)\n\
    \            return false\n\n        val a = a.toUpperCase\n        val b = b.toUpperCase\n\
    \n        val m = a.length\n        val n = b.length\n\n        val stra = a.split(\"\
    \")\n        val strb = b.split(\"\")\n\n        var i = 0\n        var j = 0\n\
    \n        var j = 0\n        var k = 0\n        var l = 0\n\n        for(i <-\
    \ 0 until m) {\n            for(j <- 0 until n) {\n                k = i * n +\
    \ j\n                if(stra(j) == strb(k))\n                    l = true\n  \
    \          }\n        }\n\n        if(l)\n            return true\n\n        return\
    \ false", "        val aList = a.toLowerCase().toList.filter(x => !(x == '.' ||\
    \ x == '_'))\n        val bList = b.toLowerCase().toList.filter(x => !(x == '.'\
    \ || x == '_'))\n        val bList2 = b.toLowerCase().toList.reverse.filter(x\
    \ => !(x == '.' || x == '_'))\n        val bList3 = b.toLowerCase().toList.reverse.filter(x\
    \ => !(x == '.' || x == '_'))\n        val rotList = aList.zip(bList2).filter{\
    \ case(a,b) => a.length > b.length }\n        val rotList3 = aList.zip(bList3).filter{\
    \ case(a,b) => a.length > b.length }\n        val pattern = aList.exists(x =>\
    \ aList.count(y => y == x) == bList.count(y => y == x))\n        val pattern2\
    \ = aList.exists(x => aList.count(y => y == x) == bList2.count(y => y == x))\n\
    \        val pattern3 = aList.exists(x => aList.count(y => y == x) == bList3.count(y\
    \ => y == x))\n        val patternRot = aList.exists(x => aList.count(y => y ==\
    \ x) == bList.count(y => y == x))\n        val patternRot2 = aList.exists(x =>\
    \ aList.count(y => y == x) == bList2.count(y => y == x))\n        val patternRot3\
    \ = aList.exists(x => aList.count(y => y == x) == bList3.count(y => y == x))\n\
    \        val patternRotRot = aList.exists(x => aList.count(y => y == x) == bList.count(y\
    \ => y == x) && bList.count(y => y == x) == bList2.count(y => y == x) && bList3.count(y\
    \ => y == x))\n        val patternRotRot2 = aList.exists(x => aList.count(y =>\
    \ y == x) == bList.count(y => y == x) && bList2.count(y => y == x) == bList3.count(y\
    \ => y == x) && bList.count(y => y == x) == bList3.count(y => y == x))\n     \
    \   val patternRotRot3 = aList.exists(x => aList.count(y => y == x) == bList.count(y\
    \ => y == x) && bList2.count(y => y == x) == bList3.count(y => y == x) && bList.count(y\
    \ => y == x) == bList3.count(y => y == x) && bList2.count(y => y == x) == bList.count(y\
    \ => y == x))\n        val patternRotRotRot = aList.exists(x => aList.count(y\
    \ => y == x) == bList.count(y => y == ", "        val listA = a.toList.sorted\n\
    \        val listB = b.toList.sorted\n        listA.size < listB.size match {\n\
    \            case true => false //list one is longer\n            case false =>\
    \ listA.toSet.subsetOf(listB.toSet) //list 2 is a subset\n        }", "      val\
    \ x = a.replaceAll(\"\\\\s\", \"\")\n      val y = b.replaceAll(\"\\\\s\", \"\"\
    )\n      val len = a.length\n      val l1 = x.toSet\n      val l2 = y.toSet\n\
    \      val m = len\n      var count = 0\n      var aSet = a\n      var bSet =\
    \ b\n      var i = m\n      while(i != 0){\n        if(aSet.contains(bSet.subsetOf(x)))\
    \ {\n          count = count + 1\n        }\n        aSet = aSet.replace(x + \"\
    $\", \"\")\n        bSet = bSet.replace(y + \"$\", \"\")\n        i = i - 1\n\
    \      }\n      count % 2 == 0", "        a zip b map { case (x, y) =>\n     \
    \     if(x contains y)\n            true\n          else\n            cycpatternCheck(x,\
    \ y, true)\n        } filter { _ => true }.isEmpty", "        val rotators = rotators(b,\
    \ a)\n        for {\n            i <- 0 until a.length\n            j <- 0 until\
    \ b.length\n        } yield {\n            val aSub = a.substring(i, i + 1)\n\
    \            val bSub = b.substring(j, j + 1)\n            rotators(aSub, bSub).contains(i)\n\
    \        }.exists(_)", "        val l = a.length\n        val b = b.toUpperCase()\n\
    \        var i = 0\n        val r = new mutable.HashSet[String]()\n        val\
    \ c = new mutable.HashSet[String]()\n        while(i < l) {\n            val x\
    \ = a.charAt(i).toUpperCase + b.charAt(i).toUpperCase\n            val y = x.toCharArray\n\
    \            for(y <- y)\n                c += y\n            r += a.substring(0,\
    \ i) + b + a.substring(i + 1, l)\n            i += 1\n        }\n        if(r.containsAll(c)\
    \ || b.containsAll(r)) {\n            true\n        }\n        else false", " \
    \       var count = 0\n        for (x <- 1 to b.length) {\n            if (b.substring(x,\
    \ x+1) == a.substring(b, x)) {\n                count += 1\n            }\n  \
    \      }\n        count == a.length", "    val pattern = \"(\" + a + \")\" + b.substring(b.length\
    \ -1)\n    def helper(b : String, c : String) : Boolean = {\n        if (b.contains(c))\
    \ true\n        else b.take(b.length - c.length).forall(c => b.contains(c.reverse))",
  "        var i = 0\n        var j = 0\n        while (i<b.length && j<a.length)\
    \ {\n            if (b.charAt(i) ==a.charAt(j)) {\n                i+=1\n    \
    \            j+=1\n            } else if (b.charAt(i) >a.charAt(j)) {\n      \
    \          j+=1\n            } else {\n                i+=1\n            }\n \
    \       }\n        (i == b.length && j == a.length)", "        val a = a.toUpperCase\n\
    \        val b = b.toUpperCase\n        var index = a.indexOf(b) //\n        while\
    \ ( index >= 0 ) {\n            var flag = true\n            for ( i <- 0 until\
    \ index-1 ) {\n                if ( a(i) == b(i) ) {\n                    flag\
    \ = false\n                    break\n                }\n            }\n     \
    \       if ( flag ) {\n                return true\n            }\n          \
    \  index = a.indexOf(b.substring(1, index), index+1)\n        }\n        return\
    \ false", "        var firstIter = new StringIterator(a)\n        var secondIter\
    \ = new StringIterator(b)\n        var found = false\n        var i = 0\n\n  \
    \      while(firstIter.hasNext && !found) {\n            found = secondIter.hasNext\
    \ && firstIter.head == secondIter.head\n            i = i + 1\n        }\n   \
    \     found", "        var bIter = b.iterator\n        if (a.size == 0 || b.size\
    \ == 0)\n            return false\n        var bIndex = 0\n        while (bIter.hasNext)\
    \ {\n            var nextChar = a(bIndex).toChar\n            bIter.next()\n \
    \           bIndex += 1\n            if (nextChar == nextChar.toUpperCase || nextChar\
    \ == nextChar.toLowerCase || nextChar == nextChar.toDigit) {\n               \
    \ val aIter = a.iterator\n                while (aIter.hasNext) {\n          \
    \          val nextChar = aIter.next()\n                    if (nextChar == nextChar.toUpperCase\
    \ || nextChar == nextChar.toLowerCase || nextChar == nextChar.toDigit)\n     \
    \                   return false\n                }\n            }\n        }\n\
    \        true", "        val aSet = a.toSet.toList\n        val bSet = b.toSet.toList\n\
    \        if (aSet.contains(b)) true\n        else {\n            for (ai <- 1\
    \ to aSet.size)\n                if (aSet.exists(b.indexOf(ai)))\n           \
    \         true\n                else {\n                    for (bi <- 1 to bSet.size)\n\
    \                        if (bSet.exists(a.indexOf(bi)))\n                   \
    \         return true\n                }\n        }\n        false", "       \
    \ // If b is empty then we are done\n        if (b.isEmpty) true\n        // If\
    \ the first and last char of b are the same, then we know we are done\n      \
    \  else if (b == b.drop(1) && b.last == b.head) true\n        else if (!b.isEmpty)\
    \ {\n            // If any substring of b is a substring of a\n            if\
    \ (b.subsetOf(a)) cycpatternCheck(a, b)\n            // Else, if we have a rotation\
    \ of b in the first char of a\n            else cycpatternCheck(a, b.tail.head\
    \ + b.head) \n        }\n        // If b is not empty but the last char of a is\
    \ different from the first char of b then we are done\n        else if (!b.isEmpty)\
    \ {\n            // If any substring of b is a substring of a\n            if\
    \ (b.subsetOf(a)) cycpatternCheck(a, b)\n            // Else, if we have a rotation\
    \ of b in the first char of a and all the other chars of a are rotated right\n\
    \            else cycpatternCheck(a, b.head + b.tail.tail)\n        }\n      \
    \  // If b is not empty and all the chars of a are rotated right or the first\
    \ char of a is different from the last char of b\n        else if (!b.isEmpty)\
    \ {\n            // If any substring of b is a substring of a\n            if\
    \ (b.subsetOf(a)) cycpatternCheck(a, b)\n            // Else, if we have a rotation\
    \ of b in the first char of a and all the other chars of a are rotated left\n\
    \            else cycpatternCheck(a, b.head + b.tail.head)\n        }\n      \
    \  // If b is not empty and all the chars of a are rotated left\n        else\
    \ if (!b.isEmpty) {\n            // If any substring of b is a substring of a\n\
    \            if (b.subsetOf(a)) cycpatternCheck(a, b)\n            // Else, if\
    \ we have a rotation of b in the first char of a and all the other chars of a\
    \ are rotated right\n            else cycpatternCheck(a, b.head + b.tail.tail)\n\
    \        }\n        // If b is not empty but the first char of a is different\
    \ from the last char of b\n        else if (!b.isEmpty) {\n            // If any\
    \ substring of b is a substring of a\n            if (b.subsetOf(a)) cycpatternCheck(a,\
    \ b)\n            // Else, if we have a rotation of b in the first char of a and\
    \ all the other chars of a are rotated left\n            else cycpatternCheck(a,\
    \ b.head + b.tail.head)\n        }\n        // If b is not empty but the first\
    \ char of a is different from the last char of b\n        else if (!b.isEmpty)\
    \ {\n            // If any substring of b is a substring of a\n            if\
    \ (b.subsetOf(a)) cycpatternCheck(a, b)\n            // Else", "        var ab\
    \ = new collection.mutable.StringBuilder(a)\n        var bb = new collection.mutable.StringBuilder(b)\n\
    \        var bc = new collection.mutable.StringBuilder(b)\n        val n = ab.length()\n\
    \        val m = bb.length()\n        var i = 0\n        var j = 0\n        var\
    \ found = false\n\n        while(i < n && j < m) {\n            if(i == n-1 ||\
    \ j == m-1 || (a(i) == b(j))) {\n                ab.replace(i, i+1, b(j))\n  \
    \              bc.insert(j, a(i))\n                found = true\n            \
    \    i = i + 1\n                j = j + 1\n            }\n            else {\n\
    \                if(ab.charAt(i) == bb.charAt(j)) {\n                    ab.replace(i,\
    \ i+1, b(j))\n                    bc.insert(j, bb.charAt(i))\n               \
    \     i = i + 1\n                    j = j + 1\n                }\n          \
    \      else {\n                    if(i == n-1 && a(i) == b(j)) {\n          \
    \              ab.replace(i, i+1, b(j))\n                        bc.insert(j,\
    \ bb.charAt(i))\n                        found = true\n                      \
    \  i = i + 1\n                        j = j + 1\n                    }\n     \
    \               else {\n                        if(bb.charAt(j) == a(i)) {\n \
    \                           ab.replace(i, i+1, b(j))\n                       \
    \     bc.insert(j, bb.charAt(i))\n                            found = true\n \
    \                           i = i + 1\n                            j = j + 1\n\
    \                        }\n                        else {\n                 \
    \           if(a(i) == b(j)) {\n                                ab.replace(i,\
    \ i+1, b(j))\n                                bc.insert(j, bb.charAt(i))\n   \
    \                             found = true\n                                i\
    \ = i + 1\n                                j = j + 1\n                       \
    \     }\n                        }\n                    }\n                }\n\
    \            }\n        }\n        if(!found) {\n            false\n        }\
    \ else {\n            true\n        }", "        var firstChar = a(0)\n      \
    \  var lastChar = b(0)\n        var secondChar = a(1)\n        var thirdChar =\
    \ b(1)\n        \n        var firstWord = a.toSet.toList\n        var secondWord\
    \ = b.toSet.toList\n        \n        val firstSet = firstWord.map(x => x -> true)\n\
    \        val secondSet = secondWord.map(x => x -> true)\n        \n        if(firstWord.size\
    \ == 0)\n            return false\n        \n        if(secondWord.size == 0)\n\
    \            return true\n        \n        val firstSetSize = firstSet.size\n\
    \        val secondSetSize = secondSet.size\n        \n        if(firstSetSize\
    \ == 0)\n            return false\n        \n        if(secondSetSize == 0)\n\
    \            return true\n        \n        for(i <- 0 until firstSetSize)\n \
    \           firstChar = firstSet(firstChar)\n        \n        for(i <- 0 until\
    \ secondSetSize)\n            secondChar = secondSet(secondChar)\n        \n \
    \       if(firstChar != secondChar)\n            return false\n        \n    \
    \    firstWord.reverse.foreach { x => if(firstWord.contains(x) || secondWord.contains(x))\
    \ { \n            return true\n        }", '        // Code Here', "        val\
    \ aSeq = a.toList.sortWith(_ < _)\n        val bSeq = b.toList.sortWith(_ < _)\n\
    \        var i = 0\n        while (aSeq.head < bSeq.head && i < aSeq.length) {\n\
    \            if (aSeq(i) != bSeq(i))\n                return false\n         \
    \   i += 1\n        }\n        return i == aSeq.length", "        val aList =\
    \ a.toList\n        val bList = b.toList\n        var result: Boolean = false\
    \ \n        for(x <- 0 until aList.size){\n            val aStr = aList(x)\n \
    \           val bStr = bList(x)\n            val aLen = aStr.length\n        \
    \    val bLen = bStr.length\n            for (x <- 0 until (aLen-bLen)){\n   \
    \             if (aStr.substring(0,x).equals(bStr.substring(0,x))) break\n   \
    \         }\n            if (x != aLen) result = true\n        }\n        result ",
  "        // Solution 1 -> O(M*(M-1))\n        // Solution 2 -> O(M*(M-2))\n    \
    \    // Solution 3 -> O((M*M) + M)\n        // Solution 4 -> O(M*(M-2)*(M-3))\n\
    \        // Solution 5 - > O((M*M*M*M + M*M + M)*M)\n        // Solution 6 ->\
    \ O((M*M*M + M)*M)\n        // Solution 7 -> O((M*M*M + M)*M)\n        // Solution\
    \ 8 -> O(M*(M + M))\n        // Solution 9 -> O(M*M)\n        // Solution 10 ->\
    \ O((M + M))\n        // Solution 11 - > O(M*(M - 1))\n        // Solution 12\
    \ - > O(M*(M-2))\n        // Solution 13 - > O(M*(M-2))\n\n        if (a == null\
    \ || b == null) return false\n        val a1 = new Array[Char](a.length)\n   \
    \     val b1 = new Array[Char](b.length)\n        a1.foreach(_ => 0)\n       \
    \ b1.foreach(_ => 0)\n        val a2 = a.toCharArray\n        val b2 = b.toCharArray\n\
    \        a1.zip(b1).foreach(x => if(x._1 == x._2) a2.foreach(_ => 1))\n      \
    \  b1.zip(a1).foreach(x => if(x._1 == x._2) b2.foreach(_ => 1))\n        val m\
    \ = a1.length\n        val n = b1.length\n        val r = m + n\n        val a3\
    \ = new Array[Boolean](m)\n        a3.foreach(_ => false)\n        a3(0) = true\n\
    \        a3(1) = true\n        a2(0) match {\n            case 0 => return false\n\
    \            case _ => return true\n        }\n        val b3 = new Array[Boolean](m)\n\
    \        b3.foreach(_ => false)\n        b3(0) = true\n        b3(1) = true\n\
    \        b2(0) match {\n            case 0 => return false\n            case _\
    \ => return true\n        }\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = a.length\n        var n = b.length\n\
    \        while(i < m && j < n) {\n            val x = a(i) match {\n         \
    \       case x if x != b(i) => false\n                case x => true\n       \
    \     }\n            val y = b(i) match {\n                case x if x != a(i)\
    \ => false\n                case x => true\n            }\n            i ", " \
    \       val aIndexMap = new HashMap[Char,Int]()\n        for (i <- 0 until a.length)\
    \ {\n            aIndexMap(a.charAt(i)) += 1\n        }\n\n        val bIndexMap\
    \ = new HashMap[Char,Int]()\n        for (i <- 0 until b.length) {\n         \
    \   bIndexMap(b.charAt(i)) += 1\n        }\n\n        for (c <- bIndexMap.keys)\
    \ {\n            if (aIndexMap(c) != bIndexMap(c)) {\n                return false\n\
    \            }\n        }\n\n        true", "      var blist = b.split(\"\")\n\
    \      var alen = a.length\n      var blen = b.length\n\n      for (i <- 0 until\
    \ alen) {\n          var substr = a.substring(i, i + 1)\n          var bstr =\
    \ b.substring(i, i + 1)\n\n          if (bstr == \"\") bstr = b.substring(i, i\
    \ + 1)\n\n          blist.remove(substr)\n          if (blist.contains(bstr))\
    \ {\n              return true\n          }\n      }\n\n      return false", " \
    \       val first = a.substring(1)\n        val second = b.substring(0,a.length-1)\n\
    \        val listFirst = List(first)\n        val listSecond = List(second)\n\
    \        listFirst.foreach( x => listSecond.foreach( y => println(\"checking:\
    \ \" + x + \" \" + y)))\n        listFirst.size == listSecond.size && listFirst.zip(listSecond).forall(x\
    \ => x == 0)", "        val l = a.length\n        val c = b.length\n        if(l==0\
    \ || c==0) true\n        else if(l == c) a.startsWith(b)\n        else (a take\
    \ l == b take c) || cycpatternCheck(a-l, b, c)", "        if (b.contains(a)) true\n\
    \        else {\n            val a = a.toUpperCase\n            val b = b.toUpperCase\n\
    \            val ab = ArrayBuffer(a.charAt(0), a.charAt(1), a.charAt(2), b.charAt(0),\
    \ b.charAt(1), b.charAt(2))\n            val ab1 = (ab ++ b.split(\"\")).groupBy(x\
    \ => x)\n            val ab2 = ab1.map(x => (x._1, x._2.length)).sortBy(_._2).map(_._1)\n\
    \            val c = []\n            val res = (0 until a.length).find(y => b\
    \ contains a.charAt(y) || ab2.exists(z => b == ab1.find(z => z.contains(a.charAt(y))))\
    \ && c.length < ab2.length)\n            if (res == -1) false\n            else\
    \ if (res < ab2.length) cycpatternCheck(a, b2.apply(res))\n            else cycpatternCheck(a,\
    \ b2.last)\n        }", "      var first = true\n      var i = a.length - 1\n\
    \      var j = b.length - 1\n      while (i >= 0 && j >= 0) {\n        var match\
    \ = 0\n        match += if(first)\n        else if(b.substring(i + 1, j + 1).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(j + 1, b).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(i + 1, b).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(j + 1, b).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(i + 1, b).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(i + 1, j).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(i + 1, j).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(i + 1, b).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(0, i).contains(a.substring(i,\
    \ j))) 1 else 0\n        match += if(b.substring(0, j).contains(a.substring(i\
    \ + 1, j + 1))) 1 else 0\n        match += if(b.substring(i + 1, b).contains(",
  "      if(a == null || b == null) return false\n      var c = b.length\n      var\
    \ d = a.length\n      while(d != 0){\n        var j = 0\n        var k = 0\n \
    \       while(j != c){\n          var x = a(k).toLowerCase\n          var y =\
    \ b(j).toLowerCase\n          if(x == y){\n            k = k + 1\n           \
    \ j = j + 1\n          }else{\n            j = 0\n          }\n        }\n   \
    \     d = d - 1\n      }\n      true", "        val arr = a.toCharArray\n    \
    \    val arr2 = b.toCharArray\n        val len = arr.length\n        var i = 0\n\
    \        while(i < len) {\n            val j = arr.indexOf(b(i))\n           \
    \ val k = i+1\n            while(j >= 0 && k < len) {\n                if (arr(j)\
    \ != arr2(k)) {\n                    i = k\n                } else {\n       \
    \             j = arr.indexOf(b(k))\n                    k = k+1\n           \
    \     }\n            }\n            i = i+1\n        }\n        i >= len", " \
    \       var ans = false\n        var temp = \"\"\n        var i = 0\n        var\
    \ j = 0\n        while (i < a.length || j < b.length) {\n            if((j < b.length)\
    \ && (i < a.length) && a(i) == b(j)) {\n                temp += a(i)\n       \
    \         i++\n                j++\n                if(i == a.length) {\n    \
    \                ans = true\n                    break\n                } else\
    \ if (j == b.length) {\n                    ans = true\n                    break\n\
    \                }\n            }\n            if((i < a.length) && (j < b.length))\
    \ {\n                temp += b(i)\n                j++\n                if(i ==\
    \ a.length) { break }\n            }\n            if((j < b.length) && (i < a.length))\
    \ {\n                temp += a(i)\n                i++\n            }\n      \
    \  }\n        ans == true", "        // Check if first string contains second\
    \ string\n        // If it does return true\n        // If not return false\n\
    \        if (b.contains(a)) {\n            return true\n        }\n        val\
    \ listOfB = b\n        val listOfA = a\n        // Check if first string has rotations\
    \ of second string\n        // If it does return true\n        // If not return\
    \ false\n        if (listOfA.contains(\"rotations\")){\n            val rotation\
    \ = listOfA.split(\"rotations\")\n            val rotationOfB = listOfB.split(\"\
    rotations\")\n            val numberOfRotations = rotation.length\n          \
    \  val numberOfRotationOfB = rotationOfB.length\n            if (numberOfRotationOfB\
    \ >= numberOfRotations)\n                true\n            else\n            \
    \    false\n        } else {\n            false\n        }", "    \tval bSet =\
    \ b.toSet\n    \tval aSet = a.toSet\n    \tbSet contains aSet || aSet contains\
    \ bSet || bSet contains aSet", "        val aArr = a.toList\n        val bArr\
    \ = b.toList\n        val length = aArr.length\n        var count = 0\n      \
    \  for (i = 0 to length - 1) {\n            if (aArr(i) == bArr(length-i)) {\n\
    \                count = count + 1\n            }\n        }\n        if (count\
    \ == b.length)\n            true\n        else\n            false", "        val\
    \ a1 = a.toCharArray\n        val b1 = b.toCharArray\n        var count = 0\n\
    \        for( i <- 0 until a.length ; j <- 0 until b.length) {\n            if\
    \ (a1(j) != b1(i)) {\n                count = count + 1\n            }\n     \
    \   }\n        if (count > 0) {\n            true\n        }\n        else {\n\
    \            false\n        }", "        val m = b.length\n        if (m>a.length)\
    \ return false\n        val n = a.length\n        if (m>n) return false\n    \
    \    val a2 = a.map(c => (c, 1))\n        val b2 = b.map(c => (c, 1))\n      \
    \  val a3 = a2.toSet\n        val b3 = b2.toSet\n        for {\n            i\
    \ <- 0 until n\n            x <- 0 until m\n        } yield {\n            if\
    \ (a3(x)==false || b3(x)==false) false else (\n                a(i) contains a(x)\
    \ || \n                b(i) contains b(x) \n            )\n        }", "     \
    \   def getRotation(x : String, y : String) : Option[String] = {\n           \
    \ if (x == y) None\n            else {\n                val newX = (x + y) match\
    \ {\n                    case x if x.length < y.length => x + \"a\"\n        \
    \            case y => y + \"a\"\n                }\n                val rotatedX\
    \ = getRotation(newX, x.substring(x.length - y.length, x.length))\n          \
    \      val rotatedY = getRotation(x.substring(0,x.length - y.length), y.substring(0,y.length\
    \ - x.length))\n                rotatedX match {\n                    case Some(rotatedX)\
    \ => rotatedY\n                    case None => None\n                }\n    \
    \        }\n        }\n        getRotation(a, b).isDefined &&\n            (a.toSet\
    \ == b.toSet) ||\n            (a.toSet == b.toSet || getRotation(a, getRotation(a,\
    \ b)) == getRotation(b, getRotation(a, b)))", "        def rotation(str: String,\
    \ index: Int, count: Int) : String = {\n            if (count > 0)\n         \
    \   {\n                val temp = str.substring(0, index) ++ str.substring(index,\
    \ index + count) ++ str.substring(index + count, str.length);\n              \
    \  rotation(temp, index, count - 1)\n            }\n            else\n       \
    \     {\n                str\n            }\n        }\n\n        def patternMatcher(str\
    \ : String, sub : String, index: Int) : Boolean = {\n            val subs = sub.split(\"\
    \").toSet;\n            if (subs.contains(str.substring(index, index + sub.length)))\n\
    \            {\n                true\n            }\n            else\n      \
    \      {\n                false\n            }\n        }\n\n        if (b.length\
    \ == 0) {\n            true\n        }\n        else if (b.length > a.length)\n\
    \        {\n            false\n        }\n        else if (b.length == a.length)\n\
    \        {\n            val sub = a.substring(b.length-1, b.length-1);\n     \
    \       val subs = sub.split(\"\").toSet;\n            val allSubs = subs.toList;\n\
    \            if (allSubs.contains(a.substring(0, b.length-1)))\n            {\n\
    \                true\n            }\n            else\n            {\n      \
    \          false\n            }\n        }\n        else if (b.length < a.length)\n\
    \        {\n            var found = false;\n            var lastMatch = -1;\n\
    \            for (i <- 0 until a.length)\n            {\n                val sub\
    \ = a.substring(i, i+1);\n                if (found)\n                {\n    \
    \                val subs = sub.split(\"\").toSet;\n                    val allSubs\
    \ = subs.toList;\n                    val foundIndex = allSubs.indexOf(sub);\n\
    \                    val foundSub = allSubs(foundIndex);\n                   \
    \ if (foundSub.contains(b.substring(0, b.length-1)))\n                    {\n\
    \                        val foundLastIndex = a.lastIndexOf(b, foundIndex);\n\
    \                        val foundLastSub = a.substring(foundLastIndex, foundLastIndex+foundLastSub.length);\n\
    \                        if (lastMatch != -1)\n                        {\n   \
    \                         if (foundLastSub.contains(sub))\n                  \
    \          {\n                                found = true;\n                \
    \                lastMatch = foundIndex;\n                            }\n    \
    \                    }\n                        else\n                       \
    \ {\n                            found = true;\n                            lastMatch\
    \ = foundIndex;\n                        }\n                    }\n          \
    \      }\n                else\n                {\n                    val subs\
    \ = sub.split(\"\").toSet;\n                    val allSubs = subs.toList;\n \
    \                   if (allSubs.contains(a.substring(0, b.length-1)))\n      \
    \              {\n                        val foundIndex = allSubs.indexOf(sub);\n\
    \                        val foundSub = allSubs(foundIndex);\n               \
    \         if (foundSub.contains(b.substring(0, b.length-1)))\n               \
    \         {\n                            val foundLastIndex = a.lastIndexOf(b,\
    \ foundIndex);\n                            val found", "        val m = a.length\n\
    \        val n = b.length\n        if (n >= m) {\n            return b.toList.filter(x\
    \ => a.indexOf(x) >= 0).isDefined\n        }\n        else {\n            return\
    \ a.toList.filter(x => b.indexOf(x) >= 0).isDefined\n        }", "        val\
    \ l1 = a.toList\n        val l2 = b.toList\n        if (l2.isEmpty) true\n   \
    \     else if (l2.head == l1.head) cycpatternCheck(l1.tail, l2.tail)\n       \
    \ else cycpatternCheck(l1, l2.tail)", "        val aSet = a.toSet\n        val\
    \ bSet = b.toSet\n        val result = aSet.subsetOf(bSet)\n        result.isEmpty\
    \ || a.subsetOf(bSet) || b.subsetOf(aSet)", '        a.indexOf(b) > -1 || b.indexOf(a
    > -1)', "        val a = a.toLowerCase + a.toUpperCase\n        val b = b.toLowerCase\
    \ + b.toUpperCase\n\n        val n1 = a.length\n        val n2 = b.length\n\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        val arr = new\
    \ Array[Boolean](n1+2)\n\n        while(i<n1 && j<n2) {\n            if (a(i)\
    \ == b(j)) {\n                arr(i+1) = true\n                i += 1\n      \
    \          j += 1\n                k += 1\n            } else if (a(i) > b(j))\
    \ {\n                arr(i+1) = false\n                i += 1\n            } else\
    \ {\n                arr(i+1) = true\n                j += 1\n            }\n\
    \        }\n        if (i==n1) {\n            if (k<n2) {\n                arr(i+2)\
    \ = true\n            } else {\n                arr(i+2) = false\n           \
    \ }\n        } else if (j==n2) {\n            if (k<n1) {\n                arr(i+2)\
    \ = true\n            } else {\n                arr(i+2) = false\n           \
    \ }\n        }\n\n        val l = arr.length\n        var x = 0\n        while(x<l-1)\
    \ {\n            if (arr(x)) {\n                return true\n            }\n \
    \           x += 1\n        }\n        return false", "        val a = a.toSet.toList\n\
    \        val b = b.toSet.toList\n        if(a.length < b.length)\n           \
    \ return false\n        for( i <- a if b.contains(i) && cycpatternCheck(i, b)\
    \ && cycpatternCheck(a, -i))\n            return true", "        var aR = b\n\
    \        var bR = a\n\n        val aSize = aR.size\n        val bSize = bR.size\n\
    \n        val aP = a.toUpperCase\n        val bP = b.toUpperCase\n        val\
    \ a = aR.toList\n        val b = bR.toList\n\n        for(i <- 0 until a.size)\
    \ {\n            val cP = aP(i)\n            val cA = a(i)\n            val cB\
    \ = bP(i)\n            val cBA = bA(i)\n            if(cP == cA) {\n         \
    \       if(cP == cB) {\n                    if(cP == cBA) {\n                \
    \        true\n                    } else {\n                        false\n \
    \                   }\n                } else {\n                    false\n \
    \               }\n            } else {\n                false\n            }\n\
    \        }", "        val b = b.toList\n        val a = a.toList\n        val\
    \ size = b.size\n        val isChecked = mutable.Set.empty[String]\n        val\
    \ allMatch = mutable.Set.empty[String]\n        val matchWord = mutable.Set.empty[String]\n\
    \n        for(i <- 0 until size) {\n            if(i < a.size) {\n           \
    \     if(b(i) == a(i)) {\n                    isChecked += b(i)\n            \
    \    }\n            }\n            else {\n                isChecked += b(i)\n\
    \            }\n\n            if(a.contains(b(i))) {\n                allMatch\
    \ += b(i)\n            }\n        }\n\n        if(allMatch.size == size) {\n \
    \           return true\n        }\n        else {\n            return false\n\
    \        }", "        def findSubstring(aStr : String, bStr : String) : Boolean\
    \ = {\n            val pattern = Pattern.compile(aStr.substring(0, aStr.length-1))\n\
    \            pattern.matcher(bStr).find\n        }\n        def rotation(str :\
    \ String, i : Int) : String = {\n            val sb = new StringBuilder(str);\n\
    \            val temp = str.substring(0, i)\n            val result = temp.substring(temp.lastIndexOf(str),\
    \ temp.length);\n            sb.replace(i, i + temp.length, result);\n       \
    \     sb.toString();\n        }\n        val aHash = a.split(' ').map(_.toInt).distinct\n\
    \        val bHash = b.split(' ').map(_.toInt).distinct\n        var flag = true\n\
    \        for (i <- 0 until aHash.length) {\n            val temp = findSubstring(aHash(i).toString,\
    \ rotation(b.toString, aHash(i)))\n            if (temp) {\n                flag\
    \ = false\n                break;\n            }\n        }\n        flag", " \
    \       def cycpattern(a : String, b : String, p : List[String]) : List[String]\
    \ = {\n            // if a rotation of b can be made from a, return that string\n\
    \            if (a == b || b.isEmpty) List(b)\n            else {\n          \
    \      // otherwise, do a breadth-first search\n                val q = b.take(b.size\
    \ - 1).tail\n                val rs = if (p(p(0)) == a) List(p.head) else if (p(p(0))\
    \ == b) cycpattern(a, b, p.tail) else cycpattern(a, b :: p.tail)\n           \
    \     if (rs.nonEmpty) rs else cycpattern(a, b :: q, p.tail)\n            }\n\
    \        }\n        cycpattern(a, b :: Nil, List.fill(b.length)(a))", "      \
    \  if (b.isEmpty || b.isEmpty) false\n        if (b.length == a.length && b.length\
    \ == b.indexOf(a(0))) true\n        else {\n            var bList = b.toList\n\
    \            var aList = a.toList\n            var cList = bList.tail\n\n    \
    \        var i = 0\n            var j = 0\n            var result = true\n\n \
    \           for (i <- 0 until b.length) {\n                val bValue = bList(i)\n\
    \                val aValue = aList(i)\n\n                for (j <- 0 until aList.length)\
    \ {\n                    var cValue = cList(i)\n                    var newCValue\
    \ = cList(i)\n\n                    var isMatch = false\n                    if\
    \ (cValue == aList(i)) {\n                        isMatch = true\n           \
    \         }\n                    else if ((newCValue = cList[j]) == (aList[j]))\
    \ {\n                        isMatch = true\n                    }\n\n       \
    \             if (isMatch) {\n                        cList = cList.tail\n   \
    \                     cValue = newCValue\n                    }\n            \
    \        else {\n                        return false\n                    }\n\
    \                }\n\n                if (!isMatch) {\n                    return\
    \ false\n                }\n            }\n\n            return result\n     \
    \   }", "        var charCountA = 0\n        var charCountB = 0\n        var isSubstringA\
    \ = false\n        var isSubstringB = false\n        val aList = a.toList\n  \
    \      val bList = b.toList\n        aList.foreach { c => charCountA += c.toInt\
    \ }\n        bList.foreach { c => charCountB += c.toInt }\n        if (charCountA\
    \ > charCountB) isSubstringA = true\n        if (charCountB > charCountA) isSubstringB\
    \ = true\n        if (isSubstringA && isSubstringB) {\n            var i = 1\n\
    \            var j = 1\n            var k = -1\n            var l = -1\n     \
    \       while ((i < aList.length) && (j < bList.length) && (k < aList.length)\
    \ && (l < bList.length)) {\n                if (aList.charAt(i) == bList.charAt(j))\
    \ {\n                    k = k + 1\n                    l = l + 1\n          \
    \      }\n                i = i + 1\n                j = j + 1\n            }\n\
    \            if (i != aList.length) return false\n            i = i\n        \
    \    while ((i < aList.length) && (j < bList.length) && (k < aList.length) &&\
    \ (l < bList.length)) {\n                if (aList.charAt(i) == bList.charAt(k))\
    \ {\n                    l = l + 1\n                }\n                i = i +\
    \ 1\n                k = k + 1\n            }\n            if (i != aList.length)\
    \ return false\n            i = i\n            while ((i < aList.length) && (j\
    \ < bList.length) && (k < aList.length) && (l < bList.length)) {\n           \
    \     if (aList.charAt(i) == bList.charAt(l)) {\n                    k = k + 1\n\
    \                }\n                i = i + 1\n                l = l + 1\n   \
    \         }\n            if (i != aList.length) return false\n        }\n    \
    \    true", "        if (a == b)\n            (true)\n        else {\n       \
    \     val aArray = a.toCharArray\n            val bArray = b.toCharArray\n   \
    \         var match = 0\n            val list1 = new ArrayList[String]()\n   \
    \         val list2 = new ArrayList[String]()\n            for (i <- 0 until aArray.length)\
    \ {\n                list1.add(aArray(i))\n            }\n            for (i <-\
    \ 0 until bArray.length) {\n                list2.add(bArray(i))\n           \
    \ }\n            val aArrayLen = list1.size\n            var j = 0\n         \
    \   var k = 0\n            var m = 0\n            var isMatch = true\n       \
    \     var isSame = true\n            var isRotation = true\n            var isSubString\
    \ = true\n            var isSameSubString = true\n            var isRotationSubString\
    \ = true\n            while (j < aArrayLen) {\n                val currentChar1\
    \ = list1(j)\n                val currentChar2 = list2(k)\n                val\
    \ currentChar = aArray(j)\n                val currentChar2 = bArray(k)\n    \
    \            val currentChar1 = List(currentChar1.toUpperCase).iterator\n    \
    \            val currentChar2 = List(currentChar2.toUpperCase).iterator\n    \
    \            var count = 0\n                while ((currentChar1.hasNext) && (currentChar2.hasNext)\
    \ && (count < aArrayLen - j)) {\n                    val currentChar1Val = currentChar1.next()\n\
    \                    val currentChar2Val = currentChar2.next()\n             \
    \       if (currentChar1Val == currentChar2Val) {\n                        count\
    \ += aArrayLen - j\n                        j += aArrayLen - count\n         \
    \               k += aArrayLen - count\n                    } else if (count <\
    \ aArrayLen - j) { // count > 0 & j > aArrayLen - count\n                    \
    \    val cArray = new Array[String](aArrayLen - count)\n                     \
    \   for (i <- 0 until aArrayLen - count) {\n                            cArray(i)\
    \ = currentChar(aArray(i))\n                        }\n                      \
    \  val cArray1 = new Array[String](aArrayLen - count)\n                      \
    \  for (i <- 0 until aArrayLen - count) {\n                            cArray1(i)\
    \ = currentChar1Val\n                        }\n                        val cArray2\
    \ = new Array[String](aArrayLen - count)\n                        for (i <- 0\
    \ until aArrayLen - count) {\n                            cArray2(i) = currentChar2Val\n\
    \                        }\n                        val cArray3 = new Array[String](aArrayLen\
    \ - count)\n                        for (i <- 0 until aArrayLen - count) {\n \
    \                           cArray3(i) = currentChar\n                       \
    \ }\n                        val cArray4 = new Array[String", "        val a1\
    \ = a.toUpperCase\n        val b1 = b.toUpperCase\n        val a1a1 = a1.chars.toList\n\
    \        val b1b1 = b1.chars.toList\n        var flag = false\n        var i =\
    \ 0\n        var j = 0\n        for( i <- 0 until a1a1.length){\n            if(i\
    \ % 2 != 0){\n                for( j <- 0 until b1b1.length){\n              \
    \      if(j % 2 != 0){\n                        val a2 = a1a1(i)\n           \
    \             val b2 = b1b1(j)\n                        val a2b2 = a2.toString\
    \ + b2.toString\n                        val b2a2 = b2.toString + a2.toString\n\
    \                        if(a2b2 == a1 || a2b2 == a1 +\"\"){\n               \
    \             if(b2a2 == b1 || b2a2 == b1 +\"\"){\n                          \
    \      flag = true\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        flag",
  "        val aLength = a\n        val bLength = b\n        var aWordCount = 0\n\
    \        var bWordCount = 0\n        for (x <- aWordList) {\n            for (y\
    \ <- bWordList) {\n                if (x == y) bWordCount += 1\n            }\n\
    \            aWordCount += 1\n        }\n        var flag = false // flag will\
    \ be true if any count is 0\n        for (x <- aWordList) {\n            if (aWordCount\
    \ != 0)\n                flag = x != bWordList\n            else\n           \
    \     flag = x != b\n        }\n        flag", "        val ab = ArrayBuffer(a.toCharArray,\
    \ b.toCharArray)\n        val ba = ArrayBuffer(b.toCharArray,a.toCharArray)\n\
    \        val ba = ab.reverse.foldRight(ba)(_+_)\n        val ac = ab.foldRight(ba){\
    \ x => (x ++ _) }\n        val bc = ac.foldRight(ba){ (x,y) => y + x }\n     \
    \   ac == bc", "        var b = b.toUpperCase\n        val length = b.length\n\
    \        var a = a.toUpperCase\n        val aLength = a.length\n        var count\
    \ = 0\n        var start = 0\n        for (i <- 0 until length) {\n          \
    \  var temp = b.charAt(i)\n            if (temp.equals(\"L\")) {\n           \
    \     start += 1\n            } else {\n                start -= 1\n         \
    \   }\n            count = (count + start.toChar).asInstanceOf[Int]\n        \
    \    if (start == 0) {\n                return true\n            }\n        }\n\
    \        for (i <- 0 until aLength) {\n            val temp = a(i)\n         \
    \   if (temp.equals(\"L\")) {\n                start += 1\n            } else\
    \ {\n                start -= 1\n            }\n            count = (count + start.toChar).asInstanceOf[Int]\n\
    \            if (start == 0) {\n                return true\n            }\n \
    \       }\n        false", "        val aArray = a.toLowerCase :: Nil\n      \
    \  val bArray = b.toLowerCase :: Nil\n        var isMatch = true\n        val\
    \ aSet = a.toLowerCase flatMap toLowerCase :: Nil\n        val bSet = b.toLowerCase\
    \ flatMap toLowerCase :: Nil\n        val aSetSet = mutable.Set.empty[String]\n\
    \        val bSetSet = mutable.Set.empty[String]\n        var aSize = 0\n    \
    \    var bSize = 0\n        val maxSize = aArray.max(aSize max bSize)\n      \
    \  aArray.foreach(x => {\n            if (aSet contains x) aSet += x :: aSetSet\n\
    \            else aSetSet += x :: aSet\n            aSize += 1\n        })\n \
    \       bArray.foreach(x => {\n            if (bSet contains x) bSet += x :: bSetSet\n\
    \            else bSetSet += x :: bSet\n            bSize += 1\n        })\n \
    \       val abSet = aSetSet ++ bSetSet\n        val abSize = aSet.size\n     \
    \   var i = 0\n        val rotation = Array.fill(abSize + maxSize - abSize) {\n\
    \            val x = i mod maxSize\n            i / maxSize\n        }\n     \
    \   val matchCount = 0\n        val misMatchCount = 0\n        val rotatedA =\
    \ aArray.foldLeft(Array.fill(abSize + maxSize - abSize)(Array[String]())) {\n\
    \            (acc, value) => {\n                acc.foreach { x =>\n         \
    \           if (x == value) acc -= 1\n                    else acc += 1\n    \
    \            }\n                acc\n            }\n        }\n        val rotatedB\
    \ = bArray.foldLeft(Array.fill(abSize + maxSize - abSize)(Array[String]())) {\n\
    \            (acc, value) => {\n                acc.foreach { x =>\n         \
    \           if (x == value) acc -= 1\n                    else acc += 1\n    \
    \            }\n                acc\n            }\n        }\n        val rotatedAB\
    \ = rotatedA.flatMap(x => rotatedB.map(y => x ++ y))\n        val isMatch = rotatedAB.takeWhile(x\
    \ => x.size < maxSize ).forall(x => abSet contains x)\n        if (isMatch) matchCount\
    \ += 1\n        else misMatchCount += 1\n        isMatch", "        val set =\
    \ new mutable.HashSet[String](b)\n        val subSet = new mutable.HashSet[String](a)\n\
    \        for ((a, b) <- a zip b) {\n            set.add(a)\n        }\n      \
    \  for ((a, b) <- a zip b) {\n            subSet.add(b)\n        }\n        return\
    \ set.subsetOf(subSet)", '        a.toSeq.zip(b.toSeq).filter(x => x._1 == x._2).takeWhile(x
    => x._1 ++ x._2).forall(x => a.contains(x._2))', "      if (a.length < b.length)\
    \ {\n        false\n      } else if (a.length > b.length) {\n        true\n  \
    \    } else {\n        val c = new HashMap[Int, String]()\n        for (x1 <-\
    \ 0 until a.length) {\n          val a1 = a.substring(x1, x1 + 1)\n          c.put(x1,\
    \ a1)\n        }\n        for (x2 <- 0 until b.length) {\n          val b1 = b.substring(x2,\
    \ x2 + 1)\n          c.put(x2, b1)\n        }\n        if (c.size == b.length)\
    \ {\n          val keySet = c.keySet\n          for (i <- 0 until a.length) {\n\
    \            val a1 = c.get(keySet(i))\n            val b1 = c.get(keySet(i +\
    \ a.length))\n            if (a1 == b1) {\n              true\n            } else\
    \ {\n              if (b1.indexOf(a1) != -1) {\n                true\n       \
    \       } else {\n                if (a1.indexOf(b1) != -1) {\n              \
    \    true\n                } else {\n                  false\n               \
    \ }\n              }\n            }\n          }\n        }\n      }", "     \
    \   val a = a.toLowerCase \n        val b = b.toLowerCase \n        if (b.length\
    \ < a) return false\n        val pattern = a.slice(b.length) \n        val arr\
    \ = new Array[String](b.length) \n        for (i <- 0 until b.length) {\n    \
    \        arr(i) = a(i) + a.slice(i + b.length)\n        }\n        val set = new\
    \ mutable.HashSet[String]() \n        for(i <- 0 until a.length)\n           \
    \ if (!set.add(arr(i))) {\n                for ((j, k) <- 0 until arr.length)\n\
    \                    if (arr(i) == arr(j) && (i+j == 0 || i+j == a.length-1 ||\
    \ arr(i+j) == pattern)) \n                        set.add(arr(k))\n          \
    \  }\n        if (set.size == b.length)\n            return true\n        return\
    \ false", "        for (x <- b) yield {\n            if (a.indexOf(x) != -1) yield\
    \ { cycpatternCheck(a drop 1 take a.indexOf(x) + 1, a drop a.indexOf(x) + 1 take\
    \ b.length); true }\n            else yield { false }\n        }\n        ()",
  "        if(b.contains(a))\n            true\n        else\n            if(rotN(a)\
    \ == rotN(b))\n                cycpatternCheck(rotN(a), rotN(b)) || cycpatternCheck(rotN(b),\
    \ rotN(a))\n            else\n                false", "        var a = a.toUpperCase.mkString.toUpperCase\n\
    \        var b = b.toUpperCase.mkString.toUpperCase\n        var substr = false\n\
    \        // Check if a is a substring\n        for ((i <- 0 until a.length) if\
    \ !a.startsWith(a(i)) || !a.startsWith(b(i))) {\n            substr = true\n \
    \           break\n        }\n        // Check if b is a substring\n        for\
    \ ((i <- 0 until b.length) if !b.startsWith(a(i)) || !b.startsWith(b(i))) {\n\
    \            substr = true\n            break\n        }\n        substring",
  "        val a1 = a.toUpperCase\n        val b1 = b.toUpperCase\n        var found\
    \ = false\n        val a1 = a1.replaceAll(\"\\\\p{Punct}+\", \"\")\n        val\
    \ b1 = b1.replaceAll(\"\\\\p{Punct}+\", \"\")\n        a1 +: a1.split(\"\").map(x\
    \ => x1 =>\n        if (x != b1) {\n            val a2 = a1.drop(x).reverse.mkString\n\
    \            val b2 = b1.drop(x).reverse.mkString\n            val a2a2 = a2.replaceAll(\"\
    \\\\p{Punct}+\", \"\")\n            val b2b2 = b2.replaceAll(\"\\\\p{Punct}+\"\
    , \"\")\n            val a2b2 = a2b2.replaceAll(\"\\\\p{Punct}+\", \"\")\n   \
    \         val b2b2b2 = b2b2.replaceAll(\"\\\\p{Punct}+\", \"\")\n            val\
    \ a2b2b2 = a2b2b2.replaceAll(\"\\\\p{Punct}+\", \"\")\n            if (a2b2b2.contains(a2b2))\n\
    \                found = true\n            else\n                cycpatternCheck(a2a2,\
    \ b2b2)\n        } else\n            found)", "        if(b.length == a.length)\
    \ {\n            a intersect b exists { x => \n                val b = b.substring(0,x)\n\
    \                val a = a.substring(0,x)\n                b != a && !b.intersect(a).isEmpty\n\
    \            }\n        } else {\n            false\n        }", '        a.contains(b)',
  "        val n = a.length\n        val m = b.length\n        // the pattern to search\
    \ for\n        val pattern = a.foldLeft(Array[Int]()){case (a,x) => a ++ Array.fill(m.toInt+1)(x)\
    \ }\n        // a list containing the permutation indices of the pattern\n   \
    \     val patternList = a.combinations(m).toList.sortBy(x=>x) match {\n      \
    \      case x if x.head==x.last => x.head\n            case x => -1\n        }\n\
    \        if (m > n || m < 1 || patternList.toList.size == 0 || patternList.contains(n+1)\
    \ || patternList.contains(0) || patternList.contains(n+1)) return false\n    \
    \    // searching for all permutations\n        val permutations = a.permutations(m).filter(x\
    \ => patternList.contains(x.toInt+1))\n        val matchFound = permutations.map(x\
    \ => pattern(x)).contains(b)\n        permutations.map(x => pattern(x)).contains(b)",
  "        val ab: List[String] = a.toList\n        val bb: List[String] = b.toList\n\
    \        var i = a.length - 1\n        var j = b.length - 1\n        while (i\
    \ >= 0 && j >= 0) {\n            if (ab(i) == bb(j)) {\n                i -= 1\n\
    \                j -= 1\n            } else if (ab(i) > bb(j)) {\n           \
    \     i -= 1\n            } else {\n                j -= 1\n            }\n  \
    \      }\n        j == 0", "        var firstWord = a.toList.map(word => word\
    \ + \"1\").mkString(\"\")\n        var secondWord = b.toList.map(word => word\
    \ + \"1\").mkString(\"\")\n        val list1 = firstWord.substring(0,firstWord.length-1)\n\
    \        val list2 = secondWord.substring(0,secondWord.length-1)\n        val\
    \ list3 = list1 + list2\n        if(list3.contains(firstWord) || list3.contains(secondWord)){\n\
    \            true\n        }\n        else{\n            false\n        }", " \
    \       val aArray = a.split(\"\").toList\n        val bArray = b.split(\"\").toList\n\
    \        val aSet = a.toSet\n        val bSet = b.toSet\n        if(aArray.length\
    \ != bArray.length)\n        {\n            return false\n        }\n        else\
    \ if(!aSet.subsetOf(bSet))\n        {\n            return false\n        }\n \
    \       else\n        {\n            val commonChars = aSet.intersect(bSet)\n\
    \            val aList = a.toLowerCase().toList.filterNot(commonChars.contains)\n\
    \            val bList = b.toLowerCase().toList.filterNot(commonChars.contains)\n\
    \            val aString = aList.toString + aArray.toList.toString\n         \
    \   val bString = bList.toString + bArray.toList.toString\n            val aChars\
    \ = aList.toSet\n            val bChars = bList.toSet\n            if(aChars.subsetOf(bChars))\n\
    \            {\n                val aRotation = aString.substring(aString.length\
    \ - aArray.length)\n                val bRotation = bString.substring(bString.length\
    \ - bArray.length)\n                val rotatedBList = bList.toList.rotateLeft(bString.length\
    \ - bArray.length)\n                val rotatedABList = rotatedBList.rotateLeft(aString.length\
    \ - aArray.length)\n                val rotatedABString = rotatedABList.toString\
    \ + rotatedABList.toString + aArray.toList.toString\n                val rotatedAString\
    \ = aList.toString.rotateLeft(aString.length - aArray.length)\n              \
    \  val rotatedAChars = rotatedAString.toSet\n                val rotatedBChars\
    \ = rotatedBString.toSet\n                if(rotatedAChars.subsetOf(rotatedBChars))\n\
    \                {\n                    val aRotatedList = rotatedAString.toList.rotateLeft(aString.length\
    \ - aArray.length)\n                    val aRotatedChars = aRotatedList.toSet\n\
    \                    if(aRotatedChars.subsetOf(aChars))\n                    {\n\
    \                        val aRotatedList = aList.toList.rotateLeft(aString.length\
    \ - aArray.length)\n                        val aRotatedString = aRotatedList.toString\
    \ + aArray.toList.toString\n                        val bRotatedList = rotatedBString.toList.rotateLeft(bString.length\
    \ - bArray.length)\n                        val bRotatedChars = bRotatedList.toSet\n\
    \                        if(bRotatedChars.subsetOf(bChars))\n                \
    \        {\n                            val bRotated", '        a.tail.forall(_
    == b.head) || b.tail.forall(_ == a.head)', "        if (a == null || a == \"\"\
    \ || b == null || b == \"\") {\n            false\n        } else {\n        \
    \    if (a.length == b.length && a.contains(b)) {\n                true\n    \
    \        } else {\n                var ab = a.toCharArray\n                var\
    \ bc = b.toCharArray\n                var i = a.length - 1\n                var\
    \ j = b.length - 1\n\n                if (bc == null && a == b) true\n       \
    \         else if (bc == null || bc == \"\" && a.startsWith(b)) true\n       \
    \         else if (bc == null || bc == \"\" && a.endsWith(b)) true\n         \
    \       else if (bc == null || bc == \"\" && a.indexOf(b) == 0) true\n       \
    \         else {\n                    while (i >= 0 || j >= 0) {\n           \
    \             val c = ab(i).toChar\n                        val d = bc(j).toChar\n\
    \                        val k = (c to d).foldLeft((0, 0))((a, b) => (a._1 + b._1,\
    \ a._2 + b._2))\n                        if (k._2 == 0) return true\n        \
    \                else if (k._1 < k._2) i = i - 1\n                        else\
    \ if (k._2 > k._1) j = j - 1\n                        else (i = i - 1, j = j -\
    \ 1)\n                    }\n                }\n                false\n      \
    \      }\n        }", "      var i : Int = 0\n      var j : Int = 0\n      var\
    \ n : Int = a.length - b.length\n      var x : String = \"\"\n      val cycPattern\
    \ = a.chars.toList\n      val cycPattern2 = b.chars.toList\n      val cycPattern3\
    \ = a.substring(0).toList ++ b.substring(0).toList\n      var cycPattern4 = a.substring(0).toList\
    \ ++ b.substring(0,1).toList\n      cycPattern.zip(cycPattern2) foreach { x =>\n\
    \          i = x._1.length\n          x = x._2\n      }\n      for ( x <- cycPattern\
    \ ) {\n          j = x.length\n          x += cycPattern2.tail\n      }\n    \
    \  cycPattern3.zip(cycPattern4) foreach { x =>\n          i = x._1.length\n  \
    \        x = x._2\n      }\n      cycPattern3.zip(cycPattern4) foreach { x =>\n\
    \          i = x._1.length\n          x = x._2\n      }\n      x = cycPattern3.zip(cycPattern4)\
    \ foreach { x =>\n          i = x._1.length\n          x = x._2\n      }\n   \
    \   x = a.substring(i).toList\n      x = b.substring(i).toList\n      cycPattern3.zip(cycPattern4)\
    \ foreach { x =>\n          i = x._1.length\n          x = x._2\n      }\n   \
    \   cycPattern3.zip(cycPattern4) foreach { x =>\n          i = x._1.length\n \
    \         x = x._2\n      }\n      cycPattern3.zip(cycPattern4) foreach { x =>\n\
    \          i = x._1.length\n          x = x._2\n      }\n      cycPattern3.zip(cycPattern4)\
    \ foreach { x =>\n          i = x._1.length\n          x = x._2\n      }\n   \
    \   cycPattern3.zip(cycPattern4) foreach { x =>\n          i = x._1.length\n \
    \         x = x._2\n      }\n      cycPattern3.zip(cycPattern4) foreach { x =>\n\
    \          i = x._1.length\n          x = x._2\n      }\n      cycPattern3.zip(cycPattern4)\
    \ foreach { x =>\n          i = x._1.length\n          x = x._2\n      }\n   \
    \   cycPattern3.zip(cycPattern4) foreach { x =>\n          i = x._1.length\n \
    \         x = x._2\n      }\n      cycPattern3.zip(cycPattern4) ", "      var\
    \ b = b.toUpperCase\n      a.reverse.foldLeft((false, \"\"))((x, y) => (if (x.contains(y)\
    \ || (y.contains(x))) (false, \"\") else (x+y, x+y)))\n      (b.reverse.foldLeft((false,\
    \ \"\"))((x, y) => (if (x.contains(y) || (y.contains(x))) (false, \"\") else (x+y,\
    \ x+y)))) match {\n        case (true, \"\") => (true)\n        case (false, _)\
    \ => (false)\n      }", "        var a1 = a.toUpperCase\n        var b1 = b.toUpperCase\n\
    \        var a2 = a1.toList\n        var b2 = b1.toList\n        var a3 = a2.reverse\n\
    \        var b3 = b2.reverse\n        var x = 0\n        var y = 0\n        var\
    \ flag = true\n        while (x < a3.length) {\n            if (b3(x) == a3(x))\
    \ {\n                x += 1\n                if (x == a3.length) {\n         \
    \           y = x\n                    flag =  true\n                }\n     \
    \       } else {\n                flag =  false\n            }\n            x\
    \ += 1\n        }\n        if (flag) {\n            return true\n        }\n \
    \       else {\n            return false\n        }", "        if (a == null ||\
    \ b == null || a.length == 0 || b.length == 0) {\n            return false\n \
    \       }\n        val pattern = a.toSet\n        val bSet = b.toSet\n       \
    \ val set = new mutable.HashSet[String]()\n        a.foreach(x => {\n        \
    \    val c = b.indexOf(x)\n            if (c < 0)\n                return false\n\
    \            if (pattern.contains(x) && bSet.contains(b.take(c + 1)))\n      \
    \          set.add(b.take(c + 1))\n        })\n        return set.length == b.length",
  "      val (first, rest) = a.splitAt(a.length - 1)\n      val (second, rest2) =\
    \ b.splitAt(b.length - 1)\n      rest.contains(second) || cycPattern(first, rest)\
    \ || cycPattern(second, rest2)", "        // Convert into a mutable Set\n    \
    \    val a1 = a.toUpperCase.toSet\n        val b1 = b.toUpperCase.toSet\n    \
    \    // Cycle through all substrings of A\n        for (aaa <- 1 to a.length)\
    \ yield {\n            // Add all possible combinations of b at that position\n\
    \            for (bbb <- 0 to b.length) yield {\n                // Check if the\
    \ b is in a\n                if (a1 contains b(bb).charAt(aaa)) {\n          \
    \          val temp = aaa\n                    val temp2 = bbb\n             \
    \       if (a1 contains b(bb).charAt(aaa - 1)) {\n                        if (a1\
    \ contains b(bb).charAt(aaa - 2)) {\n                            if (a1 contains\
    \ b(bb).charAt(aaa - 3)) {\n                                val temp = aaa\n \
    \                               val temp2 = bbb\n                            \
    \    val temp3 = aaa - 1\n                                val temp4 = aaa - 2\n\
    \                                val temp5 = aaa - 3\n                       \
    \         return true\n                            }\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    \
    \    return false", "        val charList = a.toCharArray\n        val bList =\
    \ b.toCharArray\n        charList.foreach { c =>\n            val bIndex = bList.indexWhere(_\
    \ == c)\n            if(bIndex < 0 || bIndex == bList.length-1) return false\n\
    \            bList.drop(bIndex + 1).foreach { b =>\n                if(a.toUpperCase\
    \ contains b) return true\n            }\n        }\n        return false", " \
    \       val aArr = a.toSeq.map(_.toChar).toArray\n        val bArr = b.toSeq.map(_.toChar).toArray\n\
    \n        var i = 0\n        val j = 0\n        var count = 0\n        while (i\
    \ < aArr.length && j < bArr.length) {\n            count += aArr(i) == bArr(j)\n\
    \            if (aArr(i) == bArr(j) && aArr(i+1).isLetter) i += 1\n          \
    \  if (aArr(i).isLetter && aArr(i+1).isLetter) i += 1\n            if (aArr(i).isLetter\
    \ && aArr(i+1).isLetter) i += 1\n            if (aArr(i).isLetter && aArr(i-1).isLetter)\
    \ i += 1\n            if (aArr(i).isLetter && aArr(i-1).isLetter) i += 1\n   \
    \         if (aArr(i+1).isLetter && aArr(i-1).isLetter) i += 1\n            if\
    \ (aArr(i+1).isLetter && aArr(i).isLetter) i += 1\n            if (aArr(i+1).isLetter\
    \ && aArr(i).isLetter) i += 1\n            if (aArr(i-1).isLetter && aArr(i).isLetter)\
    \ i += 1\n            if (aArr(i-1).isLetter && aArr(i).isLetter) i += 1\n   \
    \         if (aArr(i).isLetter && aArr(i+1).isLetter) i += 1\n            if (aArr(i).isLetter\
    \ && aArr(i-1).isLetter) i += 1\n            if (aArr(i).isLetter && aArr(i+1).isLetter)\
    \ i += 1\n            if (aArr(i+1).isLetter && aArr(i-1).isLetter) i += 1\n \
    \           if (aArr(i+1).isLetter && aArr(i).isLetter) i += 1\n            if\
    \ (aArr(i-1).isLetter && aArr(i).isLetter) i += 1\n            if (aArr(i-1).isLetter\
    \ && aArr(i).isLetter) i += 1\n            if (aArr(i).isLetter && aArr(i+1).isLetter)\
    \ i += 1\n            if (aArr(i).isLetter && aArr(i-1).isLetter) i += 1\n   \
    \         if (aArr(i+1).isLetter && aArr(i-1).isLetter) i += 1\n            if\
    \ (aArr(i+1).isLetter && aArr(i).isLetter) i += 1\n            if (aArr(i+1).isLetter\
    \ && aArr(i).isLetter) i += 1\n            if (aArr(i-1).isLetter && aArr(i).isLetter)\
    \ i += 1\n            if (aArr(i-1).isLetter && aArr(i).isLetter) i += 1\n   \
    \         if (aArr(i).isLetter && aArr(i+1).isLetter) i += 1\n            if (aArr",
  "        if (b.length >= a.length) true\n        else {\n            var a1 = a.substring(0,b.length)\n\
    \            var b1 = b.substring(0,a.length)\n            val a2 = a.substring(b.length)\n\
    \            val b2 = b.substring(a.length)\n            val a1b1 = Array(a1,\
    \ b1)\n            val b1b1 = Array(b1, a1)\n            val a2b1 = Array(a2,\
    \ b2)\n            val b2b1 = Array(b2, a2)\n            val a1b2 = Array(a1,\
    \ b2)\n            val b1b2 = Array(b1, a2)\n            val a2b2 = Array(a2,\
    \ b1)\n            val b2b2 = Array(b2, a1)\n            val a1bb1 = Array(a1b1,\
    \ b1b1)\n            val b1bb1 = Array(b1b1, a1bb1)\n            val a2bbb1 =\
    \ Array(a2b1, b2b1)\n            val b2bbb1 = Array(b2b1, a2bbb1)\n          \
    \  val a1bb2 = Array(a1b2, b1b2)\n            val b1bb2 = Array(b1b2, a1bb2)\n\
    \            val a2bbb2 = Array(a2b2, b2b2)\n            val b2bbb2 = Array(b2b2,\
    \ a2bbb2)\n            var result = true\n            if (a1b1.intersect(a1b2).length\
    \ > 0 || a1b2.intersect(a1b1).length > 0) result = false\n            if (a2b1.intersect(a2b2).length\
    \ > 0 || a2b2.intersect(a2b1).length > 0) result = false\n            if (b1b1.intersect(b1b2).length\
    \ > 0 || b1b2.intersect(b1b1).length > 0) result = false\n            if (b2b1.intersect(b2b2).length\
    \ > 0 || b2b2.intersect(b2b1).length > 0) result = false\n            if (b1bb1.intersect(b1bb2).length\
    \ > 0 || b1bb2.intersect(b1bb1).length > 0) result = false\n            if (b2bbb1.intersect(b2bbb2).length\
    \ > 0 || b2bbb2.intersect(b2bbb1).length > 0) result = false\n            if (a1b1.intersect(a2b1).length\
    \ > 0 || a1b2.intersect(a2b2).length > 0) result = false\n            if (a2b1.intersect(a1b1).length\
    \ > 0 || a2b2.intersect(a1b2).length > 0) result = false\n            if (b1b1.intersect(b2b1).length\
    \ > 0 || b1b2.intersect(b2b2).length > 0) result = false\n            if (b2b1.intersect(b1b1).length\
    \ > 0 || b2b2.intersect(b1b2).length > 0) result = false\n            if (a1b1.intersect(a2b2).",
  "        if (b.nonEmpty) {\n            var c : String = \"\"\n            val l\
    \ = a.length\n            var pos = 0\n            val b = b.toUpperCase\n   \
    \         var i = 0\n            while (pos < l && a(pos) == b(i)) {\n       \
    \         pos += 1\n                i += 1\n            }\n            if (i ==\
    \ b.length) {\n                return true\n            }\n            val m =\
    \ a.length - 1\n            var pos = 0\n            val b = b.toUpperCase\n \
    \           var i = 0\n            while (pos < m && a(pos) == b(i)) {\n     \
    \           pos += 1\n                i -= 1\n            }\n            if (i\
    \ < 0) {\n                return false\n            }\n            val r = a.length\
    \ - pos\n            if (r < b.length) {\n                return false\n     \
    \       }\n            if (a.length > b.length) {\n                val r = b.length\n\
    \                i = 0\n                while (i < r) {\n                    if\
    \ (a.indexOf(b, i) < i) {\n                        return false\n            \
    \        }\n                    i += 1\n                }\n                i =\
    \ 0\n                while (i < r) {\n                    if (a.indexOf(b, i)\
    \ > i) {\n                        return false\n                    }\n      \
    \              i += 1\n                }\n                return true\n      \
    \      }\n            if (r > b.length) {\n                val r = a.length\n\
    \                i = 0\n                while (i < r) {\n                    if\
    \ (a.indexOf(b, i) < i) {\n                        return false\n            \
    \        }\n                    i += 1\n                }\n                i =\
    \ 0\n                while (i < r) {\n                    if (a.indexOf(b, i)\
    \ > i) {\n                        return false\n                    }\n      \
    \              i += 1\n                }\n                return true\n      \
    \      }\n            return false\n        }\n        if (b.isEmpty) {\n    \
    \        return true\n        }\n        return false", "        if (b.isEmpty)\
    \ true\n        else a.contains(b) || a.contains(\"_\" + b + \"_\") || cycpatternCheck(a.drop(b.length),\
    \ b.drop(a.length))", "        // if pattern is empty return true\n        if\
    \ (!a.isEmpty) {\n            // if pattern is empty return true\n           \
    \ if (!b.isEmpty) {\n                // for loop to create pattern\n         \
    \       for ((x, y) <- a zip b) {\n                    // if pattern is in word\
    \ return true\n                    if (x.contains(y) || y.contains(x)) {\n   \
    \                     return true\n                    }\n                }\n\
    \            } else {\n                return true\n            }\n        } else\
    \ {\n            return true\n        }", "        // This algorithm is O(n^2)\
    \ and could be optimized by using Set instead of List\n        val aSet = a.toSet\n\
    \        val bSet = b.toSet\n        if(aSet.subsetOf(bSet)) a contains b\n  \
    \      else aSet.subsetOf(bSet) || b.subsetOf(aSet)", "        val ab = a\n  \
    \      val bc = b\n        val bIndex = bc.indexOf(bc) + b.length\n        val\
    \ abIndex = ab.indexOf(a) + a.length\n        if (abIndex >= ab.length)\n    \
    \        true\n        else if (bIndex >= bc.length)\n            false\n    \
    \    else if (ab(bIndex) == b(bIndex) || ab(bIndex + 1) != b(bIndex) || ab(bIndex\
    \ + 2) != b(bIndex) || ab(bIndex + 3) != b(bIndex) || ab(bIndex + 4) != b(bIndex)\
    \ || ab(bIndex + 5) != b(bIndex) || ab(bIndex + 6) != b(bIndex))\n           \
    \ false\n        else\n            cycpatternCheck(ab.drop(abIndex), b.drop(bIndex))",
  "        def allRotationss(s : String, i : Int, j : Int) : List[String] = if(j ==\
    \ 0) List(s) else s.tails ::: allRotationss(s.tail, j - 1, i).reverse ::: allRotationss(s,\
    \ i + 1, j)\n        val allRotationss = allRotationss(a, 0, b.size)\n       \
    \ val subsetOfAllRotations = b.toSet.subsetOf(allRotationss.toSet)\n        subsetOfAllRotations.exists(b.contains(_))",
  "        // Add all characters in b into a set (to avoid duplicates)\n        var\
    \ c = new HashSet(b)\n        // Add all characters in a into a set (to avoid\
    \ duplicates)\n        var d = new HashSet(a)\n        \n        // Create a set\
    \ of all permutations of b\n        val perms = new mutable.HashSet[String]\n\
    \        perms ++= b permutations\n        \n        // Loop through all permutations\
    \ of b\n        for(i <- perms.iterator){\n            val perm = i\n        \
    \    \n            // Add all characters in perm to a set (to avoid duplicates)\n\
    \            perm+: c.removeAll(d) match {\n                case(_) => true\n\
    \                case(true) => false\n                case(false) => true\n  \
    \          }\n        }", "        var i = math.min(b.length, a.length) -1\n \
    \       var j = math.min(a.length, b.length) -1\n        var pattern = \"\"\n\
    \        while ((i <= j) && (i < b.length) && (j >= a.length)) {\n           \
    \ pattern += b(i)\n            i += 1\n            pattern += a(j)\n         \
    \   j -= 1\n        }\n        (pattern in a) || (pattern in b)", "        var\
    \ a = a.toCharArray\n        var b = b.toCharArray\n        var c = a.clone()\n\
    \        var d = b.clone()\n        val m = a.length\n        val n = b.length\n\
    \n        var ans = false\n        // Check a\n        for (i<- 0 to m-1) {\n\
    \            val x = a(i)\n            val y = c(m-i-1)\n            if (y >=\
    \ 0 && y <= n) c(i) = y(x)\n            else return false // out of range\n  \
    \      }\n        // Check b\n        for (i<- 0 to m-1) {\n            val x\
    \ = b(i)\n            val y = d(m-i-1)\n            if (y >= 0 && y <= n) d(i)\
    \ = y(x)\n            else return false // out of range\n        }\n        //\
    \ If string matches, then true\n        if ((a.length == b.length) && (a.toCharArray.distinctSet\
    \ == b.toCharArray.distinctSet)) {\n            ans = true\n        }\n      \
    \  ans", "      var max = 0\n      var n = a.length\n      var m = b.length\n\n\
    \      for(i = 0 to (n - m)) {\n          var k = (n + m) /2 // Find the mid-point\
    \ of the two strings\n\n          if(a.charAt(i) == b.charAt(k)) {\n         \
    \     max = Math.max(max, i + k)\n          }\n          else {\n            \
    \  max = Math.max(max, Math.min(i + k + 1, n + m))\n          }\n      }\n\n \
    \     return max == n", "        val a = a.replace(\"a\", \"\")\n        val b\
    \ = b.replace(\"a\", \"\")\n        for (i <- 0 until a.length) {\n          \
    \  for (j <- 0 until b.length) {\n                val char1 = a.charAt(i)\n  \
    \              val char2 = b.charAt(j)\n                if (char1 == char2)\n\
    \                    continue\n                if (char1 != \"a\" && char2 !=\
    \ \"a\" && char1 != \"b\" && char2 != \"b\" && char1 != \"c\" && char2 != \"c\"\
    \ && char1 != \"d\" && char2 != \"d\" && char1 != \"e\" && char2 != \"e\" && char1\
    \ != \"f\" && char2 != \"f\" && char1 != \"g\" && char2 != \"g\" && char1 != \"\
    h\" && char2 != \"h\" && char1 != \"i\" && char2 != \"i\" && char1 != \"j\" &&\
    \ char2 != \"j\" && char1 != \"k\" && char2 != \"k\" && char1 != \"l\" && char2\
    \ != \"l\" && char1 != \"m\" && char2 != \"m\" && char1 != \"n\" && char2 != \"\
    n\" && char1 != \"o\" && char2 != \"o\" && char1 != \"p\" && char2 != \"p\" &&\
    \ char1 != \"q\" && char2 != \"q\" && char1 != \"r\" && char2 != \"r\" && char1\
    \ != \"s\" && char2 != \"s\" && char1 != \"t\" && char2 != \"t\" && char1 != \"\
    u\" && char2 != \"u\" && char1 != \"v\" && char2 != \"v\" && char1 != \"w\" &&\
    \ char2 != \"w\" && char1 != \"x\" && char2 != \"x\" && char1 != \"y\" && char2\
    \ != \"y\" && char1 != \"z\" && char2 != \"z\") {\n                    return\
    \ false\n                }\n            }\n        }\n        return true", " \
    \       val b = b.tail\n        val a = a.tail\n        var found = false\n  \
    \      var i = 0\n        for (elt <- a until a.length + 1) {\n            found\
    \ = false\n            var j = 0\n            for (elt <- b until b.length + 1)\
    \ {\n                if (elt.toString.toLowerCase == a.substring(i, i + elt.toString).toLowerCase)\
    \ {\n                    found = true\n                    break\n           \
    \     }\n                j+=1\n            }\n            if (found == false)\
    \ {\n                return false\n            }\n            i+=1\n        }\n\
    \        return true", "        val a = a.toUpperCase\n        val b = b.toUpperCase\n\
    \        val a2 = Array.ofDim[Char](a.size)\n        val b2 = Array.ofDim[Char](b.size)\n\
    \        for(i <- 0 until a.size){\n            a2(i) = a(i)\n        }\n    \
    \    for(i <- 0 until b.size){\n            b2(i) = b(i)\n        }\n        //\
    \ compare the strings\n        val result = a.zip(b).map( x => if ( x(0) == x(1)\
    \ ) true else false ).toSet\n        // if the lengths are not the same or the\
    \ second string is longer than the first string\n        return a.size != b.size\
    \ || result.toSet.subset(a2).isEmpty", "        var ans = true\n        val set1\
    \ = b.toSet\n        val set2 = a.toSet\n        val set3 = new mutable.HashSet[String]()\n\
    \        val set4 = new mutable.HashSet[String]()\n        var i = 0\n       \
    \ while (i < b.length) {\n            val k = b.indexOf(b(i), i)\n           \
    \ if (k < 0) {\n                ans = false\n                break\n         \
    \   }\n            val j = i + k\n            if (j > b.length) break\n      \
    \      val c = b(i+k)\n            if (set1.contains(c)) {\n                ans\
    \ = true\n                set3.add(b)\n                set4.add(a)\n         \
    \       break\n            }\n            val a = b(i + k)\n            if (set2.contains(a))\
    \ {\n                ans = true\n                set3.add(b)\n               \
    \ set4.add(a)\n                break\n            }\n            val a = b.substring(0,\
    \ k)\n            val b = a.substring(b(i), b(i+k))\n            if (set2.contains(b))\
    \ {\n                ans = true\n                set3.add(b)\n               \
    \ set4.add(a)\n                break\n            }\n            if (set1.contains(a))\
    \ {\n                ans = true\n                set3.add(b)\n               \
    \ set4.add(a)\n                break\n            }\n            val b = a.substring(b(i),\
    \ b(i+k))\n            if (set2.contains(b)) {\n                ans = true\n \
    \               set3.add(b)\n                set4.add(a)\n                break\n\
    \            }\n            i += 1\n        }\n        if (ans) println(((set4.toSet\
    \ == set3.toSet) && (set4.toSet == set4.toSet)).toString)\n        ans", "   \
    \     val set = new mutable.HashSet[String]()\n        def isSameWord(a:String,\
    \ b:String) : Boolean = {\n            if(!b.contains(a)) return false\n     \
    \       else return true\n        }\n        def isSamePermutation(a:String, b:String)\
    \ : Boolean = {\n            if(a == b) return true\n            val sb = new\
    \ StringBuilder()\n            for(i <- 0 until b.length) sb.append(b.charAt(i))\n\
    \            for(i <- 0 until a.length) sb.append(a.charAt(i))\n            if(sb.toString\
    \ == b) return true\n            else return false\n        }\n        def isRotation(a:String,\
    \ b:String) : Boolean = {\n            if(a == b) return true\n            val\
    \ sb = new StringBuilder()\n            for(i <- 0 until a.length) sb.append(a.charAt(i))\n\
    \            for(i <- 0 until b.length) sb.append(b.charAt(i))\n            if(sb.toString\
    \ == b) return true\n            else return false\n        }\n        def isSubstring(a:String,\
    \ b:String) : Boolean = {\n            val sb = new StringBuilder()\n        \
    \    for(i <- 0 until a.length) sb.append(a.charAt(i))\n            for(i <- 0\
    \ until b.length) sb.append(b.charAt(i))\n            if(sb.toString == b) return\
    \ true\n            else return false\n        }\n        for(x <- a){\n     \
    \       if(b.contains(x)){\n                set += x\n            }\n        }\n\
    \        for(x <- b){\n            if(set.contains(x)){\n                return\
    \ true\n            }\n        }\n        for(x <- a){\n            for(y <- b){\n\
    \                if(isSamePermutation(x,y)){\n                    set += y\n \
    \               }\n            }\n        }\n        for(x <- b){\n          \
    \  for(y <- a){\n                if(isSamePermutation(x,y)){\n               \
    \     return true\n                }\n            }\n        }\n        for(x\
    \ <- a){\n            for(y <- b){\n                if(isRotation(x,y)==true){\n\
    \                    set += y\n                }\n            }\n        }\n \
    \       for(x <- b){\n            for(y <- a){\n                if(isRotation(x,y)==true){\n\
    \                    return true\n                }\n            }\n        }\n\
    \        for(x <- a){\n            for(y <- b){\n                if(isSubstring(x,y)){\n\
    \                    return true\n                }\n            }\n        }\n\
    \        for(x <- b){\n            for(y <- a){\n                if(isSubstring(x,y)){\n\
    \                    return true\n                }\n            }\n        }\n\
    \        false", "        var c = b.length\n        var d = a.length\n       \
    \ var subString = \"\"\n        var check = true\n        var found = true\n \
    \       for (i <- 0 until d) {\n            if (a.charAt(i) == b.charAt(i)) {\n\
    \                subString += a.charAt(i)\n            } else {\n            \
    \    subString += a.charAt(i)\n                for (j <- 0 until c) {\n      \
    \              if (a.charAt(i - j) == b.charAt(j)) {\n                       \
    \ subString += a.charAt(i - j)\n                        c = c-1\n            \
    \            d = d-1\n                        check = false\n                \
    \        break\n                    } else {\n                        subString\
    \ += a.charAt(i - j)\n                        c = c-1\n                      \
    \  d = d-1\n                        check = false\n                        break\n\
    \                    }\n                }\n            }\n        }\n        found\
    \ = true\n        for (i <- 0 until d) {\n            if (a.charAt(i) != b.charAt(i))\
    \ {\n                found = false\n                break\n            }\n   \
    \     }\n        if (found == true && check == true) {\n            return true\n\
    \        } else {\n            return false\n        }", "        val sub = a.toLowerCase\
    \ intersect b.toLowerCase \n        if(sub.isEmpty) a.toLowerCase == b.toLowerCase\n\
    \        else false", "        val aSub = a.toLowerCase\n        val bSub = b.toLowerCase\n\
    \        val aSet = a.toLowerCase + aSub\n        val bSet = b.toLowerCase + bSub\n\
    \        val bRevSet = reverse(bSet)\n        var found = false\n        a.foreach\
    \ { x =>\n            b.foreach { y =>\n                bRevSet.contains(y) &&\
    \ {\n                    bRevSet = reverse(bRevSet)\n                    aSet.contains(x)\
    \ && {\n                        aSet = a.toLowerCase + x\n                   \
    \     found = true\n                    }\n                }\n            }\n\
    \        }\n        found", "      a match {\n        case x if x startsWith b\
    \ => true\n        case x if x endsWith b => true\n        case _ => false\n \
    \     }", "        val aSet = a.toSet\n        val bSet = b.toSet\n        //\
    \ a contains substring b\n        if(aSet.subsetOf(bSet)) {\n            true\n\
    \        } else {\n            // find first index of a in b\n            def\
    \ findIt(s : String, i : Int = 0) = {\n                if(i < b.length) if(b.charAt(i)\
    \ == s.charAt(0)) findIt(s, i+1) else false\n            }\n            // find\
    \ all rotations of b in a\n            def findRotations(b : String, n: Int) =\
    \ {\n                var i = 0\n                var result = List[String]()\n\
    \                while(i < b.length) {\n                    val s = b.substring(i,\
    \ i + n) // e.g. \"bbb\"\n                    result ::= s\n                 \
    \   i+=n\n                }\n                result.reverse\n            }\n \
    \           // all rotations should be in b itself\n            def findRotationsInB(b\
    \ : String, n: Int) = {\n                var i = 0\n                var result\
    \ = List[String]()\n                while(i < b.length) {\n                  \
    \  val s = b.substring(i, i + n) // e.g. \"bbb\"\n                    result ::=\
    \ s\n                    i+=n\n                }\n                result\n   \
    \         }\n\n            val bIndex = bSet.indexOf(bSet)\n            val n\
    \ = 0\n            // all rotations should exist in a\n            val allRotations\
    \ = findRotationsInB(b, aSet.size)\n            val allRotationsInA = findRotationsInB(a,\
    \ n)\n\n            if(allRotationsInA.subsetOf(allRotations)) {\n           \
    \     true\n            } else {\n                // get all rotations which only\
    \ exists in b\n                val bOnly = allRotationsInA.filter(x => !allRotationsInA.contains(x))\n\
    \                // return true if this subset contains b\n                aSet.subsetOf(bOnly)\n\
    \            }\n        }", "        var c = a.tail\n        var d = b.tail\n\
    \        var index = a.indexOf(b)\n        var flag = false\n        if(c.tail.startsWith(d)\
    \ || d.tail.startsWith(c)) {\n            return true\n        }\n        else\
    \ {\n            while(index != -1) {\n                c =  c.dropRight(1)\n \
    \               d =  d.dropRight(1)\n                index = a.indexOf(b,index+1)\n\
    \                if((index != -1) && (c.tail.startsWith(d) || d.tail.startsWith(c)))\
    \ {\n                    return true\n                }\n            }\n     \
    \   }\n        return flag", "        var b = b.toUpperCase\n        var b2 =\
    \ b.toUpperCase.substring(b.length-1)\n        var b3 = b.toUpperCase.substring(0,b.length-1)\n\
    \n        if (b.length != a.length) \n            return false\n        if (b\
    \ == b2)\n            return true\n        \n        if (b.length == 1 && a.substring(0,b.length-1)\
    \ == b3)\n            return true\n        \n        var result = false\n    \
    \    var aIter = aIterator(b.toUpperCase)\n        var bIter = bIterator(b2)\n\
    \        while(aIter.hasNext) {\n            var a = aIter.next()\n          \
    \  var b = bIter.next()\n            val a2 = a.toUpperCase\n            val b2\
    \ = b.toUpperCase\n            val a3 = a2.substring(a2.length-1)\n          \
    \  val b3 = b2.substring(b2.length-1)\n            \n            if (a2.length\
    \ == b.length) \n                result = result == false || (a2.substring(a2.length-1)\
    \ == b2)\n            else if (a2.length == 1 && b3 != a && ((b2.substring(b2.length-1)\
    \ == a3 && b2.substring(b2.length-1) == b2)))\n                result = result\
    \ || (a2.substring(a2.length-1) == b2)\n            else if (a2.length == 1 &&\
    \ a3 != a && ((b2.substring(b2.length-1) == b3 && b2.substring(b2.length-1) ==\
    \ b2)))\n                result = result || (a2.substring(a2.length-1) == b2)\n\
    \        }\n        return result", "        if(a.length==0 || b.length==0) {\n\
    \            return false\n        }\n        var str1 = a.mkString.toLowerCase\n\
    \        var str2 = b.mkString.toLowerCase\n        var str3 = str2.mkString.toLowerCase\n\
    \        var str4 = str1.mkString.toLowerCase\n        var firstMatch = false\n\
    \        var lastMatch = false\n        var i = 0\n        var j = 0\n       \
    \ while (i<str1.length-1 && j<str2.length-1) {\n            if(str1(i) == str2(i))\
    \ {\n                firstMatch = true\n                i += 1\n             \
    \   j += 1\n            }\n            else if(str1(i) > str2(i)) {\n        \
    \        i += 1\n                j += 1\n            }\n            else {\n \
    \               j += 1\n            }\n        }\n        if(firstMatch && j==str2.length-1\
    \ && str4.indexOf(str2(0)) >= 0) {\n            true\n        }\n        else\
    \ if(firstMatch && j==str2.length-1 && str4.indexOf(str2(0)) < 0) {\n        \
    \    false\n        }\n        else if(lastMatch && i==str1.length-1 && str3.indexOf(firstMatch)\
    \ >= 0) {\n            true\n        }\n        else if(lastMatch && i==str1.length-1\
    \ && str3.indexOf(firstMatch) < 0) {\n            false\n        }\n        else\
    \ {\n            false\n        }", "        val first = a.toSet.toSet\n     \
    \   val second = b.toSet.toSet\n        val third = first.addAll(second)\n   \
    \     val fourth = first.subsetOf(second)\n        val fifth = third.subsetOf(fourth)\n\
    \        val sixth = fifth.subsetOf(third)\n        val seventh = sixth.subsetOf(fifth)\n\
    \        val eighth = seventh.subsetOf(sixth)\n        val ninth = eighth.subsetOf(eighth)\n\
    \        ninth.exists(x => a.indexOf(x) > -1 || b.indexOf(x) > -1 || a.contains(x))",
  "        val list = a.toUpperCase.split(\"(?!^)\")\n        if (b.toUpperCase ==\
    \ b) true\n        else {\n            val listb = b.toUpperCase.split(\"(?!^)\"\
    )\n            val result = list.filter(x => listb.contains(x)).exists(x => list.contains(x))\n\
    \        }\n        result", "        if (b.equals(a)) {\n            return true\n\
    \        }\n        val ab = a.toUpperCase\n        val ba = b.toUpperCase\n \
    \       val lista = ab.split(\" \")\n        val listb = ba.split(\" \")\n   \
    \     val listab = lista.map(x => x.swapcase)\n        val listba = listb.map(x\
    \ => x.swapcase)\n        listab.exists(x => listba.exists(y => x == y))", " \
    \       val aArray = a.split(\"\").map(_.toLower)\n        val bArray = b.split(\"\
    \").map(_.toLower)\n        val aHash = a.hashCode()\n        val bHash = b.hashCode()\n\
    \        val setA = Set(aArray)\n        val setB = Set(bArray)\n        val a\
    \ = a.hashCode()\n        val b = b.hashCode()\n        val diff = setA.diff(setB)\n\
    \        diff == 0 // true\n        val newA = a - bHash\n        val newB = b\
    \ - aHash\n        // diff.size() > 0 is also true\n        newA >= 0 && newB\
    \ >= 0 && diff.size() == 0", "        val a = a.toUpperCase\n        val b = b.toUpperCase\n\
    \        val setA = b.filter( c => a contains c)\n        val setB = a.filter(\
    \ c => b contains c)\n        setA.size == setB.size || setA.exists(setB.contains)",
  "        var result : Boolean = true\n        var c = a.toCharArray\n        var\
    \ d = b.toCharArray\n        var i : Int = -1\n        var j : Int = -1\n    \
    \    while (i < a.length - 1 && j < b.length - 1) {\n            i = a.indexOf(c,\
    \ i + 1)\n            j = b.indexOf(d, j + 1)\n            if (i == -1 || j ==\
    \ -1) {\n                result = false\n                break\n            }\n\
    \            else if (c.length < b.length) {\n                val x = c.slice(i,\
    \ c.length).iterator\n                val y = d.slice(j, d.length).iterator\n\
    \                if (x == y) {\n                    result = true\n          \
    \          break\n                }\n                else {\n                \
    \    result = false\n                    break\n                }\n          \
    \  }\n        }\n        result", "      if (a.length == 0 || b.length == 0)\n\
    \          return false\n      \n      var c = new HashSet[String]()\n      var\
    \ d = new HashSet[String]()\n      var i = 0\n      var j = 0\n      val l = a.length\n\
    \      val r = b.length\n      val m = r div l\n      val n = a.length\n     \
    \ \n      while (i < m && j < n) {\n        if (a(i) == b(j))\n          c +=\
    \ a(i)\n        else\n          d += a(i) + b(j)\n        i += 1\n        j +=\
    \ 1\n      }\n      \n      c.size == m && d.size == r", "        var check =\
    \ false;\n        for (i <- 0 until b.length) {\n            if (b.indexOf(b(i))\
    \ > -1) {\n                check = true\n                break\n            }\n\
    \        }\n        for (i <- 0 until a.length) {\n            if (a.indexOf(a(i))\
    \ > -1) {\n                check = true\n                break\n            }\n\
    \        }\n        check", "        val lista = a.split(\"\\\\s+\")\n       \
    \ val listb = b.split(\"\\\\s+\")\n        val len = lista.length\n        if(len\
    \ != listb.length) {\n            return false\n        }\n        val seta =\
    \ new mutable.HashSet[String]()\n        val setb = new mutable.HashSet[String]()\n\
    \        lista.foreach(x => {\n            if(!seta.contains(x)) {\n         \
    \       seta += x\n            }\n        })\n        listb.foreach(x => {\n \
    \           if(!setb.contains(x)) {\n                setb += x\n            }\n\
    \        })\n        val res = setb.subsetOf(seta)\n        if(res.size == len)\
    \ {\n            return true\n        }\n        return false", "        val a\
    \ = a.toUpperCase\n        val b = b.toUpperCase\n        val aWords = a.split(\"\
    \")\n        val bWords = b.split(\"\")\n        val aSet = aWords.toSet\n   \
    \     val bSet = bWords.toSet\n        val wordsInCommon = aSet.intersect(bSet).size\n\
    \        if (wordsInCommon <= 1) true\n        else false", "        var i = 0\n\
    \        val length = a.length\n        val sub = b.toUpperCase\n\n        val\
    \ pattern = a.toUpperCase.substring(i, length).mkString.toUpperCase\n        val\
    \ newWords = pattern.substring(b.length).split('')\n        newWords.sortWith(_\
    \ < _)\n        var start = 0\n        var found = false\n        var subPatternFound\
    \ = false\n        newWords.foreach {\n            if (found) {\n            \
    \    subPatternFound = false\n                return\n            }\n        \
    \    if (a(i) == sub(0)) {\n                start += 1\n                val found\
    \ = pattern.indexOf(sub, start) != -1\n                subPatternFound = found\n\
    \            }\n            if (a(i) != sub(0)) {\n                if (!subPatternFound)\
    \ {\n                    start = i + 1\n                    return\n         \
    \       }\n            }\n        }\n        return true", "        val aArray\
    \ = a.toCharArray\n        val bArray = b.toCharArray\n\n        var i = 0\n \
    \       var j = 0\n\n        while (i < aArray.length && j < bArray.length) {\n\
    \            val aChar = aArray(i)\n            val bChar = bArray(j)\n\n    \
    \        if (aChar != bChar) {\n                break\n            }\n       \
    \     i += if (aChar >= 'a') 1 else -1\n            j += if (aChar >= 'a') -1\
    \ else 1\n        }\n\n        i < (aArray.length - 1) && j < (bArray.length -\
    \ 1)", "        val aArray = a.split(\"\\\\W+\").toList\n        val bArray =\
    \ b.split(\"\\\\W+\").toList\n        var x = 1\n        var y = 1\n        var\
    \ aIndex = 0\n        var bIndex = 0\n        val aSize = a.length\n        val\
    \ bSize = b.length\n\n        // Check both a and b are of same size \n      \
    \  if (aSize != bSize) \n            return false\n\n        while(aIndex < aSize\
    \ && bIndex < bSize) {\n            // If x is less than or equal to the length\
    \ of the array a and the y length is equal to the length of the array b\n    \
    \        if(a(aIndex) == b(bIndex)) {\n                // increment x and y by\
    \ 1\n                x += 1\n                y += 1\n                // increment\
    \ x and y by 1\n                x += 1\n                y += 1\n            }\n\
    \            // If the x length is greater than the length of the array a\n  \
    \          else if (a(aIndex) > aSize) {\n                // increment x by 1\n\
    \                x += 1\n            }\n            // If the y length is greater\
    \ than the length of the array b\n            else if (b(bIndex) > bSize) {\n\
    \                // increment y by 1\n                y += 1\n            }\n\
    \            // If both x and y are equal\n            else if (x == y) {\n  \
    \              // increment both x and y by 1\n                x += 1\n      \
    \          y += 1\n            }\n            // If x is greater or equal to the\
    \ length of the array a and y length is lesser than or equal to the length of\
    \ the array b\n            else if (x <= aSize && y <= bSize) {\n            \
    \    // increment x by 1\n                x += 1\n                y += 1\n   \
    \         }\n            // If y is greater or equal to the length of the array\
    \ a and x length is lesser than or equal to the length of the array b\n      \
    \      else if (x <= aSize && y >= bSize) {\n                // increment y by\
    \ 1\n                y += 1\n                x += 1\n            }\n         \
    \   // If x and y are equal\n            else {\n                // increment\
    \ both x and y by 1\n                x += 1\n                y += 1\n        \
    \    }\n            aIndex += 1\n            bIndex += 1\n        }\n        if\
    \ (x != y) \n            return false\n        // If both x and y are equal\n\
    \        else if (x == y) {\n            // increment both x and y by 1\n    \
    \        x += 1\n            y += 1\n        }\n        // If x is greater or\
    \ equal to the length of the array a\n        else if (x <= aSize)\n         \
    \   return true\n        // If y is greater or equal to the length of the array\
    \ a\n        else\n            return false", "        var i = 0\n        val\
    \ a1 = a.toArray\n        val a2 = a1.copy(b, 0, b.length).reverse\n        var\
    \ j = 0\n        val a3 = a2.toArray\n        val l = a3.length\n        var k\
    \ = 0\n        val a4 = a3.copy(a2, 0, a2.length).reverse\n        val l1 = a4(0)\n\
    \        var m = 0\n        val a5 = a3.copy(a1, 0, a1.length).reverse\n     \
    \   val l2 = a5(0)\n        val l3 = a2.length\n        val l4 = a4.length\n \
    \       while ((i <= l1) || (j <= l2) || (k <= l3) || m <= l4) {\n           \
    \ val c = a3(k)\n            val d = a1(j)\n            if ((c == a2(i)) && (d\
    \ == a3(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a4(m)) && (d\
    \ == a5(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a5(m)) && (d\
    \ == a4(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a1(i)) && (d\
    \ == a2(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a2(i)) && (d\
    \ == a1(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a3(i)) && (d\
    \ == a4(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else if ((c == a4(i)) && (d\
    \ == a5(j))) {\n                i += 1\n                j += 1\n             \
    \   k += 1\n                m += 1\n            } else {\n                i =\
    \ 0\n                j = 0\n                k = 0\n                m = 0\n   \
    \         }\n        }\n        return i == l1", "        val wordListA = a.toUpperCase.split(\"\
    \\\\W+\").filter(_.nonEmpty)\n        val wordListB = b.toUpperCase.split(\"\\\
    \\W+\").filter(_.nonEmpty)\n        val a = wordListA.size\n        val b = wordListB.size\n\
    \        if (a.toLong > b.toLong) false\n        else if (a.toLong == b.toLong\
    \ && a == 0) true\n        else if a > 0 && !wordListB.exists(_ == wordListA.head)\
    \ false\n        else if a == 0 && b > 0 && !wordListA.exists(_ == wordListB.head)\
    \ false\n        else if a > 0 && b > 0 && wordListA.exists(wordListB.contains(_))\
    \ true\n        else if b > 0 && a > 0 && wordListA.exists(wordListB.contains(_))\
    \ true\n        else false", "        val a = a.toUpperCase\n        val b = b.toUpperCase\n\
    \n        var result = (a contains b)\n        for(i <- 1 to a.length-1) result\
    \ = result && (a.substring(i, a.length) contains b.substring(i))\n        result",
  "        val pattern = b.mkString(\"\").toCharArray\n        val c = a.toCharArray\n\
    \        val m = a.length\n        val n = b.length\n        val i = 1 // start\
    \ at 1 because index 0 will never be matched in a\n        val j = 0 // start\
    \ at 0 because index 0 will never be matched in a\n        val isMatch = false\n\
    \        while (i<=m && j<=n && isMatch == false) {\n            if (a(i) == pattern(j))\
    \ {\n                isMatch = true\n                if (i == m) {\n         \
    \           j++\n                }\n                if (j == n) {\n          \
    \          i++\n                }\n            } else if (a(i) == pattern(j))\
    \ {\n                i++\n                if (i == m) {\n                    j++\n\
    \                }\n            } else {\n                j++\n            }\n\
    \        }\n        isMatch", "        // Use Java 8 stream API\n        val aStream\
    \ = a.asScala.toStream\n        val bStream = b.asScala.toStream\n        aStream.exists\
    \ { x => bStream.exists(x => x.contains(x)) }", "        val sb = b.toUpperCase\n\
    \        val sa = a.toUpperCase\n        var lb = sa.length\n        var ls =\
    \ sb.length\n        val map = mutable.HashMap[String, String]()\n        var\
    \ k = 0\n        while (lb > 0 && ls > 0) {\n            val l1 = lb % sa.size\n\
    \            val r1 = if (ls > 0) ls/sa.size else 0\n            val r2 = if (ls\
    \ > 0) ls/lb else 0\n            var c = 0\n            var d = sa.size\n    \
    \        var e = 0\n            while (c < d-1) {\n                var l = sa\n\
    \                while (l != sb) {\n                    val i = l\n          \
    \          if (lb % d < sb(l)) {\n                        i = lb % d\n       \
    \             }\n                    l = i\n                }\n              \
    \  ls = l\n                e += 1\n                c += 1\n            }\n   \
    \         l += sa\n            e += 1 // if e > sa.size then we found a rotation\
    \ of b within a\n            if (e == sa.size) map += ((sb.reverse)(k) -> sb(reverse\
    \ - (sb - sa)))\n            k += 1\n            lb = l\n            ls = e\n\
    \        }\n        map.keySet.forall(!map.contains(_))", '      a contains b
    || b.contains(a) || b == a || b.find(a contains _) != b.lastIndexOf(a contains
    _)', "        // write your solution here\n        a.toSet.subsetOf(b.toSet) ||\
    \ b.toSet.subsetOf(a.toSet)", "        val a = a.toCharArray\n        val b =\
    \ b.toCharArray\n        val a = mutable.ArrayBuffer(a.reverse)\n        val b\
    \ = mutable.ArrayBuffer(b.reverse)\n        a.remove(b)\n        a.size > 0",
  "        var x = a.toList\n        var y = b.toList\n        var match = 0\n   \
    \     var count = 0\n        for( i <- 0 until a.length){\n            while(match\
    \ == 0) {\n                val index1 = x indexOf(a (i))\n                val\
    \ index2 = y indexOf(b (i))\n                if(index1 == -1) match = -1\n   \
    \             if(index2 == -1) match = -1\n                if(index1 != -1 &&\
    \ index2 != -1) {\n                    match += 1\n                    if(index1\
    \ == index2) {\n                        count += 1\n                    }\n  \
    \              }\n            }\n        }\n        if((b.length == a.length &&\
    \ count == b.length) || b.length == 0 && count == 0) {\n            return true\n\
    \        } else {\n            return false\n        }", "        val mapA = a.toList.map(_.toInt)\n\
    \        val mapB = b.toList.map(_.toInt)\n        var countA = 0\n        var\
    \ countB = 0\n        for (x <- mapA) {\n            countA += x\n        }\n\
    \        for (x <- mapB) {\n            countB += x\n        }\n        if (countA\
    \ > countB) {\n            for (x <- mapA) {\n                if (countB - x <=\
    \ countA) {\n                    return true\n                }\n            }\n\
    \        } else {\n            for (x <- mapB) {\n                if (countA -\
    \ x <= countB) {\n                    return true\n                }\n       \
    \     }\n        }\n        return false", "        if (b.indexOf(a) == -1)\n\
    \            false\n        else if (b.indexOf(b) == -1)\n            true\n \
    \       else {\n            val lena = b.length\n            val lenb = a.length\n\
    \            var aIndex = 0\n            var bIndex = 0\n            while (lena\
    \ > 0) {\n                aIndex = 0\n                while (lenb > 0) {\n   \
    \                 bIndex = 0\n                    while (lena > 0 && lenb > 0)\
    \ {\n                        if (a.charAt(aIndex) == b.charAt(bIndex)) {\n   \
    \                         aIndex += 1\n                            bIndex += 1\n\
    \                        }\n                        else {\n                 \
    \           aIndex += 1\n                        }\n                    }\n  \
    \                  if (aIndex == lena)\n                        return true\n\
    \                }\n                lena -= 1\n            }\n            val\
    \ lenb = b.length\n            val lena = a.length\n            aIndex = 0\n \
    \           bIndex = 0\n            while (lenb > 0) {\n                aIndex\
    \ = 0\n                while (lena > 0 && lenb > 0) {\n                    if\
    \ (a.charAt(aIndex) == b.charAt(bIndex)) {\n                        aIndex +=\
    \ 1\n                        bIndex += 1\n                    }\n            \
    \        else {\n                        aIndex += 1\n                    }\n\
    \                }\n                if (aIndex == lena)\n                    return\
    \ true\n                bIndex += 1\n            }\n            lenb -= 1\n  \
    \      }\n        false", "        if (b.isEmpty)\n            true\n        else\
    \ {\n            val bList = new collection.mutable.ListBuffer[String](b)\n  \
    \          var i = 0\n            while (i < b.length) {\n                val\
    \ nextB = bList(i to i + b.length)\n                if (a.contains(nextB))\n \
    \                   return true\n                i += (b.length)\n           \
    \ }\n        }\n        false", "        val b1 = new ListBuffer[String]()\n \
    \       val a1 = new ListBuffer[String]()\n        for(x <- b.split(\"\\\\W\"\
    )) {\n            b1 += x\n        }\n        for(x <- a.split(\"\\\\W\")) {\n\
    \            a1 += x\n        }\n        if(b1.nonEmpty) {\n            if(b1.size\
    \ < a1.size) {\n                b1 ++= a1.tail\n                a1 ++= b1.tail\n\
    \            } else {\n                a1 ++= b1.tail\n                b1 ++=\
    \ a1.tail\n            }\n        }\n        b1.toSet.subset(a1.toSet)", "   \
    \     if (b.length == a.length) {\n            if (b.indexOf(a) >= 0) {\n    \
    \            // Found it !\n                return true\n            } else {\n\
    \                // Not found it !\n                return false\n           \
    \ }\n        } else {\n            // The length of b is not equal to the length\
    \ of a\n            return false\n        }", "        val aL = a\n        val\
    \ bL = b\n        if(aL == null || bL == null){\n            return false\n  \
    \      }\n        val aLSplit = aL.split(\"\").toList\n        val bLSplit = bL.split(\"\
    \").toList\n        aLSplit.toSet intersect bLSplit.toSet", "        val aArr\
    \ = a.toCharArray\n        val bArr = b.toCharArray\n\n        val aLen = aArr.length\n\
    \        val bLen = bArr.length\n\n        if (bLen == 0 || aLen == 0) false\n\
    \        else if (bLen == 1 && aArr.exists(bArr(0))) true\n        else if (bLen\
    \ == aLen) aArr(0) == bArr(0)\n        else if (bLen > aLen) false\n        else\
    \ CycPatternCheck(bArr, aArr)", "        val rotB = b.toSeq.map(x => (x, x.toSeq.tail))\n\
    \        val rotA = a.toSeq.map(x => (x, x.toSeq.tail))\n        val map = mutable.Map[Int,\
    \ Int]()\n        val res = false\n        val aLen = a.length\n        val bLen\
    \ = b.length\n        for((n, m) <- 0 until aLen) {\n            val left = a(n).length\n\
    \            val right = b(m).length\n            for(i <- 0 until left) {\n \
    \               val k = math.max((i + 1), left)\n                for(j <- 0 until\
    \ right) {\n                    val l = math.min((j + 1), right)\n           \
    \         if(!map.contains((n + i, m + j))) map += (n + i -> 0)\n            \
    \        if(map.contains((n + i, m + j))) map += (n + i -> map.get(n + i)(0) +\
    \ 1)\n                    if(map.contains((n + i, m + j))) map += ((n + i, m +\
    \ j) -> map.get((n + i, j))(1) + 1)\n                }\n            }\n      \
    \      for(i <- 0 until right) {\n                val k = math.max((i + 1), right)\n\
    \                for(j <- 0 until left) {\n                    val l = math.min((j\
    \ + 1), left)\n                    if(!map.contains((n + i, m + j))) map += (n\
    \ + i -> 0)\n                    if(map.contains((n + i, m + j))) map += (n +\
    \ i -> map.get(n + i)(0) + 1)\n                    if(map.contains((n + i, m +\
    \ j))) map += ((n + i, m + j) -> map.get((n + i, j))(1) + 1)\n               \
    \ }\n            }\n        }\n        for((n, m) <- 0 until bLen) {\n       \
    \     val left = b(n).length\n            val right = a(m).length\n          \
    \  for(i <- 0 until left) {\n                val k = math.max((i + 1), left)\n\
    \                for(j <- 0 until right) {\n                    val l = math.min((j\
    \ + 1), right)\n                    if(!map.contains((n + i, m + j))) map += (n\
    \ + i -> 0)\n                    if(map.contains((n + i, m + j))) map += (n +\
    \ i -> map.get(n + i)(0) + 1)\n                    if(map.contains((n + i, m +\
    \ j))) map += ((n + i, m + j) -> map.get((n + i, j))(1) + 1)\n               \
    \ }\n            }\n            for(i <- 0 until right) {\n                val\
    \ k = math.max((i + 1), right)\n                for(j <- 0 until left) {\n   \
    \                 ", "      val b1 = b.toUpperCase\n      val a1 = a.toUpperCase\n\
    \      val a2 = a1.drop(1)\n      val b2 = b1.drop(1)\n      val a3 = a2.tail\n\
    \      val b3 = b2.tail\n      val a4 = a3.takeWhile(x => a1.contains(x))\n  \
    \    val b4 = b3.takeWhile(x => b1.contains(x))\n      (a4.length >= b4.length)\
    \ || (a4.length == b4.length && a4 == b4)", "        var found = false\n     \
    \   var start = a.indexOf(b, 0)\n        while (start >= 0) {\n            found\
    \ = true\n            a.substring(start, start + b.length).forall { x => found\
    \ = found && a.contains(x) }\n            start = a.indexOf(b, start + 1)\n  \
    \      }\n        found", "    \tval l = a.toSeq\n    \tval r = b.toSeq\n    \t\
    val lsize = l.length\n    \tval rsize = r.length\n    \tvar j = 0\n    \tvar k\
    \ = lsize\n    \tvar i = lsize - 1\n    \tvar matching = false\n    \twhile(j\
    \ < (lsize+rsize) && k >= 0 && !(j == lsize && k == rsize)){\n    \t\tif ((j ==\
    \ lsize && k > 0)){\n    \t\t\tif(l(i) == r(k))\n    \t\t\t\tk -= 1\n    \t\t\t\
    i -= 1\n    \t\t\tj -= 1\n    \t\t}else{\n    \t\t\tif(l(i) == r(k)){\n    \t\t\
    \t\tk += 1\n    \t\t\t\ti -= 1\n    \t\t\t\tj -= 1\n    \t\t\t\tmatching |= true\n\
    \    \t\t\t}else{\n    \t\t\t\ti -= 1\n    \t\t\t\tj -= 1\n    \t\t\t}\n    \t\
    \t}\n    \t}\n    \tif (j == (lsize+rsize))\n    \t\treturn matching\n    \telse\
    \ return false", "        val a = a.toLowerCase \n        val b = b.toLowerCase\
    \ \n        var x = a.indexOf(b)\n        var y = b.indexOf(a)\n        var i\
    \ = 0\n        while (y > x && x > -1) {\n            x = a.indexOf(b, i + 1)\n\
    \            y = b.indexOf(a, i + 1)\n            i ++\n        }\n        if\
    \ (y > x && x > -1)\n            return true\n        return false", '        //
    Your code here!', "        // Check words a and b are the same length\n      \
    \  if (b.length != a.length) {\n            return false\n        }\n        var\
    \ aWords = a.toUpperCase().toCharArray\n        var bWords = b.toUpperCase().toCharArray\n\
    \        var wordMatch = new Array[Char](a.length)\n        var wordMatchCount\
    \ = new Array[Int](a.length)\n        var aWordIndex = 0\n        var bWordIndex\
    \ = 0\n\n        for(i <- 0 until b.length) {\n            var matchChar = true\n\
    \            var index\n            for(j <- 0 until a.length) {\n           \
    \     index = aWords(aWordIndex) - bWords(bWordIndex)\n                if(index\
    \ >= 0 && index < b.length) {\n                    wordMatch(aWords(aWordIndex))\
    \ = bWords(bWordIndex)\n                    wordMatchCount(aWordIndex) = index\n\
    \                    aWordIndex += 1\n                }\n                bWordIndex\
    \ += 1\n            }\n            if(matchChar && (bWordIndex != a.length)) {\n\
    \                matchChar = false\n            }\n        }\n        return (wordMatchCount.toArray.max\
    \ > 0 && aWordIndex == wordMatchCount.toArray.max)", "        if(b.length == 0)\
    \ true\n        else if(b.head == a.head) cycpatternCheck(a, b.rest) else cycpatternCheck(a.rest,\
    \ b.tail)", "      val set = b.toSet\n      val aset = a.toSet\n      val intersection\
    \ = aset.intersect(set)\n      return intersection.isEmpty", "        if (b.contains(a)\
    \ || b.contains(a.drop(1))) \n            true\n        else\n            cycpatternCheck(a,a.drop(1))",
  "      if (a.isEmpty) b.isEmpty || (b.length == 0 && a.length == 0)\n      else\
    \ a.head == b.head || (cycpatternCheck(a.tail, b.tail) && a.take(a.length - b.length)\
    \ == b)", "        val aArray = a.toUpperCase.split('')\n        val bArray =\
    \ b.toUpperCase.split('')\n        if(aArray.length != bArray.length) false\n\
    \        else {\n            val rotatedArray = bArray.zip(Array().init[String](aArray.length))\n\
    \            val rotatedArrayReversed = rotatedArray.filter(_._1 == aArray.length)\n\
    \            aArray.reverse.zip(rotatedArrayReversed).forall { t =>\n        \
    \        if(t._1.toUpperCase(0) != t._1.toUpperCase(1) || t._1 != t._2) false\n\
    \                else {\n                    cycpatternCheck(t._2, t._1)\n   \
    \             }\n            }\n        }", "        // Check length of strings\
    \ A and B\n        if(b.length != a.length) return false\n\n        // Use scala.collection.mutable.Set\
    \ to find all occurrences of b in a\n        val setA = scala.collection.mutable.Set.empty[String]\n\
    \        for(i <- 0 until a.length) {\n            val c = a.charAt(i)\n     \
    \       val k = b(c)\n            if(setA.contains(k)) {\n                return\
    \ true\n            }\n            setA += k\n        }\n\n        return false",
  "      var subset = false\n      var found = false\n      for( c <- a.chars) {\n\
    \        subset = (b.contains(c) || b.substring(b.lastIndexOf(c),b.length).contains(c))\n\
    \        if(subset)\n          found = true\n      }\n      found", "        def\
    \ rotation(s : String) : String = s.tails.mkString(\"\")\n        val aList =\
    \ a.toList\n        val bList = b.toList\n        val rotList = aList.map( l =>\
    \ rotation(l)).filter( s => bList.contains(s))\n        bList.contains(a(bList.filter(\
    \ l => rotList.contains(l))))", "        if (a == null || b == null || b.isEmpty)\
    \ {\n            return false\n        }\n\n        // TODO: replace with efficient\
    \ implementation\n        def dfs(a: String, b: String, c: List[String], d: List[String]):\
    \ Boolean = {\n            if (c == Nil && d == Nil) {\n                return\
    \ true\n            } else if (c == Nil) {\n                return false\n   \
    \         } else {\n                return c.contains(a) || d.contains(b)\n  \
    \          }\n        }\n\n        def dfsHelper(a : String, b : String, c: List[String],\
    \ d: List[String], visited: mutable.Set[String]): Boolean = {\n            if\
    \ (c == Nil && d == Nil) {\n                return true\n            } else if\
    \ (c == Nil) {\n                return false\n            } else if (visited.contains(a))\
    \ {\n                return false\n            } else if (visited.contains(b))\
    \ {\n                return false\n            }\n\n            visited += a\n\
    \            visited += b\n            if (dfs(a, b, c, d)) {\n              \
    \  return true\n            } else {\n                visited -= a\n         \
    \       visited -= b\n                dfsHelper(a, b, c.tail, d.tail, visited)\n\
    \            }\n        }\n\n        def findPattern(a: String, b : String, c:\
    \ List[String], d: List[String]): List[String] = {\n            var res = ListBuffer()\n\
    \            dfsHelper(a, b, c, d, Set(a, b))\n            res.append(a)\n   \
    \         res.append(b)\n            res.toList\n        }\n\n        val patterns\
    \ = findPattern(a, b, List(a, b), List(a, b))\n        patterns.contains(b)",
  "        val aList = a.toCharArray\n        val bList = b.toCharArray\n        val\
    \ aSet = a.toSet\n        val bSet = b.toSet\n        val aDict = collection.mutable.HashMap[Char,\
    \ Int]()\n        val bDict = collection.mutable.HashMap[Char, Int]()\n\n    \
    \    // count occurences\n        b.foreach(c => {\n            aSet.contains(c)\
    \ match {\n                case true =>\n                    aDict.put(c, aDict.getOrElse(c,\
    \ 0) + 1)\n                case false =>\n                    aDict.put(c, aDict.getOrElse(c,\
    \ 0))\n            }\n        })\n\n        a.foreach(c => {\n            bSet.contains(c)\
    \ match {\n                case true =>\n                    bDict.put(c, aDict.getOrElse(c,\
    \ 0) + 1)\n                case false =>\n                    bDict.put(c, aDict.getOrElse(c,\
    \ 0))\n            }\n        })\n\n        // check if any of word's letters\
    \ match with any of pattern's letters\n        (aDict.keys.toSet.subsetOf(bDict.keys.toSet)\
    \ && aDict.values.toSet.subsetOf(bDict.values.toSet)) match {\n            case\
    \ true => true\n            case false => false\n        }", "        var check\
    \ = true\n        var n = a.length\n        var m = b.length\n        val aArray\
    \ = a.toCharArray\n        val bArray = b.toCharArray\n        if(m==0) {\n  \
    \        check = false\n        }\n        else {\n          val m = m.toInt\n\
    \          if(m<0) {\n            check = false\n          }\n          else {\n\
    \            for(i<- 0 to m-1){\n              val k = i+1\n              val\
    \ temp = aArray(i) ^ aArray(k)\n              if(temp != bArray(i)) {\n      \
    \          check = false\n                break\n              }\n           \
    \ }\n          }\n        }\n        check\n      }\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=algorithm,data-structures,string,substring dscore=1 |>\nHere's my solution:\n\
    <code>\npublic boolean isSubString(String str, String str2) {\n    char[] strArray\
    \ = str.toCharArray();\n    char[] str2Array = str2.toCharArray();\n    int i\
    \ = 0;\n    int j = 0;\n    boolean result = true;\n    while (strArray.length\
    \ != 0) {\n        if (i == str2Array.length || j == strArray.length) {\n    \
    \        result = false;\n            break;\n        }\n        if (str2Array[i]\
    \ == strArray[j]) {\n            i++;\n            j++;\n        } else {\n  \
    \          i = 0;\n            j = 0;\n        }", "        val wordSet = new\
    \ HashSet[String]\n        val wordSetB = new HashSet[String]\n\n        //convert\
    \ the words to list\n        val aList = a.split(\"\\\\W+\").toList\n        val\
    \ bList = b.split(\"\\\\W+\").toList\n        //iterate through each character\n\
    \        aList.foreach(c => { //if c is vowel add it to aList\n            if\
    \ (c.isUpper)\n                wordSet.add(c)\n            else\n            \
    \    wordSet.remove(c)\n        })\n        bList.foreach(c => { //if c is vowel\
    \ add it to bList\n            if (c.isUpper)\n                wordSetB.add(c)\n\
    \            else\n                wordSetB.remove(c)\n        })\n        //checks\
    \ words that start with the smaller string and have the same length\n        if\
    \ (wordSet.isEmpty && wordSetB.isEmpty)\n            return false\n        else\
    \ if (wordSet.isEmpty || wordSetB.isEmpty)\n            return true\n        else\
    \ if (wordSet.size < wordSetB.size)\n            return false\n        else if\
    \ (wordSet.size == wordSetB.size)\n            return true\n        else{\n  \
    \          //iterate through each word\n            val aIterator = aList.iterator\n\
    \            val bIterator = bList.iterator\n            while (aIterator.hasNext\
    \ && bIterator.hasNext) {\n                //if the characters in the word are\
    \ the same in both strings\n                val aChar = aIterator.next\n     \
    \           val bChar = bIterator.next\n                //check if the character\
    \ is in the larger string and if the word starts with the smaller string\n   \
    \             if (wordSet.contains(aChar) && wordSetB.contains(bChar))\n     \
    \               return true\n                //check if the character is in the\
    \ smaller string and if the word starts with the larger string\n             \
    \   else if (wordSet.contains(bChar) && wordSetB.contains(aChar))\n          \
    \          return true\n            }\n            return false\n        }", " \
    \       val aLen = a.replaceAll(\"\\\\s+\", \"\").toCharArray\n        val bLen\
    \ = b.replaceAll(\"\\\\s+\", \"\").toCharArray\n        if (b.length != a.length)\
    \ {\n            false\n        } else {\n            val sb = a.substring(b.length).toString.toCharArray\n\
    \            val as = a.substring(b.length + b.length / 2).toString.toCharArray\n\
    \            val sbReverse = ArrayUtil.reverse(sb)\n            val asReverse\
    \ = ArrayUtil.reverse(as)\n            val sbRcount = sc.makeRDD(sbReverse.indices.map(i\
    \ => sbReverse(i)))\n            val asRcount = sc.makeRDD(asReverse.indices.map(i\
    \ => asReverse(i)))\n            val bRcount = sc.makeRDD(b.toString.indices.map(i\
    \ => b(i)))\n            var ccount = sc.makeRDD(Array(0, b.length))\n       \
    \     for ((c, i) in bRcount.zipWithIndex) {\n                ccount = ccount.map({\n\
    \                    case (r, i) => (r + i, r + i + 1) })\n            }\n   \
    \         ccount = ccount.join(sbRcount).join(asRcount)\n            val ccountRcount\
    \ = sc.makeRDD(ccount.map(i => (i._2, i._1)))\n            var sbFound = false\n\
    \            var asFound = false\n            val sbFoundRcount = sc.makeRDD(sbFound.indices.map(i\
    \ => sbFound(i)))\n            var asFoundRcount = sc.makeRDD(asFound.indices.map(i\
    \ => asFound(i)))\n            for ((_, resp) in ccountRcount.zipWithIndex) {\n\
    \                if (resp._2 > a.length) {\n                    false\n      \
    \          } else {\n                    val pos = resp._1\n                 \
    \   val sb = a.substring(pos, pos + resp._2)\n                    val aPos = sbFound.filter(x\
    \ => x._1 == pos)\n                    if (aPos.size > 0) {\n                \
    \        asFoundRcount = asFoundRcount.map({\n                            case\
    \ (x, y) => if (y == 1) x else x + y })\n                        if (asFoundRcount.map(x\
    \ => x == resp._2).sum > 1) {\n                            true\n            \
    \            } else {\n                            sbFoundRcount = sbFoundRcount.map({\n\
    \                                case (x, y) => if (y == 1) x else x + y })\n\
    \                            if (sbFoundRcount.map(x => x == resp._2).sum > 1)\
    \ {\n                                true\n                            } else\
    \ {\n                                sbFound = true\n                        \
    \    }\n                        }\n                    } else {\n            \
    \            sbFound = false\n                    }\n                    val as\
    \ = a.substring(pos + resp._2, pos + resp._2 + resp._2)\n                    val\
    \ aPos = asFo", "        val wordA = a.split(\"\").map(_.toInt)\n        val wordB\
    \ = b.split(\"\").map(_.toInt)\n        var subStringFound = false\n        var\
    \ i = 0\n        while(i < wordB.length)\n        {\n            if(wordA(wordB(i))\
    \ > -1)\n            {\n                subStringFound = true\n              \
    \  i = 0\n            }\n            else\n            {\n                if(wordA(wordB(i))\
    \ > -1)\n                {\n                    i = wordB.length\n           \
    \     }\n                else\n                {\n                    i -= 1\n\
    \                }\n            }\n        }\n        subStringFound", "     \
    \   val aSubSet = b.toSet - a.toSet\n        val bSubSet = a.toSet - b.toSet\n\
    \        if (aSubSet isEmpty || bSubSet isEmpty) {\n            if (aSubSet ==\
    \ bSubSet)\n                true\n            else\n                false\n  \
    \      } else {\n            val aSubSetSize = aSubSet.iterator\n            val\
    \ bSubSetSize = bSubSet.iterator\n            while (aSubSetSize.hasNext && bSubSetSize.hasNext)\
    \ {\n                val temp = aSubSetSize.next\n                val temp2 =\
    \ bSubSetSize.next\n                if (temp == temp2)\n                    cycpatternCheck(a,\
    \ temp) || cycpatternCheck(temp, b)\n                else\n                  \
    \  false\n            }\n            true\n        }", "        // Find all permutations\
    \ of a and b\n        val aPerms = permutations(a)\n        val bPerms = permutations(b)\n\
    \        var result = false\n        // for each permutation of a, check if it\
    \ contains all chars of b\n        aPerms.foreach(elem => {\n            bPerms.foreach(bPerm\
    \ => {\n                // if both a and b match exactly, then return true\n \
    \               val aMatch = bPerm.toSet.subsetOf(elem.toSet)\n              \
    \  if (aMatch) {\n                    result = true\n                    return\n\
    \                }\n            })\n        })\n        result", "        val\
    \ c = a.toUpperCase ++ b.toUpperCase // create a mutable copy of 'a' and 'b' so\
    \ that we don't modify them\n        val d = c.toLowerCase // create a mutable\
    \ copy of 'c' so that we don't modify 'c'\n        var index1 = d.indexOf(\"a\"\
    ) // index of the first 'a' in 'c'\n        var index2 = d.indexOf(\"b\") // index\
    \ of the second 'b' in 'c'\n        if (index2 == -1 || index1 == -1) return false\
    \ // no matches are found\n        if (index2 > index1) {\n            index2\
    \ = index2 - 1\n        } else {\n            index1 = index1 - 1\n        }\n\
    \        if (index2 != -1 && index2 != index1) return false // if the second word\
    \ starts after the first word\n        var found = false // boolean to keep track\
    \ of whether a match has been found\n        c #:: c.init\n        d #:: d.init\n\
    \        while(index1 != -1 && found == false){\n            index2 = index2 +\
    \ 1\n            if (index2 < c.length && c.charAt(index2) == d.charAt(index1)){\n\
    \                index1 = index1 + 1\n                found = true // a match\
    \ is found\n            }\n        }\n        return found", "        var isMatch\
    \ = true\n        var a1 = mutable.Set(a).iterator.map(_.toInt).sorted\n     \
    \   var b1 = mutable.Set(b).iterator.map(_.toInt).sorted\n        var b2 = b1.reverse.filter(p\
    \ => a1.contains(p))\n        b.foreach(p => if (!b2.contains(p)) {\n        \
    \    isMatch = false\n        }\n        )\n        return isMatch", "      var\
    \ a : String = b\n      var b : String = a\n\n      val abSet = Set(a)\n     \
    \ val bcSet = Set(b)\n\n      val commonSub = abSet.intersect(bcSet)\n      if\
    \ (commonSub == abSet) true\n      else if (commonSub == bcSet) false\n      else\
    \ cycpatternCheck(a.replace(\"[\", \"\").replace(\"]\", \"\").replace(\" \", \"\
    \"), b.replace(\"[\", \"\").replace(\"]\", \"\").replace(\" \", \"\"))", "   \
    \     val a_ = a.toList\n        val b_ = b.toList\n        val a_n = a_.mkString.length\n\
    \        val b_n = b_.mkString.length\n        if (b_n <= a_n)\n            b_\
    \ == a_\n        else\n            a_ == b_", "        val l = a.length\n    \
    \    val l = b.length\n        if (l == 0) true\n        else if (!isCyclic(l))\
    \ false\n        else cycpatternCheck(a, b.subSeq(0, a.length-1))", "        val\
    \ aChars = a.toCharArray\n        val bChars = b.toCharArray\n        var pos\
    \ = 0\n        for (i <- 0 until a.length - 1) {\n            pos = i\n      \
    \      for(j <- 0 until b.length - 1) {\n                if(aChars(pos) != bChars(j))\n\
    \                    pos = pos - 1\n                else if(aChars(pos) == bChars(j))\n\
    \                    pos = pos + 1\n            }\n        }\n        pos <= 0",
  "        // TODO Auto-generated method stub\n        var result: Boolean = false\n\
    \        var len: Int = a.length\n        var i: Int = 0\n        var j: Int =\
    \ b.length\n        var minLen: Int = 0\n        while(i < len && j < len) {\n\
    \            if(a.charAt(i) == b.charAt(j)) {\n                i += 1\n      \
    \          j += 1\n            } else {\n                if(a.charAt(i) < b.charAt(j))\
    \ {\n                    i += 1\n                } else if(a.charAt(i) > b.charAt(j))\
    \ {\n                    j += 1\n                } else {\n                  \
    \  if(i == len) {\n                        result = true\n                   \
    \     break\n                    }\n                    if(j == len) {\n     \
    \                   break\n                    }\n                    val temp\
    \ = a(i, j)\n                    var m: Int = 0\n                    for(k <-\
    \ 0 until len) {\n                        if(a(i + k, j) == temp) {\n        \
    \                    m = k\n                            break\n              \
    \          }\n                    }\n                    i += 1\n            \
    \        j = m + 1\n                }\n            }\n        }\n        if(a.charAt(len\
    \ - 1) == b.charAt(len - 1)) {\n            minLen = len\n        }\n        if(len\
    \ < minLen) {\n            result = (len == 0)\n        }\n        return result",
  "        val aSet = a.toSet\n        val bSet = b.toSet\n        val bSetString\
    \ = aSet.map(bSet.toSeq.contains).toSet\n        aSet.subsetOf(b.toSeq).exists(bSetString.contains)",
  "        var lastMatch = 0\n        for (i <- 0 until a.length) {\n            var\
    \ match = lastMatch\n            var m = i\n            while (match != -1 &&\
    \ m < b.length) {\n                if (a(i) == b(m)) {\n                    if\
    \ (match != i) {\n                        lastMatch = match\n                \
    \        lastMatch = i\n                        m = i\n                    } else\
    \ {\n                        m += 1\n                    }\n                }\
    \ else {\n                    if (lastMatch != -1) {\n                       \
    \ m += 1\n                    } else {\n                        match += 1\n \
    \                   }\n                }\n            }\n        }\n        lastMatch\
    \ != -1", "        val aMap = new mutable.HashMap[String, String]()\n        var\
    \ found = false\n        a.map(x => aMap += (x -> \"\"))\n        b.map(x => aMap\
    \ += (x -> \"\"))\n        val aMapKeys = aMap.keySet.toSeq.sorted\n        val\
    \ bMapKeys = aMap.keySet.toSeq.sorted\n        var maxi = 0\n        var maxj\
    \ = 0\n        var i = 0\n        var j = 0\n        while(i < aMapKeys.size &&\
    \ !found) {\n            while(j < bMapKeys.size && !found) {\n              \
    \  if (aMapKeys(i) == bMapKeys(j)) {\n                    found = true\n     \
    \           } else {\n                    found = false\n                }\n \
    \               j += 1\n            }\n            i += 1\n            maxi =\
    \ i\n            j += 1\n            if(!found) {\n                j = 0\n   \
    \         }\n        }\n        if (maxi == bMapKeys.size) {\n            found\
    \ = true\n        }\n        return found", "        val r = new ListBuffer[String]()\n\
    \        var c = false\n        for(i <- 0 until a.length-1){\n            for(j\
    \ <- 0 until b.length-1){\n                if(a(i) == b(j)){\n               \
    \     if(j==0){\n                        r.+=b\n                    }\n      \
    \              else {\n                        r.+=(b.substring(0,j))\n      \
    \              }\n                    c=true\n                }\n            }\n\
    \        }\n        c", "        val aArray = a.toCharArray.sorted\n        val\
    \ bArray = b.toCharArray.sorted\n        var last = 0\n        var i = a.length\
    \ - 1\n        var j = b.length - 1\n        while(i >= 0 || j >= 0) {\n     \
    \       val temp = aArray(i)\n            val temp2 = bArray(j)\n            val\
    \ charMatch = temp == temp2\n            val isLast = i == a.length - 1\n    \
    \        val isFirst = j == b.length - 1\n            if(charMatch && (isFirst\
    \ || isLast)) {\n                println(\"MATCH: \" + a + b)\n              \
    \  i = a.length - 1\n                j = b.length - 1\n            } else if(charMatch\
    \ && isFirst) {\n                println(\"MATCH: \" + a + b)\n              \
    \  i -= 1\n                j = b.length - 1\n            } else if(charMatch &&\
    \ isLast) {\n                println(\"MATCH: \" + a + b)\n                i -=\
    \ 1\n                j -= 1\n            } else {\n                println(\"\
    NO MATCH: \" + a + b)\n                i -= 1\n                j -= 1\n      \
    \      }\n        }\n        true", '      a.pattern <:< b.pattern', "       \
    \ val bArray = b.toArray\n        val aArray = a.toArray\n        val set1 = new\
    \ HashSet[bArray]\n        val set2 = new HashSet[aArray]\n        val intersection\
    \ = new HashSet[bArray]\n        val union = new HashSet[aArray]\n        val\
    \ common = new HashSet[bArray]\n        val bLen = new HashSet[bArray]\n     \
    \   val aLen = new HashSet[aArray]\n        val bIsSubSet = new HashSet[bArray]\n\
    \        val aIsSubSet = new HashSet[aArray]\n\n        for(i <- 0 until a.length){\n\
    \            val b = bArray(i)\n            val a = aArray(i)\n            bLen.add(b.length)\n\
    \            aLen.add(a.length)\n            bIsSubSet.add(b)\n            aIsSubSet.add(a)\n\
    \        }\n        for(i <- 0 until b.length){\n            val a = aArray(i)\n\
    \            val b = bArray(i)\n            set1.add(b)\n            set2.add(a)\n\
    \            intersection.add(b)\n            intersection.add(a)\n          \
    \  union.addAll(intersection)\n            union.addAll(bIsSubSet)\n         \
    \   common.addAll(union)\n        }\n        if(set1.size == set2.size && set1.size\
    \ == common.size){\n            if(set1.size == b.length){\n                val\
    \ c1 = new Array[bArray.length]\n                val c2 = new Array[aArray.length]\n\
    \                val commonArray = new Array[String](b.length)\n             \
    \   val bArrayIndex = 0\n                val aArrayIndex = 0\n               \
    \ val bArrayIndexTemp = 0\n                val aArrayIndexTemp = 0\n         \
    \       for(i <- 0 until b.length){\n                    c1.update(bArrayIndex,\
    \ b(i))\n                    c2.update(aArrayIndex, a(i))\n                  \
    \  commonArray(i) = c2.get(aArrayIndexTemp)\n                    aArrayIndexTemp\
    \ += 1\n                    bArrayIndexTemp += 1\n                }\n        \
    \        for(i  <- 0 until aArray.length){\n                    if(c2.get(aArrayIndex)\
    \ == commonArray(i)){\n                        return true\n                 \
    \   }\n                    aArrayIndexTemp += 1\n                    bArrayIndexTemp\
    \ += 1\n                }\n            }\n            if(set1.size == a.length){\n\
    \                val c1 = new Array[aArray.length]\n                val c2 = new\
    \ Array[bArray.length]\n                val commonArray = new Array[String](a.length)\n\
    \                val aArrayIndex = 0\n                val bArrayIndex = 0\n  \
    \              val aArrayIndexTemp = 0\n                val bArrayIndexTemp =\
    \ 0\n", "        var r = a.indexOf(b);\n        val r = a.lastIndexOf(b);\n  \
    \      val l = a.indexOf(b.reverse);\n        val l = a.lastIndexOf(b.reverse);\n\
    \        if(a == null || b == null || r == null || l == null || r >= 0 || l >=\
    \ 0 || r > l ) return false\n        else if(a == b || r < 0) return true\n  \
    \      else if(a == b.reverse || l < 0) return true\n        else\n          if(a.length\
    \ < b.length) cycpatternCheck(b.slice(1, b.length+1), a)\n          else cycpatternCheck(a.slice(1,\
    \ a.length+1), b)", "        val n = a.length - b.length\n        if (n == 0)\
    \ true\n        else if (n == 1) a contains b\n        else cycpatternCheck(a,\
    \ b + a.substring(0,1))", "        var a = a\n        var b = b\n        //System.out.println(a.substring(0,a.length()-1)\
    \ + \", \" + b.substring(0,b.length()-1) + \", \" + a.indexOf(b) + \", \" + b.indexOf(a))\n\
    \        if (a.substring(0,a.length()-1) + \", \" + b.substring(0,b.length()-1)\
    \ + \", \" + a.indexOf(b) + \", \" + b.indexOf(a) == -1)\n            return false\n\
    \        else\n            return true", "        var aArray = a.toArray\n   \
    \     var bArray = b.toArray\n        var l1 = aArray.length\n        var l2 =\
    \ bArray.length\n        var isMatched = false;\n\n        for (i<- 0 until l1){\n\
    \            if (i==l2){\n                if ((aArray(i)==bArray(i)) && (aArray.drop(i).isEmpty)){\n\
    \                    isMatched = true;\n                }\n            }\n   \
    \         else if ((i!=l1) && !(aArray(i) == bArray[i])){\n                var\
    \ found = false;\n                var tempArray = new Array[Char](l2)\n      \
    \          for (j <- 0 until l2){\n                    tempArray(j) = aArray(i+j)\n\
    \                }\n                tempArray(i) = bArray(i);\n              \
    \  var isMatched = false;\n                var tempArray2 = new Array[Char](l2)\n\
    \                for (j <- 0 until l2){\n                    if (tempArray(j)\
    \ == bArray(j)){\n                        isMatched = true;\n                \
    \        break;\n                    }\n                }\n                if\
    \ ((isMatched) && tempArray.length == l2){\n                    isMatched = true;\n\
    \                }\n            }\n        }\n        isMatched", "        var\
    \ flag = true\n        val m = a.length\n        val n = b.length\n        var\
    \ i = 0\n        while (i < n && i < m) {\n            if((b(i).isLetter || b(i).isDigit)\
    \ && flag) {\n                var j = i\n                while (j < n && j < m\
    \ && b(i).isLetter) {\n                    j += b(i).isLetter\n              \
    \  }\n                if((j - i) >= 0) {\n                    var k = j\n    \
    \                while (k < n && k < m && !(b(j).isLetter || b(j).isDigit)) {\n\
    \                        k += b(j).isLetter\n                    }\n         \
    \           if(k < n) {\n                        flag = false\n              \
    \      }\n                }\n            }\n            i += 1\n        }\n  \
    \      return flag", "        val a = a.replace(\"-\", \"\")\n        val b =\
    \ b.replace(\"-\", \"\")\n        if (a.length >0 && b.length > 0) {\n       \
    \     val substring = a.mkString.contains(b.mkString)\n            val substring2\
    \ = a.mkString.substring(b.length).contains(b.mkString)\n            val substring3\
    \ = a.mkString.substring(b.length, b.length + b.length).contains(b.mkString)\n\
    \            val substring4 = a.mkString.substring(a.length).contains(b.mkString)\n\
    \            val substring5 = a.mkString.substring(a.length, b.length).contains(b.mkString)\n\
    \            val substring6 = a.mkString.substring(b.length, b.length + b.length).substring(a.length).contains(b.mkString)\n\
    \            val substring7 = a.mkString.substring(a.length, b.length + b.length).substring(a.length).contains(b.mkString)\n\
    \            val substring8 = a.mkString.substring(b.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).contains(b.mkString)\n            val substring9 = a.mkString.substring(a.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(a.length).contains(b.mkString)\n\
    \            val substring10 = a.mkString.substring(a.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).contains(b.mkString)\n\
    \            val substring11 = a.mkString.substring(a.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(a.length).substring(a.length).contains(b.mkString)\n\
    \            val substring12 = a.mkString.substring(a.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(a.length).substring(a.length).substring(a.length).contains(b.mkString)\n\
    \            val substring13 = a.mkString.substring(a.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(a.length).substring(a.length).substring(a.length).substring(a.length).substring(a.length).contains(b.mkString)\n\
    \            val substring14 = a.mkString.substring(a.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(b.length,\
    \ b.length + b.length).substring(b.length, b.length + b.length).substring(b.length,\
    \ b.", "        val arr1 = a.toLowerCase ++ \"a\"\n        val arr2 = b.toLowerCase\
    \ ++ \"b\"\n        val arr3 = arr1.toList\n        var i = 2\n        for(x <-\
    \ arr3) {\n            val newArr3 = (arr3.filterNot(_ == x))\n            val\
    \ arr4 = newArr3.toList\n            val arr5 = arr4.filterNot(_ == x)\n     \
    \       val arr6 = arr5.filterNot(_ == x)\n            if(arr6.nonEmpty) {\n \
    \               if(arr6.size == arr.size)\n                    return false\n\
    \                else\n                    return true\n            }\n      \
    \  }\n        return false", "        val aArray = a.toArray\n        val bArray\
    \ = b.toArray\n        aArray.zip(bArray).map(x => {\n            val xa = x._1\n\
    \            val xb = x._2\n            val n = xb.length\n            var isSub\
    \ = false\n            var isRotation = true\n            var aIndex = 0\n   \
    \         var bIndex = 0\n            while (aIndex < n && bIndex < n) {\n   \
    \             isSub = a.substring(aIndex, bIndex).equals(xb)\n               \
    \ isRotation = isRotation && (aIndex + bIndex < n && a.substring(aIndex, bIndex).equals(a.substring(aIndex\
    \ + 1, aIndex + 1 + bIndex)))\n                if (isSub && !isRotation) {\n \
    \                   aIndex += n\n                }\n                if (isRotation)\
    \ {\n                    aIndex += 1\n                    bIndex += 1\n      \
    \          }\n            }\n            isSub\n        }).sum", "        val\
    \ pattern = a.toSet.toList ++ b.toSet.toList\n        var patternCount = pattern.length\n\
    \        var bArray = b.toList\n        var foundCount = 0\n        var isPatternMatch\
    \ = false\n        while (patternCount != 0) {\n            var patternIndex =\
    \ 0\n            var foundIndex = -1\n            for (i <- 0 until patternCount)\
    \ {\n                if (patternIndex < patternCount) {\n                    if\
    \ (pattern(i).equals(patternIndex)) {\n                        foundIndex = i\n\
    \                    }\n                    patternIndex = patternIndex + 1\n\
    \                }\n            }\n            if (foundIndex != -1) {\n     \
    \           var foundWord = bArray.get(foundIndex).toString.toUpperCase\n    \
    \            var foundWordSet = foundWord.trim.toSet\n                var aArray\
    \ = a.toList\n                var aCount = aArray.length\n                var\
    \ foundIndex = -1\n                var foundCount = 0\n                for (i\
    \ <- 0 until aCount) {\n                    if (foundIndex != -1) {\n        \
    \                var aChar = aArray(i).toString.toUpperCase\n                \
    \        if (aChar == foundWordSet.toSeq.head || aChar == foundWordSet.toSeq.last)\
    \ {\n                            foundCount = foundCount + 1\n               \
    \         }\n                    }\n                    if (foundCount == foundWordSet.toSeq.length)\
    \ {\n                        isPatternMatch = true\n                        break\n\
    \                    }\n                    if (foundCount == foundWordSet.toSeq.length\
    \ && aChar == foundWordSet.toSeq.head && aChar != foundWordSet.toSeq.last) {\n\
    \                        foundIndex = i\n                    }\n             \
    \   }\n            }\n            patternCount = patternCount - 1\n        }\n\
    \        isPatternMatch"]
stop_tokens:
- "\n    }\n"
