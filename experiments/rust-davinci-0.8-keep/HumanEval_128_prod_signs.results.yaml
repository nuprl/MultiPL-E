name: HumanEval_128_prod_signs
language: rust
results:
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|&x|\
    \ x.abs() as usize).sum::<usize>() as isize * arr.iter().product::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-144)`,\n right: `Some(-9)`', /tmp/tmp3mc5qsag.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // YOUR CODE HERE\n    None\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmp5tht2r92.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for &num in &arr {\n        prod *=\
    \ num.signum();\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // Code the function here\n    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for i in arr {\n        if i > 0 {\n       \
    \     prod *= 1;\n            sum += i;\n        } else if i < 0 {\n         \
    \   prod *= -1;\n            sum += i.abs();\n        } else {\n            prod\
    \ *= 0;\n        }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n\
    \        Some(sum * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp6doxizse.rs:24:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n24  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n\
    \    let prod = arr.iter().map(|&x| x.signum()).product::<isize>();\n    match\
    \ (sum, prod) {\n        (0, _) => None,\n        (_, 0) => Some(0),\n       \
    \ (s, p) => Some(s * p),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7bjyt17f.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = 1;\n    for i in arr {\n        product\
    \ *= (i / i.abs()) as isize;\n    }\n    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n\
    \    if sum != 0 {\n        Some(sum * product)\n    } else {\n        None\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp9v3_kb5i.rs:14:15\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |     let mut product = 1;\n11  |     for i in arr {\n\
    \    |              --- `arr` moved due to this implicit call to `.into_iter()`\n\
    ...\n14  |     let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    | \
    \              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\n    = note: borrow\
    \ occurs due to deref coercion to `[isize]`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n11\
    \  |     for i in &arr {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum = arr.iter().fold(0, |acc, &x| acc + x.abs());\n    let prod = arr.iter().fold(1,\
    \ |acc, &x| acc * x.signum());\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ product = arr.iter().fold(1, |acc, x| acc * sign(x));\n    let magnitude = arr.iter().fold(0,\
    \ |acc, x| acc + x.abs());\n    Some(product * magnitude)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpd9itc44b.rs:13:53\n\
    \   |\n13 |     let product = arr.iter().fold(1, |acc, x| acc * sign(x));\n  \
    \ |                                                     ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for n in arr {\n        prod *= prod_signs_helper(n);\n\
    \        sum += prod_signs_helper(n).abs();\n    }\n    Some(prod * sum)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prod_signs_helper` in this scope\n\
    \  --> /tmp/tmpnqannhad.rs:16:17\n   |\n16 |         prod *= prod_signs_helper(n);\n\
    \   |                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `prod_signs_helper` in this scope\n  --> /tmp/tmpnqannhad.rs:17:16\n\
    \   |\n17 |         sum += prod_signs_helper(n).abs();\n   |                ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mul_signs = || {\n        let sum_signs = arr.iter().map(|n|\
    \ if *n < 0 { -1 } else { 1 }).sum::<isize>();\n        match sum_signs {\n  \
    \          s if s == arr.len() as isize => Some(1),\n            s if s == -arr.len()\
    \ as isize => Some(-1),\n            _ => Some(0),\n        }\n    };\n    let\
    \ mul_magn = || {\n        let sum_magn = arr.iter().fold(0, |acc, n| acc + n.abs());\n\
    \        Some(sum_magn)\n    };\n    if arr.is_empty() {\n        None\n    }\
    \ else {\n        mul_signs().and_then(|signs| mul_magn().map(|magn| signs * magn))\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp4l547w3h.rs:14:23\n\
    \   |\n14 |             s if s == -arr.len() as isize => Some(-1),\n   |     \
    \                  ^^^^^^^^^^ cannot apply unary operator `-`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0600`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ a = arr.iter().map(|x| x.abs()).sum::<isize>();\n    let b = arr.iter().filter(|&x|\
    \ *x != 0).fold(1, |acc, x| acc * x.signum());\n    Some(a * b)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpyiwy89t8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        _ => {\n\
    \            let s: isize = arr.iter().map(|x| x.signum()).product();\n      \
    \      let m: isize = arr.iter().map(|x| x.abs()).sum();\n            Some(s *\
    \ m)\n        }\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpr6rdxyih.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpzhyu3m1t.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let prod = arr.iter().map(|x| if *x > 0 { 1 } else if *x\
    \ < 0 { -1 } else { 0 }).product();\n    if prod == 0 {\n        None\n    } else\
    \ {\n        Some(arr.iter().map(|x| x.abs()).sum::<isize>() * prod)\n    }\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4j2tiyzj.rs:10:9\n\
    \   |\n10 |     let prod = arr.iter().map(|x| if *x > 0 { 1 } else if *x < 0 {\
    \ -1 } else { 0 }).product();\n   |         ^^^^ consider giving `prod` a type\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3_1wotsz.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // Write a function body here\n    None\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmprjjzpm5l.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2afpcjqd.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // use a fold to accumulate\n    let (acc, _) = arr.iter().fold((0,\
    \ 1), |acc, el| {\n        let (sum, p) = acc;\n        let i = *el;\n       \
    \ if i > 0 {\n            (sum + i, p * 1)\n        } else if i < 0 {\n      \
    \      (sum + -i, p * -1)\n        } else {\n            (sum, p * 0)\n      \
    \  }\n    });\n    match acc {\n        0 => None,\n        _ => Some(acc),\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmp4mc1eipy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_product = arr.iter().filter(|&&v| v != 0).map(|&v| v as i8).fold(1, |a,\
    \ b| a * b.signum());\n    let magnitude_sum = arr.iter().map(|&v| v.abs()).sum();\n\
    \    Some(sign_product * magnitude_sum)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4cep5zxx.rs:14:9\n\
    \   |\n14 |     let magnitude_sum = arr.iter().map(|&v| v.abs()).sum();\n   |\
    \         ^^^^^^^^^^^^^ consider giving `magnitude_sum` a type\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    let prod = arr.iter().fold(1,\
    \ |acc, &x| {\n        match x {\n            x if x < 0 => acc * -1,\n      \
    \      x if x > 0 => acc * 1,\n            _ => acc,\n        }\n    });\n   \
    \ Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpnmn5t11b.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // It doesn't matter if the arr is empty,\n    // because\
    \ the expression 0 * None is None.\n    let prod = arr.iter().map(|a| if *a >\
    \ 0 { 1 } else if *a < 0 { -1 } else { 0 }).product();\n    let sum = arr.iter().map(|a|\
    \ a.abs()).sum();\n    prod * sum\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpo0icdbxh.rs:12:9\n\
    \   |\n12 |     let prod = arr.iter().map(|a| if *a > 0 { 1 } else if *a < 0 {\
    \ -1 } else { 0 }).product();\n   |         ^^^^ consider giving `prod` a type\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(None, |acc, &x| {\n        let val = x.signum();\n\
    \        match acc {\n            None => Some(val),\n            Some(sum) =>\
    \ Some(sum * val),\n        }\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpp_l8k1pw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpgjwkskc3.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ nums = arr.iter().map(|x| x.abs()).collect::<Vec<isize>>();\n    let prod =\
    \ arr.iter().map(|x| x.signum()).product::<isize>();\n    Some(nums.iter().sum::<isize>()\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sign_product = 1;\n    let mut magnitude_sum = 0;\n    for number in arr\
    \ {\n        let mut magnitude = number.abs();\n        if number == 0 {\n   \
    \         magnitude_sum += magnitude;\n            continue;\n        }\n    \
    \    sign_product *= number.signum();\n        magnitude_sum += magnitude;\n \
    \   }\n    Some(sign_product * magnitude_sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpcfsutzpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut signs: isize = 1;\n    let mut res: isize = 0;\n\
    \    for el in arr {\n        res += el.abs();\n        if el != 0 {\n       \
    \     signs *= el / el.abs();\n        }\n    }\n    res * signs\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp02f4xn5g.rs:18:5\n   |\n\
    9  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n18 |     res * signs\n   |     ^^^^^^^^^^^ expected enum `Option`, found\
    \ `isize`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |     Some(res\
    \ * signs)\n   |     +++++           +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpn9xvolyk.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1isize;\n    let mut sum = 0isize;\n    for x in arr {\n        sum\
    \ += x.abs();\n        prod *= if x > 0 { 1 } else if x < 0 { -1 } else { 0 };\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for num in arr {\n        if num == 0 {\n            continue;\n        }\
    \ else if num > 0 {\n            product *= 1;\n            sum += num;\n    \
    \    } else {\n            product *= -1;\n            sum += num.abs();\n   \
    \     }\n    }\n    match product {\n        0 => None,\n        _ => Some(product\
    \ * sum),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp763h33ao.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(Some(1), |opt, &n| opt.and_then(|acc|\n\
    \        if n == 0 { Some(0) }\n        else { Some(acc * if n > 0 { 1 } else\
    \ { -1 }) }))\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp4w99p1wm.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i > 0 {\n            prod *= 1;\n            sum += i;\n     \
    \   } else if i < 0 {\n            prod *= -1;\n            sum += i.abs();\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    match prod {\n\
    \        0 => None,\n        _ => Some(sum * prod),\n    }\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmplosvh_4c.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpf_bmj021.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for x in arr {\n        if x == 0 {\n\
    \            continue;\n        }\n        sum += x.abs();\n        prod *= x.signum();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpka0nx34a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            res *= 1;\n        } else if i < 0 {\n            res *= -1;\n  \
    \      } else {\n            res *= 0;\n        }\n        sum += i.abs();\n \
    \   }\n    Some(res * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // This can be done without `map` and `sum` methods\n \
    \   // manually, that would take additional lines of code.\n    arr.iter().map(|x|\
    \ x.abs() as isize * arr.iter().map(|x| x.signum()).product::<isize>()).sum()\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Option<isize>: Sum<isize>` is not satisfied\n\
    \    --> /tmp/tmpz6wc4t6_.rs:12:94\n     |\n12   |     arr.iter().map(|x| x.abs()\
    \ as isize * arr.iter().map(|x| x.signum()).product::<isize>()).sum()\n     |\
    \                                                                            \
    \                  ^^^ the trait `Sum<isize>` is not implemented for `Option<isize>`\n\
    \     |\n     = help: the trait `Sum<Option<U>>` is implemented for `Option<T>`\n\
    note: required by a bound in `std::iter::Iterator::sum`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let arr = arr.into_iter().map(|n| if n == 0 { 1 } else\
    \ { n }).collect::<Vec<_>>();\n    let mut product = 1;\n    let mut sum = 0;\n\
    \    for i in &arr {\n        product *= if i > &0 { 1 } else { -1 };\n      \
    \  sum += i.abs();\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n\
    \        Some(product * sum)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(0)`', /tmp/tmp_qrc_drk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut mult = 1;\n    for elem in arr {\n        if elem\
    \ > 0 {\n            sum += elem;\n            mult *= 1;\n        } else if elem\
    \ < 0 {\n            sum += -elem;\n            mult *= -1;\n        }\n    }\n\
    \    Some(sum * mult)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpvublpa0g.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut cnt = 0;\n    let mut cur = arr[0];\n    for &n in arr.iter() {\n      \
    \  if n < 0 {\n            cnt += 1;\n        }\n        cur *= n;\n    }\n  \
    \  if cnt % 2 == 0 {\n        return Some(cur);\n    }\n    Some(-cur)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpl_ae2qu9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let sign_prod =\
    \ arr.iter().map(|x| if *x == 0 { 0 } else { 1 }).product();\n    let sum_of_magnitudes\
    \ = arr.iter().map(|x| x.abs()).sum();\n    Some(sign_prod * sum_of_magnitudes)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpisr98abx.rs:11:9\n\
    \   |\n11 |     let sign_prod = arr.iter().map(|x| if *x == 0 { 0 } else { 1 }).product();\n\
    \   |         ^^^^^^^^^ consider giving `sign_prod` a type\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpq4ztq_dv.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_prod = arr.iter().fold(1, |acc, &item| {\n        match item {\n      \
    \      0 => 0,\n            item if item > 0 => acc * 1,\n            _ => acc\
    \ * -1,\n        }\n    });\n    Some(\n        arr.iter()\n            .fold(0,\
    \ |acc, &item| acc + item.abs())\n            * sign_prod,\n    )\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for num in arr {\n        match num {\n            0 => prod *= 0,\n    \
    \        n if n > 0 => {\n                prod *= 1;\n                sum += n.abs();\n\
    \            }\n            n if n < 0 => {\n                prod *= -1;\n   \
    \             sum += n.abs();\n            }\n            _ => (),\n        }\n\
    \    }\n    match sum {\n        0 => None,\n        _ => Some(sum * prod),\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(None, |acc, x| if *x == 0 { Some(0) } else\
    \ {\n        Some(acc.unwrap_or(1) * x.signum())\n    })\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpkpezo8mi.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        _ => {\n\
    \            let mut sum = 0;\n            let mut prod = 1;\n            for\
    \ i in arr {\n                if i > 0 {\n                    sum += i;\n    \
    \                prod *= 1;\n                } else if i < 0 {\n             \
    \       sum += -i;\n                    prod *= -1;\n                }\n     \
    \       }\n            Some(sum * prod)\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpgk2albb_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code here\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgb9_te_c.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut signs = 1;\n    for num in arr {\n        if num ==\
    \ 0 {\n            signs = 0;\n        } else {\n            sum += num.abs();\n\
    \            signs *= num.signum();\n        }\n    }\n    Some(sum * signs)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let l = arr.len();\n    if l == 0 {\n        return None;\n\
    \    }\n    let mut signs: isize = 1;\n    let mut sum: isize = 0;\n    for i\
    \ in arr {\n        let mut x = i;\n        if x < 0 {\n            x = -x;\n\
    \            signs = -signs;\n        }\n        sum += x;\n    }\n    Some(sum\
    \ * signs)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp6kkkfmqx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for x in arr\
    \ {\n        match x {\n            0 => (),\n            x if x > 0 => prod *=\
    \ 1,\n            x if x < 0 => prod *= -1,\n        }\n        sum += x.abs();\n\
    \    }\n    match arr.len() {\n        0 => None,\n        _ => Some(sum * prod),\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0004]: non-exhaustive patterns: `_` not covered\n  --> /tmp/tmp0rzhjmeg.rs:13:15\n\
    \   |\n13 |         match x {\n   |               ^ pattern `_` not covered\n\
    \   |\n   = note: the matched value is of type `isize`\n   = note: `isize` does\
    \ not have a fixed maximum value, so a wildcard `_` is necessary to match exhaustively\n\
    help: ensure that all possible cases are being handled by adding a match arm with\
    \ a wildcard pattern or an explicit pattern as shown\n   |\n16 ~             x\
    \ if x < 0 => prod *= -1,\n17 ~             _ => todo!(),\n   |\n\nerror[E0382]:\
    \ borrow of moved value: `arr`\n   --> /tmp/tmp0rzhjmeg.rs:20:11\n    |\n9   |\
    \ fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |               --- move\
    \ occurs because `arr` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n12  |     for x in arr {\n    |              --- `arr` moved due\
    \ to this implicit call to `.into_iter()`\n...\n20  |     match arr.len() {\n\
    \    |           ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n12  |     for x in &arr {\n    |              +\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0004, E0382.\n\
    For more information about an error, try `rustc --explain E0004`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmp7pvtu8bl.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxyzmu612.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().map(|x| x.abs() as isize).product::<isize>()\
    \ * arr.iter().product::<isize>()\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpika6hxck.rs:10:5\n   |\n\
    9  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    10 |     arr.iter().map(|x| x.abs() as isize).product::<isize>() * arr.iter().product::<isize>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     Some(arr.iter().map(|x| x.abs() as isize).product::<isize>() *\
    \ arr.iter().product::<isize>())\n   |     +++++                             \
    \                                                          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut arr_iter = arr.iter();\n    let result = arr_iter.fold(1, |acc, x| {\n \
    \       if *x < 0 {\n            acc * -1\n        } else if *x > 0 {\n      \
    \      acc * 1\n        } else {\n            acc * 0\n        }\n    });\n  \
    \  Some(arr.iter().map(|x| x.abs()).sum::<isize>() * result)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod: isize = 1;\n    let mut sum: isize = 0;\n\
    \    if arr.len() == 0 {\n        return None;\n    }\n    for x in arr {\n  \
    \      prod *= x.signum();\n        sum += x.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for val in arr {\n        if val ==\
    \ 0 {\n            continue;\n        }\n        sum += val.abs();\n        prod\
    \ *= val.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpcazpbuof.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sign = 1;\n    let mut sum = 0;\n    for i in &arr {\n        if *i == 0\
    \ {\n            sign = 0;\n        } else if *i < 0 {\n            sign *= -1;\n\
    \        }\n        sum += i.abs();\n    }\n    return Some(sum * sign);\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for num in\
    \ arr {\n        if num > 0 {\n            prod *= 1;\n            sum += num;\n\
    \        } else if num < 0 {\n            prod *= -1;\n            sum += num.abs();\n\
    \        }\n    }\n    if sum > 0 {\n        Some(sum * prod)\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpdma7l3gy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmzevuc8l.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.into_iter().fold(Some(1), |acc, cur| match (acc, cur)\
    \ {\n        (Some(sum), elem) => Some(sum * sign(elem)),\n        _ => None,\n\
    \    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmpi0356doa.rs:11:41\n\
    \   |\n11 |         (Some(sum), elem) => Some(sum * sign(elem)),\n   |       \
    \                                  ^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = 1;\n    let mut sum = 0;\n    for num\
    \ in arr {\n        if num > 0 {\n            product *= 1;\n            sum +=\
    \ num;\n        } else if num < 0 {\n            product *= -1;\n            sum\
    \ += num.abs();\n        } else {\n            product *= 0;\n        }\n    }\n\
    \    if product != 0 && sum != 0 {\n        Some(product * sum)\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmp6kot6f3s.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut total = 0;\n    let mut product = 1;\n    for i in arr {\n        if i >\
    \ 0 {\n            total += i;\n            product *= 1;\n        } else if i\
    \ < 0 {\n            total += i.abs();\n            product *= -1;\n        }\
    \ else {\n            product *= 0;\n        }\n    }\n    Some(total * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmp9gx7u3ve.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1isize;\n    let mut sum = 0isize;\n    for num in arr {\n      \
    \  sum += num.abs();\n        prod *= num.signum();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpe5kutkqz.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut signs = 1;\n    let mut mags = 0;\n    for i in &arr {\n        if *i <\
    \ 0 {\n            signs *= -1;\n        }\n        mags += i.abs();\n    }\n\
    \    Some(mags * signs)\n}\n\nfn main() {\n    let candidate = prod_signs;\n \
    \   assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp0cnd3phd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = arr.iter().fold(1, |prod, &num| {\n        prod * num.signum()\n\
    \    });\n    Some(arr.iter().fold(0, |sum, &num| {\n        let num = prod.signum()\
    \ * num.abs();\n        prod *= num.signum();\n        sum + num\n    }))\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(7)`,\n right: `Some(-9)`', /tmp/tmpb2x1rjjv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ prod = arr.iter().fold(1, |a, x| if *x < 0 { a * -1 } else { a });\n    let\
    \ sum = arr.iter().fold(0, |a, x| a + x.abs());\n    Some(sum * prod)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp4d18vnt9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmput9n53uj.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for x in arr {\n        if x < 0 {\n            prod *= -1;\n        }\n\
    \        sum += x.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpfq3vh447.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ (sum, prod) = arr.iter().fold((0, 1), |(sum, prod), &i| {\n        (sum + i.abs(),\
    \ prod * (i.signum() as isize))\n    });\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().fold(0,\
    \ |acc, &x| {\n        if x != 0 {\n            if x < 0 {\n                acc\
    \ + x\n            } else {\n                acc - x\n            }\n        }\
    \ else {\n            acc\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxu62_5lu.rs:13:21\n   |\n\
    13 |     arr.iter().fold(0, |acc, &x| {\n   |                     ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |     arr.iter().fold(Some(0), |acc, &x| {\n   |                   \
    \  +++++ +\n\nerror[E0369]: cannot add `isize` to `Option<isize>`\n  --> /tmp/tmpxu62_5lu.rs:16:21\n\
    \   |\n16 |                 acc + x\n   |                 --- ^ - isize\n   |\
    \                 |\n   |                 Option<isize>\n\nerror[E0369]: cannot\
    \ subtract `isize` from `Option<isize>`\n  --> /tmp/tmpxu62_5lu.rs:18:21\n   |\n\
    18 |                 acc - x\n   |                 --- ^ - isize\n   |       \
    \          |\n   |                 Option<isize>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut z = 1;\n    let mut p = 1;\n    for x in arr {\n        if x < 0 {\n   \
    \         p *= -1;\n        } else if x == 0 {\n            z = 0;\n        }\n\
    \    }\n    if z == 0 {\n        Some(0)\n    } else {\n        Some(p * arr.iter().map(|x|\
    \ x.abs()).sum::<isize>())\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpematds1l.rs:25:18\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n25  |         Some(p\
    \ * arr.iter().map(|x| x.abs()).sum::<isize>())\n    |                  ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `arr`\n    = note: borrow occurs due to deref\
    \ coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n15  |     for x in &arr\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num ==\
    \ 0 {\n            continue;\n        }\n        if num < 0 {\n            prod\
    \ *= -1;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpj_lw56xo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().fold(1,\
    \ |acc, x| acc * x.signum())\n        * arr.iter().fold(0, |acc, x| acc + x.abs())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpabaegjok.rs:13:5\n   |\n\
    9  |   fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |               \
    \                      ------------- expected `Option<isize>` because of return\
    \ type\n...\n13 | /     arr.iter().fold(1, |acc, x| acc * x.signum())\n14 | |\
    \         * arr.iter().fold(0, |acc, x| acc + x.abs())\n   | |____________________________________________________^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 ~     Some(arr.iter().fold(1, |acc, x| acc * x.signum())\n14 ~     \
    \    * arr.iter().fold(0, |acc, x| acc + x.abs()))\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for el in arr {\n        prod *= el.signum();\n\
    \        sum += el.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_prod = arr.iter().fold(1, |acc, x| acc * x.signum());\n    let abs_sum\
    \ = arr.iter().fold(0, |acc, x| acc + x.abs());\n    Some(sign_prod * abs_sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp49sk2pas.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut prod = 1;\n    for num in arr {\n        if num >\
    \ 0 {\n            res += num;\n            prod *= 1;\n        } else if num\
    \ < 0 {\n            res += num.abs();\n            prod *= -1;\n        }\n \
    \   }\n    Some(res * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmps6unls_h.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // Uncomment and complete!\n    // None\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn9869m2z.rs:9:35\n  |\n9 |\
    \ fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n  |    ----------       \
    \              ^^^^^^^^^^^^^ expected enum `Option`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note:   expected enum `Option<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None }\n    let sign_prod =\
    \ arr.iter().map(|x| x.signum()).product();\n    let sum = arr.iter().map(|x|\
    \ x.abs()).sum();\n    Some(sign_prod * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpt0_e7oqq.rs:11:9\n\
    \   |\n11 |     let sign_prod = arr.iter().map(|x| x.signum()).product();\n  \
    \ |         ^^^^^^^^^ consider giving `sign_prod` a type\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            res *= 1;\n        } else if i < 0 {\n            res *= -1;\n  \
    \      } else {\n            res *= 0;\n        }\n        sum += i.abs();\n \
    \   }\n    Some(res * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut acc = 1;\n    let mut res = 0;\n    for n in arr {\n        res += n.abs();\n\
    \        acc *= n.signum();\n    }\n    Some(res * acc)\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().map(|i| i.signum()).product::<isize>() * arr.iter().map(|i|\
    \ i.abs()).sum::<isize>()\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbiuw9ud9.rs:10:5\n   |\n\
    9  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    10 |     arr.iter().map(|i| i.signum()).product::<isize>() * arr.iter().map(|i|\
    \ i.abs()).sum::<isize>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     Some(arr.iter().map(|i| i.signum()).product::<isize>() * arr.iter().map(|i|\
    \ i.abs()).sum::<isize>())\n   |     +++++                                   \
    \                                                           +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.is_empty()\n        .then_some(0)\n        .or_else(||\
    \ {\n            let prod_signs = arr.iter().fold(1, |acc, x| acc * x.signum());\n\
    \            let arr_magnitude = arr.iter().map(|x| x.abs()).sum();\n        \
    \    Some(arr_magnitude * prod_signs)\n        })\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpewo76j2s.rs:14:17\n\
    \   |\n14 |             let arr_magnitude = arr.iter().map(|x| x.abs()).sum();\n\
    \   |                 ^^^^^^^^^^^^^ consider giving `arr_magnitude` a type\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code goes here\n    None\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpepo3bd7o.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let mut res = 1;\n\
    \    let mut sum = 0;\n    for n in arr {\n        if n < 0 { res *= -1; }\n \
    \       if n != 0 { sum += n.abs(); }\n    }\n    Some(res * sum)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpis29tewo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpub9torj2.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let sum = arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>();\n    let sign = arr.iter().map(|&x| x.signum()).product::<isize>();\n\
    \    Some(sum * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        1 => Some(arr[0]),\n\
    \        _ => {\n            let mut psign = 1;\n            let mut sum = 0;\n\
    \            for a in arr {\n                match a {\n                    0\
    \ => psign = 0,\n                    _ => {\n                        psign *=\
    \ if a > 0 { 1 } else { -1 };\n                        sum += a.abs();\n     \
    \               }\n                }\n            }\n            Some(psign *\
    \ sum)\n        }\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ signs: Vec<isize> = arr.iter().map(|x| x.signum()).collect();\n    let nums:\
    \ Vec<isize> = arr.iter().map(|x| x.abs()).collect();\n    Some(nums.iter().sum::<isize>()\
    \ * signs.iter().product::<isize>())\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpopplaw9n.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum: isize = arr.iter().map(|x| x.abs()).sum();\n    let mul: isize = arr.iter().fold(1,\
    \ |acc, x| {\n        if *x == 0 {\n            0\n        } else if *x > 0 {\n\
    \            acc\n        } else {\n            acc * -1\n        }\n    });\n\
    \    Some(sum * mul)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let prod_sign =\
    \ arr.iter().fold(1, |acc, &x| if x == 0 { 0 } else { acc * x.signum() });\n \
    \   Some(arr.iter().fold(0, |acc, &x| acc + (x * prod_sign).abs()))\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpsec650jp.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqbq2ogl0.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * arr.iter().fold(1, |p, x| p * x.signum())\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6_zhvuzb.rs:13:5\n   |\n\
    9  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n13 |     arr.iter().map(|x| x.abs()).sum::<isize>() * arr.iter().fold(1,\
    \ |p, x| p * x.signum())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |     Some(arr.iter().map(|x| x.abs()).sum::<isize>() * arr.iter().fold(1,\
    \ |p, x| p * x.signum()))\n   |     +++++                                    \
    \                                                  +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n    let signs = arr.iter().map(|x|\
    \ if *x > 0 { 1 } else if *x < 0 { -1 } else { 0 }).product::<isize>();\n    Some(sum\
    \ * signs)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut _r: isize = 0;\n    for i in arr {\n        _r\
    \ += i.abs() as isize;\n    }\n    if arr.len() == 0 {\n        return None;\n\
    \    }\n    if arr.iter().all(|&x| x == 0) {\n        return Some(0);\n    }\n\
    \    for i in arr {\n        if i == 0 {\n            continue;\n        }\n \
    \       _r *= i / i.abs();\n    }\n    Some(_r)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmplk4n8kxl.rs:14:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n10  |     let mut _r: isize = 0;\n11  |     for i in arr {\n\
    \    |              --- `arr` moved due to this implicit call to `.into_iter()`\n\
    ...\n14  |     if arr.len() == 0 {\n    |        ^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n11  |     for i in &arr\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut result = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0\
    \ {\n            result = 0;\n        } else if i < 0 {\n            result *=\
    \ -1;\n        }\n        sum += i.abs();\n    }\n    Some(result * sum)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i < 0 {\n            prod *= -1;\n        } else if i > 0 {\n\
    \            sum += i;\n        }\n    }\n    if prod == 1 {\n        return Some(sum);\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmp8h23g08e.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // i'm sorry for this code :D\n    match arr.is_empty()\
    \ {\n        true => None,\n        false => {\n            let mut prod = 1;\n\
    \            let mut sum = 0;\n            for i in arr {\n                if\
    \ i < 0 {\n                    prod *= -1;\n                } else if i == 0 {\n\
    \                    prod = 0;\n                }\n                sum += i.abs();\n\
    \            }\n            Some(sum * prod)\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let arr: Vec<isize>\
    \ = arr.iter().map(|x| (*x as f64).signum() as isize).collect();\n    let sum\
    \ = arr.iter().sum::<isize>();\n    let pro = arr.iter().product::<isize>();\n\
    \    Some(sum * pro)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmphwn_64hh.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpaygkf3wc.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum: isize = 0;\n    let mut prod: isize = 1;\n    for i in arr {\n    \
    \    if i == 0 {\n            continue;\n        }\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpzyf74r2i.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ n = arr.len();\n    let mut result = 0;\n    for i in 0..n {\n        result\
    \ += arr[i] * arr[n - i - 1];\n    }\n    Some(result)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmp7ttjqjo3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        sum += i.abs();\n        prod *= i.signum();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp479kg6ss.rs:16:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().fold(\n\
    \        (1, 0),\n        |(sign, sum), v| (\n            sign * (if *v > 0 {\
    \ 1 } else if *v < 0 { -1 } else { 0 }),\n            sum + v.abs(),\n       \
    \ ),\n    )\n    .0\n    .checked_mul(arr.iter().sum::<isize>())\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `checked_mul` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmp5o06x5bp.rs:21:6\n   |\n21 |     .checked_mul(arr.iter().sum::<isize>())\n\
    \   |      ^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        _ => Some(arr.iter().map(|x|\
    \ if *x == 0 { 0 } else { x.abs() }).sum::<isize>()\n            * arr.iter().map(|x|\
    \ if *x == 0 { 0 } else { x.signum() }).product::<isize>()),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num >\
    \ 0 {\n            prod *= 1;\n        } else if num < 0 {\n            prod *=\
    \ -1;\n        } else {\n            prod *= 0;\n        }\n        sum += num.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpbh7uh5zd.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut sum = 0;\n    let mut prod = 1;\n    for e in arr\
    \ {\n        sum += e.abs();\n        prod *= e.signum();\n    }\n    if prod\
    \ == 0 {\n        return None;\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmpd_5p419x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut product = 1;\n    for i in arr {\n        if i > 0\
    \ {\n            sum += i;\n            product *= 1;\n        } else if i < 0\
    \ {\n            sum += i.abs();\n            product *= -1;\n        } else {\n\
    \            sum += i.abs();\n            product *= 0;\n        }\n    }\n  \
    \  Some(sum * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = arr.iter().fold(1, |acc, &x| {\n        acc * if x < 0 { -1 } else\
    \ if x > 0 { 1 } else { 0 }\n    });\n    let ret = arr.iter().fold(0, |acc, &x|\
    \ acc + x.abs());\n    if prod < 0 {\n        Some(-ret)\n    } else {\n     \
    \   Some(ret)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmph8kwovzg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        _ => Some(arr.iter().fold(1,\
    \ |acc, &x| acc * x.signum()) *\n                   arr.iter().fold(0, |acc, &x|\
    \ acc + x.abs())),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ prod_of_signs = arr.iter().fold(1, |a, b| a * b.signum());\n    let sum_of_magnitudes\
    \ = arr.iter().fold(0, |a, b| a + b.abs());\n    Some(prod_of_signs * sum_of_magnitudes)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code goes here\n    None\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpu72ss5rc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let signs: Vec<isize> = arr.iter().map(|num| num.signum()).collect();\n\
    \    match signs.iter().product() {\n        0 => None,\n        _ => Some(arr.iter().map(|num|\
    \ num.abs()).sum::<isize>() * signs.iter().product()),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0284]: type annotations needed: cannot satisfy `<isize as Mul<_>>::Output\
    \ == isize`\n  --> /tmp/tmpps55x4gt.rs:13:66\n   |\n13 |         _ => Some(arr.iter().map(|num|\
    \ num.abs()).sum::<isize>() * signs.iter().product()),\n   |                 \
    \                                                 ^ cannot satisfy `<isize as\
    \ Mul<_>>::Output == isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0284`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sign_product = 1;\n    let mut magnitude_sum = 0;\n    for x in arr {\n\
    \        sign_product *= if x == 0 { 0 } else { x / x.abs() };\n        magnitude_sum\
    \ += x.abs();\n    }\n    Some(sign_product * magnitude_sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|n|\
    \ n.abs()).sum::<isize>() * arr.iter().map(|n| n.signum()).product::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for num in arr {\n        sum += num.abs();\n\
    \        if num > 0 {\n            prod *= 1;\n        } else if num < 0 {\n \
    \           prod *= -1;\n        } else {\n            prod *= 0;\n        }\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let sgn = arr.iter().fold(1,\
    \ |prod, &x| x == 0 ? 0 : x > 0 ? prod : -prod);\n    let mag = arr.iter().fold(0,\
    \ |sum, &x| sum + x.abs());\n    Some(sgn * mag)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `0`\n\
    \  --> /tmp/tmpx1617orz.rs:11:54\n   |\n11 |     let sgn = arr.iter().fold(1,\
    \ |prod, &x| x == 0 ? 0 : x > 0 ? prod : -prod);\n   |                       \
    \                              -^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                                                     |\n   |            \
    \                                         help: missing `,`\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, or an operator, found `prod`\n  --> /tmp/tmpx1617orz.rs:11:66\n\
    \   |\n11 |     let sgn = arr.iter().fold(1, |prod, &x| x == 0 ? 0 : x > 0 ? prod\
    \ : -prod);\n   |                                                            \
    \      ^^^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: expected\
    \ one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `)`\n  -->\
    \ /tmp/tmpx1617orz.rs:11:78\n   |\n11 |     let sgn = arr.iter().fold(1, |prod,\
    \ &x| x == 0 ? 0 : x > 0 ? prod : -prod);\n   |                              \
    \                                                ^ expected one of 8 possible\
    \ tokens\n\nerror: aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None }\n    let mut sum = 0;\n\
    \    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n        prod\
    \ *= i.signum();\n    }\n    return Some(sum * prod);\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    match arr.len() {\n        0 => None,\n        _ => Some(arr.iter().fold(1,\
    \ |acc, v| acc * v.signum()) * arr.iter().fold(0, |acc, v| acc + v.abs())),\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 0;\n    let mut mul = 1;\n    for i in arr {\n        if i == 0 {\n\
    \            res += 0;\n        } else if i > 0 {\n            res += i;\n   \
    \         mul *= 1;\n        } else {\n            res += i.abs();\n         \
    \   mul *= -1;\n        }\n    }\n    Some(res * mul)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpxvfrb420.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product = 1;\n    let mut sum = 0;\n    for i in\
    \ arr {\n        product *= i.signum();\n        sum += i.abs();\n    }\n    if\
    \ arr.len() == 0 {\n        None\n    } else {\n        Some(product * sum)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpx0sqdcd1.rs:16:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpp2_xghc1.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxrytsaqk.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut result = 0;\n    let mut has_non_zero = false;\n\
    \    for i in arr {\n        if i > 0 {\n            result += i;\n          \
    \  has_non_zero = true;\n        } else if i < 0 {\n            result -= i;\n\
    \            has_non_zero = true;\n        }\n    }\n    if has_non_zero {\n \
    \       Some(result)\n    } else {\n        None\n    }\n}\n\nfn main() {\n  \
    \  let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpko8tytjc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut m: isize = 1;\n    let mut s: isize = 0;\n    for n in arr {\n        if\
    \ n != 0 {\n            m *= n / n.abs();\n            s += n.abs();\n       \
    \ }\n    }\n    Some(m * s)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp_crq57br.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9qhy5_yk.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut res = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        res += i.abs();\n\
    \    }\n    Some(res * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let x = arr.iter().fold(Some(1), |acc, &elem|\n       \
    \ match acc {\n            Some(acc) => Some(acc * elem.signum()),\n         \
    \   None => None\n        }\n    );\n    x.and_then(|sign| Some(arr.iter().fold(0,\
    \ |acc, &elem| acc + elem.abs() as isize) * sign))\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `None`', /tmp/tmpaurnttqp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num ==\
    \ 0 {\n            continue;\n        }\n        if num > 0 {\n            prod\
    \ *= 1;\n        } else {\n            prod *= -1;\n        }\n        sum +=\
    \ num.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpgq0wv_e2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // use once\n    // let mut prod = 1;\n    // let mut sum\
    \ = 0;\n    // for i in arr {\n    //     if i == 0 {\n    //         prod = 0;\n\
    \    //         break;\n    //     }\n    //     if i > 0 {\n    //         prod\
    \ *= 1;\n    //     } else {\n    //         prod *= -1;\n    //     }\n    //\
    \     sum += i.abs();\n    // }\n    //\n    // if arr.len() == 0 {\n    //  \
    \   None\n    // } else {\n    //     Some(sum * prod)\n    // }\n\n    // use\
    \ twice\n    if arr.len() == 0 {\n        return None;\n    }\n\n    let mut product\
    \ = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n      \
    \      product = 0;\n            break;\n        }\n        if i > 0 {\n     \
    \       product *= 1;\n        } else {\n            product *= -1;\n        }\n\
    \        sum += i.abs();\n    }\n\n    Some(sum * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * arr.iter().map(|x| x.signum()).product::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut i = 0;\n    let mut sign = 1;\n    let mut sum = 0;\n    for x in arr {\n\
    \        if x < 0 {\n            sign *= -1;\n        } else if x > 0 {\n    \
    \        sum += x;\n        }\n        i += 1;\n    }\n    sum = sum.abs();\n\
    \    Some(sum * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpwwf70fee.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut prod = 1;\n    let mut sum = 0;\n    for a in arr\
    \ {\n        match a.signum() {\n            -1 => prod *= -1,\n            0\
    \ => return None,\n            _ => {}\n        }\n        sum += a.abs();\n \
    \   }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmpc7ye_okm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ prod = arr.iter().fold(1, |acc, x| acc * x.signum());\n    let mags = arr.iter().map(|x|\
    \ x.abs()).sum();\n    Some(prod * mags)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpjxnff5f8.rs:14:9\n\
    \   |\n14 |     let mags = arr.iter().map(|x| x.abs()).sum();\n   |         ^^^^\
    \ consider giving `mags` a type\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for num in arr {\n        if num ==\
    \ 0 {\n            continue;\n        }\n        prod *= num.signum();\n     \
    \   sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpz5boa6m5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(None, |acc, &x|\n        match (acc, x)\
    \ {\n            (None, _) => Some(x),\n            (Some(acc), 0) => Some(acc),\n\
    \            (Some(acc), x) => Some(acc * x.signum() * x.abs()),\n        }\n\
    \    )\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp0sgvrz5z.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let arr: Vec<_> = arr.into_iter().filter(|&x| x != 0).collect();\n\
    \    if arr.is_empty() {\n        return None;\n    }\n    let product = arr.iter().map(|&x|\
    \ x.signum()).product::<isize>();\n    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n\
    \    Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpawtga6jf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sums: isize = arr.iter().map(|&x| x.abs()).sum();\n    let sign: isize = arr.iter().map(|&x|\
    \ x.signum()).product();\n    Some(sums * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod: isize = 1;\n    let mut sum: isize = 0;\n    for i in arr {\n    \
    \    prod *= i.signum();\n        sum += i.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut res = 1;\n    let mut cnt = 0;\n    for x in arr {\n        if x > 0 {\n\
    \            res *= 1;\n        } else if x < 0 {\n            res *= -1;\n  \
    \      } else {\n            cnt += 1;\n        }\n    }\n    match cnt {\n  \
    \      0 => Some(res),\n        _ => None,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmplwpy7dgr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut product: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for i in &arr {\n        if *i > 0 {\n            product *= 1;\n       \
    \     sum += i.abs();\n        } else if *i < 0 {\n            product *= -1;\n\
    \            sum += i.abs();\n        } else {\n            product *= 0;\n  \
    \      }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n       \
    \ Some(product * sum)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpvs6o0iw2.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ (signs, magnitudes): (Vec<isize>, Vec<isize>) = arr.iter().map(|x| (*x, abs(*x))).unzip();\n\
    \    let mut res = signs.iter().fold(1, |acc, x| acc * x);\n    res *= magnitudes.iter().fold(0,\
    \ |acc, x| acc + x);\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmps7og6b5z.rs:13:81\n\
    \   |\n13 |     let (signs, magnitudes): (Vec<isize>, Vec<isize>) = arr.iter().map(|x|\
    \ (*x, abs(*x))).unzip();\n   |                                              \
    \                                   ^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_prod = arr.iter().fold(1, |acc, n| {\n        if *n > 0 {\n           \
    \ acc * 1\n        } else if *n < 0 {\n            acc * -1\n        } else {\n\
    \            acc * 0\n        }\n    });\n    let mag_sum = arr.iter().fold(0,\
    \ |acc, n| acc + n.abs());\n    Some(sign_prod * mag_sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num >\
    \ 0 {\n            prod *= 1;\n        } else if num < 0 {\n            prod *=\
    \ -1;\n        } else {\n            prod *= 0;\n        }\n        sum += num.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().fold(Some(1),\
    \ |acc, &x| {\n        match acc {\n            Some(n) => Some(n * x.signum()),\n\
    \            None => None,\n        }\n    })\n        .map(|s| arr.iter().fold(0,\
    \ |sum, &x| sum + x.abs() * s))\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut r: isize = 1;\n    let mut s: isize = 0;\n    for el in arr {\n        if\
    \ el == 0 {\n            r = 0;\n        } else if el < 0 {\n            r *=\
    \ -1;\n        }\n        s += el.abs();\n    }\n    Some(r * s)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().fold((1,\
    \ 0), |(p, s), x| {\n        let (x1, x2) = (*x, x.abs());\n        (p * if x1\
    \ > 0 { 1 } else if x1 < 0 { -1 } else { 0 }, s + x2)\n    }).1)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpnzuj512p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpequq4ygh.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut signs = 1;\n    let mut res = 0;\n    for item in arr {\n        if item\
    \ != 0 {\n            signs *= (item as f64 / item.abs() as f64) as isize;\n \
    \       }\n        res += item.abs();\n    }\n    Some(res * signs)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpdhf445r3.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0uj0n32t.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpow90qksl.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let size = arr.len();\n    if size == 0 {\n        return\
    \ None;\n    }\n\n    let mut prod = 1;\n    let mut sum = 0;\n    for n in arr\
    \ {\n        if n < 0 {\n            prod *= -1;\n        }\n        sum += n.abs();\n\
    \    }\n\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp847azm_2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum = arr.iter().fold(0, |acc, &x| acc + x.abs());\n    let sign = arr.iter().fold(1,\
    \ |acc, &x| acc * x.signum());\n    Some(sum * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_product = arr.iter().map(|&n| n.signum()).product();\n    let abs_sum =\
    \ arr.iter().map(|&n| n.abs()).sum();\n    Some(sign_product * abs_sum)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmptcosl977.rs:13:9\n\
    \   |\n13 |     let sign_product = arr.iter().map(|&n| n.signum()).product();\n\
    \   |         ^^^^^^^^^^^^ consider giving `sign_product` a type\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sign = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            sign *= 1;\n        } else if i < 0 {\n            sign *= -1;\n\
    \        } else {\n            sign *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ s = arr.iter().map(|x| match x {\n        x if x > &0 => 1,\n        x if x\
    \ < &0 => -1,\n        _ => 0,\n    });\n    let sign_prod = s.fold(1, |acc, x|\
    \ acc * x);\n    let p = arr.iter().map(|x| x.abs());\n    let sum_of_magnitudes\
    \ = p.fold(0, |acc, x| acc + x);\n    Some(sum_of_magnitudes * sign_prod)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // your code here\n    None\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpw4h239ee.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptegp4ypx.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let arr: Vec<Option<isize>> = arr.iter().map(|i| if *i\
    \ == 0 { None } else { Some(*i) }).collect();\n    let mut result = if arr.is_empty()\
    \ { None } else { Some(1) };\n    for e in arr {\n        if let Some(i) = e {\n\
    \            if let Some(i) = result {\n                result = Some(i * i.signum());\n\
    \            }\n        }\n    }\n    if let Some(i) = result {\n        result\
    \ = Some(i.abs());\n    }\n    result\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `signum` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpiklys9gw.rs:15:37\n   |\n14 |             if let Some(i) = result\
    \ {\n   |                         - you must specify a type for this binding,\
    \ like `i32`\n15 |                 result = Some(i * i.signum());\n   |      \
    \                               ^^^^^^\n\nerror[E0689]: can't call method `abs`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpiklys9gw.rs:20:25\n   |\n\
    19 |     if let Some(i) = result {\n   |                 - you must specify a\
    \ type for this binding, like `i32`\n20 |         result = Some(i.abs());\n  \
    \ |                         ^^^\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut sum = 0;\n    let mut prod = 1;\n    for n in arr\
    \ {\n        sum += n.abs();\n        prod *= n.signum();\n    }\n    if arr.is_empty()\
    \ {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpstpj4h7h.rs:16:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for n in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     if arr.is_empty()\
    \ {\n    |        ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for n in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpvepmotvo.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let s = arr.len();\n    if s == 0 {\n        return None;\n\
    \    }\n\n    let mut prod = 1;\n    let mut sum = 0;\n    for a in arr {\n  \
    \      if a > 0 {\n            prod *= 1;\n        } else if a < 0 {\n       \
    \     prod *= -1;\n        } else {\n            prod *= 0;\n        }\n     \
    \   sum += a.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_product = arr.iter().filter(|&x| *x != 0).fold(1, |prod, n| n.signum()\
    \ * prod);\n    let sum_of_magnitudes = arr.iter().map(|x| x.abs()).sum();\n \
    \   Some(sign_product * sum_of_magnitudes)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp14r9xzcm.rs:14:9\n\
    \   |\n14 |     let sum_of_magnitudes = arr.iter().map(|x| x.abs()).sum();\n \
    \  |         ^^^^^^^^^^^^^^^^^ consider giving `sum_of_magnitudes` a type\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() { return None; }\n    let mut sigma =\
    \ 1;\n    let mut sum = 0;\n    for num in arr {\n        sum += num.abs();\n\
    \        sigma *= num.signum();\n    }\n    Some(sum * sigma)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    None\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpbz24bqt8.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ arr_len = arr.len();\n    let mut res = 1;\n    let mut sum = 0;\n    for i\
    \ in 0..arr_len {\n        let sign = arr[i].signum();\n        sum += arr[i].abs();\n\
    \        res *= sign;\n    }\n    Some(sum * res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ p1 = arr.iter().map(|x| x.abs()).sum::<isize>();\n    let p2 = arr.iter().fold(1,\
    \ |acc, &x| acc * x.signum());\n    Some(p1 * p2)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu3rycl0x.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3edzb8iy.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut p = 1;\n    let mut s = 0;\n    for x in arr {\n        p *= (x > 0) as\
    \ isize + (x < 0) as isize;\n        s += x.abs();\n    }\n    Some(p * s)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpru9_2_kp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3zh8_pa8.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let size = arr.len();\n    if size == 0 {\n        return\
    \ None;\n    }\n    let mut signs = 1;\n    let mut sum = 0;\n    for i in 0..size\
    \ {\n        let n = arr[i];\n        if n == 0 {\n            continue;\n   \
    \     }\n        if n < 0 {\n            signs *= -1;\n        }\n        sum\
    \ += n.abs();\n    }\n    Some(sum * signs)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpz2icttl9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpp28ingzi.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * arr.iter().map(|x| x.signum()).product::<isize>()\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2201uvcr.rs:13:5\n   |\n\
    9  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n13 |     arr.iter().map(|x| x.abs()).sum::<isize>() * arr.iter().map(|x|\
    \ x.signum()).product::<isize>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |     Some(arr.iter().map(|x| x.abs()).sum::<isize>() * arr.iter().map(|x|\
    \ x.signum()).product::<isize>())\n   |     +++++                            \
    \                                                                  +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mag = arr.iter().map(|x| x.abs()).sum::<isize>();\n    let sign = arr.iter().fold(1,\
    \ |acc, x| if *x == 0 { acc } else { acc * (*x / x.abs()) });\n    Some(mag *\
    \ sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp8qj61yfg.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut sum = 0;\n    for a in arr {\n        product\
    \ *= signum(a);\n        sum += a.abs();\n    }\n    Some(sum * product)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `signum` in this scope\n  --> /tmp/tmpuz7llexm.rs:16:20\n\
    \   |\n16 |         product *= signum(a);\n   |                    ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut product = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        product *= i.signum();\n    }\n    Some(sum * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(None, |acc, x| {\n        let prod = acc.unwrap_or(1);\n\
    \        let x_val = x.abs() as isize;\n        let x_sign = x.signum();\n   \
    \     Some(prod * x_val * x_sign)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpuxh9s09n.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut sum = 0;\n    let mut prod = 1;\n    for i in arr\
    \ {\n        sum += i.abs();\n        prod *= i.signum();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpsb6px1pu.rs:16:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|&x|\
    \ (x.abs(), x.signum())).fold((0, 1), |acc, (a, b)| (acc.0 + a, acc.1 * b)))\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxpd04v07.rs:13:58\n   |\n\
    13 |     Some(arr.iter().map(|&x| (x.abs(), x.signum())).fold((0, 1), |acc, (a,\
    \ b)| (acc.0 + a, acc.1 * b)))\n   |                                         \
    \                 ^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `({integer}, {integer})`\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpxpd04v07.rs:13:85\n\
    \   |\n13 |     Some(arr.iter().map(|&x| (x.abs(), x.signum())).fold((0, 1), |acc,\
    \ (a, b)| (acc.0 + a, acc.1 * b)))\n   |                                     \
    \                                                ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpxpd04v07.rs:13:96\n\
    \   |\n13 |     Some(arr.iter().map(|&x| (x.abs(), x.signum())).fold((0, 1), |acc,\
    \ (a, b)| (acc.0 + a, acc.1 * b)))\n   |                                     \
    \                                                           ^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ (magnitude, signs) = arr.iter().fold((0, 1), |acc, x| {\n        (acc.0 + x.abs(),\
    \ acc.1 * x.signum())\n    });\n    Some(magnitude * signs)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgct7p3_l.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // Your code goes here!\n    // let arr: Vec<isize> = vec![1,\
    \ 2, 2, -4];\n    let mut res = 1;\n    let mut sum = 0;\n    for i in arr {\n\
    \        res *= (i as f64 / i.abs() as f64) as isize;\n        sum += i.abs();\n\
    \    }\n    match arr.len() {\n        0 => None,\n        _ => Some(res * sum),\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpfyg_ldzc.rs:18:11\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n18  |     match arr.len()\
    \ {\n    |           ^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n14  |     for i in &arr {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    arr.iter().fold(Some(1), |acc, &x| {\n        match x {\n\
    \            x if x > 0 => acc.map(|v| v * 1),\n            x if x < 0 => acc.map(|v|\
    \ v * -1),\n            _ => None,\n        }\n    }).map(|sign| {\n        arr.iter().fold(0,\
    \ |acc, &x| acc + x.abs()) * sign\n    })\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmpn_jtp1p4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    // TODO\n    None\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpu_cckzeg.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        match i.signum()\
    \ {\n            0 => {},\n            1 => {\n                prod *= 1;\n  \
    \              sum += i.abs();\n            },\n            -1 => {\n        \
    \        prod *= -1;\n                sum += i.abs();\n            },\n      \
    \      _ => unreachable!(),\n        }\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpzry7ri4t.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut s = 1;\n    let mut p = 1;\n    for x in arr {\n\
    \        s += x.signum();\n        p *= x.signum();\n    }\n    if arr.len() ==\
    \ 0 {\n        None\n    } else {\n        Some(s * p)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpc8xcvoxh.rs:16:8\n\
    \    |\n9   | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n12  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n12  |     for x in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    let mut counter = 0;\n    let mut sign = 1;\n    for a\
    \ in arr {\n        if a > 0 {\n            counter += a;\n        } else if a\
    \ < 0 {\n            counter += a.abs();\n            sign *= -1;\n        }\n\
    \    }\n    if counter == 0 {\n        None\n    } else {\n        Some(counter\
    \ * sign)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpcijnnr6u.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ arr = arr.into_iter()\n                 .map(|num| {\n                     if\
    \ num > 0 { 1 }\n                     else if num < 0 { -1 }\n               \
    \      else { 0 }\n                 })\n                 .collect::<Vec<isize>>();\n\
    \    let prod = arr.iter().product();\n    let sum = arr.iter().map(|num| num.abs()).sum();\n\
    \    Some(prod * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp_734_vxv.rs:20:9\n\
    \   |\n20 |     let prod = arr.iter().product();\n   |         ^^^^ consider giving\
    \ `prod` a type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) ->\
    \ Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sum: isize = arr.iter().map(|&x| x.abs()).sum();\n    let mut prod: isize =\
    \ 1;\n    for x in arr {\n        prod *= match x {\n            0 => 1,\n   \
    \         _ if x > 0 => 1,\n            _ => -1,\n        };\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp04y_3ehj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
