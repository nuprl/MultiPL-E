name: HumanEval_159_eat
language: rust
results:
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ remaining = remaining;\n    let mut eaten_carrots: isize = 0;\n    let mut i\
    \ = 0;\n    loop {\n        if i > need {\n            break;\n        }\n   \
    \     if remaining > 0 {\n            number += 1;\n            remaining -= 1;\n\
    \            eaten_carrots += 1;\n        }\n        i += 1;\n    }\n    vec![eaten_carrots,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 3]`,\n right: `[11, 4]`', /tmp/tmpn4f3oake.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut need = need;\n    let mut remaining\
    \ = remaining;\n    let mut result = number;\n    loop {\n        if need == 0\
    \ {\n            break;\n        } else if remaining > 0 {\n            remaining\
    \ -= 1;\n            need -= 1;\n            result += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    vec![result, remaining]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let (n, r) = (number + need, remaining\
    \ - need);\n    if r < 0 {\n        vec![r + n, 0]\n    } else {\n        vec![n,\
    \ r]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![];\n    if remaining\
    \ < number {\n        result.push(remaining + number);\n        result.push(0);\n\
    \    } else {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, -6]`,\n right: `[7, 0]`', /tmp/tmpoecvv_3q.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut num = number;\n    let mut rem\
    \ = remaining;\n    for _ in 0..need {\n        if rem > 0 {\n            num\
    \ += 1;\n            rem -= 1;\n        }\n    }\n    vec![num, rem]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_eat = number + if need > remaining\
    \ { remaining } else { need };\n    vec![total_eat, (remaining - need).max(0)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ remaining - std::cmp::min(need, remaining)]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    let left = remaining - need;\n    vec![eaten, std::cmp::max(left,\
    \ 0)]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ need = need;\n    let mut remaining = remaining;\n    if number + remaining\
    \ >= need {\n        remaining -= need - number;\n        number = need;\n   \
    \ } else {\n        number += remaining;\n        remaining = 0;\n    }\n    vec![number,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp47tv8o4b.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let mut\
    \ left = remaining;\n    let can_eat = if need < remaining { need } else { remaining\
    \ };\n    eaten += can_eat;\n    left -= can_eat;\n    vec![eaten, left]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    let left = remaining - need;\n    if left < 0 {\n        vec![eaten,\
    \ 0]\n    } else {\n        vec![eaten, left]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, number + remaining\
    \ - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkwacpad.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + need;\n    let remaining\
    \ = if total <= remaining {\n        remaining - total\n    } else {\n       \
    \ 0\n    };\n    vec![total, remaining]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpciqmk3i_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if\
    \ need <= remaining {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![];\n    if need\
    \ >= remaining {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    } else {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let (mut total, mut rem) = (number, remaining);\n\
    \    total += ::std::cmp::min(need, remaining);\n    rem -= need;\n    if rem\
    \ < 0 {\n        rem = 0;\n    }\n    vec![total, rem]\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![\n        std::cmp::min(remaining,\
    \ number + need),\n        std::cmp::max(0, remaining - need),\n    ]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 4]`,\n right: `[11, 4]`', /tmp/tmpbll_10f_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut done = number + need;\n    let\
    \ eaten = if done <= remaining {\n        done\n    } else {\n        done = remaining;\n\
    \        done\n    };\n    vec![eaten, remaining - eaten]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpw_j7u63_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    vec![eaten, std::cmp::max(0, remaining - need)]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need < number { return vec![number,\
    \ remaining] }\n    let mut total = number;\n    let mut left = remaining;\n \
    \   for _ in 0..need - number {\n        if left > 0 {\n            total += 1;\n\
    \            left -= 1;\n        }\n    }\n    vec![total, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpz7eivave.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need > number {\n        let mut eaten\
    \ = number;\n        let mut remaining = remaining;\n        if remaining > 0\
    \ {\n            if need - number > remaining {\n                eaten += remaining;\n\
    \                remaining = 0;\n            } else {\n                eaten +=\
    \ need - number;\n                remaining -= need - number;\n            }\n\
    \        }\n        vec![eaten, remaining]\n    } else {\n        vec![number,\
    \ remaining]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpekjght77.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number >= need {\n        vec![number,\
    \ remaining]\n    } else {\n        let total_needed = number + need;\n      \
    \  if total_needed <= remaining {\n            vec![total_needed, remaining -\
    \ total_needed]\n        } else {\n            vec![total_needed - remaining,\
    \ 0]\n        }\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[11, 4]`', /tmp/tmp916icood.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining >= need {\n   \
    \     vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_a2ae9jz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_carrots = number + remaining;\n\
    \    if total_carrots >= need {\n        vec![need, total_carrots - need]\n  \
    \  } else {\n        vec![total_carrots, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmppohs9jv0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut res = number + remaining;\n \
    \   if res < need {\n        res = number + remaining;\n    } else {\n       \
    \ res = number + need;\n    }\n    vec![res, remaining - need]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpm8kkuo26.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut res = number + remaining;\n \
    \   if res >= need {\n        res = need;\n    }\n    vec![res, remaining - res\
    \ + number]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmps71zadlg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten: isize = number;\n    let\
    \ mut remaining_carrots: isize = remaining;\n    while eaten < need && remaining_carrots\
    \ > 0 {\n        eaten += 1;\n        remaining_carrots -= 1;\n    }\n    vec![eaten,\
    \ remaining_carrots]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpojmdnshq.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eat_n = number;\n    let mut\
    \ remaining_n = remaining;\n    if need >= remaining {\n        eat_n += remaining;\n\
    \        remaining_n = 0;\n    } else {\n        eat_n += need;\n        remaining_n\
    \ -= need;\n    }\n    vec![eat_n, remaining_n]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let n = if number + remaining >= need\
    \ {\n        need\n    } else {\n        number + remaining\n    };\n    vec![n,\
    \ remaining - n + number]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpqord4z1t.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining >= need {\n   \
    \     vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpn075ke3i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n\
    \    if number + need <= remaining {\n        res.push(number + need);\n     \
    \   res.push(remaining - (number + need));\n    } else {\n        res.push(remaining\
    \ + number);\n        res.push(0);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp0b1n3sw8.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // Your code here!\n    if number + remaining\
    \ < need {\n        vec![number + remaining, 0]\n    } else {\n        vec![need,\
    \ number + remaining - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpgycvb4ul.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining < need - number {\n    \
    \    vec![remaining + number, 0]\n    } else {\n        vec![need, remaining -\
    \ (need - number)]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpjjwwt1w3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ need = need;\n    let mut remaining = remaining;\n    while need > 0 && remaining\
    \ > 0 {\n        number += 1;\n        need -= 1;\n        remaining -= 1;\n \
    \   }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ std::cmp::max(0, remaining - need)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // This is your job. :)\n    let mut\
    \ stock = remaining;\n    let mut number = number;\n    for _ in 0..need {\n \
    \       if stock > 0 {\n            number += 1;\n            stock -= 1;\n  \
    \      }\n    }\n    vec![number, stock]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ std::cmp::max(0, remaining - need)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need >= remaining {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ remaining = remaining;\n    let mut need = need;\n    let mut total = 0;\n \
    \   while number < need {\n        if remaining > 0 {\n            number += 1;\n\
    \            remaining -= 1;\n            total += 1;\n        } else {\n    \
    \        return vec![total, 0];\n        }\n    }\n    return vec![total, remaining];\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 9]`,\n right: `[11, 4]`', /tmp/tmpe6ye_2x7.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total_numbers = number + remaining;\n\
    \    let mut left = 0;\n    if need > total_numbers {\n        total_numbers =\
    \ total_numbers - need;\n        left = total_numbers.abs();\n    } else {\n \
    \       left = total_numbers - need;\n    }\n    vec![total_numbers, left]\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmps3eu7hqk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let result = number + need;\n    if result\
    \ <= remaining {\n        vec![result, remaining - result]\n    } else {\n   \
    \     vec![result - remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[11, 4]`', /tmp/tmp4ijoxuhk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut count: isize = number;\n    let\
    \ mut need_c = need;\n    if remaining >= need {\n        count += need;\n   \
    \     need_c = 0;\n    } else {\n        count += remaining;\n        need_c -=\
    \ remaining;\n    }\n    vec![count, need_c]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpis2e4pxl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // your code\n    let mut total = number\
    \ + remaining;\n    if total >= need {\n        total = need;\n    }\n    vec![total,\
    \ remaining - (total - number)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmph3l7rfpg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining < number + need {\n    \
    \    vec![remaining, 0]\n    } else {\n        vec![number + need, remaining -\
    \ (number + need)]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp962u2ues.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let mut\
    \ remain = remaining;\n    if need > remaining {\n        eaten += remain;\n \
    \       remain = 0;\n    } else {\n        eaten += need;\n        remain -= need;\n\
    \    }\n    vec![eaten, remain]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    match remaining > need {\n        true\
    \ => vec![number + need, remaining - need],\n        false => vec![number + remaining,\
    \ 0],\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let number_after_meals = number + need;\n\
    \    let remaining_after_meals = remaining - need;\n    if remaining_after_meals\
    \ < 0 {\n        return vec![number_after_meals, 0];\n    }\n    vec![number_after_meals,\
    \ remaining_after_meals]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmp8wa9wsgk.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    return [number + (if need > remaining\
    \ { remaining } else { need }),\n            remaining - (if need > remaining\
    \ { remaining } else { need })]\n        .to_vec();\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let left = number + remaining - need;\n\
    \    if left >= 0 {\n        vec![number + remaining, left]\n    } else {\n  \
    \      vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmpfk4cg_6z.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // your code here\n    if remaining <\
    \ need - number {\n        return vec![number + remaining, 0];\n    }\n    vec![number\
    \ + need, remaining - need + number]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmplbru1hb2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![\n        number + std::cmp::min(need,\
    \ remaining),\n        std::cmp::max(remaining - need, 0),\n    ]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + remaining;\n   \
    \ let eat = if total < need {\n        total\n    } else {\n        need\n   \
    \ };\n    let left = if total < need {\n        0\n    } else {\n        total\
    \ - need\n    };\n    vec![eat, left]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp6jv43mb_.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let max_eat = (number + remaining).min(need);\n\
    \    vec![max_eat, remaining - (max_eat - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpn4x08ocu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut answer = vec![];\n    if number\
    \ + remaining >= need {\n        answer.push(number + need);\n        answer.push(remaining\
    \ - need);\n    } else {\n        answer.push(number + remaining);\n        answer.push(0);\n\
    \    }\n    answer\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpmmbgc0gi.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots_eaten = 0;\n    if need\
    \ < remaining {\n        carrots_eaten = number + need;\n    } else {\n      \
    \  carrots_eaten = number + remaining;\n    }\n    return vec![carrots_eaten,\
    \ remaining - need];\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp3vad3vsi.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut rem = remaining;\n    if rem\
    \ >= need {\n        rem -= need;\n    } else {\n        need -= rem;\n      \
    \  rem = 0;\n    }\n    vec![number + need, rem]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `need`\n  --> /tmp/tmpy239teas.rs:28:9\n\
    \   |\n23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                       ---- help: consider making this binding mutable:\
    \ `mut need`\n...\n28 |         need -= rem;\n   |         ^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut new_number = number + remaining;\n\
    \    if new_number >= need {\n        new_number = need;\n    }\n    vec![new_number,\
    \ new_number - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpr5b3kj9y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let current_total = number + remaining;\n\
    \    let not_enough = current_total < need;\n    let zero = 0;\n    let eaten\
    \ = if not_enough { current_total } else { need };\n    let left = if not_enough\
    \ { zero } else { current_total - need };\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpupf1i79n.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // Your code here\n    let mut carrots\
    \ = number + remaining;\n    let mut food = need;\n    let mut result = Vec::new();\n\
    \    if remaining < need {\n        food = remaining;\n    }\n    result.push(carrots\
    \ - food);\n    result.push(food);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 6]`,\n right: `[11, 4]`', /tmp/tmpbudlk5qv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + remaining;\n   \
    \ let eaten = total.min(need);\n    let left = total - eaten;\n    vec![eaten,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpccj4gs6c.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut m = number + remaining;\n   \
    \ if m >= need {\n        m = need;\n    } else {\n        m = m;\n    }\n   \
    \ vec![m, number + remaining - m]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmps5ff5gum.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut x = number + remaining;\n   \
    \ if x >= need {\n        x = need;\n    }\n    vec![x, need - x]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpny0i_hp6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ remaining = remaining;\n    for _ in 0..need {\n        if remaining > 0 {\n\
    \            number += 1;\n            remaining -= 1;\n        }\n    }\n   \
    \ vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // your code here\n    let mut number\
    \ = number;\n    let mut remaining = remaining;\n    if number >= need {\n   \
    \     return vec![number, remaining];\n    }\n    if remaining >= need - number\
    \ {\n        remaining -= need - number;\n        number = need;\n    } else {\n\
    \        number += remaining;\n        remaining = 0;\n    }\n    vec![number,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxx296mwv.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let can_eat = if need >= remaining {\
    \ remaining } else { need };\n    vec![number + can_eat, remaining - can_eat]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ need = need;\n    let mut remaining = remaining;\n    if number + remaining\
    \ < need {\n        need -= number + remaining;\n        number += remaining;\n\
    \        remaining = 0;\n    } else {\n        remaining -= need - number;\n \
    \       number = need;\n        need = 0;\n    }\n    vec![number, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpd8yb30rf.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut vec = Vec::with_capacity(2);\n\
    \    if number < 0 || need < 0 || remaining < 0 {\n        vec.push(0);\n    \
    \    vec.push(0);\n        return vec;\n    }\n    if number >= need {\n     \
    \   vec.push(number);\n        vec.push(remaining);\n        return vec;\n   \
    \ }\n    let sum = number + remaining;\n    if sum >= need {\n        vec.push(need);\n\
    \        vec.push(sum - need);\n        return vec;\n    }\n    vec.push(sum);\n\
    \    vec.push(0);\n    vec\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpysw5tjp0.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need <= remaining {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need <= remaining {\n        return\
    \ vec![number + need, remaining - need];\n    }\n    vec![number + remaining,\
    \ 0]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, remaining -\
    \ (need - number)]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpuw_gindd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = if remaining >= need {\n\
    \        number + need\n    } else {\n        number + remaining\n    };\n   \
    \ vec![eaten, remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpbrfeeye4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_need = number + need;\n   \
    \ let total_remaining = total_need - remaining;\n    let remaining_carrots = remaining\
    \ - total_need;\n    let eaten_carrots = if remaining_carrots < 0 { 0 } else {\
    \ remaining_carrots };\n    vec![total_need, eaten_carrots]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpggp3v2gk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut rem = remaining;\n    let mut\
    \ eaten = number;\n    let mut need = need;\n    loop {\n        if rem == 0 ||\
    \ need == 0 {\n            break;\n        }\n        eaten += 1;\n        rem\
    \ -= 1;\n        need -= 1;\n    }\n    vec![eaten, rem]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut remaining = remaining;\n    let\
    \ mut eaten = number;\n    for _ in 0..need {\n        if remaining > 0 {\n  \
    \          eaten += 1;\n            remaining -= 1;\n        }\n    }\n    vec![eaten,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + if need <= remaining\
    \ { need } else { remaining };\n    let remaining = if need <= remaining { remaining\
    \ - need } else { 0 };\n    vec![total, remaining]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // number + remaining >= need\n    //\
    \ need - number <= remaining\n    let val = if number + remaining >= need {\n\
    \        need - number\n    } else {\n        remaining\n    };\n    vec![number\
    \ + val, remaining - val]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpv75j7tnu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        result.push(0);\n\
    \        result.push(0);\n        return result;\n    }\n    let number = number\
    \ as i32;\n    let need = need as i32;\n    let remaining = remaining as i32;\n\
    \    let sum = number + need;\n    let mut left = remaining - sum;\n    if left\
    \ < 0 {\n        left = 0;\n    }\n    result.push(sum as isize);\n    result.push(left\
    \ as isize);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpbh29le9x.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total_eaten = number;\n    let\
    \ mut left_after_meals = remaining - need;\n    if left_after_meals < 0 {\n  \
    \      total_eaten += remaining;\n        left_after_meals = 0;\n    } else {\n\
    \        total_eaten += need;\n    }\n    vec![total_eaten, left_after_meals]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let number_of_carrots_eaten = number\
    \ + need;\n    let carrots_left = number_of_carrots_eaten - remaining;\n    if\
    \ carrots_left > 0 {\n        vec![number_of_carrots_eaten, carrots_left]\n  \
    \  } else {\n        vec![number_of_carrots_eaten, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1]`,\n right: `[11, 4]`', /tmp/tmpf_sfabpi.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need <= remaining {\n        return\
    \ vec![number + need, remaining - need];\n    } else {\n        return vec![number\
    \ + remaining, 0];\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    let left\
    \ = if remaining >= need { remaining - need } else { 0 };\n    vec![eaten, left]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmp6v2lgshx.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total = number + need;\n    if\
    \ total > remaining {\n        total = remaining;\n    }\n    vec![total, remaining\
    \ - total]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpki24uwwn.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + need;\n    if total\
    \ > remaining {\n        vec![remaining, 0]\n    } else {\n        vec![total,\
    \ remaining - total]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp2arrhhg4.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    if eaten\
    \ + remaining < need {\n        eaten += remaining;\n        vec![eaten, 0]\n\
    \    } else {\n        vec![eaten + need, remaining - need]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpxif63g6a.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // my solution\n    if remaining > number\
    \ + need {\n        vec![number + need, remaining - (number + need)]\n    } else\
    \ if remaining <= number + need && remaining > number {\n        vec![remaining,\
    \ 0]\n    } else {\n        vec![number, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpfii1ga65.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten_carrots = number + std::cmp::min(need,\
    \ remaining);\n    let carrots_left = remaining - std::cmp::min(need, remaining);\n\
    \    vec![eaten_carrots, carrots_left]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + remaining;\n   \
    \ if total >= need {\n        vec![need, total - need]\n    } else {\n       \
    \ vec![total, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp83d2gn8c.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let remaining = remaining - number;\n\
    \    if remaining < need {\n        vec![number + remaining, 0]\n    } else {\n\
    \        vec![number + need, remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpa4mz0nls.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total = number + need;\n    let\
    \ mut left = remaining - need;\n    if total > remaining {\n        total = remaining;\n\
    \        left = 0;\n    }\n    vec![total, left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpk8gtbloq.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + remaining.min(need\
    \ - number);\n    vec![eaten, remaining - (eaten - number)]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpriy6rjb6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining < need - number {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![number + need, remaining\
    \ - need + number]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp4bixg_kc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = if need <= remaining {\n\
    \        number + need\n    } else {\n        number + remaining\n    };\n   \
    \ vec![eaten, remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpx7ga4qxd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    //if remaining >= need\n    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= number + need {\n   \
    \     vec![number + need, remaining - number - need]\n    } else {\n        vec![remaining\
    \ + number, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmply7sssdd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    match remaining as isize {\n        e\
    \ if e <= 0 => vec![number, 0],\n        e if e < need - number => vec![number\
    \ + e, 0],\n        _ => vec![number + need, remaining - need],\n    }\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpdbpphxtt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ remaining - std::cmp::min(need, remaining)]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    let left\
    \ = if eaten > remaining {\n        0\n    } else {\n        remaining - eaten\n\
    \    };\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n \
    \   assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmp5yu2equ3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let diff = need - number;\n    match\
    \ remaining >= diff {\n        true => vec![number + diff, remaining - diff],\n\
    \        false => vec![number + remaining, 0],\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpg_mmsrx3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![number + remaining,\
    \ 0];\n    if need > result[0] {\n        result[0] = need;\n    } else {\n  \
    \      result[1] = result[0] - need;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmp68o2qjsa.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need + number > remaining {\n    \
    \    vec![remaining, 0]\n    } else {\n        vec![need + number, remaining -\
    \ need - number]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpruxzc0zw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let mut\
    \ left = remaining;\n    let eaten_last = std::cmp::min(need, left);\n    eaten\
    \ += eaten_last;\n    left -= eaten_last;\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    let left = std::cmp::max(0, remaining - need);\n    vec![eaten,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let diff = need - number;\n    let mut\
    \ remaining = remaining;\n    if diff <= remaining {\n        remaining -= diff;\n\
    \    } else {\n        remaining = 0;\n    }\n    vec![number + need - remaining,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 9]`,\n right: `[11, 4]`', /tmp/tmpuw2wx9qd.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= need - number {\n   \
    \     vec![number + need, remaining - (need - number)]\n    } else {\n       \
    \ vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpx14srd28.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut n = number;\n    let mut r =\
    \ remaining;\n    let left_to_eat = need - n;\n    if left_to_eat <= r {\n   \
    \     n += left_to_eat;\n        r -= left_to_eat;\n    } else {\n        n +=\
    \ r;\n        r = 0;\n    }\n    vec![n, r]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxn99gdqz.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + remaining;\n   \
    \ let eaten = if need <= total {\n        need\n    } else {\n        total\n\
    \    };\n    vec![eaten, total - eaten]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmposrba6jg.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining >= need {\n   \
    \     vec![need, remaining - (need - number)]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpotx3a8wv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, remaining -\
    \ (need - number)]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_etbt_gb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let number_left = remaining - need;\n\
    \    let number_ate = number + remaining;\n    if number_left < 0 {\n        return\
    \ vec![number_ate, 0];\n    }\n    vec![number_ate, number_left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 4]`,\n right: `[11, 4]`', /tmp/tmp_az5pv4x.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let mut\
    \ rem = remaining;\n    if eaten < need {\n        eaten += rem;\n        rem\
    \ = 0;\n    }\n    if eaten > need {\n        rem = eaten - need;\n        eaten\
    \ = need;\n    }\n    vec![eaten, rem]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp5mjmo5pk.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut num = number;\n    if num < 0\
    \ || num > 1000 {\n        num = 0;\n    }\n    let mut ned = need;\n    if ned\
    \ < 0 || ned > 1000 {\n        ned = 0;\n    }\n    let mut rem = remaining;\n\
    \    if rem < 0 || rem > 1000 {\n        rem = 0;\n    }\n    let mut re_ve =\
    \ Vec::new();\n    let mut rem_rem = rem - ned;\n    if rem_rem < 0 {\n      \
    \  re_ve.push(num + rem);\n        re_ve.push(0);\n    } else {\n        re_ve.push(num\
    \ + ned);\n        re_ve.push(rem_rem);\n    }\n    re_ve\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    let carrots\
    \ = if remaining < need { 0 } else { remaining - need };\n    vec![eaten, carrots]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmpzbb_2up2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // make a clone var to prevent changing\
    \ the remaining value.\n    let mut rem = remaining;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let total_eat = need + number;\n    result.push(total_eat);\n\
    \    if total_eat > remaining {\n        rem = 0;\n    } else {\n        rem -=\
    \ total_eat;\n    }\n    result.push(rem);\n    result\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpn53ct78n.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_number = number + (if remaining\
    \ > need { need } else { remaining });\n    let remaining_carrots = remaining\
    \ - need;\n    vec![total_number, remaining_carrots.max(0)]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let remaining\
    \ = if need > remaining {\n        eaten += remaining;\n        0\n    } else\
    \ {\n        remaining - need\n    };\n    vec![eaten, remaining]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmpbsqmdk2u.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining > need {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ remaining = remaining;\n    let mut need = need;\n    let mut res: Vec<isize>\
    \ = Vec::new();\n    if remaining <= 0 {\n        res.push(number);\n        res.push(0);\n\
    \        return res;\n    } else if need <= 0 {\n        res.push(number);\n \
    \       res.push(remaining);\n        return res;\n    } else if number >= need\
    \ {\n        res.push(number);\n        res.push(remaining);\n        return res;\n\
    \    } else {\n        if remaining > need {\n            number += need;\n  \
    \          remaining -= need;\n            need = 0;\n        } else {\n     \
    \       number += remaining;\n            need -= remaining;\n            remaining\
    \ = 0;\n        }\n    }\n    res.push(number);\n    res.push(remaining);\n  \
    \  return res;\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = if number + remaining < need\
    \ {\n        number + remaining\n    } else {\n        need\n    };\n    vec![eaten,\
    \ remaining - eaten + number]\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_tgm4tzg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut count: isize = number;\n    if\
    \ remaining + number < need {\n        count += remaining;\n        remaining\
    \ = 0;\n    } else {\n        count += need;\n        remaining -= need;\n   \
    \ }\n    vec![count, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `remaining`\n  --> /tmp/tmpdjmajf0c.rs:27:9\n\
    \   |\n23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n27 |         remaining = 0;\n   |   \
    \      ^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `remaining`\n  --> /tmp/tmpdjmajf0c.rs:30:9\n \
    \  |\n23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n30 |         remaining -= need;\n   |\
    \         ^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let mut\
    \ left = remaining;\n    if left >= need {\n        eaten += need;\n        left\
    \ -= need;\n    } else {\n        eaten += left;\n        left = 0;\n    }\n \
    \   vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + remaining.min(need);\n\
    \    let remaining = remaining - need.min(remaining);\n    vec![eaten, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_eat = number + need;\n    if\
    \ total_eat <= remaining {\n        vec![total_eat, remaining - total_eat]\n \
    \   } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp42_3be8u.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_carrots = number + remaining;\n\
    \    let current_carrots = std::cmp::min(total_carrots, need);\n    let remaining_carrots\
    \ = std::cmp::max(total_carrots - need, 0);\n    vec![current_carrots, remaining_carrots]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpni5y1evx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total = number + remaining;\n\
    \    if total < need {\n        total = number + remaining;\n    } else {\n  \
    \      total = number + need;\n    }\n    vec![total, remaining - need]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpueogoysd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    vec![eaten, remaining - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, -1]`,\n right: `[11, 4]`', /tmp/tmpoq166ec4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let needed = need - number;\n    if needed\
    \ > remaining {\n        vec![remaining + number, 0]\n    } else {\n        vec![needed\
    \ + number, remaining - needed]\n    }\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpc0soz9z3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![number];\n    if\
    \ need > remaining {\n        result.push(0);\n    } else {\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmpb6quzji8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = Vec::with_capacity(2);\n\
    \    if remaining > need {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ remaining - std::cmp::min(need, remaining)]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let needed = need - number;\n    if needed\
    \ <= remaining {\n        vec![number + needed, remaining - needed]\n    } else\
    \ {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpwjv2kn2j.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, number + remaining\
    \ - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpqhs2yxr6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let rem = remaining - number;\n    if\
    \ rem >= need {\n        vec![number + need, rem - need]\n    } else {\n     \
    \   vec![number + rem, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpx3zs8d09.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut n = number + remaining;\n   \
    \ let mut m = need - n;\n    if m < 0 {\n        m = 0;\n    }\n    vec![n, m]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp5xao8qpa.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need + number <= remaining {\n   \
    \     vec![need + number, remaining - (need + number)]\n    } else {\n       \
    \ vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpz83ok59p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total = number + remaining;\n\
    \    let mut hungry = need;\n    if hungry > total {\n        hungry = total;\n\
    \    }\n    let mut remaining = total - hungry;\n    vec![hungry, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpw33_o5k6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut remaining = remaining;\n    let\
    \ mut result = number;\n    if result >= need {\n        return vec![result, remaining];\n\
    \    }\n    for _ in 0..need - result {\n        if remaining > 0 {\n        \
    \    remaining -= 1;\n            result += 1;\n        }\n    }\n    vec![result,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpt2bedzn3.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ remaining - std::cmp::min(need, remaining)]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if\
    \ number + remaining >= need {\n        result.push(need);\n        result.push(remaining\
    \ - (need - number));\n    } else {\n        result.push(number + remaining);\n\
    \        result.push(0);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpit1qx03u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining < need {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots_left = remaining - number;\n\
    \    let mut eaten = number;\n    if carrots_left < need {\n        eaten += carrots_left;\n\
    \        carrots_left = 0;\n    } else {\n        eaten += need;\n        carrots_left\
    \ -= need;\n    }\n    vec![eaten, carrots_left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpibq3y067.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + remaining;\n   \
    \ if total >= need {\n        vec![need, total - need]\n    } else {\n       \
    \ vec![total, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmptk5fzfni.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots_remaining = remaining;\n\
    \    let mut carrots_eaten = number;\n    let mut left_to_eat = need;\n    if\
    \ carrots_remaining >= left_to_eat {\n        carrots_remaining -= left_to_eat;\n\
    \        carrots_eaten += left_to_eat;\n        left_to_eat = 0;\n    } else {\n\
    \        carrots_eaten += carrots_remaining;\n        left_to_eat -= carrots_remaining;\n\
    \        carrots_remaining = 0;\n    }\n    vec![carrots_eaten, carrots_remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    if eaten\
    \ + remaining < need {\n        eaten += remaining;\n        remaining = 0;\n\
    \    } else {\n        eaten += need;\n        remaining -= need;\n    }\n   \
    \ vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `remaining`\n  --> /tmp/tmp1e_xweon.rs:27:9\n\
    \   |\n23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n27 |         remaining = 0;\n   |   \
    \      ^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `remaining`\n  --> /tmp/tmp1e_xweon.rs:30:9\n \
    \  |\n23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n30 |         remaining -= need;\n   |\
    \         ^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut total_carrots = number + remaining;\n\
    \    if total_carrots >= need {\n        total_carrots = need;\n    }\n    vec![total_carrots,\
    \ remaining - (need - total_carrots)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 10]`,\n right: `[11, 4]`', /tmp/tmpu92h9rwt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need <= number + remaining {\n   \
    \     vec![number + need, remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmp9xzxmu9z.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut remain = remaining;\n    let\
    \ need = if need >= remaining {\n        let temp = need - remaining;\n      \
    \  remain = 0;\n        temp\n    } else {\n        remain -= need;\n        0\n\
    \    };\n    vec![number + need, remain]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmpye__maty.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number < 0 || need < 0 || remaining\
    \ < 0 {\n        panic!(\"Out of bounds\");\n    }\n    let sum = number + need;\n\
    \    if sum < remaining {\n        vec![sum, remaining - sum]\n    } else {\n\
    \        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmphy20q009.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + std::cmp::min(need,\
    \ remaining);\n    vec![total, remaining - need]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5qzn548x.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number >= need {\n        return vec![number,\
    \ remaining];\n    }\n    let left = need - number;\n    if left > remaining {\n\
    \        return vec![number + remaining, 0];\n    }\n    vec![number + left, remaining\
    \ - left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_z6miod4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    if remaining <\
    \ number + need {\n        result.push(remaining);\n        remaining = 0;\n \
    \   } else {\n        number += need;\n        remaining -= number;\n        result.push(number);\n\
    \    }\n    result.push(remaining);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpdjp9iin9.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut new_number = number + remaining;\n\
    \    if new_number >= need {\n        new_number = need;\n    }\n    vec![new_number,\
    \ remaining - (new_number - number)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpnpi65mr_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eat_count = number;\n    let\
    \ mut need_count = need;\n    if remaining == 0 {\n        return vec![number,\
    \ 0];\n    } else if remaining < need {\n        need_count = remaining;\n   \
    \ }\n    eat_count += need_count;\n    vec![eat_count, remaining - need_count]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ need = need;\n    let mut remaining = remaining;\n    if need > remaining {\n\
    \        number += remaining;\n        remaining = 0;\n    } else {\n        number\
    \ += need;\n        remaining -= need;\n    }\n    vec![number, remaining]\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining >= need {\n   \
    \     vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpoh7ynakc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, number + remaining\
    \ - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmptqmvttfw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    if eaten\
    \ > remaining {\n        vec![remaining, 0]\n    } else {\n        vec![eaten,\
    \ remaining - eaten]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpum17_qnu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots_remaining = remaining\
    \ - number;\n    let mut carrots_needed = need - number;\n    let mut eaten_carrots\
    \ = number;\n    if carrots_remaining >= carrots_needed {\n        eaten_carrots\
    \ += carrots_needed;\n        carrots_remaining -= carrots_needed;\n        carrots_needed\
    \ = 0;\n    } else {\n        eaten_carrots += carrots_remaining;\n        carrots_needed\
    \ -= carrots_remaining;\n        carrots_remaining = 0;\n    }\n    vec![eaten_carrots,\
    \ carrots_remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 4]`,\n right: `[11, 4]`', /tmp/tmpkxiyt8pt.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut num = number;\n    let mut rem\
    \ = remaining;\n    let mut eaten = 0;\n    while rem > 0 && num < need {\n  \
    \      num += 1;\n        rem -= 1;\n        eaten += 1;\n    }\n    vec![num,\
    \ rem]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpt29hv0kf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![];\n    if number\
    \ + remaining >= need {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpzud03elu.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut new_number = number + remaining;\n\
    \    let mut new_remaining = 0;\n    if need > new_number {\n        new_number\
    \ = number + remaining;\n        new_remaining = 0;\n    } else {\n        new_number\
    \ = number + remaining;\n        new_remaining = new_number - need;\n    }\n \
    \   vec![new_number, new_remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmp0_zrimbc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut num = number;\n    let mut rem\
    \ = remaining;\n    if need > remaining {\n        num += remaining;\n       \
    \ rem = 0;\n    } else {\n        num += need;\n        rem -= need;\n    }\n\
    \    vec![num, rem]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut a = Vec::new();\n    if number\
    \ + remaining >= need {\n        a.push(number + need);\n        a.push(remaining\
    \ - need);\n    } else {\n        a.push(number + remaining);\n        a.push(0);\n\
    \    }\n    a\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmp8vggka3r.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total_carrots = number + remaining;\n\
    \    if total_carrots >= need {\n        vec![need, total_carrots - need]\n  \
    \  } else {\n        vec![total_carrots, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpudj8_4ah.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut n = number + remaining;\n   \
    \ if n >= need {\n        n = need;\n    }\n    vec![n, need - n]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpvc6dtoih.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    let left\
    \ = if eaten > remaining { 0 } else { remaining - eaten };\n    vec![eaten, left]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmp9w3xt89k.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut number = number;\n    let mut\
    \ need = need;\n    let mut remaining = remaining;\n    while remaining > 0 &&\
    \ need > 0 {\n        number += 1;\n        need -= 1;\n        remaining -= 1;\n\
    \    }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= need {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // Your code here\n    let sum: isize\
    \ = number + need;\n    if sum <= remaining {\n        vec![sum, remaining - sum]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpqaqpu_7b.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut arr = vec![];\n    if remaining\
    \ <= number + need {\n        arr.push(remaining + number);\n        arr.push(0);\n\
    \    } else {\n        arr.push(number + need);\n        arr.push(remaining -\
    \ need);\n    }\n    arr\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpkc7moc4j.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let a = number + need;\n    if a <= remaining\
    \ {\n        vec![a, remaining - a]\n    } else {\n        vec![a - (a - remaining),\
    \ 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpm9p2ngxo.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= need {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut eaten = number;\n    let (mut\
    \ remain, mut left) = if remaining > need {\n        (remaining - need, 0)\n \
    \   } else {\n        (0, need - remaining)\n    };\n    eaten += remain;\n  \
    \  remain = left;\n    vec![eaten, remain]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 0]`,\n right: `[11, 4]`', /tmp/tmpfcgnec_e.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![number];\n    if\
    \ remaining < need {\n        result.push(0);\n    } else {\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmpeupff5dx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = number + remaining;\n\
    \    if result > need {\n        result = need;\n    }\n    vec![result, remaining\
    \ - result + number]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpamx0ha_5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut result = vec![];\n    if number\
    \ + remaining >= need {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmp0_8k_rwu.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= need - number {\n   \
    \     vec![number + need, remaining - (need - number)]\n    } else {\n       \
    \ vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmp730ke_b9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let num_carrots_eaten: isize = number\
    \ + std::cmp::min(need, remaining);\n    let num_carrots_left: isize = std::cmp::max(0,\
    \ remaining - need);\n    vec![num_carrots_eaten, num_carrots_left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining >= need {\n   \
    \     vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpg1l195z3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining >= need - number {\n   \
    \     vec![number + need, remaining - (need - number)]\n    } else {\n       \
    \ vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmplycr5yli.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // I don't know if you can solve this\
    \ without an if statement\n    // but I like to try to solve it only by using\
    \ one if\n    // I'm sure there are other solutions\n    if number >= need {\n\
    \        return vec![number + remaining, 0];\n    } else if remaining >= need\
    \ - number {\n        return vec![need, remaining - (need - number)];\n    } else\
    \ {\n        return vec![remaining + number, 0];\n    }\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpk1rg3r_d.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let left = remaining - need;\n    let\
    \ out = if left > 0 {\n        vec![number + need, left]\n    } else {\n     \
    \   vec![number + remaining, 0]\n    };\n    out\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    return vec![\n        number + need.min(remaining),\n\
    \        remaining - need.min(remaining),\n    ];\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    vec![eaten, remaining - need]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpb7jnxx4w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots = vec![number, need,\
    \ remaining];\n    carrots.sort();\n    let (number, need, remaining) = (carrots[0],\
    \ carrots[1], carrots[2]);\n    let mut result = vec![];\n    result.push(number\
    \ + remaining);\n    if result[0] < need {\n        result.push(0);\n    } else\
    \ {\n        result.push(result[0] - need);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmpmrt8brlc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut num = number;\n    if remaining\
    \ <= need {\n        num += remaining;\n        return vec![num, 0];\n    }\n\
    \    num += need;\n    remaining - need\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphjbzq7kq.rs:30:5\n   |\n\
    23 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n  \
    \ |                                                         ---------- expected\
    \ `Vec<isize>` because of return type\n...\n30 |     remaining - need\n   |  \
    \   ^^^^^^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let eaten = number + std::cmp::min(need,\
    \ remaining);\n    vec![eaten, remaining - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, -1]`,\n right: `[11, 4]`', /tmp/tmpowthst3y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let result: isize = number + need;\n\
    \    let mut remaining = remaining;\n    if remaining < result {\n        remaining\
    \ = 0;\n    } else {\n        remaining -= result;\n    }\n    vec![result, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmpw_496m3x.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if need <= remaining {\n        return\
    \ vec![number + need, remaining - need];\n    }\n    if need > remaining && remaining\
    \ != 0 {\n        return vec![number + remaining, 0];\n    }\n    vec![number,\
    \ 0]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut value = remaining - need + number;\n\
    \    if value < 0 {\n        return vec![number + remaining, 0];\n    }\n    return\
    \ vec![number + need, value];\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpmyi4msa5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut carrots_left = remaining - number;\n\
    \    let mut carrots_left_after_eating = need - carrots_left;\n    if carrots_left\
    \ >= need {\n        carrots_left -= need;\n        carrots_left_after_eating\
    \ = 0;\n    }\n    vec![number + need - carrots_left_after_eating, carrots_left]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 5]`,\n right: `[11, 4]`', /tmp/tmp_i__uqyn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    vec![number + std::cmp::min(need, remaining),\
    \ std::cmp::max(0, remaining - need)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut res = number + remaining;\n \
    \   if res >= need {\n        res = need;\n    }\n    vec![res, need - res]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmp1fr4f2oc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let mut n = number + need;\n    let mut\
    \ r = remaining;\n    if r < n {\n        n = r;\n        r = 0;\n    } else {\n\
    \        r -= n;\n    }\n    vec![n, r]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpmu35t82l.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let total = number + need;\n    if total\
    \ > remaining {\n        return vec![total - need, 0];\n    }\n    return vec![total,\
    \ remaining - total];\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0]`,\n right: `[11, 4]`', /tmp/tmpbz5vhwg2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let leftover = if need < remaining {\n\
    \        remaining - need\n    } else {\n        0\n    };\n    vec![number +\
    \ need, leftover]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmp811s6hg6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if number + remaining < need {\n    \
    \    vec![number + remaining, 0]\n    } else {\n        vec![need, number + remaining\
    \ - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzogm_k26.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    match remaining >= need {\n        true\
    \ => vec![number + need, remaining - need],\n        false => vec![number + remaining,\
    \ 0],\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    // let (a, b) = if number + remaining\
    \ >= need { (need, (number + remaining) - need) } else { (number + remaining,\
    \ 0) };\n    // vec![a, b]\n    vec![\n        std::cmp::min(number + remaining,\
    \ need),\n        std::cmp::max(number + remaining - need, 0),\n    ]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpumyx05m2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    if remaining == 0 {\n        return vec![number,\
    \ 0];\n    }\n\n    if remaining > number + need {\n        return vec![number\
    \ + need, remaining - number - need];\n    }\n\n    if remaining > number {\n\
    \        return vec![remaining, 0];\n    }\n\n    vec![number, 0]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp3dgab6cc.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4,\
    \ 8, 9) -> [12, 1]\n/// * eat(1, 10, 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7,\
    \ 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you\
    \ have eaten.\n/// @need : integer\n/// the number of carrots that you need to\
    \ eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist\
    \ in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n\
    /// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize,\
    \ remaining: isize) -> Vec<isize> {\n    let left = remaining - need;\n    if\
    \ left < 0 {\n        vec![number + remaining, 0]\n    } else {\n        vec![number\
    \ + need, left]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
