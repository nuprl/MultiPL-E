name: HumanEval_161_solve
language: rust
results:
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpdu14e_1x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() {\n    \
    \    c.to_ascii_uppercase()\n    } else {\n        c\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpubbdlhnq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| {\n        match x {\n            'a'...'z'\
    \ => (x as u8 - 32) as char,\n            'A'...'Z' => (x as u8 + 32) as char,\n\
    \            _ => x,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpacqsuyiw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect();\n    }\n    s.chars().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                c.to_lowercase().to_string()\n\
    \            } else {\n                c.to_uppercase().to_string()\n        \
    \    }\n        } else {\n            c.to_string()\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars: Vec<char> = s.chars().collect();\n    if chars.iter().all(|&c|\
    \ !c.is_alphabetic()) {\n        chars.reverse();\n        return chars.into_iter().collect();\n\
    \    }\n    chars.iter().map(|&c| {\n        if c.is_ascii_uppercase() {\n   \
    \         c.to_ascii_lowercase()\n        } else if c.is_ascii_lowercase() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpckboeykc.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_lowercase().next().unwrap()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpnvalre8j.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            if c.is_uppercase() {\n                c.to_lowercase().to_string()\n\
    \            } else {\n                c.to_uppercase().to_string()\n        \
    \    }\n        } else {\n            c.to_string()\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpzey0tg1_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c|\
    \ if c.is_alphabetic() { c.to_ascii_uppercase() } else { c }).collect()\n    }\
    \ else {\n        s.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp4ob1ekt4.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if !s.chars().any(|x| x.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect::<String>();\n    }\n    s.chars().map(|x| {\n     \
    \   if x.is_ascii_uppercase() {\n            x.to_ascii_lowercase()\n        }\
    \ else if x.is_ascii_lowercase() {\n            x.to_ascii_uppercase()\n     \
    \   } else {\n            x\n        }\n    }).collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      match c {\n            'A'...'Z' => res.push(c.to_ascii_lowercase()),\n\
    \            'a'...'z' => res.push(c.to_ascii_uppercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    return s.chars().rev().map(|c| c.is_ascii_alphabetic()? c.to_ascii_uppercase():\
    \ c.to_ascii_lowercase()).collect();\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmppq5vz4j2.rs:11:61\n\
    \   |\n11 |     return s.chars().rev().map(|c| c.is_ascii_alphabetic()? c.to_ascii_uppercase():\
    \ c.to_ascii_lowercase()).collect();\n   |                                   \
    \                          ^^^^^^^^^^^^^^^^^^^^^^---\n   |                   \
    \                                                                |\n   |     \
    \                                                                            \
    \  help: remove the type ascription\n\nerror: expected one of `)`, `,`, `.`, `?`,\
    \ or an operator, found `c`\n  --> /tmp/tmppq5vz4j2.rs:11:61\n   |\n11 |     return\
    \ s.chars().rev().map(|c| c.is_ascii_alphabetic()? c.to_ascii_uppercase(): c.to_ascii_lowercase()).collect();\n\
    \   |                                                            -^ expected one\
    \ of `)`, `,`, `.`, `?`, or an operator\n   |                                \
    \                            |\n   |                                         \
    \                   help: missing `,`\n\nerror[E0425]: cannot find value `c` in\
    \ this scope\n  --> /tmp/tmppq5vz4j2.rs:11:61\n   |\n11 |     return s.chars().rev().map(|c|\
    \ c.is_ascii_alphabetic()? c.to_ascii_uppercase(): c.to_ascii_lowercase()).collect();\n\
    \   |                                                             ^ expecting\
    \ a type here because of type ascription\n\nerror[E0412]: cannot find type `c`\
    \ in this scope\n  --> /tmp/tmppq5vz4j2.rs:11:85\n   |\n11 |     return s.chars().rev().map(|c|\
    \ c.is_ascii_alphabetic()? c.to_ascii_uppercase(): c.to_ascii_lowercase()).collect();\n\
    \   |                                                                        \
    \             ^ expecting a type here because of type ascription\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmppq5vz4j2.rs:11:28\n\
    \    |\n11  |     return s.chars().rev().map(|c| c.is_ascii_alphabetic()? c.to_ascii_uppercase():\
    \ c.to_ascii_lowercase()).collect();\n    |                            ^^^ ----------------------------\
    \ ---------------------------------------------- supplied "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let s = s.chars().map(|c|\
    \ if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n    } else\
    \ if c.is_lowercase() {\n        c.to_uppercase().next().unwrap()\n    } else\
    \ {\n        c\n    }).collect::<String>();\n    if s.chars().all(|c| !c.is_alphabetic())\
    \ {\n        s.chars().rev().collect::<String>()\n    } else {\n        s\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    if !s.iter().any(|x|\
    \ x.is_alphabetic()) {\n        s.reverse();\n        return s.into_iter().collect();\n\
    \    }\n    for i in 0..s.len() {\n        let current = s[i];\n        if current.is_alphabetic()\
    \ {\n            s[i] = if current.is_uppercase() {\n                current.to_lowercase().next().unwrap()\n\
    \            } else {\n                current.to_uppercase().next().unwrap()\n\
    \            };\n        }\n    }\n    s.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.chars().any(|c|\
    \ c.is_alphabetic()) {\n        res\n    } else {\n        res.chars().rev().collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpepqcnfcq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for ch in s.chars() {\n \
    \       match ch {\n            'a'..='z' => res.push(ch.to_ascii_uppercase()),\n\
    \            'A'..='Z' => res.push(ch.to_ascii_lowercase()),\n            _ =>\
    \ res.push(ch),\n        }\n    }\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmphokrgbrl.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in s.chars() {\n\
    \        if ch.is_ascii_alphabetic() {\n            result.push(ch.swap_case());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_9knqlqj.rs:14:28\n   |\n14 |             result.push(ch.swap_case());\n\
    \   |                            ^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  let mut result = s.chars().rev().collect::<String>();\n  for\
    \ (i, c) in result.chars().enumerate() {\n    let mut cc = c;\n    if c.is_alphabetic()\
    \ {\n      cc = c.to_uppercase().next().unwrap();\n      if c.is_uppercase() {\n\
    \        cc = c.to_lowercase().next().unwrap();\n      }\n    }\n    result.replace_range(i..i+1,\
    \ &cc.to_string());\n  }\n  result\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp36a66d1f.rs:20:5\n   |\n12 |   for (i, c) in result.chars().enumerate()\
    \ {\n   |                 --------------------------\n   |                 |\n\
    \   |                 immutable borrow occurs here\n   |                 immutable\
    \ borrow later used here\n...\n20 |     result.replace_range(i..i+1, &cc.to_string());\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    let mut s_chars =\
    \ s.chars();\n    let mut is_str_has_letter = false;\n    while let Some(c) =\
    \ s_chars.next() {\n        let c_len = c.len_utf8();\n        if c_len == 1 {\n\
    \            if c.is_ascii_alphabetic() {\n                is_str_has_letter =\
    \ true;\n                result.push(c.to_ascii_uppercase());\n            } else\
    \ {\n                result.push(c);\n            }\n        } else {\n      \
    \      result.push(c);\n        }\n    }\n    if is_str_has_letter {\n       \
    \ result\n    } else {\n        result.chars().rev().collect()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplmny3fjj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    String::from_iter(s.chars().rev().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            return c.to_ascii_uppercase();\n        }\n        return c;\n\
    \    }))\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpqtrv46fb.rs:11:13\n   |\n\
    11 |     String::from_iter(s.chars().rev().map(|c| {\n   |             ^^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::iter::FromIterator;\n   |\nhelp: there is an associated function with a\
    \ similar name\n   |\n11 |     String::from_utf8(s.chars().rev().map(|c| {\n \
    \  |             ~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    let s: Vec<char> = s.chars().collect();\n\
    \    let mut has_letters = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            result.push(s[i].to_uppercase().next().unwrap());\n         \
    \   has_letters = true;\n        } else {\n            result.push(s[i]);\n  \
    \      }\n    }\n    if !has_letters {\n        result = result.chars().rev().collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpftkk32k8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_ascii_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if !res.is_empty()\
    \ {\n        res\n    } else {\n        s.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplxghd8k1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| x.is_alphabetic() && x.is_lowercase()\n\
    \                                               || x.is_uppercase()\n        \
    \                                          && x.is_alphabetic() ? x.to_uppercase().to_string()\n\
    \                                                                          : x.to_lowercase().to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmp2bfamgjw.rs:13:74\n\
    \   |\n13 |    ...                   && x.is_alphabetic() ? x.to_uppercase().to_string()\n\
    \   |   ______________________________________________^___________________________-\n\
    \   |  |______________________________________________|\n   | ||\n14 | || ...\
    \                                           : x.to_lowercase().to_string()).collect()\n\
    \   | ||_________________________________________________^ help: remove the type\
    \ ascription\n   | |__________________________________________________|\n   |\
    \ \n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `x`\n \
    \ --> /tmp/tmp2bfamgjw.rs:13:74\n   |\n13 | ...                   && x.is_alphabetic()\
    \ ? x.to_uppercase().to_string()\n   |                                       \
    \      -^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |           \
    \                                  |\n   |                                   \
    \          help: missing `,`\n\nerror[E0425]: cannot find value `x` in this scope\n\
    \  --> /tmp/tmp2bfamgjw.rs:13:74\n   |\n13 | ...                   && x.is_alphabetic()\
    \ ? x.to_uppercase().to_string()\n   |                                       \
    \       ^ expecting a type here because of type ascription\n14 | ...         \
    \                                  : x.to_lowercase().to_string()).collect()\n\
    \   |                                               - help: maybe you meant to\
    \ write `;` here\n\nerror[E0412]: cannot find type `x` in this scope\n  --> /tmp/tmp2bfamgjw.rs:14:77\n\
    \   |\n14 | ...                   : x.to_lowercase().to_string()).collect()\n\
    \   |                       - ^ expecting a type here because of type ascription\n\
    \   |                       |\n   |                       help: maybe you meant\
    \ to write `;` here\n\nerror[E0277]: the `?` operator can only be used in a closure\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp2bfamgjw.rs:13:72\n   |\n11 |       s.chars().rev().map(|x| x.is_alphabetic()\
    \ && x.is_lowercase()\n   |  _________________________-\n12"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    //method 1: use fold\n    //s.chars().fold(String::new(), |mut\
    \ acc, c| {\n    //    acc.push(if c.is_alphabetic() {\n    //        c.to_ascii_uppercase()\n\
    \    //    } else {\n    //        c.to_ascii_lowercase()\n    //    });\n   \
    \ //    acc\n    //})\n\n    //method 2: by hand\n    if s.is_empty() {\n    \
    \    return s;\n    }\n    let mut str_vec: Vec<char> = s.chars().collect();\n\
    \    for i in 0..str_vec.len() {\n        if str_vec[i].is_alphabetic() {\n  \
    \          if str_vec[i].is_lowercase() {\n                str_vec[i] = str_vec[i].to_ascii_uppercase();\n\
    \            } else {\n                str_vec[i] = str_vec[i].to_ascii_lowercase();\n\
    \            }\n        }\n    }\n    str_vec.iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmphmyivmvd.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect();\n    }\n    s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_ascii_uppercase() } else { c.to_ascii_lowercase() }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp74y7vuk5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'A'..='Z' => c.to_ascii_lowercase(),\n\
    \        'a'..='z' => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp8t3i29sv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            res.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        return s.chars().rev().collect();\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asdf\"`,\n right: `\"aSdF\"`', /tmp/tmpp6tlv0if.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n\
    \    } else {\n        s.chars().map(|c| if c.is_ascii_lowercase() {\n       \
    \     c.to_ascii_uppercase()\n        } else if c.is_ascii_uppercase() {\n   \
    \         c.to_ascii_lowercase()\n        } else {\n            c\n        }).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if !s.contains(char::is_alphabetic) {\n        s.chars().rev().collect()\n\
    \    } else {\n        s.chars().map(|c| if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n\
    \        } else {\n            c.to_ascii_lowercase()\n        }).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpiywo59ew.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut lower_case = vec![];\n    let mut upper_case = vec![];\n\
    \    for c in (b'a'..=b'z').rev() {\n        lower_case.push(c as char);\n   \
    \ }\n    for c in (b'A'..=b'Z').rev() {\n        upper_case.push(c as char);\n\
    \    }\n    let mut result = String::new();\n    for c in s.chars() {\n      \
    \  if let Some(x) = lower_case.iter().position(|&r| r == c) {\n            result.push(upper_case[x]);\n\
    \        } else if let Some(x) = upper_case.iter().position(|&r| r == c) {\n \
    \           result.push(lower_case[x]);\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpwhpw2xha.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp1lptv4xs.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().filter(|c| c.is_alphabetic()).count() == 0 {\n\
    \        return s.chars().rev().collect::<String>();\n    }\n    s.chars().map(|c|\
    \ if c.is_alphabetic() {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   } else {\n        c\n    }).collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    return s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c.to_ascii_lowercase() }).collect::<String>();\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_y4ok6t9.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if c.is_ascii_alphabetic() {\n\
    \            if c.is_lowercase() {\n                c.to_ascii_uppercase()\n \
    \           } else {\n                c.to_ascii_lowercase()\n            }\n\
    \        } else {\n            c\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpcpddi1c0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_string = String::new();\n    for i in s.chars()\
    \ {\n        if i.is_alphabetic() {\n            new_string.push(i.to_ascii_uppercase());\n\
    \        } else {\n            new_string.push(i);\n        }\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpwqjj2nll.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ch_vec: Vec<char> = s.chars().collect();\n    let mut\
    \ res = String::from(\"\");\n    for ch in ch_vec {\n        if ch.is_alphabetic()\
    \ {\n            if ch.is_lowercase() {\n                res.push(ch.to_uppercase().next().unwrap());\n\
    \            } else {\n                res.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            res.push(ch);\n        }\n    }\n\
    \    if s.len() == res.len() {\n        res.chars().rev().collect()\n    } else\
    \ {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpudpy5jr9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(if c.is_uppercase() {\
    \ c.to_lowercase().to_string() } else { c.to_uppercase().to_string() });\n   \
    \     } else {\n            result.push(c);\n        }\n    }\n    if result.chars().any(|c|\
    \ c.is_alphabetic()) {\n        result\n    } else {\n        result.chars().rev().collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjti3c_oj.rs:14:47\n   |\n\
    14 |             result.push(if c.is_uppercase() { c.to_lowercase().to_string()\
    \ } else { c.to_uppercase().to_string() });\n   |                            \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjti3c_oj.rs:14:85\n\
    \   |\n14 |             result.push(if c.is_uppercase() { c.to_lowercase().to_string()\
    \ } else { c.to_uppercase().to_string() });\n   |                            \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut cnt = 0;\n    for\
    \ c in s.chars() {\n        if !c.is_ascii_alphabetic() {\n            cnt +=\
    \ 1;\n            res.push(c);\n        } else {\n            if c.is_lowercase()\
    \ {\n                res.push(c.to_uppercase().to_string());\n            } else\
    \ {\n                res.push(c.to_lowercase().to_string());\n            }\n\
    \        }\n    }\n    if cnt == res.len() {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsgyexkyo.rs:19:26\n   |\n\
    19 |                 res.push(c.to_uppercase().to_string());\n   |           \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsgyexkyo.rs:21:26\n   |\n21 |\
    \                 res.push(c.to_lowercase().to_string());\n   |              \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result: Vec<char> = Vec::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     result.push(c.to_lowercase().to_string().chars().next().unwrap());\n   \
    \         has_letter = true;\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    if !has_letter {\n        result.reverse();\n    }\n  \
    \  let mut string = result.into_iter().collect::<String>();\n    for i in 0..string.len()\
    \ {\n        if string.chars().nth(i).unwrap().is_alphabetic() {\n           \
    \ string.replace_range(i..i+1, &string.chars().nth(i).unwrap().to_uppercase().to_string());\n\
    \        }\n    }\n    string\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp31jbqwte.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| x.to_ascii_lowercase()).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmp22bog1e7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            res.push(c.to_lowercase().to_string().parse::<char>().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpbr4_nd4n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut letter_found =\
    \ false;\n    for c in s.chars() {\n        if !c.is_alphabetic() {\n        \
    \    result.push(c);\n        } else {\n            letter_found = true;\n   \
    \         result.push(c.to_ascii_uppercase());\n        }\n    }\n    if !letter_found\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3jys6ldb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| c.is_alphabetic() && c.is_lowercase()\n\
    \        || c.is_alphabetic() && c.is_uppercase() ? c.to_ascii_uppercase() : c).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `c`\n\
    \  --> /tmp/tmpqvn0yshh.rs:12:52\n   |\n12 |         || c.is_alphabetic() && c.is_uppercase()\
    \ ? c.to_ascii_uppercase() : c).collect()\n   |                              \
    \                     -^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                                                   |\n   |              \
    \                                     help: missing `,`\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpqvn0yshh.rs:12:52\n   |\n12 |  \
    \       || c.is_alphabetic() && c.is_uppercase() ? c.to_ascii_uppercase() : c).collect()\n\
    \   |                                                    ^ expecting a type here\
    \ because of type ascription\n\nerror[E0412]: cannot find type `c` in this scope\n\
    \  --> /tmp/tmpqvn0yshh.rs:12:77\n   |\n12 |         || c.is_alphabetic() && c.is_uppercase()\
    \ ? c.to_ascii_uppercase() : c).collect()\n   |                              \
    \                                               ^ expecting a type here because\
    \ of type ascription\n\nerror[E0277]: the `?` operator can only be used in a closure\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpqvn0yshh.rs:12:50\n   |\n11 |       s.chars().rev().map(|c| c.is_alphabetic()\
    \ && c.is_lowercase()\n   |  _________________________-\n12 | |         || c.is_alphabetic()\
    \ && c.is_uppercase() ? c.to_ascii_uppercase() : c).collect()\n   | |        \
    \                                          ^\n   | |                         \
    \                         |\n   | |__________________________________________________cannot\
    \ use the `?` operator in a closure that returns `bool`\n   |                \
    \                                    this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not implemented\
    \ for `bool`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n   --> /tmp/tmpqvn0yshh.rs:11:21\n    |\n11  |       s.chars().rev().map(|c|\
    \ c.is_alphabetic() && c.is_lowercase()\n    |  _"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      res.push(match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n\
    \            'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n     \
    \   });\n    }\n    res.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpih15efhy.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_lowercase() {\n        c.to_uppercase().next().unwrap()\n\
    \    } else if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n\
    \    } else {\n        c\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp23k05pgm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            c.swap_case()\n        } else {\n            c\n        }\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpkl0go2gq.rs:13:15\n   |\n13 |             c.swap_case()\n\
    \   |               ^^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpzrxf_6f1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if !c.is_alphabetic() {\n    \
    \        c\n        } else if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmph8ive5zf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let mut has_letter\
    \ = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic() {\n   \
    \         has_letter = true;\n            if s[i].is_lowercase() {\n         \
    \       s[i] = s[i].to_uppercase().next().unwrap();\n            } else {\n  \
    \              s[i] = s[i].to_lowercase().next().unwrap();\n            }\n  \
    \      }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n    if s.iter().any(|c|\
    \ c.is_alphabetic()) {\n        for c in s.iter_mut() {\n            if c.is_alphabetic()\
    \ {\n                *c = c.to_uppercase().next().unwrap();\n            } else\
    \ {\n                *c = c.to_lowercase().next().unwrap();\n            }\n \
    \       }\n    } else {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc26k63u6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_dh_omxf.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  let mut s: Vec<char> = s.chars().collect();\n  let mut no_letters\
    \ = true;\n  for i in 0..s.len() {\n    if s[i].is_alphabetic() {\n      no_letters\
    \ = false;\n      if s[i].is_lowercase() {\n        s[i] = s[i].to_uppercase().next().unwrap();\n\
    \      } else {\n        s[i] = s[i].to_lowercase().next().unwrap();\n      }\n\
    \    }\n  }\n  if no_letters {\n    s.reverse();\n  }\n  s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c|\n        if c.is_lowercase() {\n  \
    \          c.to_uppercase().to_string()\n        } else if c.is_uppercase() {\n\
    \            c.to_lowercase().to_string()\n        } else {\n            c.to_string()\n\
    \        }\n    ).collect()\n}\n\nfn main() {\n    let candidate = solve;\n  \
    \  assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n  \
    \  assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n  \
    \  assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpxj297wi7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|ch| match ch {\n        'a'...'z' => ch.to_ascii_uppercase(),\n\
    \        'A'...'Z' => ch.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp1x2rzz8j.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'\
    \ | 'A' => 'A',\n            'b' | 'B' => 'B',\n            'c' | 'C' => 'C',\n\
    \            'd' | 'D' => 'D',\n            'e' | 'E' => 'E',\n            'f'\
    \ | 'F' => 'F',\n            'g' | 'G' => 'G',\n            'h' | 'H' => 'H',\n\
    \            'i' | 'I' => 'I',\n            'j' | 'J' => 'J',\n            'k'\
    \ | 'K' => 'K',\n            'l' | 'L' => 'L',\n            'm' | 'M' => 'M',\n\
    \            'n' | 'N' => 'N',\n            'o' | 'O' => 'O',\n            'p'\
    \ | 'P' => 'P',\n            'q' | 'Q' => 'Q',\n            'r' | 'R' => 'R',\n\
    \            's' | 'S' => 'S',\n            't' | 'T' => 'T',\n            'u'\
    \ | 'U' => 'U',\n            'v' | 'V' => 'V',\n            'w' | 'W' => 'W',\n\
    \            'x' | 'X' => 'X',\n            'y' | 'Y' => 'Y',\n            'z'\
    \ | 'Z' => 'Z',\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpd3w8ynvf.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| {\n        if x.is_alphabetic() {\n\
    \            x.to_ascii_uppercase()\n        } else {\n            x\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpnzn7r5ln.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_ascii_alphabetic() {\n            if c.is_ascii_lowercase() {\n\
    \                result.push(c.to_ascii_uppercase());\n            } else {\n\
    \                result.push(c.to_ascii_lowercase());\n            }\n       \
    \ } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        return s;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmptqow_i_8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c|\
    \ if c.is_alphabetic() { c.to_lowercase().next().unwrap() } else { c }).collect()\n\
    \    } else {\n        s.chars().rev().collect()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asdf\"`,\n right: `\"aSdF\"`', /tmp/tmpsym5w1dw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpiqk4vd5v.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let s = s.as_bytes();\n    let mut chars = vec![];\n    for\
    \ c in s {\n        let x = match *c {\n            b'a'...b'z' => {\n       \
    \         c - b'a' + b'A'\n            },\n            b'A'...b'Z' => {\n    \
    \            c - b'A' + b'a'\n            },\n            _ => *c,\n        };\n\
    \        chars.push(x);\n    }\n    unsafe { String::from_utf8_unchecked(chars)\
    \ }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpmepzx_wl.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp_dam61nb.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        return s.chars().rev().collect();\n    } else {\n        return\
    \ result;\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpi572iope.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut r = String::from(\"\");\n    let mut c: char;\n   \
    \ for i in s.chars() {\n        if (65 <= i as u8 && i as u8 <= 90) || (97 <=\
    \ i as u8 && i as u8 <= 122) {\n            c = if i.is_uppercase() {\n      \
    \          i.to_lowercase().next().unwrap()\n            } else {\n          \
    \      i.to_uppercase().next().unwrap()\n            };\n            r.push(c);\n\
    \        } else {\n            r.push(i);\n        }\n    }\n    if r.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        r\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp4n6toyt0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  s.chars().map(|c| match c {\n    'A'..='Z' => c.to_ascii_lowercase(),\n\
    \    'a'..='z' => c.to_ascii_uppercase(),\n    _ => c\n  }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpb4vcssm2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_lowercase().next().unwrap()\n        } else {\n            c\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmp0whm6imp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        match c {\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n\
    \            'a'...'z' => result.push(c.to_ascii_uppercase()),\n            _\
    \ => result.push(c),\n        }\n    }\n    result.chars().rev().collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpm6u_kyem.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|i| if i.is_alphabetic() { i.to_ascii_uppercase()\
    \ } else { i }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpn7sd529f.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n    let mut\
    \ letters = Vec::new();\n    let mut rev = Vec::new();\n    for c in s.iter_mut()\
    \ {\n        match c {\n            'A'..='Z' => {\n                letters.push(c.clone());\n\
    \                rev.push(c.to_ascii_lowercase());\n            }\n          \
    \  'a'..='z' => {\n                letters.push(c.clone());\n                rev.push(c.to_ascii_uppercase());\n\
    \            }\n            _ => continue,\n        }\n    }\n    rev.reverse();\n\
    \    for (i, c) in letters.iter().enumerate() {\n        *s.iter_mut().find(|&&x|\
    \ x == *c).unwrap() = rev[i];\n    }\n    s.iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu8a53g01.rs:29:30\n   |\n\
    29 |         *s.iter_mut().find(|&&x| x == *c).unwrap() = rev[i];\n   |      \
    \                        ^-\n   |                              ||\n   |      \
    \                        |expected due to this\n   |                         \
    \     types differ in mutability\n   |                              help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note: expected mutable\
    \ reference `&mut char`\n                      found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpzvgtjice.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| c.is_ascii_alphabetic() && c.is_ascii_lowercase()\n\
    \        || c.is_ascii_alphabetic() && c.is_ascii_uppercase()\n            ? c.to_ascii_uppercase()\n\
    \            : c.to_ascii_lowercase()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpjizj_9nv.rs:13:15\n\
    \   |\n13 |                ? c.to_ascii_uppercase()\n   |   _______________^_____________________-\n\
    \   |  |_______________|\n   | ||\n14 | ||             : c.to_ascii_lowercase()).collect()\n\
    \   | ||_______________^ help: remove the type ascription\n   | |________________|\n\
    \   | \n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `c`\n\
    \  --> /tmp/tmpjizj_9nv.rs:13:15\n   |\n13 |             ? c.to_ascii_uppercase()\n\
    \   |              -^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |\
    \              |\n   |              help: missing `,`\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpjizj_9nv.rs:13:15\n   |\n13 |  \
    \           ? c.to_ascii_uppercase()\n   |               ^ expecting a type here\
    \ because of type ascription\n14 |             : c.to_ascii_lowercase()).collect()\n\
    \   |             - help: maybe you meant to write `;` here\n\nerror[E0412]: cannot\
    \ find type `c` in this scope\n  --> /tmp/tmpjizj_9nv.rs:14:15\n   |\n14 |   \
    \          : c.to_ascii_lowercase()).collect()\n   |             - ^ expecting\
    \ a type here because of type ascription\n   |             |\n   |           \
    \  help: maybe you meant to write `;` here\n\nerror[E0277]: the `?` operator can\
    \ only be used in a closure that returns `Result` or `Option` (or another type\
    \ that implements `FromResidual`)\n  --> /tmp/tmpjizj_9nv.rs:13:13\n   |\n11 |\
    \       s.chars().rev().map(|c| c.is_ascii_alphabetic() && c.is_ascii_lowercase()\n\
    \   |  _________________________-\n12 | |         || c.is_ascii_alphabetic() &&\
    \ c.is_ascii_uppercase()\n13 | |             ? c.to_ascii_uppercase()\n   | |\
    \             ^\n   | |             |\n   | |_____________cannot use the `?` operator\
    \ in a closure that returns `bool`\n   |               this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `bool`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n   --> /tmp/tmpjizj_9nv.rs:11:21\n    |\n11 \
    \ |        s.c"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() {\n    \
    \    c.to_ascii_uppercase()\n    } else {\n        c\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpb0xx1l9w.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for character in s.chars()\
    \ {\n        if character.is_alphabetic() {\n            result.push(character.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(character);\n        }\n    }\n   \
    \ result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpw5zzrlcx.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| match x {\n        'a'..='z' => x.to_ascii_uppercase(),\n\
    \        'A'..='Z' => x.to_ascii_lowercase(),\n        _ => x,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp86b7nanc.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        c => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpmbhnuei1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpjod1hytt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result: String = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           result.push(c.to_lowercase().collect::<String>());\n            }\
    \ else {\n                result.push(c.to_uppercase().collect::<String>());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm5vau_we.rs:15:29\n   |\n\
    15 |                 result.push(c.to_lowercase().collect::<String>());\n   |\
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5vau_we.rs:17:29\n\
    \   |\n17 |                 result.push(c.to_uppercase().collect::<String>());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut vec = Vec::new();\n    for c in s.chars() {\n     \
    \   if c.is_ascii_alphabetic() {\n            if c.is_lowercase() {\n        \
    \        vec.push(c.to_ascii_uppercase());\n            } else {\n           \
    \     vec.push(c.to_ascii_lowercase());\n            }\n        } else {\n   \
    \         vec.push(c);\n        }\n    }\n    if vec.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        vec.into_iter().collect()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpsklip9_t.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut has_letters = false;\n\
    \    for ch in s.chars() {\n        if ch.is_alphabetic() {\n            has_letters\
    \ = true;\n            res.push(ch.to_ascii_uppercase());\n        } else {\n\
    \            res.push(ch);\n        }\n    }\n    if has_letters {\n        res\n\
    \    } else {\n        s.chars().rev().collect()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5_1bsfd_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let mut counter\
    \ = 0;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic() {\n       \
    \     counter += 1;\n        }\n    }\n    if counter > 0 {\n        for i in\
    \ 0..s.len() {\n            if s[i].is_alphabetic() {\n                s[i] =\
    \ if s[i].is_lowercase() {\n                    s[i].to_uppercase().next().unwrap()\n\
    \                } else {\n                    s[i].to_lowercase().next().unwrap()\n\
    \                };\n            }\n        }\n    } else {\n        for i in\
    \ 0..s.len() / 2 {\n            s.swap(i, s.len() - i - 1);\n        }\n    }\n\
    \    s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `s` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpefkwb6ad.rs:30:23\n   |\n30 |             s.swap(i,\
    \ s.len() - i - 1);\n   |             ----------^^^^^^^---------\n   |       \
    \      | |       |\n   |             | |       immutable borrow occurs here\n\
    \   |             | mutable borrow later used by call\n   |             mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmpefkwb6ad.rs:30:23\n   |\n30 |             s.swap(i, s.len() - i\
    \ - 1);\n   |                       ^^^^^^^\nhelp: ...and then using that local\
    \ as the argument to this call\n  --> /tmp/tmpefkwb6ad.rs:30:13\n   |\n30 |  \
    \           s.swap(i, s.len() - i - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| c.toggle_case()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `toggle_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmps33jvv_0.rs:11:31\n   |\n11 |     s.chars().rev().map(|c|\
    \ c.toggle_case()).collect()\n   |                               ^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        'a'...'z' => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpqnd76wne.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_lowercase().nth(0).unwrap()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpm72jv8jr.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'A'..='Z' => c.to_ascii_lowercase(),\n\
    \        'a'..='z' => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmplzrm3qt7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  s.chars().map(|c| if c.is_ascii_alphabetic() {\n    if c.is_lowercase()\
    \ {\n      c.to_ascii_uppercase()\n    } else {\n      c.to_ascii_lowercase()\n\
    \    }\n  } else {\n    c\n  }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmplmbx1dr2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars: Vec<char> = s.chars().collect();\n    chars.reverse();\n\
    \    chars.iter().map(|x| {\n        match x {\n            'a'...'z' => *x =\
    \ x.to_ascii_uppercase(),\n            'A'...'Z' => *x = x.to_ascii_lowercase(),\n\
    \            _ => {}\n        }\n        x\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpm_ddzm6o.rs:15:16\n\
    \   |\n15 |             'a'...'z' => *x = x.to_ascii_uppercase(),\n   |      \
    \          ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpm_ddzm6o.rs:16:16\n\
    \   |\n16 |             'A'...'Z' => *x = x.to_ascii_lowercase(),\n   |      \
    \          ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0594]: cannot assign to `*x`, which is behind a `&` reference\n  -->\
    \ /tmp/tmpm_ddzm6o.rs:15:26\n   |\n13 |     chars.iter().map(|x| {\n   |     \
    \                  - help: consider changing this to be a mutable reference: `&mut\
    \ char`\n14 |         match x {\n15 |             'a'...'z' => *x = x.to_ascii_uppercase(),\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `x` is a `&` reference,\
    \ so the data it refers to cannot be written\n\nerror[E0594]: cannot assign to\
    \ `*x`, which is behind a `&` reference\n  --> /tmp/tmpm_ddzm6o.rs:16:26\n   |\n\
    13 |     chars.iter().map(|x| {\n   |                       - help: consider changing\
    \ this to be a mutable reference: `&mut char`\n...\n16 |             'A'...'Z'\
    \ => *x = x.to_ascii_lowercase(),\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `x` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0594`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|ch| match ch {\n        'A' ... 'Z' =>\
    \ ch.to_ascii_lowercase(),\n        'a' ... 'z' => ch.to_ascii_uppercase(),\n\
    \        _ => ch,\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpxzooy6et.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpf7ia6jtf.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  let mut result: String = String::new();\n  let mut reverse: bool\
    \ = true;\n  for i in s.chars() {\n    if i.is_alphabetic() {\n      reverse =\
    \ false;\n      result.push(if i.is_lowercase() { i.to_uppercase().next().unwrap()\
    \ } else { i.to_lowercase().next().unwrap() });\n    } else {\n      result.push(i);\n\
    \    }\n  }\n  if reverse {\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    chars.reverse();\n    result = chars.into_iter().collect();\n  }\n  result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_lowercase() {\n                c.to_ascii_uppercase()\n\
    \            } else {\n                c.to_ascii_lowercase()\n            }\n\
    \        } else {\n            c\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpshut3g07.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  s.chars().rev().map(|c| match c {\n      'a'...'z' => c.to_ascii_uppercase(),\n\
    \      'A'...'Z' => c.to_ascii_lowercase(),\n      _ => c\n  }).collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpj1brmshr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      match c {\n            'a'...'z' => res.push(c.to_ascii_uppercase()),\n\
    \            'A'...'Z' => res.push(c.to_ascii_lowercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().fold(String::new(), |mut acc, c| {\n        if c.is_alphabetic()\
    \ {\n            let is_upper = c.is_uppercase();\n            acc.push(c.to_ascii_lowercase());\n\
    \            if is_upper {\n                acc.pop();\n                acc.push(c.to_ascii_uppercase());\n\
    \            }\n        } else {\n            acc.push(c);\n        }\n      \
    \  acc\n    })\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"AsDf\"`,\n right: `\"aSdF\"`', /tmp/tmpw9f3e2ft.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut output: String = String::new();\n    for c in s.chars()\
    \ {\n        match c {\n            x if x.is_alphabetic() => {\n            \
    \    output.push(x.to_ascii_uppercase());\n            },\n            x if x.is_ascii_uppercase()\
    \ => {\n                output.push(x.to_ascii_lowercase());\n            },\n\
    \            _ => {\n                output.push(c);\n            }\n        }\n\
    \    }\n    if output.chars().any(|c| c.is_alphabetic()) {\n        output\n \
    \   } else {\n        s.chars().rev().collect()\n    }\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpu7y91d0l.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp4jfseiyu.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpk7szfmrd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let s = s.chars();\n    let mut res = String::new();\n    for\
    \ i in s {\n        if i.is_alphabetic() {\n            res.push(i.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(i);\n        }\n    }\n    res.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpw3b3cqaa.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // https://stackoverflow.com/questions/38406736/how-to-convert-a-char-to-uppercase-in-rust\n\
    \    s.chars().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp_nqn59k9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            if c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n\
    \            } else {\n                c.to_lowercase().next().unwrap()\n    \
    \        }\n        } else {\n            c\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpld75rt_r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_ascii_lowercase() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            res.push(c.to_ascii_lowercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.chars().all(|c|\
    \ !c.is_ascii_alphabetic()) {\n        res.chars().rev().collect()\n    } else\
    \ {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_lowercase() { c.to_ascii_uppercase()\
    \ } else { c.to_ascii_lowercase() }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp0287l0c0.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ret = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            ret.push(c.to_ascii_uppercase());\n\
    \        } else {\n            ret.push(c);\n        }\n    }\n    if ret.is_empty()\
    \ {\n        ret = s;\n    }\n    ret.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpcct58815.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|x| x.is_alphabetic()) {\n        s.chars().map(|x|\
    \ if x.is_alphabetic() {x.to_ascii_uppercase()} else {x}).collect()\n    } else\
    \ {\n        s.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmps3ag8zjp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpbm7zvbz8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        s.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplyrs_zz7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        a if a.is_lowercase()\
    \ => a.to_uppercase().next().unwrap(),\n        a if a.is_uppercase() => a.to_lowercase().next().unwrap(),\n\
    \        _ => c\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp_stqqa25.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            res.push(if c.is_lowercase() { c.to_uppercase().nth(0).unwrap()\
    \ } else { c.to_lowercase().nth(0).unwrap() });\n        } else {\n          \
    \  res.push(c);\n        }\n    }\n    if res.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpp5xo6sb5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| if x.is_alphabetic() { x.to_ascii_uppercase()\
    \ } else { x }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpaeep6oer.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'..='z'\
    \ => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp0e4r_ev0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpj1vl9ucl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut iter = s.chars();\n    let mut res = String::new();\n\
    \    while let Some(c) = iter.next() {\n        match c {\n            'A'...'Z'\
    \ => res.push((c as u8 + 32) as char),\n            'a'...'z' => res.push((c as\
    \ u8 - 32) as char),\n            _ => res.push(c),\n        }\n    }\n    if\
    \ res.is_empty() {\n        s.chars().rev().collect()\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpmlhekso2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut answer = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            answer.push(c.to_ascii_uppercase());\n\
    \        } else {\n            answer.push(c);\n        }\n    }\n    answer\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpbo5xr29n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpzzhnyx0x.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut c = s.chars();\n    let mut iter = s.chars();\n   \
    \ let mut result = String::new();\n    let mut no_letter = true;\n    while let\
    \ Some(v) = c.next() {\n        if v.is_ascii_letter() {\n            no_letter\
    \ = false;\n            break;\n        }\n    }\n    if no_letter {\n       \
    \ while let Some(v) = iter.next() {\n            result.push(v);\n        }\n\
    \        return result.chars().rev().collect();\n    }\n\n    for c in s.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpogud8uxe.rs:16:14\n   |\n16 |         if v.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprafb4jt_.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    if let Some(c) = chars.next()\
    \ {\n        let mut r = String::new();\n        if c.is_ascii_lowercase() {\n\
    \            r.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            r.push(c.to_ascii_lowercase());\n        } else {\n         \
    \   r.push(c);\n        }\n        for c in chars {\n            if c.is_ascii_lowercase()\
    \ {\n                r.push(c.to_ascii_uppercase());\n            } else if c.is_ascii_uppercase()\
    \ {\n                r.push(c.to_ascii_lowercase());\n            } else {\n \
    \               r.push(c);\n            }\n        }\n        r\n    } else {\n\
    \        s\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpe159vlfe.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // TODO\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpc3uamu0g.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    return s.chars().map(|x| {\n        if x.is_uppercase() {\n\
    \            x.to_lowercase().next().unwrap()\n        } else if x.is_lowercase()\
    \ {\n            x.to_uppercase().next().unwrap()\n        } else {\n        \
    \    x\n        }\n    }).collect();\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpajylkwi0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().collect::<String>()\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmpwd_ytb6y.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_alphabetic() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c\n    }).rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpkg_bi2qr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      match c {\n            'a'..='z' => res.push(c.to_ascii_uppercase()),\n\
    \            'A'..='Z' => res.push(c.to_ascii_lowercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // let mut result = String::new();\n    // for c in s.chars()\
    \ {\n    //     if c.is_alphabetic() {\n    //         if c.is_lowercase() {\n\
    \    //             result.push(c.to_uppercase().next().unwrap());\n    //   \
    \      } else {\n    //             result.push(c.to_lowercase().next().unwrap());\n\
    \    //         }\n    //     } else {\n    //         result.push(c);\n    //\
    \     }\n    // }\n    // if result.is_empty() {\n    //     result = s.chars().rev().collect();\n\
    \    // }\n    // result\n\n    // Alternative solution\n    // if s.chars().any(|x|\
    \ x.is_alphabetic()) {\n    //     s.chars().map(|x| if x.is_alphabetic() {\n\
    \    //         if x.is_lowercase() {\n    //             x.to_uppercase().next().unwrap()\n\
    \    //         } else {\n    //             x.to_lowercase().next().unwrap()\n\
    \    //         }\n    //     } else {\n    //         x\n    //     }).collect()\n\
    \    // } else {\n    //     s.chars().rev().collect()\n    // }\n\n    // Alternative\
    \ solution\n    s.chars().map(|x| if x.is_alphabetic() {\n        if x.is_lowercase()\
    \ {\n            x.to_uppercase().next().unwrap()\n        } else {\n        \
    \    x.to_lowercase().next().unwrap()\n        }\n    } else {\n        x\n  \
    \  }).collect::<String>().chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp2xsrigy7.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| match x {\n        x if x.is_ascii_lowercase()\
    \ => x.to_ascii_uppercase(),\n        x if x.is_ascii_uppercase() => x.to_ascii_lowercase(),\n\
    \        _ => x,\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpdo6hla9h.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_ascii_lowercase() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|x|\
    \ !x.is_ascii_alphabetic()) {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        s.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp0l4im9gw.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut r: String = String::from(\"\");\n    for i in s.chars()\
    \ {\n        match i {\n            'a'...'z' => r.push(i.to_ascii_uppercase()),\n\
    \            'A'...'Z' => r.push(i.to_ascii_lowercase()),\n            _ => r.push(i),\n\
    \        }\n    }\n    if r.chars().any(|x| x.is_ascii_alphabetic()) {\n     \
    \   r\n    } else {\n        r.chars().rev().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n\
    \        'A'..='Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpc8vmlnbg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = s.chars().rev().collect::<String>();\n   \
    \ if s.chars().any(|c| c.is_alphabetic()) {\n        result = result.chars().map(|c|\
    \ c.to_lowercase().next().unwrap_or(c)).collect();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpzuwreb46.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut answer = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       answer.push(c.to_uppercase().to_string());\n            } else {\n   \
    \             answer.push(c.to_lowercase().to_string());\n            }\n    \
    \    } else {\n            answer.push(c.to_string());\n        }\n    }\n   \
    \ if answer.is_empty() {\n        s.chars().rev().collect()\n    } else {\n  \
    \      answer\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoqy7f2mw.rs:15:29\n   |\n\
    15 |                 answer.push(c.to_uppercase().to_string());\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoqy7f2mw.rs:17:29\n\
    \   |\n17 |                 answer.push(c.to_lowercase().to_string());\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoqy7f2mw.rs:20:25\n\
    \   |\n20 |             answer.push(c.to_string());\n   |                    \
    \     ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'..='z'\
    \ => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp9q97seqh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().any(|c| c.is_alphabetic()) {\n        return s.chars().map(|c|\
    \ if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n        } else {\n\
    \            c.to_ascii_lowercase()\n        }).collect();\n    }\n    s.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpoaakoj6t.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut solution = String::new();\n    let mut char_count =\
    \ 0;\n    for character in s.chars() {\n        if character.is_alphabetic() {\n\
    \            char_count += 1;\n            if character.is_uppercase() {\n   \
    \             solution.push(character.to_lowercase().next().unwrap());\n     \
    \       } else {\n                solution.push(character.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            solution.push(character);\n    \
    \    }\n    }\n    if char_count == 0 {\n        solution.chars().rev().collect()\n\
    \    } else {\n        solution\n    }\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let mut has_letter\
    \ = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic() {\n   \
    \         has_letter = true;\n            if s[i].is_uppercase() {\n         \
    \       s[i] = s[i].to_lowercase().next().unwrap();\n            } else {\n  \
    \              s[i] = s[i].to_uppercase().next().unwrap();\n            }\n  \
    \      }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp66rgod8k.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::from(\"\");\n    for ch in s.chars()\
    \ {\n        if ch.is_alphabetic() {\n            res.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(ch);\n        }\n    }\n    if res ==\
    \ s {\n        return s.chars().rev().collect();\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asdf\"`,\n right: `\"aSdF\"`', /tmp/tmp4eqt8l1a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| {\n        match x {\n            'a'...'z'\
    \ => x.to_ascii_uppercase(),\n            'A'...'Z' => x.to_ascii_lowercase(),\n\
    \            _ => x,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp0juaecef.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let iter = s.chars();\n    let mut ss = String::new();\n  \
    \  for c in iter {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                ss.push(c.to_lowercase().next().unwrap());\n            }\
    \ else {\n                ss.push(c.to_uppercase().next().unwrap());\n       \
    \     }\n        } else {\n            ss.push(c);\n        }\n    }\n    if ss.is_empty()\
    \ {\n        ss = s;\n    }\n    ss.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpf05imrji.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::from(\"\");\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            res.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.len()\
    \ == 0 {\n        res = s;\n    }\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpap8vydqm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut is_letter_found = false;\n    s.chars().map(|c| {\n\
    \        if c.is_ascii_alphabetic() {\n            is_letter_found = true;\n \
    \           c.to_ascii_uppercase()\n        } else {\n            c\n        }\n\
    \    }).collect::<String>().chars().rev().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c\n   \
    \     }\n    }).collect::<String>()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmppmmqdskg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| c.is_ascii_alphabetic() ? c.to_ascii_uppercase()\
    \ : c.to_ascii_lowercase()).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmppu3epxs6.rs:11:55\n\
    \   |\n11 |     s.chars().rev().map(|c| c.is_ascii_alphabetic() ? c.to_ascii_uppercase()\
    \ : c.to_ascii_lowercase()).collect()\n   |                                  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^----\n   |                       \
    \                                                      |\n   |               \
    \                                                              help: remove the\
    \ type ascription\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found `c`\n  --> /tmp/tmppu3epxs6.rs:11:55\n   |\n11 |     s.chars().rev().map(|c|\
    \ c.is_ascii_alphabetic() ? c.to_ascii_uppercase() : c.to_ascii_lowercase()).collect()\n\
    \   |                                                      -^ expected one of\
    \ `)`, `,`, `.`, `?`, or an operator\n   |                                   \
    \                   |\n   |                                                  \
    \    help: missing `,`\n\nerror[E0425]: cannot find value `c` in this scope\n\
    \  --> /tmp/tmppu3epxs6.rs:11:55\n   |\n11 |     s.chars().rev().map(|c| c.is_ascii_alphabetic()\
    \ ? c.to_ascii_uppercase() : c.to_ascii_lowercase()).collect()\n   |         \
    \                                              ^ expecting a type here because\
    \ of type ascription\n\nerror[E0412]: cannot find type `c` in this scope\n  -->\
    \ /tmp/tmppu3epxs6.rs:11:80\n   |\n11 |     s.chars().rev().map(|c| c.is_ascii_alphabetic()\
    \ ? c.to_ascii_uppercase() : c.to_ascii_lowercase()).collect()\n   |         \
    \                                                                       ^ expecting\
    \ a type here because of type ascription\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n   --> /tmp/tmppu3epxs6.rs:11:21\n\
    \    |\n11  |     s.chars().rev().map(|c| c.is_ascii_alphabetic() ? c.to_ascii_uppercase()\
    \ : c.to_ascii_lowercase()).collect()\n    |                     ^^^ -----------------------------\
    \ ----------------------------------------------- supplied 2 arguments\n    |\
    \                     |\n    |                     expected 1 argu"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for ch in s.chars() {\n \
    \       match ch {\n            'a'...'z' => res.push((ch as u8 - 'a' as u8 +\
    \ 'A' as u8) as char),\n            'A'...'Z' => res.push((ch as u8 - 'A' as u8\
    \ + 'a' as u8) as char),\n            _ => res.push(ch),\n        }\n    }\n \
    \   if res.is_empty() {\n        s.chars().rev().collect()\n    } else {\n   \
    \     res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpj_e394tc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.len() < 1 { return s; }\n    let mut result = String::new();\n\
    \    let mut contains_letter = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            contains_letter = true;\n            result.push(if c.is_ascii_lowercase()\
    \ { c.to_ascii_uppercase() } else { c.to_ascii_lowercase() });\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    if !contains_letter {\
    \ result.chars().rev().collect() } else { result }\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = s.chars().rev().collect::<String>();\n   \
    \ if result.is_empty() {\n        return result;\n    }\n    let result_vec: Vec<char>\
    \ = result.chars().collect();\n    for (i, c) in result_vec.iter().enumerate()\
    \ {\n        if c.is_lowercase() {\n            result = result.replace(c, &c.to_ascii_uppercase().to_string());\n\
    \        } else if c.is_uppercase() {\n            result = result.replace(c,\
    \ &c.to_ascii_lowercase().to_string());\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmp4hkq3s6z.rs:18:29\n\
    \    |\n18  |             result = result.replace(c, &c.to_ascii_uppercase().to_string());\n\
    \    |                             ^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n    = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmp4hkq3s6z.rs:20:29\n\
    \    |\n20  |             result = result.replace(c, &c.to_ascii_lowercase().to_string());\n\
    \    |                             ^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n    = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp900a9jbo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // Your code here\n    if s.chars().all(|c| c.is_numeric())\
    \ {\n        s.chars().rev().collect()\n    } else {\n        s.chars().map(|c|\
    \ c.to_lowercase().next().unwrap_or(c)).rev().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmp_qoiefah.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| match x {\n        'a'..='z' => x.to_ascii_uppercase(),\n\
    \        'A'..='Z' => x.to_ascii_lowercase(),\n        _ => x,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmprsnarig6.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpl_7v0uga.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let reverse = |ch: char| {\n        match ch {\n          \
    \  'a'..='z' => ch.to_ascii_uppercase(),\n            'A'..='Z' => ch.to_ascii_lowercase(),\n\
    \            _ => ch,\n        }\n    };\n    let chars: Vec<char> = s.chars().map(reverse).collect();\n\
    \    let len = chars.len();\n    if len == 0 {\n        return s;\n    }\n   \
    \ chars[..len / 2]\n        .iter()\n        .rev()\n        .chain(chars[len\
    \ / 2..].iter())\n        .collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"SadF\"`,\n right: `\"aSdF\"`', /tmp/tmpqgzjg3dv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = s.chars().rev().collect::<String>();\n    str.chars().enumerate().for_each(|(i,\
    \ c)| {\n        let mut v = c;\n        if v.is_ascii_alphabetic() {\n      \
    \      v = v.to_ascii_lowercase();\n            if c.is_ascii_lowercase() {\n\
    \                v = v.to_ascii_uppercase();\n            }\n        }\n     \
    \   str.replace_range(i..i+1, &v.to_string());\n    });\n    str\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `str` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpz_fzlpi8.rs:12:38\n   |\n12 |     str.chars().enumerate().for_each(|(i,\
    \ c)| {\n   |     -----------             -------- ^^^^^^^^ mutable borrow occurs\
    \ here\n   |     |                       |\n   |     |                       immutable\
    \ borrow later used by call\n   |     immutable borrow occurs here\n...\n20 |\
    \         str.replace_range(i..i+1, &v.to_string());\n   |         --- second\
    \ borrow occurs due to use of `str` in closure\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let v: Vec<char> = s.chars().collect();\n    let mut nv: Vec<char>\
    \ = Vec::new();\n    for i in 0..v.len() {\n        if v[i].is_alphabetic() {\n\
    \            if v[i].is_lowercase() {\n                nv.push(v[i].to_uppercase().next().unwrap());\n\
    \            } else {\n                nv.push(v[i].to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            nv.push(v[i]);\n        }\n    }\n\
    \    if nv.len() == 0 {\n        nv = v.clone();\n        nv.reverse();\n    }\n\
    \    nv.iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp0v5up4ub.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'A'...'Z'\
    \ => c.to_lowercase().next().unwrap(),\n            'a'...'z' => c.to_uppercase().next().unwrap(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpk270p5k7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if c.is_alphabetic() {\n     \
    \       if c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n\
    \            } else {\n                c.to_lowercase().next().unwrap()\n    \
    \        }\n        } else {\n            c\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpi09p8nw5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let mut result\
    \ = String::with_capacity(s.len());\n    let mut letter_found = false;\n    for\
    \ c in s.chars() {\n        if c.is_ascii_alphabetic() {\n            result.push(if\
    \ c.is_lowercase() {\n                c.to_ascii_uppercase()\n            } else\
    \ {\n                c.to_ascii_lowercase()\n            });\n            letter_found\
    \ = true;\n        } else {\n            result.push(c);\n        }\n    }\n \
    \   if !letter_found {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_string = String::new();\n    for (index, character)\
    \ in s.chars().enumerate() {\n        if character.is_ascii_alphabetic() {\n \
    \           if character.is_lowercase() {\n                new_string.push(character.to_ascii_uppercase());\n\
    \            } else {\n                new_string.push(character.to_ascii_lowercase());\n\
    \            }\n        } else {\n            new_string.push(character);\n  \
    \      }\n    }\n    if new_string.is_empty() {\n        return s.chars().rev().collect();\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpwyq2itw8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if c.is_ascii_alphabetic() {\n\
    \            match c.is_ascii_uppercase() {\n                true => c.to_ascii_lowercase(),\n\
    \                false => c.to_ascii_uppercase(),\n            }\n        } else\
    \ {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp65hok9r_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmplq2wktgd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    String::from_iter(s.chars().rev().map(|ch| match ch {\n   \
    \     'a'..='z' => ch.to_ascii_uppercase(),\n        'A'..='Z' => ch.to_ascii_lowercase(),\n\
    \        _ => ch,\n    }))\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp9oyevwli.rs:11:13\n   |\n\
    11 |     String::from_iter(s.chars().rev().map(|ch| match ch {\n   |         \
    \    ^^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::iter::FromIterator;\n   |\nhelp: there is an associated function\
    \ with a similar name\n   |\n11 |     String::from_utf8(s.chars().rev().map(|ch|\
    \ match ch {\n   |             ~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let is_alpha = |c: char| c.is_alphabetic();\n    let mut res\
    \ = s.chars().map(|c| {\n        if is_alpha(c) {\n            if c.is_uppercase()\
    \ {\n                c.to_lowercase().next().unwrap()\n            } else {\n\
    \                c.to_uppercase().next().unwrap()\n            }\n        } else\
    \ {\n            c\n        }\n    }).collect::<String>();\n    res.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmph74egplv.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_alphabetic() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c\n    }).rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpipn2gex7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new = String::new();\n    for c in s.chars() {\n  \
    \      new.push(match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n\
    \            'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n     \
    \   });\n    }\n    new\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpg6jqm7r_.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_s = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            new_s.push(c.to_ascii_uppercase());\n\
    \        } else {\n            new_s.push(c);\n        }\n    }\n    new_s.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp74_7gg06.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpg78byxk2.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    return s.chars().rev().map(|ch| {\n        match ch {\n   \
    \         'a'...'z' => ch.to_ascii_uppercase(),\n            'A'...'Z' => ch.to_ascii_lowercase(),\n\
    \            _ => ch\n        }\n    }).collect::<String>();\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpk5t00t9s.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut v: Vec<char> = s.chars().collect();\n    let mut i\
    \ = 0;\n    let mut is_letter_found = false;\n    while i < v.len() {\n      \
    \  if v[i].is_alphabetic() {\n            is_letter_found = true;\n          \
    \  if v[i].is_lowercase() {\n                v[i] = v[i].to_uppercase().collect::<Vec<char>>()[0];\n\
    \            } else {\n                v[i] = v[i].to_lowercase().collect::<Vec<char>>()[0];\n\
    \            }\n        }\n        i += 1;\n    }\n    if !is_letter_found {\n\
    \        v.reverse();\n    }\n    v.into_iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            res.push(if c.is_uppercase() { c.to_lowercase().next().unwrap()\
    \ } else { c.to_uppercase().next().unwrap() });\n        } else {\n          \
    \  res.push(c);\n        }\n    }\n    res.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp7escbzsn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        match c {\n            'a'...'z' => result.push(c.to_ascii_uppercase()),\n\
    \            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n            _\
    \ => result.push(c),\n        }\n    }\n    if result.chars().all(|c| !c.is_alphabetic())\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let letters = b\"abcdefghijklmnopqrstuvwxyz\";\n    let mut\
    \ res = String::new();\n    let mut letters_count = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            letters_count += 1;\n       \
    \     let cc = if c.is_uppercase() {\n                let cci = letters.iter().position(|&x|\
    \ x == c.to_ascii_lowercase() as u8).unwrap();\n                letters[cci].to_ascii_uppercase()\
    \ as char\n            } else {\n                let cci = letters.iter().position(|&x|\
    \ x == c.to_ascii_uppercase() as u8).unwrap();\n                letters[cci].to_ascii_lowercase()\
    \ as char\n            };\n            res.push(cc);\n        } else {\n     \
    \       res.push(c);\n        }\n    }\n    if letters_count == 0 {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpcz00814u.rs:21:91\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_string = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            new_string.push(c.to_ascii_uppercase());\n\
    \        } else {\n            new_string.push(c);\n        }\n    }\n    if new_string\
    \ == s {\n        let mut s = s.chars().rev().collect::<String>();\n        return\
    \ s;\n    } else {\n        let s = new_string.chars().rev().collect::<String>();\n\
    \        return s;\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpapr864t0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut r: String = s.chars().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect();\n    if r.chars().any(|c| c.is_alphabetic())\
    \ {\n        r\n    } else {\n        r.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut answer = s.chars().map(|c| {\n        match c {\n \
    \           'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect::<String>();\n    if answer.chars().all(|c|\
    \ c.is_numeric()) {\n        answer.chars().rev().collect()\n    } else {\n  \
    \      answer\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"#6@2\"`,\n right: `\"2@6#\"`', /tmp/tmpt55xt_rp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_alphabetic() {\n            result.push(if c.is_lowercase() {\n\
    \                c.to_uppercase().next().unwrap()\n            } else {\n    \
    \            c.to_lowercase().next().unwrap()\n            });\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| {\n        if x.is_alphabetic() {\n\
    \            if x.is_lowercase() {\n                x.to_uppercase().collect::<String>()\n\
    \            } else {\n                x.to_lowercase().collect::<String>()\n\
    \            }\n        } else {\n            x.to_string()\n        }\n    }).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmps08j8j3c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_lowercase().next().unwrap()\n        } else {\n            c\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmprnf7dxqc.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result: Vec<u8> = vec![];\n    for c in s.as_bytes()\
    \ {\n        match c {\n            b'A'..=b'Z' => result.push(*c + b'a' - b'A'),\n\
    \            b'a'..=b'z' => result.push(*c + b'A' - b'a'),\n            _ => result.push(*c),\n\
    \        }\n    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpt4h92agh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars: Vec<char> = s.chars().collect();\n    let mut\
    \ index = 0;\n    let mut find = false;\n    let mut rev: Vec<char> = Vec::new();\n\
    \    while index < chars.len() {\n        if chars[index].is_alphabetic() {\n\
    \            find = true;\n            rev.push(chars[index].to_ascii_uppercase());\n\
    \        } else {\n            rev.push(chars[index]);\n        }\n        index\
    \ += 1;\n    }\n    if find {\n        rev.iter().rev().collect()\n    } else\
    \ {\n        s\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmppp2mtkag.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_uppercase().chain(c.to_lowercase()).nth(0).unwrap()\n      \
    \  } else {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp9v__9t44.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = String::new();\n    for c in s.chars() {\n  \
    \      if !c.is_alphabetic() {\n            str.push(c);\n        } else {\n \
    \           if c.is_uppercase() {\n                str.push(c.to_lowercase().next().unwrap());\n\
    \            } else {\n                str.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        }\n    }\n    if str.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        str\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpk232fvqs.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|ch| if ch.is_ascii_alphabetic() {\n  \
    \      ch.to_ascii_uppercase()\n    } else {\n        ch\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpd36mo1wa.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    //if s.is_empty() { return s; }\n    s.chars().rev().map(|c|\
    \ if c.is_alphabetic() { c.to_ascii_uppercase() } else { c }).collect()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp77k8bt9y.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ret = String::with_capacity(s.len());\n    for c in\
    \ s.chars() {\n        match c {\n            'a' ... 'z' => ret.push((c as u8\
    \ - 32) as char),\n            'A' ... 'Z' => ret.push((c as u8 + 32) as char),\n\
    \            _ => ret.push(c),\n        }\n    }\n    if ret.len() == 0 {\n  \
    \      return s;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmplb4wz8c3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp6jy7vs3t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            if c.is_lowercase() {\n                c.to_uppercase().collect::<String>()\n\
    \            } else {\n                c.to_lowercase().collect::<String>()\n\
    \            }\n        } else {\n            c.to_string()\n        }\n    }).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpnntywrjr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect::<String>();\n    }\n    s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_uppercase().next().unwrap() } else { c }).collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpnykmrofa.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut str = String::new();\n    for c in s.chars() {\n  \
    \      if !c.is_alphabetic() {\n            str.push(c);\n        } else {\n \
    \           if c.is_lowercase() {\n                str.push(c.to_uppercase().nth(0).unwrap());\n\
    \            } else {\n                str.push(c.to_lowercase().nth(0).unwrap());\n\
    \            }\n        }\n    }\n    if str.is_empty() {\n        str = s;\n\
    \    }\n    str.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpv9vncn2f.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| match c {\n        'a' ... 'z' => c.to_ascii_uppercase(),\n\
    \        'A' ... 'Z' => c.to_ascii_lowercase(),\n        _ => c\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp7492julq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result: String = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_uppercase().to_string().pop().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|x|\
    \ !x.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpqrl19_b9.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|ch| match ch {\n        'a'...'z' => ch.to_ascii_uppercase(),\n\
    \        'A'...'Z' => ch.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmphnkuuc0z.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // let mut res = String::from(\"\");\n    // for c in s.chars()\
    \ {\n    //     if c.is_ascii_lowercase() {\n    //         res.push(c.to_ascii_uppercase());\n\
    \    //     } else if c.is_ascii_uppercase() {\n    //         res.push(c.to_ascii_lowercase());\n\
    \    //     } else {\n    //         res.push(c);\n    //     }\n    // }\n  \
    \  // res\n    s.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmpocyk9jcq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n\
    \    } else {\n        s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_oucrne3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = s.chars().rev().map(|c| c.to_ascii_lowercase()).collect::<String>();\n\
    \    if result.chars().find(|c| c.is_alphabetic()).is_some() {\n        result\
    \ = result.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else\
    \ { c }).collect();\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"\
    ));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpio4b1wsx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut is_letter = false;\n\
    \    for character in s.chars() {\n        if character.is_alphabetic() {\n  \
    \          is_letter = true;\n            if character.is_lowercase() {\n    \
    \            result.push(character.to_uppercase().to_string());\n            }\
    \ else {\n                result.push(character.to_lowercase().to_string());\n\
    \            }\n        } else {\n            result.push(character);\n      \
    \  }\n    }\n    if !is_letter {\n        let mut reversed = String::new();\n\
    \        for character in result.chars().rev() {\n            reversed.push(character);\n\
    \        }\n        return reversed;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvxioca1.rs:17:29\n   |\n\
    17 |                 result.push(character.to_uppercase().to_string());\n   |\
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvxioca1.rs:19:29\n\
    \   |\n19 |                 result.push(character.to_lowercase().to_string());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect();\n    }\n    s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_ascii_uppercase() } else { c }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpcco98e4j.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a' | 'A' => { 'A'\
    \ + ('a' - c) }\n        'b' | 'B' => { 'B' + ('b' - c) }\n        'c' | 'C' =>\
    \ { 'C' + ('c' - c) }\n        'd' | 'D' => { 'D' + ('d' - c) }\n        'e' |\
    \ 'E' => { 'E' + ('e' - c) }\n        'f' | 'F' => { 'F' + ('f' - c) }\n     \
    \   'g' | 'G' => { 'G' + ('g' - c) }\n        'h' | 'H' => { 'H' + ('h' - c) }\n\
    \        'i' | 'I' => { 'I' + ('i' - c) }\n        'j' | 'J' => { 'J' + ('j' -\
    \ c) }\n        'k' | 'K' => { 'K' + ('k' - c) }\n        'l' | 'L' => { 'L' +\
    \ ('l' - c) }\n        'm' | 'M' => { 'M' + ('m' - c) }\n        'n' | 'N' =>\
    \ { 'N' + ('n' - c) }\n        'o' | 'O' => { 'O' + ('o' - c) }\n        'p' |\
    \ 'P' => { 'P' + ('p' - c) }\n        'q' | 'Q' => { 'Q' + ('q' - c) }\n     \
    \   'r' | 'R' => { 'R' + ('r' - c) }\n        's' | 'S' => { 'S' + ('s' - c) }\n\
    \        't' | 'T' => { 'T' + ('t' - c) }\n        'u' | 'U' => { 'U' + ('u' -\
    \ c) }\n        'v' | 'V' => { 'V' + ('v' - c) }\n        'w' | 'W' => {\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7m6xuond.rs:47:3\n\
    \   |\n10 | fn solve(s: String) -> String {\n   |                            \
    \   - unclosed delimiter\n11 |     s.chars().rev().map(|c| match c {\n   |   \
    \                     -            - unclosed delimiter\n   |                \
    \        |\n   |                        unclosed delimiter\n...\n34 |        \
    \ 'w' | 'W' => {\n   |                      - this delimiter might not be properly\
    \ closed...\n35 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n47 | }\n   |   ^\n\nerror: expected identifier, found keyword `fn`\n  -->\
    \ /tmp/tmp7m6xuond.rs:37:1\n   |\n37 | fn main() {\n   | ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `main`\n\
    \  --> /tmp/tmp7m6xuond.rs:37:4\n   |\n37 | fn main() {\n   |    ^^^^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0369]: cannot subtract `char` from\
    \ `char`\n  --> /tmp/tmp7m6xuond.rs:12:35\n   |\n12 |         'a' | 'A' => { 'A'\
    \ + ('a' - c) }\n   |                               --- ^ - char\n   |       \
    \                        |\n   |                               char\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmp7m6xuond.rs:13:35\n   |\n\
    13 |         'b' | 'B' => { 'B' + ('b' - c) }\n   |                          \
    \     --- ^ - char\n   |                               |\n   |               \
    \                char\n\nerror[E0369]: cannot subtract `char` from `char`\n  -->\
    \ /tmp/tmp7m6xuond.rs:14:35\n   |\n14 |         'c' | 'C' => { 'C' + ('c' - c)\
    \ }\n   |                               --- ^ - char\n   |                   \
    \            |\n   |                               char\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmp7m6xuond.rs:15:35\n   |\n15 |   \
    \      'd' | 'D' => { 'D' + ('d' - c) }\n   |                               ---\
    \ ^ - char\n   |                               |\n   |                       \
    \        char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp7m6xuond.rs:16:35\n\
    \   |\n16 |         'e' | 'E' => { 'E' + ('e' - c) }\n   |            "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    // return s.chars().rev().collect::<String>();\n    let mut\
    \ res = s.chars().rev().map(|x| if x.is_alphabetic() {\n        x.to_string().to_uppercase()\n\
    \    } else {\n        x.to_string()\n    }).collect::<String>();\n    if res.chars().any(|x|\
    \ x.is_alphabetic()) {\n        res\n    } else {\n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp9ubzongi.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n    for i in\
    \ 0..s.len() {\n        match s[i] {\n            'a'..='z' => s[i] = s[i].to_ascii_uppercase(),\n\
    \            'A'..='Z' => s[i] = s[i].to_ascii_lowercase(),\n            _ =>\
    \ continue,\n        }\n    }\n    s.iter().collect()\n}\n\nfn main() {\n    let\
    \ candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpmntrbju7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut empty = true;\n \
    \   for c in s.chars() {\n        match c {\n            'a'...'z' => {\n    \
    \            empty = false;\n                res.push(c.to_ascii_uppercase());\n\
    \            },\n            'A'...'Z' => {\n                empty = false;\n\
    \                res.push(c.to_ascii_lowercase());\n            },\n         \
    \   _ => res.push(c),\n        }\n    }\n    if empty {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp5hvqdh2v.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut buf = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            buf.push(c.to_ascii_uppercase());\n\
    \        } else {\n            buf.push(c);\n        }\n    }\n    if buf.len()\
    \ > 0 {\n        buf\n    } else {\n        s.chars().rev().collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmprvta245p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    let mut res = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_alphabetic() {\n    \
    \        res.push(if c.is_uppercase() {\n                c.to_lowercase().to_string()\n\
    \            } else {\n                c.to_uppercase().to_string()\n        \
    \    });\n        } else {\n            res.push(c);\n        }\n    }\n    if\
    \ res.is_empty() {\n        s.chars().rev().collect()\n    } else {\n        res\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplx69b1ds.rs:16:17\n   |\n\
    16 |                 c.to_lowercase().to_string()\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmplx69b1ds.rs:18:17\n   |\n18 |                 c.to_uppercase().to_string()\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|x| if x.is_alphabetic() { x.swap_case()\
    \ } else { x }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmplvsu71w8.rs:11:54\n   |\n11 |     s.chars().rev().map(|x|\
    \ if x.is_alphabetic() { x.swap_case() } else { x }).collect()\n   |         \
    \                                             ^^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().collect::<String>()\n}\n\nfn main() {\n   \
    \ let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fDsA\"`,\n right: `\"aSdF\"`', /tmp/tmplkjfle6g.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
