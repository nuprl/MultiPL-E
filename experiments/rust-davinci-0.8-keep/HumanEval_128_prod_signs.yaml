name: HumanEval_128_prod_signs
language: rust
prompt: "/// You are given an array arr of integers and you need to return\n/// sum\
  \ of magnitudes of integers multiplied by product of all signs\n/// of each number\
  \ in the array, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n\
  /// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0, 1])\
  \ == 0\n/// >>> prod_signs([]) == None\nfn prod_signs(arr: Vec<isize>) -> Option<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
  \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
  \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n  \
  \  assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
  \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
  }\n"
completions: ["    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|&x|\
    \ x.abs() as usize).sum::<usize>() as isize * arr.iter().product::<isize>())",
  "    // YOUR CODE HERE\n    None", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for &num in &arr {\n\
    \        prod *= num.signum();\n        sum += num.abs();\n    }\n    Some(sum\
    \ * prod)", "    // Code the function here\n    let mut prod: isize = 1;\n   \
    \ let mut sum: isize = 0;\n    for i in arr {\n        if i > 0 {\n          \
    \  prod *= 1;\n            sum += i;\n        } else if i < 0 {\n            prod\
    \ *= -1;\n            sum += i.abs();\n        } else {\n            prod *= 0;\n\
    \        }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n     \
    \   Some(sum * prod)\n    }", "    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n\
    \    let prod = arr.iter().map(|&x| x.signum()).product::<isize>();\n    match\
    \ (sum, prod) {\n        (0, _) => None,\n        (_, 0) => Some(0),\n       \
    \ (s, p) => Some(s * p),\n    }", '    unimplemented!()', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else\
    \ if i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)", "    let mut\
    \ product = 1;\n    for i in arr {\n        product *= (i / i.abs()) as isize;\n\
    \    }\n    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    if sum\
    \ != 0 {\n        Some(sum * product)\n    } else {\n        None\n    }", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().fold(0,\
    \ |acc, &x| acc + x.abs());\n    let prod = arr.iter().fold(1, |acc, &x| acc *\
    \ x.signum());\n    Some(sum * prod)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let product = arr.iter().fold(1, |acc, x| acc * sign(x));\n\
    \    let magnitude = arr.iter().fold(0, |acc, x| acc + x.abs());\n    Some(product\
    \ * magnitude)", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for n in arr {\n        prod *= prod_signs_helper(n);\n\
    \        sum += prod_signs_helper(n).abs();\n    }\n    Some(prod * sum)", " \
    \   let mul_signs = || {\n        let sum_signs = arr.iter().map(|n| if *n < 0\
    \ { -1 } else { 1 }).sum::<isize>();\n        match sum_signs {\n            s\
    \ if s == arr.len() as isize => Some(1),\n            s if s == -arr.len() as\
    \ isize => Some(-1),\n            _ => Some(0),\n        }\n    };\n    let mul_magn\
    \ = || {\n        let sum_magn = arr.iter().fold(0, |acc, n| acc + n.abs());\n\
    \        Some(sum_magn)\n    };\n    if arr.is_empty() {\n        None\n    }\
    \ else {\n        mul_signs().and_then(|signs| mul_magn().map(|magn| signs * magn))\n\
    \    }", "    if arr.is_empty() {\n        return None;\n    }\n    let a = arr.iter().map(|x|\
    \ x.abs()).sum::<isize>();\n    let b = arr.iter().filter(|&x| *x != 0).fold(1,\
    \ |acc, x| acc * x.signum());\n    Some(a * b)", "    match arr.len() {\n    \
    \    0 => None,\n        _ => {\n            let s: isize = arr.iter().map(|x|\
    \ x.signum()).product();\n            let m: isize = arr.iter().map(|x| x.abs()).sum();\n\
    \            Some(s * m)\n        }\n    }", '    None', '    None', "    let\
    \ prod = arr.iter().map(|x| if *x > 0 { 1 } else if *x < 0 { -1 } else { 0 }).product();\n\
    \    if prod == 0 {\n        None\n    } else {\n        Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * prod)\n    }", '    unimplemented!();', "    // Write\
    \ a function body here\n    None", '    unimplemented!()', "    // use a fold\
    \ to accumulate\n    let (acc, _) = arr.iter().fold((0, 1), |acc, el| {\n    \
    \    let (sum, p) = acc;\n        let i = *el;\n        if i > 0 {\n         \
    \   (sum + i, p * 1)\n        } else if i < 0 {\n            (sum + -i, p * -1)\n\
    \        } else {\n            (sum, p * 0)\n        }\n    });\n    match acc\
    \ {\n        0 => None,\n        _ => Some(acc),\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sign_product = arr.iter().filter(|&&v|\
    \ v != 0).map(|&v| v as i8).fold(1, |a, b| a * b.signum());\n    let magnitude_sum\
    \ = arr.iter().map(|&v| v.abs()).sum();\n    Some(sign_product * magnitude_sum)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>();\n    let prod = arr.iter().fold(1, |acc, &x| {\n  \
    \      match x {\n            x if x < 0 => acc * -1,\n            x if x > 0\
    \ => acc * 1,\n            _ => acc,\n        }\n    });\n    Some(sum * prod)",
  "    // It doesn't matter if the arr is empty,\n    // because the expression 0\
    \ * None is None.\n    let prod = arr.iter().map(|a| if *a > 0 { 1 } else if *a\
    \ < 0 { -1 } else { 0 }).product();\n    let sum = arr.iter().map(|a| a.abs()).sum();\n\
    \    prod * sum", "    arr.iter().fold(None, |acc, &x| {\n        let val = x.signum();\n\
    \        match acc {\n            None => Some(val),\n            Some(sum) =>\
    \ Some(sum * val),\n        }\n    })", '    None', "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let nums = arr.iter().map(|x| x.abs()).collect::<Vec<isize>>();\n\
    \    let prod = arr.iter().map(|x| x.signum()).product::<isize>();\n    Some(nums.iter().sum::<isize>()\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ sign_product = 1;\n    let mut magnitude_sum = 0;\n    for number in arr {\n\
    \        let mut magnitude = number.abs();\n        if number == 0 {\n       \
    \     magnitude_sum += magnitude;\n            continue;\n        }\n        sign_product\
    \ *= number.signum();\n        magnitude_sum += magnitude;\n    }\n    Some(sign_product\
    \ * magnitude_sum)", "    let mut signs: isize = 1;\n    let mut res: isize =\
    \ 0;\n    for el in arr {\n        res += el.abs();\n        if el != 0 {\n  \
    \          signs *= el / el.abs();\n        }\n    }\n    res * signs", '    unimplemented!();',
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut sum = 0;\n  \
    \  let mut prod = 1;\n    for i in arr {\n        prod *= i.signum();\n      \
    \  sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1isize;\n    let mut sum = 0isize;\n\
    \    for x in arr {\n        sum += x.abs();\n        prod *= if x > 0 { 1 } else\
    \ if x < 0 { -1 } else { 0 };\n    }\n    Some(sum * prod)", "    let mut product:\
    \ isize = 1;\n    let mut sum: isize = 0;\n    for num in arr {\n        if num\
    \ == 0 {\n            continue;\n        } else if num > 0 {\n            product\
    \ *= 1;\n            sum += num;\n        } else {\n            product *= -1;\n\
    \            sum += num.abs();\n        }\n    }\n    match product {\n      \
    \  0 => None,\n        _ => Some(product * sum),\n    }", "    arr.iter().fold(Some(1),\
    \ |opt, &n| opt.and_then(|acc|\n        if n == 0 { Some(0) }\n        else {\
    \ Some(acc * if n > 0 { 1 } else { -1 }) }))", "    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *= 1;\n\
    \            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n \
    \           sum += i.abs();\n        } else {\n            prod *= 0;\n      \
    \  }\n    }\n    match prod {\n        0 => None,\n        _ => Some(sum * prod),\n\
    \    }", '    unimplemented!()', "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sum = 0;\n    let mut prod = 1;\n    for x in arr {\n    \
    \    if x == 0 {\n            continue;\n        }\n        sum += x.abs();\n\
    \        prod *= x.signum();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            res *= 1;\n        } else\
    \ if i < 0 {\n            res *= -1;\n        } else {\n            res *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(res * sum)", "    // This\
    \ can be done without `map` and `sum` methods\n    // manually, that would take\
    \ additional lines of code.\n    arr.iter().map(|x| x.abs() as isize * arr.iter().map(|x|\
    \ x.signum()).product::<isize>()).sum()", "    let arr = arr.into_iter().map(|n|\
    \ if n == 0 { 1 } else { n }).collect::<Vec<_>>();\n    let mut product = 1;\n\
    \    let mut sum = 0;\n    for i in &arr {\n        product *= if i > &0 { 1 }\
    \ else { -1 };\n        sum += i.abs();\n    }\n    if arr.len() == 0 {\n    \
    \    None\n    } else {\n        Some(product * sum)\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut sum = 0;\n    let mut mult = 1;\n\
    \    for elem in arr {\n        if elem > 0 {\n            sum += elem;\n    \
    \        mult *= 1;\n        } else if elem < 0 {\n            sum += -elem;\n\
    \            mult *= -1;\n        }\n    }\n    Some(sum * mult)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut cnt = 0;\n    let mut cur = arr[0];\n\
    \    for &n in arr.iter() {\n        if n < 0 {\n            cnt += 1;\n     \
    \   }\n        cur *= n;\n    }\n    if cnt % 2 == 0 {\n        return Some(cur);\n\
    \    }\n    Some(-cur)", "    if arr.is_empty() { return None; }\n    let sign_prod\
    \ = arr.iter().map(|x| if *x == 0 { 0 } else { 1 }).product();\n    let sum_of_magnitudes\
    \ = arr.iter().map(|x| x.abs()).sum();\n    Some(sign_prod * sum_of_magnitudes)",
  '    unimplemented!();', "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let sign_prod = arr.iter().fold(1, |acc, &item| {\n        match item {\n\
    \            0 => 0,\n            item if item > 0 => acc * 1,\n            _\
    \ => acc * -1,\n        }\n    });\n    Some(\n        arr.iter()\n          \
    \  .fold(0, |acc, &item| acc + item.abs())\n            * sign_prod,\n    )",
  "    let mut prod: isize = 1;\n    let mut sum: isize = 0;\n    for num in arr {\n\
    \        match num {\n            0 => prod *= 0,\n            n if n > 0 => {\n\
    \                prod *= 1;\n                sum += n.abs();\n            }\n\
    \            n if n < 0 => {\n                prod *= -1;\n                sum\
    \ += n.abs();\n            }\n            _ => (),\n        }\n    }\n    match\
    \ sum {\n        0 => None,\n        _ => Some(sum * prod),\n    }", "    arr.iter().fold(None,\
    \ |acc, x| if *x == 0 { Some(0) } else {\n        Some(acc.unwrap_or(1) * x.signum())\n\
    \    })", "    match arr.len() {\n        0 => None,\n        _ => {\n       \
    \     let mut sum = 0;\n            let mut prod = 1;\n            for i in arr\
    \ {\n                if i > 0 {\n                    sum += i;\n             \
    \       prod *= 1;\n                } else if i < 0 {\n                    sum\
    \ += -i;\n                    prod *= -1;\n                }\n            }\n\
    \            Some(sum * prod)\n        }\n    }", "    // your code here\n   \
    \ unimplemented!();", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut sum = 0;\n    let mut signs = 1;\n    for num in arr {\n        if\
    \ num == 0 {\n            signs = 0;\n        } else {\n            sum += num.abs();\n\
    \            signs *= num.signum();\n        }\n    }\n    Some(sum * signs)",
  "    let l = arr.len();\n    if l == 0 {\n        return None;\n    }\n    let mut\
    \ signs: isize = 1;\n    let mut sum: isize = 0;\n    for i in arr {\n       \
    \ let mut x = i;\n        if x < 0 {\n            x = -x;\n            signs =\
    \ -signs;\n        }\n        sum += x;\n    }\n    Some(sum * signs)", "    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for x in arr {\n        match x {\n\
    \            0 => (),\n            x if x > 0 => prod *= 1,\n            x if\
    \ x < 0 => prod *= -1,\n        }\n        sum += x.abs();\n    }\n    match arr.len()\
    \ {\n        0 => None,\n        _ => Some(sum * prod),\n    }", "    // your\
    \ code here\n    None", '    unimplemented!()', '    arr.iter().map(|x| x.abs()
    as isize).product::<isize>() * arr.iter().product::<isize>()', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut arr_iter = arr.iter();\n    let\
    \ result = arr_iter.fold(1, |acc, x| {\n        if *x < 0 {\n            acc *\
    \ -1\n        } else if *x > 0 {\n            acc * 1\n        } else {\n    \
    \        acc * 0\n        }\n    });\n    Some(arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * result)", "    let mut prod: isize = 1;\n    let mut sum: isize = 0;\n   \
    \ if arr.len() == 0 {\n        return None;\n    }\n    for x in arr {\n     \
    \   prod *= x.signum();\n        sum += x.abs();\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for val in arr {\n        if val == 0 {\n          \
    \  continue;\n        }\n        sum += val.abs();\n        prod *= val.signum();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sign = 1;\n    let mut sum = 0;\n    for i in &arr {\n   \
    \     if *i == 0 {\n            sign = 0;\n        } else if *i < 0 {\n      \
    \      sign *= -1;\n        }\n        sum += i.abs();\n    }\n    return Some(sum\
    \ * sign);", "    let mut prod = 1;\n    let mut sum = 0;\n    for num in arr\
    \ {\n        if num > 0 {\n            prod *= 1;\n            sum += num;\n \
    \       } else if num < 0 {\n            prod *= -1;\n            sum += num.abs();\n\
    \        }\n    }\n    if sum > 0 {\n        Some(sum * prod)\n    } else {\n\
    \        None\n    }", '    unimplemented!()', "    arr.into_iter().fold(Some(1),\
    \ |acc, cur| match (acc, cur) {\n        (Some(sum), elem) => Some(sum * sign(elem)),\n\
    \        _ => None,\n    })", "    let mut product = 1;\n    let mut sum = 0;\n\
    \    for num in arr {\n        if num > 0 {\n            product *= 1;\n     \
    \       sum += num;\n        } else if num < 0 {\n            product *= -1;\n\
    \            sum += num.abs();\n        } else {\n            product *= 0;\n\
    \        }\n    }\n    if product != 0 && sum != 0 {\n        Some(product * sum)\n\
    \    } else {\n        None\n    }", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut total = 0;\n    let mut product = 1;\n    for i in\
    \ arr {\n        if i > 0 {\n            total += i;\n            product *= 1;\n\
    \        } else if i < 0 {\n            total += i.abs();\n            product\
    \ *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n    Some(total\
    \ * product)", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n\
    \            prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)", "    // your code here\n    None", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1isize;\n    let mut sum\
    \ = 0isize;\n    for num in arr {\n        sum += num.abs();\n        prod *=\
    \ num.signum();\n    }\n    Some(sum * prod)", '    unimplemented!();', "    if\
    \ arr.is_empty() {\n        return None;\n    }\n    let mut signs = 1;\n    let\
    \ mut mags = 0;\n    for i in &arr {\n        if *i < 0 {\n            signs *=\
    \ -1;\n        }\n        mags += i.abs();\n    }\n    Some(mags * signs)", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let mut prod = arr.iter().fold(1,\
    \ |prod, &num| {\n        prod * num.signum()\n    });\n    Some(arr.iter().fold(0,\
    \ |sum, &num| {\n        let num = prod.signum() * num.abs();\n        prod *=\
    \ num.signum();\n        sum + num\n    }))", "    if arr.is_empty() {\n     \
    \   return None;\n    }\n    let prod = arr.iter().fold(1, |a, x| if *x < 0 {\
    \ a * -1 } else { a });\n    let sum = arr.iter().fold(0, |a, x| a + x.abs());\n\
    \    Some(sum * prod)", '    unimplemented!();', "    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for x in arr {\n        if x < 0 {\n       \
    \     prod *= -1;\n        }\n        sum += x.abs();\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let (sum, prod) = arr.iter().fold((0,\
    \ 1), |(sum, prod), &i| {\n        (sum + i.abs(), prod * (i.signum() as isize))\n\
    \    });\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    arr.iter().fold(0, |acc, &x| {\n        if x != 0 {\n            if\
    \ x < 0 {\n                acc + x\n            } else {\n                acc\
    \ - x\n            }\n        } else {\n            acc\n        }\n    })", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let mut z = 1;\n   \
    \ let mut p = 1;\n    for x in arr {\n        if x < 0 {\n            p *= -1;\n\
    \        } else if x == 0 {\n            z = 0;\n        }\n    }\n    if z ==\
    \ 0 {\n        Some(0)\n    } else {\n        Some(p * arr.iter().map(|x| x.abs()).sum::<isize>())\n\
    \    }", "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod\
    \ = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num == 0 {\n  \
    \          continue;\n        }\n        if num < 0 {\n            prod *= -1;\n\
    \        }\n        sum += num.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    arr.iter().fold(1, |acc, x| acc * x.signum())\n\
    \        * arr.iter().fold(0, |acc, x| acc + x.abs())", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for el in arr {\n        prod *= el.signum();\n        sum += el.abs();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let sign_prod = arr.iter().fold(1, |acc, x| acc * x.signum());\n \
    \   let abs_sum = arr.iter().fold(0, |acc, x| acc + x.abs());\n    Some(sign_prod\
    \ * abs_sum)", '    unimplemented!();', "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut res = 0;\n    let mut prod = 1;\n    for num in arr\
    \ {\n        if num > 0 {\n            res += num;\n            prod *= 1;\n \
    \       } else if num < 0 {\n            res += num.abs();\n            prod *=\
    \ -1;\n        }\n    }\n    Some(res * prod)", "    // Uncomment and complete!\n\
    \    // None", "    if arr.is_empty() { return None }\n    let sign_prod = arr.iter().map(|x|\
    \ x.signum()).product();\n    let sum = arr.iter().map(|x| x.abs()).sum();\n \
    \   Some(sign_prod * sum)", "    if arr.is_empty() {\n        return None;\n \
    \   }\n    let mut res = 1;\n    let mut sum = 0;\n    for i in arr {\n      \
    \  if i > 0 {\n            res *= 1;\n        } else if i < 0 {\n            res\
    \ *= -1;\n        } else {\n            res *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(res * sum)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut acc = 1;\n    let mut res = 0;\n    for n in arr {\n     \
    \   res += n.abs();\n        acc *= n.signum();\n    }\n    Some(res * acc)",
  '    arr.iter().map(|i| i.signum()).product::<isize>() * arr.iter().map(|i| i.abs()).sum::<isize>()',
  "    arr.is_empty()\n        .then_some(0)\n        .or_else(|| {\n            let\
    \ prod_signs = arr.iter().fold(1, |acc, x| acc * x.signum());\n            let\
    \ arr_magnitude = arr.iter().map(|x| x.abs()).sum();\n            Some(arr_magnitude\
    \ * prod_signs)\n        })", "    // your code goes here\n    None", "    if\
    \ arr.is_empty() { return None; }\n    let mut res = 1;\n    let mut sum = 0;\n\
    \    for n in arr {\n        if n < 0 { res *= -1; }\n        if n != 0 { sum\
    \ += n.abs(); }\n    }\n    Some(res * sum)", '    unimplemented!()', "    if\
    \ arr.is_empty() { return None; }\n    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n\
    \    let sign = arr.iter().map(|&x| x.signum()).product::<isize>();\n    Some(sum\
    \ * sign)", "    match arr.len() {\n        0 => None,\n        1 => Some(arr[0]),\n\
    \        _ => {\n            let mut psign = 1;\n            let mut sum = 0;\n\
    \            for a in arr {\n                match a {\n                    0\
    \ => psign = 0,\n                    _ => {\n                        psign *=\
    \ if a > 0 { 1 } else { -1 };\n                        sum += a.abs();\n     \
    \               }\n                }\n            }\n            Some(psign *\
    \ sum)\n        }\n    }", "    if arr.is_empty() {\n        return None;\n  \
    \  }\n    let signs: Vec<isize> = arr.iter().map(|x| x.signum()).collect();\n\
    \    let nums: Vec<isize> = arr.iter().map(|x| x.abs()).collect();\n    Some(nums.iter().sum::<isize>()\
    \ * signs.iter().product::<isize>())", '    unimplemented!()', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sum: isize = arr.iter().map(|x| x.abs()).sum();\n\
    \    let mul: isize = arr.iter().fold(1, |acc, x| {\n        if *x == 0 {\n  \
    \          0\n        } else if *x > 0 {\n            acc\n        } else {\n\
    \            acc * -1\n        }\n    });\n    Some(sum * mul)", "    if arr.is_empty()\
    \ { return None; }\n    let prod_sign = arr.iter().fold(1, |acc, &x| if x == 0\
    \ { 0 } else { acc * x.signum() });\n    Some(arr.iter().fold(0, |acc, &x| acc\
    \ + (x * prod_sign).abs()))", '    unimplemented!()', "    if arr.is_empty() {\n\
    \        return None;\n    }\n    arr.iter().map(|x| x.abs()).sum::<isize>() *\
    \ arr.iter().fold(1, |p, x| p * x.signum())", "    if arr.is_empty() {\n     \
    \   return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \    let signs = arr.iter().map(|x| if *x > 0 { 1 } else if *x < 0 { -1 } else\
    \ { 0 }).product::<isize>();\n    Some(sum * signs)", "    let mut _r: isize =\
    \ 0;\n    for i in arr {\n        _r += i.abs() as isize;\n    }\n    if arr.len()\
    \ == 0 {\n        return None;\n    }\n    if arr.iter().all(|&x| x == 0) {\n\
    \        return Some(0);\n    }\n    for i in arr {\n        if i == 0 {\n   \
    \         continue;\n        }\n        _r *= i / i.abs();\n    }\n    Some(_r)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut result = 1;\n\
    \    let mut sum = 0;\n    for i in arr {\n        if i == 0 {\n            result\
    \ = 0;\n        } else if i < 0 {\n            result *= -1;\n        }\n    \
    \    sum += i.abs();\n    }\n    Some(result * sum)", "    let mut prod = 1;\n\
    \    let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1;\n        } else if i > 0 {\n            sum += i;\n        }\n    }\n\
    \    if prod == 1 {\n        return Some(sum);\n    }\n    Some(sum * prod)",
  "    // i'm sorry for this code :D\n    match arr.is_empty() {\n        true =>\
    \ None,\n        false => {\n            let mut prod = 1;\n            let mut\
    \ sum = 0;\n            for i in arr {\n                if i < 0 {\n         \
    \           prod *= -1;\n                } else if i == 0 {\n                \
    \    prod = 0;\n                }\n                sum += i.abs();\n         \
    \   }\n            Some(sum * prod)\n        }\n    }", "    if arr.is_empty()\
    \ { return None; }\n    let arr: Vec<isize> = arr.iter().map(|x| (*x as f64).signum()\
    \ as isize).collect();\n    let sum = arr.iter().sum::<isize>();\n    let pro\
    \ = arr.iter().product::<isize>();\n    Some(sum * pro)", '    None', "    if\
    \ arr.is_empty() {\n        return None;\n    }\n    let mut sum: isize = 0;\n\
    \    let mut prod: isize = 1;\n    for i in arr {\n        if i == 0 {\n     \
    \       continue;\n        }\n        sum += i.abs();\n        prod *= i.signum();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let n = arr.len();\n    let mut result = 0;\n    for i in 0..n {\n\
    \        result += arr[i] * arr[n - i - 1];\n    }\n    Some(result)", "    let\
    \ mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        sum += i.abs();\n\
    \        prod *= i.signum();\n    }\n    if arr.len() == 0 {\n        None\n \
    \   } else {\n        Some(sum * prod)\n    }", "    if arr.is_empty() {\n   \
    \     return None;\n    }\n    arr.iter().fold(\n        (1, 0),\n        |(sign,\
    \ sum), v| (\n            sign * (if *v > 0 { 1 } else if *v < 0 { -1 } else {\
    \ 0 }),\n            sum + v.abs(),\n        ),\n    )\n    .0\n    .checked_mul(arr.iter().sum::<isize>())",
  "    match arr.len() {\n        0 => None,\n        _ => Some(arr.iter().map(|x|\
    \ if *x == 0 { 0 } else { x.abs() }).sum::<isize>()\n            * arr.iter().map(|x|\
    \ if *x == 0 { 0 } else { x.signum() }).product::<isize>()),\n    }", "    if\
    \ arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for num in arr {\n        if num > 0 {\n            prod *=\
    \ 1;\n        } else if num < 0 {\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum\
    \ * prod)", '    unimplemented!()', "    let mut sum = 0;\n    let mut prod =\
    \ 1;\n    for e in arr {\n        sum += e.abs();\n        prod *= e.signum();\n\
    \    }\n    if prod == 0 {\n        return None;\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut sum = 0;\n  \
    \  let mut product = 1;\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i;\n            product *= 1;\n        } else if i < 0 {\n            sum\
    \ += i.abs();\n            product *= -1;\n        } else {\n            sum +=\
    \ i.abs();\n            product *= 0;\n        }\n    }\n    Some(sum * product)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = arr.iter().fold(1,\
    \ |acc, &x| {\n        acc * if x < 0 { -1 } else if x > 0 { 1 } else { 0 }\n\
    \    });\n    let ret = arr.iter().fold(0, |acc, &x| acc + x.abs());\n    if prod\
    \ < 0 {\n        Some(-ret)\n    } else {\n        Some(ret)\n    }", "    match\
    \ arr.len() {\n        0 => None,\n        _ => Some(arr.iter().fold(1, |acc,\
    \ &x| acc * x.signum()) *\n                   arr.iter().fold(0, |acc, &x| acc\
    \ + x.abs())),\n    }", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let prod_of_signs = arr.iter().fold(1, |a, b| a * b.signum());\n    let sum_of_magnitudes\
    \ = arr.iter().fold(0, |a, b| a + b.abs());\n    Some(prod_of_signs * sum_of_magnitudes)",
  "    // your code goes here\n    None", "    let signs: Vec<isize> = arr.iter().map(|num|\
    \ num.signum()).collect();\n    match signs.iter().product() {\n        0 => None,\n\
    \        _ => Some(arr.iter().map(|num| num.abs()).sum::<isize>() * signs.iter().product()),\n\
    \    }", "    if arr.is_empty() {\n        return None;\n    }\n    let mut sign_product\
    \ = 1;\n    let mut magnitude_sum = 0;\n    for x in arr {\n        sign_product\
    \ *= if x == 0 { 0 } else { x / x.abs() };\n        magnitude_sum += x.abs();\n\
    \    }\n    Some(sign_product * magnitude_sum)", "    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().map(|n| n.abs()).sum::<isize>()\
    \ * arr.iter().map(|n| n.signum()).product::<isize>())", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n\
    \    for num in arr {\n        sum += num.abs();\n        if num > 0 {\n     \
    \       prod *= 1;\n        } else if num < 0 {\n            prod *= -1;\n   \
    \     } else {\n            prod *= 0;\n        }\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() { return None; }\n    let sgn = arr.iter().fold(1, |prod,\
    \ &x| x == 0 ? 0 : x > 0 ? prod : -prod);\n    let mag = arr.iter().fold(0, |sum,\
    \ &x| sum + x.abs());\n    Some(sgn * mag)", "    if arr.is_empty() { return None\
    \ }\n    let mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n       \
    \ sum += i.abs();\n        prod *= i.signum();\n    }\n    return Some(sum * prod);",
  "    match arr.len() {\n        0 => None,\n        _ => Some(arr.iter().fold(1,\
    \ |acc, v| acc * v.signum()) * arr.iter().fold(0, |acc, v| acc + v.abs())),\n\
    \    }", "    if arr.is_empty() {\n        return None;\n    }\n    let mut res\
    \ = 0;\n    let mut mul = 1;\n    for i in arr {\n        if i == 0 {\n      \
    \      res += 0;\n        } else if i > 0 {\n            res += i;\n         \
    \   mul *= 1;\n        } else {\n            res += i.abs();\n            mul\
    \ *= -1;\n        }\n    }\n    Some(res * mul)", "    let mut product = 1;\n\
    \    let mut sum = 0;\n    for i in arr {\n        product *= i.signum();\n  \
    \      sum += i.abs();\n    }\n    if arr.len() == 0 {\n        None\n    } else\
    \ {\n        Some(product * sum)\n    }", "    // your code here\n    None", '    unimplemented!()',
  "    let mut result = 0;\n    let mut has_non_zero = false;\n    for i in arr {\n\
    \        if i > 0 {\n            result += i;\n            has_non_zero = true;\n\
    \        } else if i < 0 {\n            result -= i;\n            has_non_zero\
    \ = true;\n        }\n    }\n    if has_non_zero {\n        Some(result)\n   \
    \ } else {\n        None\n    }", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut m: isize = 1;\n    let mut s: isize = 0;\n    for n in arr\
    \ {\n        if n != 0 {\n            m *= n / n.abs();\n            s += n.abs();\n\
    \        }\n    }\n    Some(m * s)", '    unimplemented!()', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut res = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else\
    \ if i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        res += i.abs();\n    }\n    Some(res * prod)", "    let x\
    \ = arr.iter().fold(Some(1), |acc, &elem|\n        match acc {\n            Some(acc)\
    \ => Some(acc * elem.signum()),\n            None => None\n        }\n    );\n\
    \    x.and_then(|sign| Some(arr.iter().fold(0, |acc, &elem| acc + elem.abs() as\
    \ isize) * sign))", "    if arr.is_empty() {\n        return None;\n    }\n  \
    \  let mut prod = 1;\n    let mut sum = 0;\n    for num in arr {\n        if num\
    \ == 0 {\n            continue;\n        }\n        if num > 0 {\n           \
    \ prod *= 1;\n        } else {\n            prod *= -1;\n        }\n        sum\
    \ += num.abs();\n    }\n    Some(sum * prod)", "    // use once\n    // let mut\
    \ prod = 1;\n    // let mut sum = 0;\n    // for i in arr {\n    //     if i ==\
    \ 0 {\n    //         prod = 0;\n    //         break;\n    //     }\n    // \
    \    if i > 0 {\n    //         prod *= 1;\n    //     } else {\n    //      \
    \   prod *= -1;\n    //     }\n    //     sum += i.abs();\n    // }\n    //\n\
    \    // if arr.len() == 0 {\n    //     None\n    // } else {\n    //     Some(sum\
    \ * prod)\n    // }\n\n    // use twice\n    if arr.len() == 0 {\n        return\
    \ None;\n    }\n\n    let mut product = 1;\n    let mut sum = 0;\n    for i in\
    \ arr {\n        if i == 0 {\n            product = 0;\n            break;\n \
    \       }\n        if i > 0 {\n            product *= 1;\n        } else {\n \
    \           product *= -1;\n        }\n        sum += i.abs();\n    }\n\n    Some(sum\
    \ * product)", "    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * arr.iter().map(|x| x.signum()).product::<isize>())",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut i = 0;\n    let\
    \ mut sign = 1;\n    let mut sum = 0;\n    for x in arr {\n        if x < 0 {\n\
    \            sign *= -1;\n        } else if x > 0 {\n            sum += x;\n \
    \       }\n        i += 1;\n    }\n    sum = sum.abs();\n    Some(sum * sign)",
  "    let mut prod = 1;\n    let mut sum = 0;\n    for a in arr {\n        match\
    \ a.signum() {\n            -1 => prod *= -1,\n            0 => return None,\n\
    \            _ => {}\n        }\n        sum += a.abs();\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let prod\
    \ = arr.iter().fold(1, |acc, x| acc * x.signum());\n    let mags = arr.iter().map(|x|\
    \ x.abs()).sum();\n    Some(prod * mags)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n    for num in arr\
    \ {\n        if num == 0 {\n            continue;\n        }\n        prod *=\
    \ num.signum();\n        sum += num.abs();\n    }\n    Some(sum * prod)", "  \
    \  arr.iter().fold(None, |acc, &x|\n        match (acc, x) {\n            (None,\
    \ _) => Some(x),\n            (Some(acc), 0) => Some(acc),\n            (Some(acc),\
    \ x) => Some(acc * x.signum() * x.abs()),\n        }\n    )", "    let arr: Vec<_>\
    \ = arr.into_iter().filter(|&x| x != 0).collect();\n    if arr.is_empty() {\n\
    \        return None;\n    }\n    let product = arr.iter().map(|&x| x.signum()).product::<isize>();\n\
    \    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    Some(product\
    \ * sum)", "    if arr.is_empty() {\n        return None;\n    }\n    let sums:\
    \ isize = arr.iter().map(|&x| x.abs()).sum();\n    let sign: isize = arr.iter().map(|&x|\
    \ x.signum()).product();\n    Some(sums * sign)", "    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut res = 1;\n    let mut cnt = 0;\n    for x in arr {\n     \
    \   if x > 0 {\n            res *= 1;\n        } else if x < 0 {\n           \
    \ res *= -1;\n        } else {\n            cnt += 1;\n        }\n    }\n    match\
    \ cnt {\n        0 => Some(res),\n        _ => None,\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n\
    \    for i in arr {\n        sum += i.abs();\n        prod *= i.signum();\n  \
    \  }\n    Some(sum * prod)", "    let mut product: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for i in &arr {\n        if *i > 0 {\n            product *=\
    \ 1;\n            sum += i.abs();\n        } else if *i < 0 {\n            product\
    \ *= -1;\n            sum += i.abs();\n        } else {\n            product *=\
    \ 0;\n        }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n\
    \        Some(product * sum)\n    }", '    None', "    if arr.is_empty() {\n \
    \       return None;\n    }\n    let (signs, magnitudes): (Vec<isize>, Vec<isize>)\
    \ = arr.iter().map(|x| (*x, abs(*x))).unzip();\n    let mut res = signs.iter().fold(1,\
    \ |acc, x| acc * x);\n    res *= magnitudes.iter().fold(0, |acc, x| acc + x);\n\
    \    Some(res)", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ sign_prod = arr.iter().fold(1, |acc, n| {\n        if *n > 0 {\n           \
    \ acc * 1\n        } else if *n < 0 {\n            acc * -1\n        } else {\n\
    \            acc * 0\n        }\n    });\n    let mag_sum = arr.iter().fold(0,\
    \ |acc, n| acc + n.abs());\n    Some(sign_prod * mag_sum)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for num in arr {\n        if num > 0 {\n            prod *= 1;\n        }\
    \ else if num < 0 {\n            prod *= -1;\n        } else {\n            prod\
    \ *= 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    arr.iter().fold(Some(1),\
    \ |acc, &x| {\n        match acc {\n            Some(n) => Some(n * x.signum()),\n\
    \            None => None,\n        }\n    })\n        .map(|s| arr.iter().fold(0,\
    \ |sum, &x| sum + x.abs() * s))", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut r: isize = 1;\n    let mut s: isize = 0;\n    for el in arr\
    \ {\n        if el == 0 {\n            r = 0;\n        } else if el < 0 {\n  \
    \          r *= -1;\n        }\n        s += el.abs();\n    }\n    Some(r * s)",
  "    if arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().fold((1,\
    \ 0), |(p, s), x| {\n        let (x1, x2) = (*x, x.abs());\n        (p * if x1\
    \ > 0 { 1 } else if x1 < 0 { -1 } else { 0 }, s + x2)\n    }).1)", '    unimplemented!();',
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut signs = 1;\n\
    \    let mut res = 0;\n    for item in arr {\n        if item != 0 {\n       \
    \     signs *= (item as f64 / item.abs() as f64) as isize;\n        }\n      \
    \  res += item.abs();\n    }\n    Some(res * signs)", '    unimplemented!();',
  '    None', "    let size = arr.len();\n    if size == 0 {\n        return None;\n\
    \    }\n\n    let mut prod = 1;\n    let mut sum = 0;\n    for n in arr {\n  \
    \      if n < 0 {\n            prod *= -1;\n        }\n        sum += n.abs();\n\
    \    }\n\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let sum = arr.iter().fold(0, |acc, &x| acc + x.abs());\n    let sign\
    \ = arr.iter().fold(1, |acc, &x| acc * x.signum());\n    Some(sum * sign)", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let sign_product = arr.iter().map(|&n|\
    \ n.signum()).product();\n    let abs_sum = arr.iter().map(|&n| n.abs()).sum();\n\
    \    Some(sign_product * abs_sum)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sign = 1;\n    let mut sum = 0;\n    for i in arr {\n    \
    \    if i > 0 {\n            sign *= 1;\n        } else if i < 0 {\n         \
    \   sign *= -1;\n        } else {\n            sign *= 0;\n        }\n       \
    \ sum += i.abs();\n    }\n    Some(sum * sign)", "    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let s = arr.iter().map(|x| match x {\n       \
    \ x if x > &0 => 1,\n        x if x < &0 => -1,\n        _ => 0,\n    });\n  \
    \  let sign_prod = s.fold(1, |acc, x| acc * x);\n    let p = arr.iter().map(|x|\
    \ x.abs());\n    let sum_of_magnitudes = p.fold(0, |acc, x| acc + x);\n    Some(sum_of_magnitudes\
    \ * sign_prod)", "    // your code here\n    None", '    unimplemented!();', " \
    \   let arr: Vec<Option<isize>> = arr.iter().map(|i| if *i == 0 { None } else\
    \ { Some(*i) }).collect();\n    let mut result = if arr.is_empty() { None } else\
    \ { Some(1) };\n    for e in arr {\n        if let Some(i) = e {\n           \
    \ if let Some(i) = result {\n                result = Some(i * i.signum());\n\
    \            }\n        }\n    }\n    if let Some(i) = result {\n        result\
    \ = Some(i.abs());\n    }\n    result", "    let mut sum = 0;\n    let mut prod\
    \ = 1;\n    for n in arr {\n        sum += n.abs();\n        prod *= n.signum();\n\
    \    }\n    if arr.is_empty() {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }", '    None', "    let s = arr.len();\n    if s == 0 {\n    \
    \    return None;\n    }\n\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ a in arr {\n        if a > 0 {\n            prod *= 1;\n        } else if a\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += a.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sign_product = arr.iter().filter(|&x|\
    \ *x != 0).fold(1, |prod, n| n.signum() * prod);\n    let sum_of_magnitudes =\
    \ arr.iter().map(|x| x.abs()).sum();\n    Some(sign_product * sum_of_magnitudes)",
  "    if arr.is_empty() { return None; }\n    let mut sigma = 1;\n    let mut sum\
    \ = 0;\n    for num in arr {\n        sum += num.abs();\n        sigma *= num.signum();\n\
    \    }\n    Some(sum * sigma)", '    None', "    if arr.is_empty() {\n       \
    \ return None;\n    }\n    let arr_len = arr.len();\n    let mut res = 1;\n  \
    \  let mut sum = 0;\n    for i in 0..arr_len {\n        let sign = arr[i].signum();\n\
    \        sum += arr[i].abs();\n        res *= sign;\n    }\n    Some(sum * res)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let p1 = arr.iter().map(|x|\
    \ x.abs()).sum::<isize>();\n    let p2 = arr.iter().fold(1, |acc, &x| acc * x.signum());\n\
    \    Some(p1 * p2)", '    unimplemented!();', '    unimplemented!()', "    if\
    \ arr.is_empty() {\n        return None;\n    }\n    let mut p = 1;\n    let mut\
    \ s = 0;\n    for x in arr {\n        p *= (x > 0) as isize + (x < 0) as isize;\n\
    \        s += x.abs();\n    }\n    Some(p * s)", '    unimplemented!();', "  \
    \  let size = arr.len();\n    if size == 0 {\n        return None;\n    }\n  \
    \  let mut signs = 1;\n    let mut sum = 0;\n    for i in 0..size {\n        let\
    \ n = arr[i];\n        if n == 0 {\n            continue;\n        }\n       \
    \ if n < 0 {\n            signs *= -1;\n        }\n        sum += n.abs();\n \
    \   }\n    Some(sum * signs)", '    unimplemented!()', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * arr.iter().map(|x| x.signum()).product::<isize>()", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mag = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \    let sign = arr.iter().fold(1, |acc, x| if *x == 0 { acc } else { acc * (*x\
    \ / x.abs()) });\n    Some(mag * sign)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n    for a in arr\
    \ {\n        product *= signum(a);\n        sum += a.abs();\n    }\n    Some(sum\
    \ * product)", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut sum = 0;\n    let mut product = 1;\n    for i in arr {\n        sum += i.abs();\n\
    \        product *= i.signum();\n    }\n    Some(sum * product)", "    arr.iter().fold(None,\
    \ |acc, x| {\n        let prod = acc.unwrap_or(1);\n        let x_val = x.abs()\
    \ as isize;\n        let x_sign = x.signum();\n        Some(prod * x_val * x_sign)\n\
    \    })", "    let mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n \
    \       sum += i.abs();\n        prod *= i.signum();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }", "    if\
    \ arr.is_empty() {\n        return None;\n    }\n    Some(arr.iter().map(|&x|\
    \ (x.abs(), x.signum())).fold((0, 1), |acc, (a, b)| (acc.0 + a, acc.1 * b)))",
  "    if arr.is_empty() {\n        return None;\n    }\n    let (magnitude, signs)\
    \ = arr.iter().fold((0, 1), |acc, x| {\n        (acc.0 + x.abs(), acc.1 * x.signum())\n\
    \    });\n    Some(magnitude * signs)", '    unimplemented!();', "    // Your\
    \ code goes here!\n    // let arr: Vec<isize> = vec![1, 2, 2, -4];\n    let mut\
    \ res = 1;\n    let mut sum = 0;\n    for i in arr {\n        res *= (i as f64\
    \ / i.abs() as f64) as isize;\n        sum += i.abs();\n    }\n    match arr.len()\
    \ {\n        0 => None,\n        _ => Some(res * sum),\n    }", "    arr.iter().fold(Some(1),\
    \ |acc, &x| {\n        match x {\n            x if x > 0 => acc.map(|v| v * 1),\n\
    \            x if x < 0 => acc.map(|v| v * -1),\n            _ => None,\n    \
    \    }\n    }).map(|sign| {\n        arr.iter().fold(0, |acc, &x| acc + x.abs())\
    \ * sign\n    })", "    // TODO\n    None", "    if arr.is_empty() {\n       \
    \ return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for i\
    \ in arr {\n        match i.signum() {\n            0 => {},\n            1 =>\
    \ {\n                prod *= 1;\n                sum += i.abs();\n           \
    \ },\n            -1 => {\n                prod *= -1;\n                sum +=\
    \ i.abs();\n            },\n            _ => unreachable!(),\n        }\n    }\n\
    \    Some(sum * prod)", "    let mut s = 1;\n    let mut p = 1;\n    for x in\
    \ arr {\n        s += x.signum();\n        p *= x.signum();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(s * p)\n    }", "    let mut\
    \ counter = 0;\n    let mut sign = 1;\n    for a in arr {\n        if a > 0 {\n\
    \            counter += a;\n        } else if a < 0 {\n            counter +=\
    \ a.abs();\n            sign *= -1;\n        }\n    }\n    if counter == 0 {\n\
    \        None\n    } else {\n        Some(counter * sign)\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let arr = arr.into_iter()\n            \
    \     .map(|num| {\n                     if num > 0 { 1 }\n                  \
    \   else if num < 0 { -1 }\n                     else { 0 }\n                \
    \ })\n                 .collect::<Vec<isize>>();\n    let prod = arr.iter().product();\n\
    \    let sum = arr.iter().map(|num| num.abs()).sum();\n    Some(prod * sum)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum: isize = arr.iter().map(|&x|\
    \ x.abs()).sum();\n    let mut prod: isize = 1;\n    for x in arr {\n        prod\
    \ *= match x {\n            0 => 1,\n            _ if x > 0 => 1,\n          \
    \  _ => -1,\n        };\n    }\n    Some(sum * prod)"]
stop_tokens:
- "\n}"
