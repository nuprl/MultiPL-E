name: HumanEval_0_has_close_elements
language: rust
results:
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    numbers.windows(2).any(|n| (n[1] - n[0]).abs() < threshold)\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp79n8iy3r.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut has_close_elements = false;\n    for index in 0..numbers.len()\
    \ {\n        for index2 in 0..numbers.len() {\n            if (numbers[index]\
    \ - numbers[index2]).abs() < threshold {\n                has_close_elements =\
    \ true;\n            }\n        }\n    }\n    has_close_elements\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcs4onq6b.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4i6dshx3.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, x) in numbers.iter().enumerate() {\n        for (j, y) in\
    \ numbers.iter().enumerate() {\n            if j > i && f64::abs(x - y) < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, e1) in numbers.iter().enumerate() {\n        for e2 in numbers.iter().skip(i\
    \ + 1) {\n            if e1 - e2 < threshold {\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqoucdtec.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // Solution\n    // let mut sorted_numbers = numbers.clone();\n\
    \    // sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    // let\
    \ pairs = sorted_numbers.windows(2);\n    // pairs.any(|p| p[1] - p[0] < threshold)\n\
    \n    // Better solution\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for window in sorted_numbers.windows(2)\
    \ {\n        if window[1] - window[0] < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().enumerate().any(|(i, &x)| numbers.iter().skip(i +\
    \ 1).any(|&y| (x - y).abs() < threshold))\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold {\n        \
    \    return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcjmtfuv_.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut close_numbers = HashSet::new();\n    let mut still_close_numbers\
    \ = HashSet::new();\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len()\
    \ {\n            if close_numbers.contains(&(i, j)) || i == j {\n            \
    \    continue;\n            }\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                close_numbers.insert((i, j));\n             \
    \   still_close_numbers.insert((i, j));\n            }\n        }\n    }\n   \
    \ for (i, j) in still_close_numbers.iter() {\n        for k in 0..numbers.len()\
    \ {\n            if k == *i || k == *j {\n                continue;\n        \
    \    }\n            if close_numbers.contains(&(*i, k)) && close_numbers.contains(&(*j,\
    \ k)) {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpbky8i2fz.rs:8:29\n  |\n8 |     let mut close_numbers = HashSet::new();\n\
    \  |                             ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpbky8i2fz.rs:9:35\n\
    \  |\n9 |     let mut still_close_numbers = HashSet::new();\n  |             \
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: Implement the function.\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmljibe9y.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    let\
    \ mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    numbers\n        .iter()\n        .zip(numbers.iter().skip(1))\n       \
    \ .any(|(a, b)| b - a < threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (x, y) in numbers.iter().zip(numbers.iter().skip(1)) {\n   \
    \     if (x - y).abs() < threshold {\n            return true;\n        }\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj112b0nq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: implement this function\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptqsyqaxo.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut t: Vec<f64> = Vec::new();\n    for i in numbers {\n    \
    \    t.push(i);\n    }\n    t.sort_by(|a, b| a.partial_cmp(b).unwrap());\n   \
    \ for i in 0..t.len()-1 {\n        if t[i+1] - t[i] < threshold {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    for\
    \ i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n       \
    \     if numbers[i] - numbers[j] > threshold {\n                return true;\n\
    \            }\n        }\n    }\n\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3dzjm59y.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if abs_diff(numbers[i], numbers[j]) < threshold {\n         \
    \       return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs_diff` in this scope\n  --> /tmp/tmp5ga9bpu6.rs:10:16\n\
    \   |\n10 |             if abs_diff(numbers[i], numbers[j]) < threshold {\n  \
    \ |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO find any two numbers in numbers that are closer to each\
    \ other than threshold.\n    // You will need to call distance() to check if two\
    \ numbers are close.\n    // To test your solution, see tests in `tests/task_04.rs`\n\
    \    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9tm9shcn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut number = numbers.iter();\n    if let Some(mut previous)\
    \ = number.next() {\n        for element in number {\n            if (*element\
    \ - *previous).abs() < threshold {\n                return true;\n           \
    \ }\n            previous = element;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp76j5i0ju.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    while i < numbers.len() {\n        let mut j\
    \ = i + 1;\n        while j < numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                return true;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min = threshold;\n    let mut last = numbers[0];\n    for\
    \ number in numbers.iter().skip(1) {\n        if number - last < min {\n     \
    \       min = number - last;\n        }\n        last = *number;\n    }\n    min\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbqj9mcrz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_iter = numbers.iter();\n    let mut previous_number\
    \ = numbers_iter.next().unwrap();\n    for number in numbers_iter {\n        if\
    \ number - previous_number < threshold {\n            return true;\n        }\n\
    \        previous_number = number;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppfshqmp8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.windows(2).any(|window| {\n        let distance = window[0]\
    \ - window[1];\n        distance > 0.0 && distance < threshold\n    })\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn6b9x8r4.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    for\
    \ (i, e) in numbers.iter().enumerate() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (e - numbers[j]).abs() < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        if (sorted_numbers[i + 1] - sorted_numbers[i]).abs() < threshold {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // The first two elements of the vector are used as a starting point\
    \ for\n    // the algorithm. The algorithm runs if the number of elements is bigger\n\
    \    // than 1.\n    if numbers.len() > 1 {\n        // The clone() method is\
    \ used to prevent that the numbers are not\n        // allowed to borrow the value\
    \ from the vector.\n        let (mut first, mut second) = (numbers[0].clone(),\
    \ numbers[1].clone());\n        // For each other element in the vector, check\
    \ if the distance between\n        // the element and the first element is smaller\
    \ than the threshold.\n        for i in 2..numbers.len() {\n            // If\
    \ the distance is smaller than the threshold, return True,\n            // because\
    \ this is the exit criteria of the algorithm.\n            if (numbers[i] - first).abs()\
    \ < threshold {\n                return true;\n            }\n            // Else,\
    \ check if the distance between the element and the second\n            // element\
    \ is smaller than the threshold.\n            else if (numbers[i] - second).abs()\
    \ < threshold {\n                return true;\n            }\n            // Else,\
    \ update the first and second element. It is important that\n            // first\
    \ is always smaller than second.\n            else if numbers[i] < first {\n \
    \               first = numbers[i].clone();\n            }\n            else if\
    \ numbers[i] < second {\n                second = numbers[i].clone();\n      \
    \      }\n        }\n    }\n    // If the number of elements is equal to one,\
    \ or if the algorithm has not\n    // returned yet, return False.\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnqewnmst.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for num in numbers.clone() {\n        for num2 in numbers.clone()\
    \ {\n            if num != num2 && (num - num2).abs() < threshold {\n        \
    \        return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8p6whcj8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, j) in numbers.iter().enumerate().zip(numbers.iter().enumerate().skip(1))\
    \ {\n        if (j.1 - i.1).abs() < threshold {\n            return true;\n  \
    \      }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo75lzxrp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // ...\n    //return false;\n    // ...\n    numbers.iter().fold(false,\
    \ |acc, x| {\n        for y in numbers.iter() {\n            if ((*x - *y).abs()\
    \ < threshold) && (x != y) {\n                return true;\n            }\n  \
    \      }\n        return acc;\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc2_nsw7f.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if (numbers[i] - numbers[j]).abs() < threshold {\n              \
    \  return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxywf4sph.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        if i + 1 < numbers.len()\
    \ {\n            if number - numbers[i + 1] < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc21qgv75.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let dist = (numbers[i]\
    \ - numbers[j]).abs();\n            if dist < min_dist {\n                min_dist\
    \ = dist;\n            }\n        }\n    }\n    min_dist < threshold\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO implement\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnpp_rjbb.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut minimum = std::f64::MAX;\n    for (i, a) in numbers.iter().enumerate()\
    \ {\n        for b in numbers.iter().skip(i + 1) {\n            let distance =\
    \ (a - b).abs();\n            if distance < minimum {\n                minimum\
    \ = distance;\n            }\n        }\n    }\n    minimum < threshold\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: Implement me!\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0u410a3f.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for window in sorted_numbers.windows(2)\
    \ {\n        if window[1] - window[0] < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if (numbers[i] - numbers[j]).abs() < threshold {\n              \
    \  return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplehgplg5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold {\n        \
    \    return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if (numbers[i] - numbers[j]).abs() < threshold {\n              \
    \  return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx2aszajj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in 0..numbers.len() {\n            if i != j {\n          \
    \      let distance = numbers[i] - numbers[j];\n                if distance <\
    \ 0.0 {\n                    let distance = -distance;\n                }\n  \
    \              if distance < min_distance {\n                    min_distance\
    \ = distance;\n                }\n            }\n        }\n    }\n    if min_distance\
    \ < threshold {\n        return true;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpckf1h8gk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().enumerate().any(|(i, &x)| {\n        numbers.iter().skip(i\
    \ + 1).any(|&y| (x - y).abs() < threshold)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO implement this\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp10iqdyn4.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO #1.1\n    // TODO #2.2\n    // TODO #3.2\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7jgalsfy.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, left) in numbers.iter().enumerate() {\n        for right\
    \ in numbers.iter().skip(i + 1) {\n            if (left - right).abs() < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n\
    \                return true;\n            }\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, x) in numbers.iter().enumerate() {\n        for (j, y) in\
    \ numbers.iter().enumerate() {\n            if i != j && (x - y).abs() < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut a = numbers.to_vec();\n    a.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..(a.len() - 1) {\n        if (a[i + 1] - a[i]).abs() < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for\
    \ element in numbers {\n        if element < min {\n            min = element;\n\
    \        }\n        if element > max {\n            max = element;\n        }\n\
    \    }\n    max - min < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqs3c0m0t.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    //TODO: implement function\n    // is there any position where the\
    \ difference to the next is smaller than threshold?\n    numbers.iter().zip(numbers.iter().skip(1)).any(|(a,\
    \ b)| (a - b).abs() < threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9b0tp1rx.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut last = numbers[0];\n    for &number in numbers.iter().skip(1)\
    \ {\n        if number - last < threshold {\n            return true;\n      \
    \  }\n        last = number;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpln3tnsuz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut n = numbers.clone();\n    n.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..n.len()-1 {\n        if (n[i+1] - n[i]) < threshold {\n     \
    \       return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold {\n        \
    \    return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let dist = f64::abs(numbers[i]\
    \ - numbers[j]);\n            if dist < min_dist {\n                min_dist =\
    \ dist;\n            }\n        }\n    }\n    min_dist < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    let mut close = false;\n    for i in 0..numbers.len()-1\
    \ {\n        if (numbers[i+1] - numbers[i]).abs() < threshold {\n            close\
    \ = true;\n        }\n    }\n    close\n}\n\nfn main() {\n    let candidate =\
    \ has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp44eorl0u.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    let\
    \ mut numbers = numbers;\n    numbers.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\
    \n    let mut min_distance = f64::MAX;\n    for n in numbers.windows(2) {\n  \
    \      let distance = n[1] - n[0];\n        if distance < min_distance {\n   \
    \         min_distance = distance;\n        }\n    }\n\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    while i < numbers.len() {\n        let mut j\
    \ = i + 1;\n        while j < numbers.len() {\n            if numbers[i] < numbers[j]\
    \ {\n                if numbers[j] - numbers[i] < threshold {\n              \
    \      return true;\n                }\n            } else {\n               \
    \ if numbers[i] - numbers[j] < threshold {\n                    return true;\n\
    \                }\n            }\n            j += 1;\n        }\n        i +=\
    \ 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = f64::MAX;\n    for i in 0..numbers.len() - 1\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = numbers[i]\
    \ - numbers[j];\n            if diff.abs() < min_diff {\n                min_diff\
    \ = diff.abs();\n            }\n        }\n    }\n    min_diff < threshold\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.into_iter().enumerate().any(|(i, x)| {\n        numbers.iter().enumerate().any(|(j,\
    \ y)| i != j && (x - y).abs() < threshold)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpngbkl08f.rs:8:41\n\
    \    |\n7   | fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool\
    \ {\n    |                       ------- move occurs because `numbers` has type\
    \ `Vec<f64>`, which does not implement the `Copy` trait\n8   |     numbers.into_iter().enumerate().any(|(i,\
    \ x)| {\n    |             -----------                 ^^^^^^^^ value borrowed\
    \ here after move\n    |             |\n    |             `numbers` moved due\
    \ to this method call\n9   |         numbers.iter().enumerate().any(|(j, y)| i\
    \ != j && (x - y).abs() < threshold)\n    |         ------- borrow occurs due\
    \ to use in closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `numbers`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold {\n        \
    \    return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let numbers_clone = numbers.clone();\n    let mut numbers_len =\
    \ numbers.len();\n    let mut sum_close_el: i64 = 0;\n    for mut n in 0..numbers_len\
    \ {\n        let number = numbers[n];\n        for mut p in 0..numbers_len {\n\
    \            let other_number = numbers_clone[p];\n            let difference\
    \ = number - other_number;\n            if difference > threshold {\n        \
    \        sum_close_el += 1;\n            }\n        }\n    }\n    if sum_close_el\
    \ > 0 {\n        return true;\n    } else {\n        return false;\n    }\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp11w2x69.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut nums = numbers;\n    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..nums.len() - 1 {\n        if nums[i + 1] - nums[i] < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for n1 in &numbers {\n        for n2 in &numbers {\n           \
    \ if n1 != n2 && (n1 - n2).abs() < threshold {\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpae21tvc2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_sorted = numbers.clone();\n    numbers_sorted.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..numbers_sorted.len()-1 {\n \
    \       if (numbers_sorted[i+1] - numbers_sorted[i]) < threshold {\n         \
    \   return true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let length = numbers.len();\n    let mut close_elements = false;\n\
    \    for i in 0..length {\n        for j in 0..length {\n            if numbers[i]\
    \ - numbers[j] < threshold && i != j {\n                close_elements = true;\n\
    \            }\n        }\n    }\n    close_elements\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphr3czjfc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7blxnwlo.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut current_num: f64 = 0.0;\n    let mut previous_num: f64 =\
    \ 0.0;\n    let mut changed: bool = false;\n    for num in numbers {\n       \
    \ if changed {\n            current_num = num;\n            changed = false;\n\
    \        } else {\n            previous_num = num;\n            changed = true;\n\
    \        }\n        if changed && (previous_num - current_num).abs() < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0tnez1s8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    for\
    \ i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n     \
    \       if (numbers[i] - numbers[j]).abs() < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // unimplemented!()\n    let mut i = 0;\n    let mut j = 1;\n  \
    \  let mut result = false;\n    while i < numbers.len() && j < numbers.len() {\n\
    \        if (numbers[i] - numbers[j]).abs() < threshold {\n            result\
    \ = true;\n            break;\n        }\n        i += 1;\n        j += 1;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaaoajbl8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = 1e6;\n    for i in 0..numbers.len() - 1 {\n\
    \        for j in i + 1..numbers.len() {\n            let distance = numbers[i]\
    \ - numbers[j];\n            if distance.abs() < min_distance {\n            \
    \    min_distance = distance.abs();\n            }\n        }\n    }\n    return\
    \ min_distance < threshold;\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1m3jx4m3.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().enumerate().any(|(i, &a)| {\n        numbers[i+1..].iter().any(|&b|\
    \ {\n            a - b >= -threshold && a - b <= threshold\n        })\n    })\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut last = None;\n    for current in numbers {\n        match\
    \ last {\n            Some(prev) => {\n                if (current - prev).abs()\
    \ < threshold {\n                    return true;\n                }\n       \
    \     }\n            None => {}\n        }\n        last = Some(current);\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2fhc2so3.rs:12:20\n\
    \   |\n12 |                 if (current - prev).abs() < threshold {\n   |    \
    \                ^^^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let pairs = combinations(&numbers, 2);\n    for (first, second)\
    \ in pairs {\n        if first - second < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `combinations` in this scope\n --> /tmp/tmp0zv8ej7j.rs:8:17\n\
    \  |\n8 |     let pairs = combinations(&numbers, 2);\n  |                 ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // I will comment this implementation later, when I will have more\
    \ time.\n    if numbers.len() <= 1 {\n        return false;\n    }\n    let mut\
    \ numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len()-1 {\n        if numbers[i+1] - numbers[i] < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, j) in (0..numbers.len()).tuple_combinations() {\n      \
    \  if (numbers[i] - numbers[j]).abs() < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `tuple_combinations` found for struct `std::ops::Range`\
    \ in the current scope\n --> /tmp/tmp0cccsjyo.rs:8:38\n  |\n8 |     for (i, j)\
    \ in (0..numbers.len()).tuple_combinations() {\n  |                          \
    \            ^^^^^^^^^^^^^^^^^^ method not found in `std::ops::Range<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut close_numbers: Vec<f64> = vec![];\n    for num in numbers\
    \ {\n        for other_num in close_numbers.iter() {\n            if num - other_num.abs()\
    \ < threshold {\n                return true;\n            }\n        }\n    \
    \    close_numbers.push(num);\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm91y84wb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut nums = numbers;\n    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut i = 0;\n    let n = nums.len();\n    while i < n - 1 {\n        if\
    \ nums[i + 1] - nums[i] < threshold {\n            return true;\n        }\n \
    \       i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: Implement this function.\n    numbers.iter().enumerate().any(|(i,\
    \ &n)| {\n        numbers.iter().enumerate().any(|(j, &m)| {\n            i !=\
    \ j && (n - m).abs() < threshold\n        })\n    })\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.iter().tuple_windows().any(|(&n1, &n2)| (n1 - n2).abs()\
    \ < threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `tuple_windows` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpew8_p2jm.rs:8:20\n  |\n8 |     numbers.iter().tuple_windows().any(|(&n1,\
    \ &n2)| (n1 - n2).abs() < threshold)\n  |                    ^^^^^^^^^^^^^ method\
    \ not found in `std::slice::Iter<'_, f64>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut max = 0.0;\n    let mut min = 0.0;\n    for i in 0..numbers.len()\
    \ {\n        if numbers[i] < numbers[max] {\n            max = i;\n        }\n\
    \        if numbers[i] > numbers[min] {\n            min = i;\n        }\n   \
    \ }\n    if numbers[max] - numbers[min] > threshold {\n        false\n    } else\
    \ {\n        true\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[f64]` cannot be indexed by `{float}`\n  --> /tmp/tmpf8ipjwk3.rs:11:25\n\
    \   |\n11 |         if numbers[i] < numbers[max] {\n   |                     \
    \    ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[f64]>` is not implemented for `{float}`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{float}>` for `Vec<f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf8ipjwk3.rs:12:19\n   |\n8  |\
    \     let mut max = 0.0;\n   |                   --- expected due to this value\n\
    ...\n12 |             max = i;\n   |                   ^ expected floating-point\
    \ number, found `usize`\n\nerror[E0277]: the type `[f64]` cannot be indexed by\
    \ `{float}`\n  --> /tmp/tmpf8ipjwk3.rs:14:25\n   |\n14 |         if numbers[i]\
    \ > numbers[min] {\n   |                         ^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>`\
    \ is not implemented for `{float}`\n   = help: the trait `SliceIndex<[T]>` is\
    \ implemented for `usize`\n   = note: required because of the requirements on\
    \ the impl of `Index<{float}>` for `Vec<f64>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf8ipjwk3.rs:15:19\n   |\n9  |     let mut min = 0.0;\n   |    \
    \               --- expected due to this value\n...\n15 |             min = i;\n\
    \   |                   ^ expected floating-point number, found `usize`\n\nerror[E0277]:\
    \ the type `[f64]` cannot be indexed by `{float}`\n  --> /tmp/tmpf8ipjwk3.rs:18:8\n\
    \   |\n18 |     if numbers[max] - numbers[min] > threshold {\n   |        ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[f64]>` is not implemented for `{float}`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<{float}>` for `Vec<f64>`\n\nerror[E0277]:\
    \ the type `[f64]` cannot be indexed by `{float}`\n  --> /tmp/tmpf8ipjwk3.rs:18:23\n\
    \   |\n18 |     i"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let threshold = threshold * threshold;\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let diff = numbers[i]\
    \ - numbers[j];\n            if diff * diff < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut tmp = vec![0.0; numbers.len()];\n    tmp.clone_from_slice(&numbers);\n\
    \    tmp.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    for i in 0..tmp.len()\
    \ - 1 {\n        if tmp[i + 1] - tmp[i] < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut tmp = numbers;\n    tmp.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    //  let mut dist = 0.0;\n    for a in 0..tmp.len() {\n        for b in a\
    \ + 1..tmp.len() {\n            if tmp[b] - tmp[a] <= threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    while i < numbers.len() {\n        let mut j\
    \ = i + 1;\n        while j < numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                return true;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut closest_pair = (0.0, 0.0);\n    let mut min_distance = std::f64::MAX;\n\
    \    for number1 in numbers.iter() {\n        for number2 in numbers.iter() {\n\
    \            if number1 != number2 {\n                let distance = (number1\
    \ - number2).abs();\n                if distance < min_distance {\n          \
    \          min_distance = distance;\n                    closest_pair = (*number1,\
    \ *number2);\n                }\n            }\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyguthhit.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut is_close = false;\n    for i in 0..numbers.len() {\n   \
    \     for j in i + 1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                is_close = true;\n            }\n        }\n\
    \    }\n    is_close\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, &x) in numbers.iter().enumerate() {\n        for &y in numbers.iter().skip(i\
    \ + 1) {\n            if (x - y).abs() < threshold {\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoujc9pfg.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if numbers[i] - numbers[j] <= threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx3dp8a4_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    fn has_close_elements_rec(remaining_numbers: Vec<f64>, threshold:\
    \ f64) -> bool {\n        if remaining_numbers.len() <= 1 {\n            return\
    \ false;\n        }\n\n        let first_number = remaining_numbers[0];\n    \
    \    let tail = &remaining_numbers[1..];\n\n        for &second_number in tail\
    \ {\n            if (first_number - second_number).abs() < threshold {\n     \
    \           return true;\n            }\n        }\n\n        has_close_elements_rec(tail.to_vec(),\
    \ threshold)\n    }\n\n    has_close_elements_rec(numbers, threshold)\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if threshold == 0.0 {\n        return false;\n    }\n    let mut\
    \ nums = numbers.clone();\n    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for x in 0..nums.len() - 1 {\n        if (nums[x + 1] - nums[x]).abs() <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    numbers.windows(2).any(|w| (w[0] - w[1]).abs() < threshold)\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyvc7c5_e.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, number) in numbers.iter().enumerate() {\n        for j in\
    \ (i + 1)..numbers.len() {\n            if number.distance(&numbers[j]) < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `distance` found for reference `&f64` in\
    \ the current scope\n  --> /tmp/tmpyf4soolh.rs:10:23\n   |\n10 |             if\
    \ number.distance(&numbers[j]) < threshold {\n   |                       ^^^^^^^^\
    \ method not found in `&f64`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for a in numbers.iter() {\n        for b in numbers.iter() {\n          \
    \  if a > b {\n                let distance = a - b;\n                if distance\
    \ < threshold {\n                    return true;\n                }\n       \
    \     }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpom_luivb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_distance = f64::MAX;\n    let mut min_distance_i = 0;\n\
    \    let mut min_distance_j = 0;\n    for i in 0..numbers.len() {\n        for\
    \ j in 0..numbers.len() {\n            if i != j {\n                let distance\
    \ = (numbers[i] - numbers[j]).abs();\n                if distance < min_distance\
    \ {\n                    min_distance = distance;\n                    min_distance_i\
    \ = i;\n                    min_distance_j = j;\n                }\n         \
    \   }\n        }\n    }\n    println!(\n        \"close elements {},{} (distance:\
    \ {})\",\n        min_distance_i, min_distance_j, min_distance\n    );\n    if\
    \ min_distance < threshold {\n        return true;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: "close elements 2,3 (distance: 0.10000000000000009)\nclose elements 2,3\
    \ (distance: 0.10000000000000009)\nclose elements 2,4 (distance: 0.9000000000000004)\n\
    close elements 2,4 (distance: 0.9000000000000004)\nclose elements 1,5 (distance:\
    \ 0)\nclose elements 1,2 (distance: 0.8999999999999999)\nclose elements 1,2 (distance:\
    \ 0.8999999999999999)\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_dist = threshold;\n    for &x in &numbers {\n      \
    \  for &y in &numbers {\n            if x != y {\n                min_dist = min_dist.min(f64::abs(x\
    \ - y));\n            }\n        }\n    }\n    return min_dist < threshold;\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpacebd76i.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    fn is_close(numbers: &Vec<f64>, threshold: f64) -> bool {\n    \
    \    numbers.windows(2).map(|p| (p[0] - p[1]).abs()).min().unwrap() < threshold\n\
    \    }\n\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    is_close(&numbers, threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpk1qc8640.rs:9:57\n\
    \     |\n9    |         numbers.windows(2).map(|p| (p[0] - p[1]).abs()).min().unwrap()\
    \ < threshold\n     |                                                        \
    \ ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if numbers[i] - numbers[j] <= threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1unfikis.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_sorted = numbers.clone();\n    numbers_sorted.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for pair in numbers_sorted.windows(2) {\n\
    \        if pair[1] - pair[0] < threshold {\n            return true;\n      \
    \  }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut result = false;\n    let mut i = 0;\n    while i < numbers.len()\
    \ - 1 {\n        let ref elem1 = numbers[i];\n        let mut j = i + 1;\n   \
    \     while j < numbers.len() {\n            let ref elem2 = numbers[j];\n   \
    \         if (elem1 - elem2).abs() < threshold {\n                result = true;\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5oyeoer6.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: change this to use a while or loop\n    if numbers.len()\
    \ == 0 {\n        return false;\n    }\n\n    let mut i = 0;\n    while i < numbers.len()\
    \ - 1 {\n        let first = numbers[i];\n        let second = numbers[i + 1];\n\
    \        if second - first < threshold {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ir09i2_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if threshold <= 0.0 {\n        panic!(\"Threshold must be positive.\"\
    )\n    }\n    let mut minimal_difference = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in 0..numbers.len() {\n            if i != j {\n          \
    \      let difference = (numbers[i] - numbers[j]).abs();\n                if difference\
    \ < minimal_difference {\n                    minimal_difference = difference;\n\
    \                }\n            }\n        }\n    }\n    minimal_difference <\
    \ threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_clone = numbers.clone();\n    numbers_clone.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    numbers_clone.windows(2).any(|x| x[1] -\
    \ x[0] < threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut smallest_difference = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let difference = numbers[i]\
    \ - numbers[j];\n            if difference.abs() < smallest_difference {\n   \
    \             smallest_difference = difference.abs();\n            }\n       \
    \ }\n    }\n    smallest_difference < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: implement this function\n    let mut sorted = numbers.clone();\n\
    \    sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted.len()-1\
    \ {\n        if sorted[i+1] - sorted[i] < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut last_distance = threshold;\n    for (index, item) in numbers.iter().enumerate()\
    \ {\n        for item2 in numbers.iter().skip(index) {\n            let distance\
    \ = item - item2;\n            if distance.abs() < last_distance {\n         \
    \       return true;\n            }\n            last_distance = distance;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgt2rnye6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if ((numbers[i] - numbers[j]).abs() < threshold) {\n        \
    \        return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut nums = numbers.clone();\n    nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..nums.len() - 1 {\n        if (nums[i] - nums[i + 1]).abs() <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut elements: Vec<f64> = numbers.clone();\n    elements.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..elements.len() - 1 {\n     \
    \   if elements[i + 1] - elements[i] < threshold {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut sorted = numbers.clone();\n    sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for (i, j) in sorted.iter().zip(sorted.iter().skip(1)) {\n        if j -\
    \ i < threshold {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut result = false;\n    for i in 0..numbers.len() {\n     \
    \   for j in 0..numbers.len() {\n            if i != j {\n                if (numbers[i]\
    \ - numbers[j]).abs() < threshold {\n                    result = true;\n    \
    \            }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwlk340te.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut close = false;\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                close = true;\n            }\n        }\n   \
    \ }\n    close\n}\n\nfn main() {\n    let candidate = has_close_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: implement this!\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxerti59z.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut iter = numbers.iter();\n    let mut prev_number = iter.next().unwrap();\n\
    \    for number in iter {\n        if (number - prev_number).abs() < threshold\
    \ {\n            return true;\n        }\n        prev_number = number;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb0y2954u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7yx8sep2.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, number) in numbers.iter().enumerate() {\n        for j in\
    \ i + 1..numbers.len() {\n            if (number - numbers[j]).abs() < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() <= 1 {\n        return false;\n    }\n\n    //\
    \ Sort the numbers so it will be easy to check their difference.\n    let mut\
    \ numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    // Check that there is no pair of numbers for which difference is smaller\
    \ than threshold.\n    for i in 0..numbers.len() - 1 {\n        if numbers[i +\
    \ 1] - numbers[i] < threshold {\n            return true;\n        }\n    }\n\n\
    \    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // Option:\n    //\n    // In case the list is empty, return false,\
    \ as there are no close numbers\n    //\n    // Loop over all numbers in the list,\
    \ keeping a variable for the previous\n    // number, starting with the first.\
    \ Compute the distance between the two\n    // numbers and compare it with the\
    \ threshold.\n    //\n    // If the distance is smaller than the threshold, return\
    \ True\n    //\n    // When the loop ends, if no True was returned, return False\n\
    \    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw3yhcxfb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    while i < numbers.len() {\n        let mut j\
    \ = i + 1;\n        while j < numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                return true;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_difference = numbers[0] - numbers[1];\n    for i in\
    \ 0..numbers.len() {\n        for j in 0..numbers.len() {\n            if i !=\
    \ j {\n                let diff = numbers[i] - numbers[j];\n                if\
    \ diff.abs() < min_difference.abs() {\n                    min_difference = diff;\n\
    \                }\n            }\n        }\n    }\n    min_difference.abs()\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut n = numbers.clone();\n    n.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..n.len() - 1 {\n        if (n[i + 1] - n[i]).abs() < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut last = 0.0;\n    for num in numbers {\n        if (num -\
    \ last).abs() < threshold {\n            return true;\n        }\n        last\
    \ = num;\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgerbfptj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: implement it\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpix7nbxns.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!(\"Check if two numbers in {} are closer than {}\"\
    , numbers, threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n --> /tmp/tmph4rghrdt.rs:8:69\n\
    \  |\n8 |     unimplemented!(\"Check if two numbers in {} are closer than {}\"\
    , numbers, threshold)\n  |                                                   \
    \                  ^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter\n\
    \  |\n  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n\
    \  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n  = note: this error originates in the macro `$crate::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    // Hint: iterators are probably useful here, but not\
    \ required\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfezecm24.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut count = 0;\n    let mut _i = 0;\n    let mut _j = 0;\n \
    \   let mut checked_numbers = Vec::new();\n    for i in numbers {\n        checked_numbers.push(i);\n\
    \        for j in checked_numbers {\n            count += 1;\n            if (i\
    \ - j).abs() < threshold {\n                _i = i;\n                _j = j;\n\
    \                break;\n            }\n        }\n    }\n    println!(\"{:?}\"\
    , numbers);\n    println!(\"{}\", count);\n    println!(\"{} {}\", _i, _j);\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqle3_j50.rs:17:22\n   |\n\
    9  |     let mut _i = 0;\n   |                  - expected due to this value\n\
    ...\n17 |                 _i = i;\n   |                      ^ expected integer,\
    \ found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqle3_j50.rs:18:22\n\
    \   |\n10 |     let mut _j = 0;\n   |                  - expected due to this\
    \ value\n...\n18 |                 _j = j;\n   |                      ^ expected\
    \ integer, found `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut has_close_elements\
    \ = false;\n    while i < numbers.len() && !has_close_elements {\n        j =\
    \ i + 1;\n        while j < numbers.len() && !has_close_elements {\n         \
    \   has_close_elements = numbers[i] - numbers[j] <= threshold;\n            j\
    \ += 1;\n        }\n        i += 1;\n    }\n    has_close_elements\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg1uqxa0h.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: Implement this function\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnpzs05nd.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() <= 1 {\n        return false;\n    }\n\n    for\
    \ i in 0..numbers.len() - 1 {\n        if (numbers[i] - numbers[i + 1]).abs()\
    \ < threshold {\n            return true;\n        }\n    }\n\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmxbmmiw9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut close_elements: bool = false;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            if j != i && (numbers[j]\
    \ - numbers[i]).abs() < threshold {\n                close_elements = true;\n\
    \            }\n        }\n    }\n    close_elements\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 1..numbers.len() {\n        if numbers[i] - numbers[i -\
    \ 1] < threshold {\n            return true;\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplj4s2zgw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n\
    \            if i != j && (numbers[i] - numbers[j]).abs() < threshold {\n    \
    \            return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut has_close_elements = false;\n    let mut closest_distance\
    \ = 999999999.0;\n    let mut closest_indices = (0, 0);\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        for m in numbers.iter().skip(i + 1) {\n            let distance =\
    \ (n - m).abs();\n            if distance < closest_distance {\n             \
    \   closest_distance = distance;\n                closest_indices = (i, i + 1\
    \ + m.index());\n            }\n        }\n    }\n    if closest_distance < threshold\
    \ {\n        has_close_elements = true;\n        println!(\n            \"Closest\
    \ elements {:?} with distance {:?}\",\n            closest_indices, closest_distance\n\
    \        );\n    }\n    has_close_elements\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for reference `&f64` in the\
    \ current scope\n  --> /tmp/tmpq3v1bb28.rs:16:49\n   |\n16 |                 closest_indices\
    \ = (i, i + 1 + m.index());\n   |                                            \
    \     ^^^^^ method not found in `&f64`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO implement function\n    true\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphcjxu3r0.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let sorted_list = sort_numbers(numbers);\n    for i in 0..sorted_list.len()\
    \ - 1 {\n        if (sorted_list[i + 1] - sorted_list[i]).abs() < threshold {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_numbers` in this scope\n --> /tmp/tmp2k70b0_i.rs:8:23\n\
    \  |\n8 |     let sorted_list = sort_numbers(numbers);\n  |                  \
    \     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    for\
    \ n in numbers.iter() {\n        let diff = n - threshold;\n        let diff_abs\
    \ = if diff < 0.0 { -diff } else { diff };\n        let numbers_next = &numbers[1..];\n\
    \        if numbers_next.contains(&diff_abs) {\n            return true;\n   \
    \     }\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo1_x_w6f.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // If a pair is found, it is pointless to continue.\n    let mut\
    \ has_close_elements = false;\n    for i in 0..numbers.len() {\n        for j\
    \ in i + 1..numbers.len() {\n            if numbers[i] < numbers[j] {\n      \
    \          if numbers[j] - numbers[i] < threshold {\n                    has_close_elements\
    \ = true;\n                    break;\n                }\n            } else {\n\
    \                if numbers[i] - numbers[j] < threshold {\n                  \
    \  has_close_elements = true;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    has_close_elements\n}\n\nfn main() {\n \
    \   let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 1..numbers.len() {\n        let previous = numbers[i -\
    \ 1];\n        let current = numbers[i];\n        if current - previous < threshold\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp72s5bwfl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    let len = numbers.len();\n    while i < len\
    \ {\n        let mut j = i + 1;\n        while j < len {\n            if numbers[i]\
    \ - numbers[j] > -threshold && numbers[i] - numbers[j] < threshold {\n       \
    \         return true;\n            }\n            j += 1;\n        }\n      \
    \  i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpe4i378li.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2r83ta49.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() < 2 {\n        return false;\n    }\n\n    let\
    \ mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    let pairs = numbers.windows(2);\n    for pair in pairs {\n        if pair[1]\
    \ - pair[0] < threshold {\n            return true;\n        }\n    }\n\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let length = numbers.len();\n    for i in 0..length {\n        for\
    \ j in i + 1..length {\n            if (numbers[i] - numbers[j]).abs() < threshold\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if numbers[i] - numbers[j] < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0djlgru4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut min_diff = f64::MAX;\n    for i in 0..numbers.len() {\n\
    \        for j in i+1..numbers.len() {\n            let dist = (numbers[i] - numbers[j]).abs();\n\
    \            if dist < min_diff {\n                min_diff = dist;\n        \
    \    }\n        }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut v: Vec<f64> = numbers;\n    v.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..v.len() - 1 {\n        if v[i + 1] - v[i] < threshold {\n   \
    \         return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    //fmt::print(\"{:?}\\n\", numbers_copy);\n\
    \    for i in 0..numbers_copy.len() - 1 {\n        if numbers_copy[i + 1] - numbers_copy[i]\
    \ < threshold {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n          \
    \      return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut closest_distance = std::f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            closest_distance =\n\
    \                std::cmp::min(closest_distance, (numbers[i] - numbers[j]).abs());\n\
    \        }\n    }\n    closest_distance < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpn6zw37qn.rs:12:17\n\
    \     |\n12   |                 std::cmp::min(closest_distance, (numbers[i] -\
    \ numbers[j]).abs());\n     |                 ^^^^^^^^^^^^^ the trait `Ord` is\
    \ not implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\nnote: required by a bound in `std::cmp::min`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for element in numbers.iter() {\n        for number in numbers.iter()\
    \ {\n            if (element - number).abs() < threshold {\n                return\
    \ true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5_xsf17j.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO implement this function\n    for i in 0..numbers.len() {\n\
    \        for j in i+1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs()\
    \ < threshold {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len()\
    \ {\n            if abs_diff(numbers[i], numbers[j]) < threshold {\n         \
    \       return true;\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs_diff` in this scope\n  --> /tmp/tmpltwso42i.rs:10:16\n\
    \   |\n10 |             if abs_diff(numbers[i], numbers[j]) < threshold {\n  \
    \ |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut pair_found = false;\n    for (index1, number1) in numbers.iter().enumerate()\
    \ {\n        for (index2, number2) in numbers.iter().enumerate() {\n         \
    \   if index1 != index2 {\n                let distance = (number1 - number2).abs();\n\
    \                if distance < threshold {\n                    pair_found = true;\n\
    \                }\n            }\n        }\n    }\n    pair_found\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    numbers\n        .windows(2)\n        .any(|pair| (pair[0] - pair[1]).abs()\
    \ < threshold)\n}\n\nfn main() {\n    let candidate = has_close_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    if numbers.len() == 0 {\n        return false;\n    }\n    let mut\
    \ sorted = numbers.clone();\n    sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..(sorted.len() - 1) {\n        if (sorted[i + 1] - sorted[i]).abs()\
    \ < threshold {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..numbers.len() - 1 {\n        if numbers[i + 1] - numbers[i] <\
    \ threshold {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    for (i, x) in numbers.iter().enumerate() {\n        for y in numbers.iter().skip(i\
    \ + 1) {\n            if (x - y).abs() < threshold {\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut buffer = numbers.clone();\n    buffer.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..buffer.len() - 1 {\n        if (buffer[i + 1] - buffer[i]).abs()\
    \ < threshold {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmc26i289.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut i = 0;\n    let mut j = 1;\n    while i < numbers.len()\
    \ {\n        while j < numbers.len() {\n            if numbers[i] - numbers[j]\
    \ < threshold {\n                return true;\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpouy12opx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut last_value = numbers[0];\n    for value in numbers {\n \
    \       if (value - last_value).abs() < threshold {\n            return true;\n\
    \        }\n        last_value = value;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiw_d1vmu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    let mut idx = 0;\n    let mut has_close_elements = false;\n    while\
    \ idx < numbers.len() - 1 && !has_close_elements {\n        has_close_elements\
    \ =\n            (numbers[idx] - numbers[idx + 1]).abs() < threshold ||\n    \
    \        (numbers[idx + 1] - numbers[idx]).abs() < threshold;\n        idx +=\
    \ 1;\n    }\n    has_close_elements\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy331h70t.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements([1.0, 2.0, 3.0],\
    \ 0.5)\n/// False\n/// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0],\
    \ 0.3)\n/// True\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) ->\
    \ bool {\n    // TODO: Implement me!\n    let mut max_idx = 0;\n    let mut min_idx\
    \ = 0;\n    let mut temp = threshold;\n    let mut check = 0;\n    for i in 0..numbers.len()\
    \ {\n        if numbers[i] > numbers[max_idx] {\n            max_idx = i;\n  \
    \      }\n        if numbers[i] < numbers[min_idx] {\n            min_idx = i;\n\
    \        }\n    }\n    if numbers[max_idx] - numbers[min_idx] <= threshold {\n\
    \        return true;\n    } else {\n        for i in 0..numbers.len() {\n   \
    \         for j in i+1..numbers.len() {\n                if (numbers[i] - numbers[j]).abs()\
    \ < temp {\n                    temp = (numbers[i] - numbers[j]).abs();\n    \
    \                check = 1;\n                }\n            }\n        }\n   \
    \     if check == 1 {\n            return true;\n        } else {\n          \
    \  return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
