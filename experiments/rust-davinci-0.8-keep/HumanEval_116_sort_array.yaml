name: HumanEval_116_sort_array
language: rust
prompt: "/// In this Kata, you have to sort an array of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1, 0, 2, 3, 4])\
  \ [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
  \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
  \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3,\
  \ 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
  \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4,\
  \ 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]),\
  \ vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
  \ vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2,\
  \ 4, 8, 16, 32]);\n}\n"
completions: ['    return arr.iter().map(|n| (n, n.count_ones())).sorted_by(|a, b|
    b.1.cmp(&a.1)).map(|t| t.0).collect();', "    arr.iter()\n        .map(|&x| (x.count_ones(),\
    \ x))\n        .sorted()\n        .map(|x| x.1)\n        .collect()", "    arr.into_iter()\n\
    \        .map(|x| (x, x.count_ones()))\n        .collect::<Vec<_>>()\n       \
    \ .sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n        .into_iter()\n \
    \       .map(|x| x.0)\n        .collect()", "    let mut base: Vec<(usize, isize)>\
    \ = arr.iter().map(|x| (x.count_ones(), *x)).collect();\n    base.sort();\n  \
    \  base.iter().map(|x| x.1).collect()", "    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        match count_ones(a).cmp(&count_ones(b)) {\n            std::cmp::Ordering::Equal\
    \ => a.cmp(b),\n            x => x,\n        }\n    });\n    res", "    arr.into_iter()\n\
    \        .map(|x| (-x.count_ones(), x))\n        .sorted()\n        .into_iter()\n\
    \        .map(|(_, x)| x)\n        .collect()", "    arr.into_iter()\n       \
    \ .sorted_by(|a, b| {\n            if a.count_ones() == b.count_ones() {\n   \
    \             a.cmp(b)\n            } else {\n                a.count_ones().cmp(&b.count_ones())\n\
    \            }\n        })\n        .collect()", "    arr.iter()\n        .map(|n|\
    \ {\n            (\n                std::char::from_digit(n.abs() as u32, 2).unwrap(),\n\
    \                n.abs(),\n            )\n        })\n        .collect::<Vec<(char,\
    \ isize)>>()\n        .sort_by(|a, b| {\n            if a.0.count_ones() == b.0.count_ones()\
    \ {\n                a.1.cmp(&b.1)\n            } else {\n                a.0.count_ones().cmp(&b.0.count_ones())\n\
    \            }\n        })\n        .iter()\n        .map(|(ch, n)| {\n      \
    \      if ch.is_alphabetic() {\n                return -(*n as isize);\n     \
    \       }\n            *n as isize\n        })\n        .collect()", "    let\
    \ mut res = vec![];\n    let mut sorted_ones: Vec<(usize, isize)> = arr\n    \
    \    .iter()\n        .map(|&e| {\n            let ones = e.abs().count_ones();\n\
    \            (ones, e)\n        })\n        .collect();\n    sorted_ones.sort_by(|&(o1,\
    \ _), &(o2, _)| o1.cmp(&o2));\n    for (_, v) in sorted_ones {\n        res.push(v);\n\
    \    }\n    res", "    let mut arr: Vec<isize> = arr;\n    arr.sort_by(|a, b|\
    \ {\n        // we sort all the non-negative integers according to number of ones\
    \ in their binary\n        // representation in ascending order.\n\n        if\
    \ a < &0 || b < &0 {\n            a.cmp(b)\n        } else {\n            let\
    \ zeros_a = a.count_zeros();\n            let zeros_b = b.count_zeros();\n   \
    \         if zeros_a != zeros_b {\n                zeros_a.cmp(&zeros_b)\n   \
    \         } else {\n                a.cmp(b)\n            }\n        }\n    });\n\
    \    arr", "    let mut res = arr.clone();\n    res.sort_by(|a, b| {\n       \
    \ let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n       \
    \ match a_ones.cmp(&b_ones) {\n            Ordering::Equal => a.cmp(b),\n    \
    \        o => o,\n        }\n    });\n    res", "    let mut pos = 0;\n    for\
    \ i in 0..arr.len() {\n        for j in 0..arr.len() - 1 {\n            if arr[j].count_ones()\
    \ > arr[j + 1].count_ones() {\n                pos = arr[j];\n               \
    \ arr[j] = arr[j + 1];\n                arr[j + 1] = pos;\n            } else\
    \ if arr[j].count_ones() == arr[j + 1].count_ones() {\n                if arr[j]\
    \ > arr[j + 1] {\n                    pos = arr[j];\n                    arr[j]\
    \ = arr[j + 1];\n                    arr[j + 1] = pos;\n                }\n  \
    \          }\n        }\n    }\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let num_of_ones_a = binary_ones(*a);\n        let num_of_ones_b\
    \ = binary_ones(*b);\n        num_of_ones_a.cmp(&num_of_ones_b).then(a.cmp(b))\n\
    \    });\n    arr", "    arr.into_iter()\n        .map(|x| ((count_ones(x.abs()),\
    \ x.abs()), x))\n        .sorted_by_key(|&((count, val), _)| (count, val))\n \
    \       .map(|((_, _), x)| x)\n        .collect()", "    let mut count_ones =\
    \ vec![0isize; arr.len()];\n    for i in 0..arr.len() {\n        count_ones[i]\
    \ = format!(\"{:b}\", arr[i]).chars().filter(|&x| x == '1').count() as isize;\n\
    \    }\n    arr.into_iter().zip(count_ones.into_iter()).sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0))).map(|x|\
    \ x.0).collect()", "    arr.iter()\n        .map(|&num| (num, num.count_ones()))\n\
    \        .sorted_by(|a, b| {\n            if a.1 < b.1 {\n                Ordering::Less\n\
    \            } else if a.1 > b.1 {\n                Ordering::Greater\n      \
    \      } else {\n                a.0.cmp(&b.0)\n            }\n        })\n  \
    \      .map(|&(num, _)| num)\n        .collect()", "    let mut arr = arr;\n \
    \   arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n        let b_ones\
    \ = b.count_ones();\n        match a_ones.cmp(&b_ones) {\n            Ordering::Equal\
    \ => a.cmp(b),\n            otherwise => otherwise,\n        }\n    });\n    arr",
  "    let mut n = arr.len();\n    let mut m = n;\n    let mut arr = arr;\n    while\
    \ m > 0 {\n        m = 0;\n        let mut j = 0;\n        for i in 1..n {\n \
    \           if let Some(f) = compare_binary(&arr[i - 1], &arr[i]) {\n        \
    \        arr.swap(i - 1, i);\n                m = j;\n            }\n        \
    \    j += 1;\n        }\n        n = m;\n    }\n    arr", "    let mut res = arr.to_vec();\n\
    \    res.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n        let b_ones\
    \ = b.count_ones();\n        if a_ones == b_ones {\n            a.cmp(b)\n   \
    \     } else {\n            a_ones.cmp(&b_ones)\n        }\n    });\n    res",
  "    arr.into_iter()\n        .map(|n| (n, count_ones(n)))\n        .collect::<Vec<_>>()\n\
    \        .sort_by(|a, b| {\n            if a.1 != b.1 {\n                a.1.cmp(&b.1)\n\
    \            } else {\n                a.0.cmp(&b.0)\n            }\n        })\n\
    \        .into_iter()\n        .map(|(n, _)| n)\n        .collect()", "    let\
    \ mut vec = arr.clone();\n    vec.sort_by(|a, b| {\n        let b1 = format!(\"\
    {:b}\", a).chars().filter(|&n| n == '1').count();\n        let b2 = format!(\"\
    {:b}\", b).chars().filter(|&n| n == '1').count();\n        if b1 == b2 {\n   \
    \         a.cmp(b)\n        } else {\n            b1.cmp(&b2)\n        }\n   \
    \ });\n    vec", "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| (a.1, a.0).cmp(&(b.1, b.0)))\n\
    \        .into_iter()\n        .map(|x| x.0)\n        .collect()", "    let mut\
    \ ones: Vec<(isize, isize)> = arr.iter().map(|x| (*x, count_ones(*x))).collect();\n\
    \    ones.sort_by(|a, b| match a.1.cmp(&b.1) {\n        Ordering::Equal => a.0.cmp(&b.0),\n\
    \        other => other,\n    });\n    ones.iter().map(|x| x.0).collect()", " \
    \   arr.into_iter()\n        .map(|n| (n, format!(\"{:b}\", n).chars().filter(|x|\
    \ *x == '1').count()))\n        .collect::<Vec<_>>()\n        .sort_by(|x, y|\
    \ x.1.cmp(&y.1).then(x.0.cmp(&y.0)))\n        .into_iter()\n        .map(|x| x.0)\n\
    \        .collect()", "    let mut v: Vec<_> = arr.into_iter().map(|i| (i, to_binary_string(i))).collect();\n\
    \    v.sort_by(|&(_, ref a), &(_, ref b)| {\n        let len_a = a.len();\n  \
    \      let len_b = b.len();\n        if len_a == len_b {\n            a.cmp(b)\n\
    \        } else {\n            len_a.cmp(&len_b)\n        }\n    });\n    v.into_iter().map(|(i,\
    \ _)| i).collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n     \
    \   let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n     \
    \   if ones_a == ones_b {\n            a.cmp(b)\n        } else {\n          \
    \  ones_a.cmp(&ones_b)\n        }\n    });\n    arr", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let a_binary = format!(\"{:b}\", a);\n    \
    \    let b_binary = format!(\"{:b}\", b);\n        a_binary.chars().filter(|&c|\
    \ c == '1').count().cmp(&b_binary.chars().filter(|&c| c == '1').count()).then(a.cmp(b))\n\
    \    });\n    arr", "    let mut m: HashMap<_, _> = arr.iter().map(|&x| (x, num_of_ones(x))).collect();\n\
    \    arr.iter().map(|&x| *m.get(&x).unwrap()).collect::<Vec<_>>();\n    arr.sort_by(|&a,\
    \ &b| {\n        let (a_ones, b_ones) = (*m.get(&a).unwrap(), *m.get(&b).unwrap());\n\
    \        if a_ones == b_ones {\n            a.cmp(&b)\n        } else {\n    \
    \        a_ones.cmp(&b_ones)\n        }\n    });\n    arr", "    arr.into_iter()\n\
    \        .map(|n| (n, n.count_ones()))\n        .collect::<Vec<_>>()\n       \
    \ .sort_by(|(_, a1), (_, a2)| match a1.cmp(a2) {\n            Ordering::Equal\
    \ => a1.cmp(a2),\n            ord => ord,\n        })\n        .into_iter()\n\
    \        .map(|(num, _)| num)\n        .collect()", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let ones = format!(\"{:b}\", a).matches('1').count();\n\
    \        let twos = format!(\"{:b}\", b).matches('1').count();\n        if ones\
    \ == twos {\n            a.cmp(b)\n        } else {\n            ones.cmp(&twos)\n\
    \        }\n    });\n    arr", "    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        let a_ones = format!(\"{:b}\", a)\n            .chars()\n    \
    \        .filter(|&x| x == '1')\n            .count();\n        let b_ones = format!(\"\
    {:b}\", b)\n            .chars()\n            .filter(|&x| x == '1')\n       \
    \     .count();\n        if a_ones == b_ones {\n            a.cmp(b)\n       \
    \ } else {\n            a_ones.cmp(&b_ones)\n        }\n    });\n    res", " \
    \   let mut ones: Vec<(isize, usize)> = arr.iter().map(|n| (n, count_ones(*n))).collect();\n\
    \    ones.sort_by(|a, b| a.1.cmp(&b.1));\n    ones.iter().map(|n| n.0).collect()",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n        }\n\
    \    });\n    arr", "    let mut ones_and_zeros: Vec<(isize, Vec<bool>)> = arr\n\
    \        .iter()\n        .map(|num| (num.clone(), num.to_string(2).chars().map(|c|\
    \ c == '1').collect()))\n        .collect();\n    ones_and_zeros.sort_by(|a, b|\
    \ {\n        let ones_a = a.1.iter().filter(|b| **b).count();\n        let ones_b\
    \ = b.1.iter().filter(|b| **b).count();\n        if ones_a < ones_b {\n      \
    \      return std::cmp::Ordering::Less;\n        } else if ones_a > ones_b {\n\
    \            return std::cmp::Ordering::Greater;\n        }\n        let a_dec\
    \ = format!(\"{:?}\", a.1).replace(\"true\", \"1\").replace(\"false\", \"0\");\n\
    \        let b_dec = format!(\"{:?}\", b.1).replace(\"true\", \"1\").replace(\"\
    false\", \"0\");\n        a_dec.cmp(&b_dec)\n    });\n    ones_and_zeros.iter().map(|a|\
    \ a.0).collect()", "    arr.into_iter()\n        .map(|n| n.abs())\n        .map(|n|\
    \ n as u64)\n        .map(|n| (n, n.count_ones()))\n        .collect::<Vec<(u64,\
    \ u32)>>()\n        .sort_by(|a, b| {\n            if a.1 == b.1 {\n         \
    \       a.0.cmp(&b.0)\n            } else {\n                a.1.cmp(&b.1)\n \
    \           }\n        })\n        .into_iter()\n        .map(|(n, _)| n as isize)\n\
    \        .collect()", "    let mut x = arr.clone();\n    x.sort_by(|a, b| {\n\
    \        let c = a.count_ones().cmp(&b.count_ones());\n        if c == std::cmp::Ordering::Equal\
    \ {\n            b.cmp(a)\n        } else {\n            c\n        }\n    });\n\
    \    x", "    fn one_count(n: usize) -> usize {\n        let mut count = 0;\n\
    \        let mut x = n;\n        while x > 0 {\n            count += x & 1;\n\
    \            x >>= 1;\n        }\n        count\n    }\n    arr.into_iter().map(|n|\
    \ (one_count(n as usize), n)).sorted_by(|a, b| {\n        let cmp = a.0.cmp(&b.0);\n\
    \        if cmp == std::cmp::Ordering::Equal {\n            a.1.cmp(&b.1)\n  \
    \      } else {\n            cmp\n        }\n    }).map(|(_, n)| n).collect()",
  "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n        .sorted_by(|a,\
    \ b| {\n            let (i, a1) = a;\n            let (j, b1) = b;\n         \
    \   a1.cmp(&b1).then(i.cmp(&j))\n        })\n        .map(|(x, _)| x)\n      \
    \  .collect()", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a, b|\
    \ {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n\
    \        ones_a.cmp(&ones_b).then(a.cmp(b))\n    });\n    sorted", "    // your\
    \ code here\n    let mut vec: Vec<(isize, usize)> = arr.iter().map(|x| (x.clone(),\
    \ bits(*x))).collect();\n    vec.sort_by(|a, b| {\n        if a.1 == b.1 {\n \
    \           a.0.cmp(&b.0)\n        } else {\n            a.1.cmp(&b.1)\n     \
    \   }\n    });\n    vec.iter().map(|x| x.0).collect()", "    let mut sorted =\
    \ arr.clone();\n    sorted.sort_by(|a, b| {\n        let a = format!(\"{:b}\"\
    , a);\n        let b = format!(\"{:b}\", b);\n        if a.matches('1').count()\
    \ == b.matches('1').count() {\n            a.parse::<isize>().unwrap().cmp(&b.parse::<isize>().unwrap())\n\
    \        } else {\n            a.matches('1').count().cmp(&b.matches('1').count())\n\
    \        }\n    });\n    sorted", "    let mut sorted_arr = arr.clone();\n   \
    \ sorted_arr.sort_by(|a, b| (a.count_ones(), a).cmp(&(b.count_ones(), b)));\n\
    \    sorted_arr", "    let mut arr = arr;\n    let mut one_count = 0;\n    for\
    \ i in 0..arr.len() {\n        one_count = num_ones(arr[i]);\n        for j in\
    \ i..arr.len() {\n            if num_ones(arr[j]) < one_count || (num_ones(arr[j])\
    \ == one_count && arr[j] < arr[i]) {\n                let temp = arr[i];\n   \
    \             arr[i] = arr[j];\n                arr[j] = temp;\n            }\n\
    \        }\n    }\n    arr", "    let mut tmp = arr.clone();\n    tmp.sort_by(|a,\
    \ b| (a.count_ones(), *a).cmp(&(b.count_ones(), *b)));\n    tmp", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let x = count_ones(*a);\n    \
    \    let y = count_ones(*b);\n        if x == y {\n            a.cmp(b)\n    \
    \    } else {\n            x.cmp(&y)\n        }\n    });\n    arr", "    let mut\
    \ array: Vec<(usize, isize)> = arr.iter().map(|&x| (x.count_ones(), x)).collect();\n\
    \    array.sort();\n    array.iter().map(|&(_, x)| x).collect()", "    let mut\
    \ z: Vec<_> = arr.iter().map(|x| (x, format!(\"{:b}\", x))).collect();\n    z.sort_by(|a,\
    \ b| match a.1.len().cmp(&b.1.len()) {\n        std::cmp::Ordering::Equal => {\n\
    \            match a.0.cmp(b.0) {\n                std::cmp::Ordering::Equal =>\
    \ std::cmp::Ordering::Equal,\n                std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,\n\
    \                std::cmp::Ordering::Less => std::cmp::Ordering::Less,\n     \
    \       }\n        }\n        std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,\n\
    \        std::cmp::Ordering::Less => std::cmp::Ordering::Less,\n    });\n    z.iter().map(|x|\
    \ *x.0).collect()", "    let mut arr: Vec<isize> = arr;\n    arr.sort_by(|x, y|\
    \ {\n        let x_ones = x.count_ones();\n        let y_ones = y.count_ones();\n\
    \        x_ones.cmp(&y_ones).then(x.cmp(y))\n    });\n    arr", "    // sort by\
    \ number of 1's in binary representation\n    // and then sort by value\n    let\
    \ mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n        binary_ones(*a).cmp(&binary_ones(*b))\n\
    \            .then(a.cmp(b))\n    });\n    sorted", "    let mut arr: Vec<_> =\
    \ arr.into_iter().map(|n| (n, count_ones(n))).collect();\n    arr.sort_by(|(n1,\
    \ ones1), (n2, ones2)| ones1.cmp(ones2).then(n1.cmp(n2)));\n    arr.into_iter().map(|(n,\
    \ _)| n).collect()", "    if arr.is_empty() {\n        return vec![];\n    }\n\
    \    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n\
    \    });\n    arr", "    let bit_n = |i: isize| -> usize {\n        i.count_ones()\
    \ as usize\n    };\n    arr.iter().enumerate().sorted_by(|&(i, a), &(j, b)| {\n\
    \        let ba = bit_n(*a);\n        let bb = bit_n(*b);\n        match ba.cmp(&bb)\
    \ {\n            Ordering::Equal => i.cmp(&j),\n            c => c,\n        }\n\
    \    }).map(|(_, c)| *c).collect()", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let bin_a = format!(\"{:b}\", a);\n        let bin_b = format!(\"\
    {:b}\", b);\n        if bin_a.matches('1').count() != bin_b.matches('1').count()\
    \ {\n            bin_a.matches('1').count().cmp(&bin_b.matches('1').count())\n\
    \        } else {\n            a.cmp(&b)\n        }\n    });\n    arr", "    let\
    \ mut nums = arr.clone();\n    nums.sort_by(|a, b| {\n        let a_ones = count_ones(a);\n\
    \        let b_ones = count_ones(b);\n        let ord = a_ones.cmp(&b_ones);\n\
    \        match ord {\n            Ord::Equal => a.cmp(&b),\n            _ => ord,\n\
    \        }\n    });\n    nums", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ count_ones(*a).cmp(&count_ones(*b)));\n    arr", "    let mut vec = arr.clone();\n\
    \    vec.sort_by(|a, b| {\n        let len_a = a.to_string().len();\n        let\
    \ len_b = b.to_string().len();\n        if len_a == len_b {\n            a.cmp(b)\n\
    \        } else {\n            len_a.cmp(&len_b)\n        }\n    });\n    vec",
  "    arr.iter()\n        .map(|x| format!(\"{:b}\", x))\n        .map(|x| (x.matches('1').count(),\
    \ x.parse::<isize>().unwrap()))\n        .collect::<Vec<(usize, isize)>>()\n \
    \       .sort_by(|&a, &b| {\n            let a = a.0.cmp(&b.0);\n            if\
    \ a == Ordering::Equal {\n                return a.then(a.1.cmp(&b.1));\n    \
    \        }\n            a\n        })\n        .iter()\n        .map(|x| x.1)\n\
    \        .collect()", "    use std::cmp::Ordering;\n    arr.into_iter()\n    \
    \    .map(|n| (n, format!(\"{:b}\", n)))\n        .sorted_by(|(_, a), (_, b)|\
    \ {\n            a.chars()\n                .filter(|c| *c == '1')\n         \
    \       .count()\n                .cmp(&b.chars().filter(|c| *c == '1').count())\n\
    \        })\n        .sorted_by(|(a, _), (b, _)| match a.cmp(b) {\n          \
    \  Ordering::Equal => Ordering::Equal,\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        })\n        .map(|(n,\
    \ _)| n)\n        .collect()", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        bin_ones(*a).cmp(&bin_ones(*b))\n            .then(a.cmp(b))\n\
    \    });\n    sorted", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        let a_ones = format!(\"{:b}\", a)\n            .chars()\n    \
    \        .filter(|c| *c == '1')\n            .count();\n        let b_ones = format!(\"\
    {:b}\", b)\n            .chars()\n            .filter(|c| *c == '1')\n       \
    \     .count();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n    });\n    sorted",
  "    fn bitcount(n: isize) -> usize {\n        let mut r = 0;\n        let mut n\
    \ = n;\n        while n > 0 {\n            if n & 1 != 0 {\n                r\
    \ += 1;\n            }\n            n >>= 1;\n        }\n        r\n    }\n  \
    \  let mut v = arr.clone();\n    v.sort_by(|a, b| {\n        let s = bitcount(*a)\
    \ - bitcount(*b);\n        if s != 0 {\n            s\n        } else {\n    \
    \        a.cmp(b)\n        }\n    });\n    v", "    let mut res = arr.clone();\n\
    \    res.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n        let b_ones\
    \ = b.count_ones();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n    });\n   \
    \ res", "    let mut arr = arr;\n    arr.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()).then(a.cmp(b)));\n\
    \    arr", "    // Find the number of ones in the binary representation of each\
    \ element of\n    // the array. Create a map associating this number with the\
    \ original value.\n    let mut ones_count: HashMap<isize, isize> = HashMap::new();\n\
    \    for value in arr.iter() {\n        let mut ones = 0;\n        let mut num\
    \ = *value;\n        while num > 0 {\n            ones += (num & 1) as isize;\n\
    \            num >>= 1;\n        }\n        ones_count.insert(*value, ones);\n\
    \    }\n\n    // Sort the array in reverse order according to the number of ones,\
    \ then\n    // according to the original value.\n    let mut sorted = arr.clone();\n\
    \    sorted.sort_by(|a, b| {\n        let ones_a = ones_count.get(a).unwrap();\n\
    \        let ones_b = ones_count.get(b).unwrap();\n        match ones_a.cmp(ones_b)\
    \ {\n            Ordering::Equal => a.cmp(b),\n            _ => ones_a.cmp(ones_b),\n\
    \        }\n    });\n    sorted", "    let mut v: Vec<(usize, isize)> = arr.iter().map(|&x|\
    \ (to_bin(x), x)).collect();\n    v.sort_by(|a, b| (a.0).cmp(&b.0));\n    v.iter().map(|&x|\
    \ x.1).collect()", "    let mut arr: Vec<_> = arr.into_iter().map(|x| (x, (x as\
    \ usize).count_ones())).collect();\n    arr.sort_by(|a, b| {\n        if a.1 ==\
    \ b.1 {\n            a.0.cmp(&b.0)\n        } else {\n            a.1.cmp(&b.1)\n\
    \        }\n    });\n    arr.into_iter().map(|(x, _)| x).collect()", "    let\
    \ mut arr_with_ones: Vec<_> = arr\n        .iter()\n        .map(|x| (*x, x.count_ones()))\n\
    \        .collect();\n    arr_with_ones.sort_by(|a, b| match a.1.cmp(&b.1) {\n\
    \        Ordering::Equal => a.0.cmp(&b.0),\n        x => x,\n    });\n    arr_with_ones.iter().map(|x|\
    \ x.0).collect()", "    let mut arr: Vec<(usize, isize)> = arr.into_iter().map(|i|\
    \ {\n        let ones = i.to_string().chars().filter(|c| *c == '1').count();\n\
    \        (ones, i)\n    }).collect();\n    arr.sort_by(|a, b| {\n        let ones\
    \ = a.0.cmp(&b.0);\n        if ones == std::cmp::Ordering::Equal {\n         \
    \   a.1.cmp(&b.1)\n        } else {\n            ones\n        }\n    });\n  \
    \  arr.into_iter().map(|(_, i)| i).collect()", "    let mut bin_arr: Vec<(String,\
    \ isize)> = arr.iter().map(|x| (format!(\"{:b}\", x), *x)).collect();\n    bin_arr.sort_by(|x,\
    \ y| x.0.chars().filter(|c| *c == '1').count().cmp(&y.0.chars().filter(|c| *c\
    \ == '1').count()));\n    bin_arr.sort_by(|x, y| x.1.cmp(&y.1));\n    bin_arr.iter().map(|x|\
    \ x.1).collect()", "    let mut arr_ones = arr.clone();\n    arr_ones.sort_by(|a,\
    \ b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n\
    \        ones_a.cmp(&ones_b).then(a.cmp(b))\n    });\n    arr_ones", "    use\
    \ std::collections::HashMap;\n    use std::cmp::Ordering;\n\n    let mut ones_map:\
    \ HashMap<isize, usize> = HashMap::new();\n    for num in arr.clone() {\n    \
    \    let mut x = num;\n        let mut count = 0;\n        while x > 0 {\n   \
    \         if x % 2 == 1 {\n                count += 1;\n            }\n      \
    \      x /= 2;\n        }\n        ones_map.insert(num, count);\n    }\n\n   \
    \ let mut sorted_vec: Vec<isize> = arr.clone();\n    sorted_vec.sort_by(|a, b|\
    \ {\n        let ones_a = ones_map.get(a).unwrap();\n        let ones_b = ones_map.get(b).unwrap();\n\
    \        match ones_a.cmp(ones_b) {\n            Ordering::Equal => a.cmp(b),\n\
    \            x => x,\n        }\n    });\n    sorted_vec", "    let binary = arr.iter().map(|x|\
    \ x.to_string(2));\n    let ones = binary.map(|x| x.chars().filter(|y| *y == '1').count());\n\
    \    let sort = (arr, ones)\n        .into_iter()\n        .sorted_by(|x, y| x.1.cmp(&y.1).then(x.0.cmp(&y.0)));\n\
    \    sort.into_iter().map(|x| x.0).collect()", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        num_ones(*a).cmp(&num_ones(*b))\n            .then(a.cmp(b))\n\
    \    });\n    arr", "    use std::cmp::Ordering;\n    arr.iter()\n        .map(|x|\
    \ {\n            let mut ones = 0;\n            let mut c = *x;\n            while\
    \ c > 0 {\n                ones += c & 1;\n                c >>= 1;\n        \
    \    }\n            (ones, *x)\n        })\n        .collect::<Vec<(isize, isize)>>()\n\
    \        .sort_by(|a, b| match a.0.cmp(&b.0) {\n            Ordering::Equal =>\
    \ a.1.cmp(&b.1),\n            res => res,\n        })\n        .iter()\n     \
    \   .map(|x| x.1)\n        .collect()", "    arr.into_iter()\n        .map(|n|\
    \ (n, format!(\"{:b}\", n).chars().filter(|&x| x == '1').count()))\n        .collect::<Vec<_>>()\n\
    \        .sort_by(|a, b| {\n            let (n1, c1) = a;\n            let (n2,\
    \ c2) = b;\n            match c1.cmp(&c2) {\n                Ordering::Equal =>\
    \ n1.cmp(&n2),\n                o => o,\n            }\n        })\n        .into_iter()\n\
    \        .map(|(n, _)| n)\n        .collect()", "    fn count_ones(i: isize) ->\
    \ usize {\n        i.count_ones() as usize\n    }\n\n    fn index_ones(i: isize)\
    \ -> usize {\n        i.index_ones() as usize\n    }\n\n    fn to_array(i: isize)\
    \ -> [u8; 64] {\n        i.to_le_bytes()\n    }\n\n    arr.iter()\n        .map(|&i|\
    \ (i, count_ones(i), index_ones(i), to_array(i)))\n        .sorted_by(|&(_, n,\
    \ i, l), &(_, m, j, r)| match n.cmp(&m) {\n            Ordering::Equal => match\
    \ l[i].cmp(&r[j]) {\n                Ordering::Equal => j.cmp(&i),\n         \
    \       c => c,\n            },\n            c => c,\n        })\n        .map(|(i,\
    \ _, _, _)| i)\n        .collect()", "    let mut mut_arr = arr.clone();\n   \
    \ let mut ones_vec: Vec<(usize, isize)> = vec![];\n    let mut final_vec: Vec<isize>\
    \ = vec![];\n\n    for num in arr {\n        ones_vec.push((num.count_ones(),\
    \ num));\n    }\n\n    ones_vec.sort();\n\n    for num in ones_vec {\n       \
    \ final_vec.push(num.1);\n    }\n\n    final_vec", "    // Your code goes here\n\
    \    let mut neg: Vec<isize> = Vec::new();\n    let mut pos: Vec<isize> = Vec::new();\n\
    \    for n in arr {\n        if n < 0 {\n            neg.push(n);\n        } else\
    \ {\n            pos.push(n);\n        }\n    }\n    neg.sort();\n    neg.reverse();\n\
    \    pos.sort();\n    let mut ans: Vec<isize> = Vec::new();\n    ans.append(&mut\
    \ neg);\n    ans.append(&mut pos);\n    ans", "    let mut v = arr.clone();\n\
    \    v.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()));\n    v", "    let\
    \ mut arr = arr;\n    arr.sort_by(|x, y| x.count_ones().cmp(&y.count_ones()).then(x.cmp(y)));\n\
    \    arr", "    arr.into_iter()\n        .map(|n| (n, n.count_ones()))\n     \
    \   .collect::<Vec<_>>()\n        .sort_by(|x, y| (x.1, x.0).cmp(&(y.1, y.0)));\n\
    \    arr", "    let mut counts = HashMap::new();\n    let mut arr_copy = arr.clone();\n\
    \    arr_copy.sort();\n    arr_copy.iter().for_each(|i| {\n        let c = i.count_ones();\n\
    \        if counts.contains_key(&c) {\n            let mut v = counts.get_mut(&c).unwrap();\n\
    \            v.push(*i);\n        } else {\n            counts.insert(c, vec![*i]);\n\
    \        }\n    });\n    let mut keys: Vec<_> = counts.keys().collect();\n   \
    \ keys.sort();\n    let mut result = vec![];\n    keys.iter().for_each(|k| {\n\
    \        let mut v = counts.get(k).unwrap();\n        v.sort();\n        result.append(v);\n\
    \    });\n    result", "    let mut one_counts: Vec<_> = arr.iter().map(|num|\
    \ {\n        num.abs()\n            .to_string(2)\n            .chars()\n    \
    \        .map(|c| c.to_digit(10).unwrap())\n            .sum::<u32>()\n    }).collect();\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n    \
    \    let a_ones = one_counts[*a as usize];\n        let b_ones = one_counts[*b\
    \ as usize];\n        if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    sorted_arr",
  "    let mut a: Vec<isize> = arr.iter().map(|x| x.clone()).collect();\n    a.sort_by(|x,\
    \ y| x.count_ones().cmp(&y.count_ones()));\n    a", "    let mut list = arr.clone();\n\
    \    list.sort_by(|a, b| count_one(a) - count_one(b));\n    list", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        match a_ones.cmp(&b_ones) {\n \
    \           Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        format!(\"\
    {:b}\", a).chars().count().cmp(&format!(\"{:b}\", b).chars().count())\n      \
    \      .then(a.cmp(b))\n    });\n    arr", "    arr.into_iter()\n        .map(|x|\
    \ {\n            let x = x.abs();\n            (x, x.count_ones())\n        })\n\
    \        .sorted_by(|&(x1, c1), &(x2, c2)| {\n            if c1 != c2 {\n    \
    \            c1.cmp(&c2)\n            } else {\n                x1.cmp(&x2)\n\
    \            }\n        })\n        .map(|(x, _)| x)\n        .collect()", " \
    \   let mut unique = HashMap::new();\n    for v in arr.iter() {\n        let mut\
    \ ones = 0;\n        let mut vv = *v;\n        while vv > 0 {\n            if\
    \ vv % 2 != 0 {\n                ones += 1;\n            }\n            vv /=\
    \ 2;\n        }\n        let vec = unique.entry(ones).or_insert(Vec::new());\n\
    \        vec.push(*v);\n    }\n    let mut res = Vec::new();\n    let mut ones\
    \ = 0;\n    while res.len() < arr.len() {\n        if let Some(vec) = unique.get(&ones)\
    \ {\n            for v in vec.iter() {\n                res.push(*v);\n      \
    \      }\n        }\n        ones += 1;\n    }\n    res", "    let mut v = arr.clone();\n\
    \    v.sort_by(|a, b| format!(\"{:b}\", a).len().cmp(&format!(\"{:b}\", b).len()));\n\
    \    v", "    let mut unsorted: Vec<(usize, isize)> = arr.iter().map(|&x| (ones(x),\
    \ x)).collect();\n    unsorted.sort_by(|&a, &b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)));\n\
    \    unsorted.iter().map(|&(_, x)| x).collect()", "    let mut arr: Vec<(usize,\
    \ isize)> = arr.into_iter().map(|x| (x.count_ones(), x)).collect();\n    arr.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    arr.into_iter().map(|(_, x)|\
    \ x).collect()", "    let mut map = arr.iter().map(|x| (x, format!(\"{:b}\", x).chars().filter(|&x|\
    \ x == '1').count())).collect::<Vec<(&isize, usize)>>();\n    map.sort_by(|&(_,\
    \ ref a), &(_, ref b)| a.cmp(b));\n    map.iter().map(|&(a, _)| *a).collect()",
  "    let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n        let a_ones\
    \ = count_ones(*a);\n        let b_ones = count_ones(*b);\n        if a_ones ==\
    \ b_ones {\n            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    sorted", "    let mut result = vec![];\n    let mut v\
    \ = vec![];\n    for i in arr {\n        let bits = i.abs().count_ones();\n  \
    \      if v.len() < bits as usize + 1 {\n            v.push(vec![]);\n       \
    \ }\n        v[bits as usize].push(i);\n    }\n    for i in 0..v.len() {\n   \
    \     v[i].sort();\n        result.append(&mut v[i]);\n    }\n    result", " \
    \   let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_count = a.count_ones();\n\
    \        let b_count = b.count_ones();\n        a_count.cmp(&b_count).then(a.cmp(b))\n\
    \    });\n    arr", "    fn num_of_ones(n: isize) -> usize {\n        n.count_ones()\
    \ as usize\n    }\n\n    arr.into_iter()\n        .map(|n| (n, num_of_ones(n)))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|&(x, y), &(x1, y1)| match y.cmp(&y1)\
    \ {\n            Ordering::Equal => x.cmp(&x1),\n            Ordering::Less =>\
    \ Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n     \
    \   })\n        .into_iter()\n        .map(|(n, _)| n)\n        .collect()", " \
    \   use std::collections::BinaryHeap;\n    use std::cmp::Reverse;\n\n    // sort\
    \ by number of ones, then by decimal value\n    let mut heap = BinaryHeap::new();\n\
    \    for n in arr {\n        let mut n = n;\n        let mut ones = 0;\n     \
    \   while n > 0 {\n            if n % 2 == 1 {\n                ones += 1;\n \
    \           }\n            n /= 2;\n        }\n        heap.push(Reverse((ones,\
    \ n)));\n    }\n\n    let mut result = Vec::new();\n    while let Some(Reverse((_,\
    \ n))) = heap.pop() {\n        result.push(n);\n    }\n    result", "    let mut\
    \ v = arr.iter().enumerate().map(|(i, x)| (i, x)).collect::<Vec<_>>();\n    v.sort_by(|x,\
    \ y| {\n        let xbits = x.1.count_ones();\n        let ybits = y.1.count_ones();\n\
    \        match xbits.cmp(&ybits) {\n            Ordering::Equal => x.0.cmp(&y.0),\n\
    \            r => r,\n        }\n    });\n    v.iter().map(|(_, &x)| x).collect()",
  "    let mut ret = arr.clone();\n    ret.sort_by(|a, b| (count_ones(*a), *a).cmp(&(count_ones(*b),\
    \ *b)));\n    ret", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        match a.count_ones().cmp(&b.count_ones()) {\n            Ordering::Equal\
    \ => a.cmp(b),\n            x => x,\n        }\n    });\n    sorted", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        get_ones(*a).cmp(&get_ones(*b))\n\
    \            .then(a.cmp(b))\n    });\n    arr", "    arr.iter()\n        .map(|a|\
    \ (*a, a.count_ones()))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b|\
    \ {\n            if a.1 == b.1 {\n                a.0.cmp(&b.0)\n            }\
    \ else {\n                a.1.cmp(&b.1)\n            }\n        })\n        .into_iter()\n\
    \        .map(|a| a.0)\n        .collect()", "    let mut one_count: Vec<(usize,\
    \ isize)> = arr.iter().map(|x| (x.count_ones(), *x)).collect();\n    one_count.sort();\n\
    \    one_count.iter().map(|(_, y)| *y).collect()", "    if arr.len() < 2 {\n \
    \       return arr;\n    }\n    let n = arr.len();\n    let mut tmp = arr.clone();\n\
    \    tmp.sort_by(|a, b| {\n        let count_a = count_ones(*a);\n        let\
    \ count_b = count_ones(*b);\n        if count_a == count_b {\n            a.cmp(b)\n\
    \        } else {\n            count_a.cmp(&count_b)\n        }\n    });\n   \
    \ let mut res = vec![0; n];\n    res[..n].clone_from_slice(&tmp[..n]);\n    res",
  "    let mut arr = arr;\n    arr.sort_by(|x, y| {\n        let x_count = x.count_ones();\n\
    \        let y_count = y.count_ones();\n        match x_count.cmp(&y_count) {\n\
    \            Ordering::Equal => x.cmp(y),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ arr", "    let mut ones: Vec<usize> = arr.iter().map(|x| x.count_ones()).collect();\n\
    \    let mut neg: Vec<isize> = arr.iter().map(|x| *x).collect();\n    ones.sort();\n\
    \    ones.dedup();\n    let mut new: Vec<isize> = Vec::new();\n    for i in ones\
    \ {\n        for j in &neg {\n            if i == j.count_ones() {\n         \
    \       new.push(*j);\n            }\n        }\n    }\n    new", "    let mut\
    \ v = arr.clone();\n    v.sort_by(|a, b| {\n        if a.count_ones() == b.count_ones()\
    \ {\n            a.cmp(b)\n        } else {\n            a.count_ones().cmp(&b.count_ones())\n\
    \        }\n    });\n    v", "    let mut vec = arr.clone();\n    vec.sort_by(|a,\
    \ b| {\n        let a = a.abs();\n        let b = b.abs();\n        let ones =\
    \ |x: isize| {\n            let mut count = 0;\n            let mut temp = x;\n\
    \            while temp > 0 {\n                if temp % 2 == 1 {\n          \
    \          count += 1;\n                }\n                temp /= 2;\n      \
    \      }\n            count\n        };\n        let ones_a = ones(a);\n     \
    \   let ones_b = ones(b);\n        if ones_a == ones_b {\n            a.cmp(&b)\n\
    \        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    vec",
  "    arr.into_iter()\n        .map(|x| (x, format!(\"{:b}\", x).chars().filter(|c|\
    \ *c == '1').count()))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b|\
    \ (a.1, b.0).cmp(&(b.1, a.0)))\n        .into_iter()\n        .map(|x| x.0)\n\
    \        .collect()", "    let l: Vec<(usize, isize)> = arr.iter().map(|x| {\n\
    \        let mut num = *x;\n        let mut ones = 0;\n        while num > 0 {\n\
    \            ones += num & 1;\n            num >>= 1;\n        }\n        (ones,\
    \ *x)\n    }).collect();\n    l.iter().sorted_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    }).map(|x| x.1).collect()", "    let mut v: Vec<(usize, isize)>\
    \ = arr.iter().map(|&x| (count_ones(x), x)).collect();\n    v.sort();\n    v.iter().map(|(_,\
    \ x)| *x).collect()", "    let mut res = arr;\n    res.sort_by(|a, b| {\n    \
    \    let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n    \
    \    if ones_a == ones_b {\n            a.cmp(b)\n        } else {\n         \
    \   ones_a.cmp(&ones_b)\n        }\n    });\n    res", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n        let b_ones\
    \ = b.count_ones();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n    });\n   \
    \ arr", "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n        .collect::<Vec<_>>()\n\
    \        .sort_by(|(x1, count1), (x2, count2)| {\n            if count1 == count2\
    \ {\n                Ord::cmp(x1, x2)\n            } else {\n                Ord::cmp(count1,\
    \ count2)\n            }\n        })\n        .into_iter()\n        .map(|(x,\
    \ _)| x)\n        .collect()", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        let a_digits = a.to_string()\n            .chars()\n         \
    \   .filter(|ch| *ch == '1')\n            .count();\n        let b_digits = b.to_string()\n\
    \            .chars()\n            .filter(|ch| *ch == '1')\n            .count();\n\
    \        a_digits.cmp(&b_digits).then(a.cmp(b))\n    });\n    sorted", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_num_ones = a.count_ones();\n\
    \        let b_num_ones = b.count_ones();\n        if a_num_ones == b_num_ones\
    \ {\n            a.cmp(b)\n        } else {\n            a_num_ones.cmp(&b_num_ones)\n\
    \        }\n    });\n    arr", "    let mut v: Vec<(usize, isize)> = arr.iter().map(|n|\
    \ (n.count_ones(), *n)).collect();\n    v.sort();\n    v.iter().map(|v| v.1).collect()",
  "    let mut arr: Vec<isize> = arr;\n    arr.sort_by(|a, b| {\n        if a.count_ones()\
    \ != b.count_ones() {\n            return a.count_ones().cmp(&b.count_ones());\n\
    \        }\n        a.cmp(b)\n    });\n    arr", "    fn num_ones(n: isize) ->\
    \ usize {\n        format!(\"{:b}\", n).matches('1').count()\n    }\n\n    arr.into_iter().map(|n|\
    \ (num_ones(n), n)).sorted().into_iter().map(|(_, n)| n).collect()", "    let\
    \ mut ones: Vec<(usize, isize)> = vec![];\n    let mut zeros: Vec<isize> = vec![];\n\
    \    let mut base = 1;\n    while base < arr.len() {\n        base *= 2;\n   \
    \ }\n    base /= 2;\n    while base > 0 {\n        let mut head = base;\n    \
    \    while head < arr.len() {\n            let mut r = 0;\n            let mut\
    \ i = head;\n            while i > 0 && i % 2 == 1 {\n                r += 1;\n\
    \                i /= 2;\n            }\n            if r > 0 {\n            \
    \    ones.push((r, arr[head]));\n            } else {\n                zeros.push(arr[head]);\n\
    \            }\n            head += 1;\n        }\n        ones.sort_by(|a, b|\
    \ {\n            if a.0 == b.0 {\n                a.1.cmp(&b.1)\n            }\
    \ else {\n                a.0.cmp(&b.0)\n            }\n        });\n        ones.iter().for_each(|x|\
    \ {\n            arr[x.0] = x.1;\n        });\n        let mut i = 0;\n      \
    \  for x in zeros.iter() {\n            arr[ones.len() + i] = *x;\n          \
    \  i += 1;\n        }\n        base /= 2;\n        ones.clear();\n        zeros.clear();\n\
    \    }\n    arr", "    arr.iter()\n        .cloned()\n        .sorted_by(|a, b|\
    \ {\n            if a.count_ones() == b.count_ones() {\n                a.cmp(b)\n\
    \            } else {\n                a.count_ones().cmp(&b.count_ones())\n \
    \           }\n        })\n        .collect()", "    if arr.is_empty() {\n   \
    \     return arr;\n    }\n    let mut ones = Vec::new();\n    let mut zeros =\
    \ Vec::new();\n    for n in arr {\n        let mut cnt = 0;\n        let mut m\
    \ = n;\n        while m > 0 {\n            cnt += m % 2;\n            m /= 2;\n\
    \        }\n        if cnt == 0 {\n            zeros.push(n);\n        } else\
    \ {\n            ones.push((cnt, n));\n        }\n    }\n    ones.sort();\n  \
    \  let mut res = Vec::new();\n    for (cnt, n) in ones {\n        res.push(n);\n\
    \    }\n    res.extend(zeros);\n    res", "    fn cmp(a: &isize, b: &isize) ->\
    \ cmp::Ordering {\n        let a_bin = format!(\"{:b}\", a);\n        let b_bin\
    \ = format!(\"{:b}\", b);\n        match a_bin.matches('1').count().cmp(&b_bin.matches('1').count())\
    \ {\n            cmp::Ordering::Equal => a.cmp(&b),\n            x => x,\n   \
    \     }\n    }\n    let mut v = arr;\n    v.sort_by(cmp);\n    v", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = format!(\"{:b}\"\
    , a).matches('1').count();\n        let b_ones = format!(\"{:b}\", b).matches('1').count();\n\
    \        match a_ones.cmp(&b_ones) {\n            std::cmp::Ordering::Equal =>\
    \ a.cmp(b),\n            _ => a_ones.cmp(&b_ones),\n        }\n    });\n    arr",
  "    let mut arr: Vec<_> = arr.into_iter().map(|a| (a, count_bits(a))).collect();\n\
    \    arr.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n    arr.into_iter().map(|(a,\
    \ _)| a).collect()", "    let mut res = arr.clone();\n    res.sort_by(|a, b| {\n\
    \        match (a.count_ones(), b.count_ones()) {\n            (a, b) if a > b\
    \ => Ordering::Less,\n            (a, b) if a < b => Ordering::Greater,\n    \
    \        _ => a.cmp(b),\n        }\n    });\n    res", "    // Your code here!\n\
    \    arr", "    use std::cmp::Ordering;\n    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones == b_ones {\n            return a.cmp(b);\n        }\n    \
    \    a_ones.cmp(&b_ones)\n    });\n    res", "    let mut sorted = arr.clone();\n\
    \    sorted.sort_by(|a, b| {\n        let count_a = count_ones(*a);\n        let\
    \ count_b = count_ones(*b);\n        if count_a == count_b {\n            return\
    \ a.cmp(b);\n        }\n        count_a.cmp(&count_b)\n    });\n    sorted", " \
    \   let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n        }\n\
    \    });\n    arr", "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|&(a, b), &(c, d)| if b == d {\
    \ a.cmp(&c) } else { b.cmp(&d) })\n        .into_iter()\n        .map(|(a, _)|\
    \ a)\n        .collect()", "    let mut sorted = arr.clone();\n    sorted.sort_by(|x,\
    \ y| {\n        let x_ones = x.count_ones();\n        let y_ones = y.count_ones();\n\
    \        if x_ones == y_ones {\n            return x.cmp(y);\n        }\n    \
    \    x_ones.cmp(&y_ones)\n    });\n    sorted", "    let mut arr: Vec<_> = arr.into_iter().map(|x|\
    \ (x, x.count_ones())).collect();\n    arr.sort_by(|a, b| match (a.1).cmp(&b.1)\
    \ {\n        Ordering::Equal => a.0.cmp(&b.0),\n        Ordering::Less => Ordering::Less,\n\
    \        Ordering::Greater => Ordering::Greater,\n    });\n    arr.into_iter().map(|x|\
    \ x.0).collect()", "    arr.iter()\n        .map(|&x| (x, format!(\"{:b}\", x).chars().filter(|&d|\
    \ d == '1').count()))\n        .sorted_by(|a, b| {\n            if a.1 == b.1\
    \ {\n                a.0.cmp(&b.0)\n            } else {\n                a.1.cmp(&b.1)\n\
    \            }\n        })\n        .map(|(x, _)| x)\n        .collect()", " \
    \   let mut ret = arr.clone();\n    ret.sort_by(|a, b| {\n        let mut n1 =\
    \ *a;\n        let mut n2 = *b;\n        let mut ones1 = 0;\n        let mut ones2\
    \ = 0;\n        while n1 > 0 {\n            ones1 += n1 % 2;\n            n1 /=\
    \ 2;\n        }\n        while n2 > 0 {\n            ones2 += n2 % 2;\n      \
    \      n2 /= 2;\n        }\n        match ones1.cmp(&ones2) {\n            Ordering::Less\
    \ => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n  \
    \          Ordering::Equal => a.cmp(&b),\n        }\n    });\n    ret", "    let\
    \ mut ones_and_decimals: Vec<(usize, isize)> =\n        arr.iter().map(|&x| (x.count_ones(),\
    \ x)).collect();\n    ones_and_decimals.sort();\n    ones_and_decimals.iter().map(|(_,\
    \ &x)| x).collect()", "    let mut ones_map: HashMap<isize, isize> = HashMap::new();\n\
    \    for n in arr.iter() {\n        *ones_map.entry(*n).or_insert(0) += 1;\n \
    \   }\n    let mut zeros_only: Vec<isize> = arr.iter().filter(|n| n.abs() == 0).map(|n|\
    \ *n).collect();\n    let mut sorted: Vec<isize> = ones_map.keys().map(|n| *n).collect();\n\
    \    sorted.sort_by(|x, y| {\n        let x_ones = x.abs().count_ones();\n   \
    \     let y_ones = y.abs().count_ones();\n        let x_zeros = 64 - x_ones;\n\
    \        let y_zeros = 64 - y_ones;\n        if x_zeros == y_zeros {\n       \
    \     if x_ones == y_ones {\n                x.cmp(y)\n            } else {\n\
    \                x_ones.cmp(&y_ones)\n            }\n        } else {\n      \
    \      x_zeros.cmp(&y_zeros)\n        }\n    });\n    let mut sorted_ones: Vec<isize>\
    \ = sorted.iter().map(|n| ones_map[n] * *n).collect();\n    sorted_ones.append(&mut\
    \ zeros_only);\n    sorted_ones", "    let n = arr.len();\n    let mut ones =\
    \ vec![0; n];\n    for i in 0..n {\n        ones[i] = arr[i].count_ones();\n \
    \   }\n    let mut index = vec![0; n];\n    for i in 0..n {\n        index[i]\
    \ = i;\n    }\n    index.sort_by(|&i, &j| {\n        let r = ones[i].cmp(&ones[j]);\n\
    \        if r == std::cmp::Ordering::Equal {\n            arr[i].cmp(&arr[j])\n\
    \        } else {\n            r\n        }\n    });\n    let mut ans = vec![0;\
    \ n];\n    for i in 0..n {\n        ans[i] = arr[index[i]];\n    }\n    ans",
  "    fn binary_ones(mut n: isize) -> isize {\n        let mut ret = 0;\n       \
    \ while n > 0 {\n            if n % 2 == 1 {\n                ret += 1;\n    \
    \        }\n            n /= 2;\n        }\n        ret\n    }\n\n    fn sort_ones(a:\
    \ &isize, b: &isize) -> std::cmp::Ordering {\n        let ao = binary_ones(*a);\n\
    \        let bo = binary_ones(*b);\n        if ao > bo {\n            std::cmp::Ordering::Less\n\
    \        } else if ao < bo {\n            std::cmp::Ordering::Greater\n      \
    \  } else {\n            a.cmp(b)\n        }\n    }\n\n    let mut ret = arr.clone();\n\
    \    ret.sort_by(sort_ones);\n    ret", "    let mut result = arr.clone();\n \
    \   result.sort_by(|a, b| {\n        let (ones_a, ones_b) = (a.count_ones(), b.count_ones());\n\
    \        if ones_a == ones_b {\n            return a.cmp(b);\n        }\n    \
    \    ones_a.cmp(&ones_b)\n    });\n    result", "    let mut map = HashMap::new();\n\
    \    let mut vec = vec![];\n    let mut highest = 0;\n    for x in arr {\n   \
    \     let ones = x.count_ones();\n        if ones > highest {\n            highest\
    \ = ones;\n        }\n        if !map.contains_key(&ones) {\n            map.insert(ones,\
    \ vec![x]);\n        } else {\n            let mut tmp = map.get_mut(&ones).unwrap();\n\
    \            tmp.push(x);\n        }\n    }\n    for n in 0..=highest {\n    \
    \    let tmp = map.get(&n).unwrap();\n        vec.extend(tmp);\n    }\n    vec",
  "    let mut vec: Vec<_> = arr.into_iter().map(|x| (x, x.count_ones())).collect();\n\
    \    vec.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n    vec.into_iter().map(|x|\
    \ x.0).collect()", "    let mut v = arr;\n    v.sort_by(|a, b| {\n        let\
    \ a1 = a.count_ones();\n        let b1 = b.count_ones();\n        if a1 == b1\
    \ {\n            return a.cmp(b);\n        }\n        a1.cmp(&b1)\n    });\n \
    \   v", "    let mut res = arr.clone();\n    res.sort_by(|a, b| count_ones(*a).cmp(&count_ones(*b)));\n\
    \    res", "    arr.into_iter()\n        .map(|x| (x, format!(\"{:0t$b}\", x,\
    \ t = 10)))\n        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n  \
    \      .map(|x| x.0)\n        .collect()", "    use std::cmp::Ordering;\n    if\
    \ arr.len() == 0 {\n        return arr;\n    }\n    let mut res = arr.clone();\n\
    \    res.sort_by(|a, b| {\n        let c = num_ones(*a) - num_ones(*b);\n    \
    \    if c == 0 {\n            a.cmp(b)\n        } else {\n            c.cmp(&0)\n\
    \        }\n    });\n    res", "    let mut binarr: Vec<(usize, isize)> = vec![];\n\
    \    for x in arr {\n        let b = x.abs();\n        let mut c = 0;\n      \
    \  let mut v = b;\n        while v > 0 {\n            c += v % 2;\n          \
    \  v /= 2;\n        }\n        binarr.push((c, x));\n    }\n    binarr.sort();\n\
    \    binarr.iter().map(|&(_, v)| v).collect()", "    let mut v = arr.clone();\n\
    \    v.sort_by(|a, b| {\n        let cnt_a = format!(\"{:b}\", a).chars().filter(|&c|\
    \ c == '1').count();\n        let cnt_b = format!(\"{:b}\", b).chars().filter(|&c|\
    \ c == '1').count();\n        match cnt_a.cmp(&cnt_b) {\n            Ordering::Equal\
    \ => a.cmp(&b),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    v", "    let mut arr_vec: Vec<(usize,\
    \ isize)> = arr.iter().map(|x| (to_bin(*x).len(), *x)).collect();\n    arr_vec.sort();\n\
    \    arr_vec.iter().map(|x| x.1).collect()", "    let mut v: Vec<isize> = arr.iter().map(|i|\
    \ {\n        let mut cnt = 0;\n        let mut n = *i;\n        while n > 0 {\n\
    \            cnt += n & 1;\n            n >>= 1;\n        }\n        (cnt, *i)\n\
    \    }).collect();\n    v.sort();\n    v.iter().map(|(_, i)| *i).collect()", " \
    \   let mut arr: Vec<_> = arr.into_iter().map(|n| (n, n.count_ones())).collect();\n\
    \    arr.sort_by(|&(a, x), &(b, y)| {\n        if x == y {\n            a.cmp(&b)\n\
    \        } else {\n            x.cmp(&y)\n        }\n    });\n    arr.into_iter().map(|(a,\
    \ _)| a).collect()", "    arr.iter()\n        .map(|n| (n, n.count_ones()))\n\
    \        .sort_by(|(_, a), (_, b)| a.cmp(b))\n        .map(|(n, _)| *n)\n    \
    \    .collect()", "    arr.into_iter()\n        .map(|i| (i, i.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n\
    \        .into_iter()\n        .map(|(i, _)| i)\n        .collect()", "    let\
    \ mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n        let\
    \ ones_a = format!(\"{:b}\", a).matches('1').count();\n        let ones_b = format!(\"\
    {:b}\", b).matches('1').count();\n        ones_a.cmp(&ones_b).then(a.cmp(b))\n\
    \    });\n    sorted_arr", "    let mut v: Vec<_> = arr.into_iter().map(|x| (x,\
    \ x.count_ones())).collect();\n    v.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n\
    \    v.into_iter().map(|(a, _)| a).collect()", "    let mut v = arr.iter().map(|&x|\
    \ (x, x.count_ones())).collect::<Vec<_>>();\n    v.sort_by(|a, b| {\n        if\
    \ a.1 != b.1 {\n            a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    v.iter().map(|&(x, _)| x).collect()", "    let mut arr:\
    \ Vec<isize> = arr;\n    arr.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()).then(a.cmp(b)));\n\
    \    arr", "    let mut ones = HashMap::new();\n    let mut zeros = HashMap::new();\n\
    \    let mut both = HashMap::new();\n    let mut new_arr = Vec::new();\n\n   \
    \ for i in arr {\n        let i_bin = format!(\"{:b}\", i);\n        let j = i_bin.matches(\"\
    1\").count();\n        let k = i_bin.matches(\"0\").count();\n        if j > 0\
    \ && k > 0 {\n            both.insert(i, j);\n        } else if j > 0 {\n    \
    \        ones.insert(i, j);\n        } else {\n            zeros.insert(i, k);\n\
    \        }\n    }\n\n    let mut sorted_ones = ones.into_iter().collect::<Vec<(isize,\
    \ usize)>>();\n    sorted_ones.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut sorted_zeros\
    \ = zeros.into_iter().collect::<Vec<(isize, usize)>>();\n    sorted_zeros.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    let mut sorted_both = both.into_iter().collect::<Vec<(isize,\
    \ usize)>>();\n    sorted_both.sort_by(|a, b| a.1.cmp(&b.1));\n\n    for i in\
    \ sorted_zeros {\n        new_arr.push(i.0);\n    }\n    for i in sorted_ones\
    \ {\n        new_arr.push(i.0);\n    }\n    for i in sorted_both {\n        new_arr.push(i.0);\n\
    \    }\n\n    new_arr", "    let mut ones = Vec::with_capacity(arr.len());\n \
    \   let mut zeros = Vec::with_capacity(arr.len());\n    for &x in &arr {\n   \
    \     if x >= 0 {\n            ones.push(x);\n        } else {\n            zeros.push(x);\n\
    \        }\n    }\n    ones.sort_by(|a, b| {\n        a.count_ones()\n       \
    \     .cmp(&b.count_ones())\n            .then(a.cmp(b))\n    });\n    zeros.sort_by(|a,\
    \ b| {\n        a.count_ones()\n            .cmp(&b.count_ones())\n          \
    \  .then(a.cmp(b))\n    });\n    let mut result = ones;\n    result.extend(zeros);\n\
    \    result", "    arr.into_iter()\n        .map(|e| (e, e.count_ones()))\n  \
    \      .collect::<Vec<_>>()\n        .sort_by(|a, b| {\n            a.1.cmp(&b.1).then(a.0.cmp(&b.0))\n\
    \        })\n        .into_iter()\n        .map(|e| e.0)\n        .collect()",
  "    let mut new_arr = arr.clone();\n    new_arr.sort_by(|a, b| {\n        let a_binary\
    \ = format!(\"{:b}\", a);\n        let b_binary = format!(\"{:b}\", b);\n    \
    \    let a_ones = a_binary.matches('1').count();\n        let b_ones = b_binary.matches('1').count();\n\
    \        a_ones.cmp(&b_ones).then(a.cmp(b))\n    });\n    new_arr", "    arr.into_iter()\n\
    \        .map(|i| (i, i.count_ones()))\n        .collect::<Vec<_>>()\n       \
    \ .sort_by(|a, b| {\n            if a.1 == b.1 {\n                a.0.cmp(&b.0)\n\
    \            } else {\n                a.1.cmp(&b.1)\n            }\n        })\n\
    \        .into_iter()\n        .map(|i| i.0)\n        .collect()", "    arr.iter()\n\
    \        .cloned()\n        .map(|n| (n, n.count_ones()))\n        .sorted_by(|&(a,\
    \ ones_a), &(b, ones_b)| {\n            if ones_a == ones_b {\n              \
    \  a.cmp(&b)\n            } else {\n                ones_a.cmp(&ones_b)\n    \
    \        }\n        })\n        .map(|(n, _)| n)\n        .collect()", "    let\
    \ mut vec = arr.clone();\n    let mut length = vec.len();\n    if length == 0\
    \ {\n        return vec;\n    }\n    let mut idx = 0;\n    while idx < length\
    \ {\n        let first = vec[idx];\n        let mut min_idx = idx;\n        let\
    \ mut min_val = first;\n        let mut min_ones = get_ones(first);\n        for\
    \ j in idx + 1..length {\n            let curr = vec[j];\n            let curr_ones\
    \ = get_ones(curr);\n            if curr_ones < min_ones || (curr_ones == min_ones\
    \ && curr < min_val) {\n                min_idx = j;\n                min_val\
    \ = curr;\n                min_ones = curr_ones;\n            }\n        }\n \
    \       if min_idx != idx {\n            vec[idx] = min_val;\n            vec[min_idx]\
    \ = first;\n        }\n        idx += 1;\n    }\n    vec", "    // Get the number\
    \ of 1s in the binary representation of each number.\n    let bin_ones = arr.iter().map(|&x|\
    \ {\n        let mut counter = 0;\n        let mut copy = x;\n        while copy\
    \ > 0 {\n            counter += copy & 1;\n            copy >>= 1;\n        }\n\
    \        counter\n    });\n\n    // Sort arr using bin_ones as a sort key.\n \
    \   let mut zipped: Vec<_> = arr.iter().zip(bin_ones).collect();\n    zipped.sort_by(|&(a,\
    \ b), &(c, d)| (b, a).cmp(&(d, c)));\n    zipped.iter().map(|&(a, _)| *a).collect()",
  "    let mut result = arr.iter().map(|&n| (n, n.count_ones())).collect::<Vec<_>>();\n\
    \    result.sort_by(|a, b| {\n        match a.1.cmp(&b.1) {\n            Ordering::Equal\
    \ => a.0.cmp(&b.0),\n            other => other,\n        }\n    });\n    result.iter().map(|(n,\
    \ _)| *n).collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n    \
    \    let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n    \
    \    if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n         \
    \   a_ones.cmp(&b_ones)\n        }\n    });\n    arr", "    let mut sorted = arr.clone();\n\
    \    sorted.sort_by(|a, b| {\n        let an = a.count_ones();\n        let bn\
    \ = b.count_ones();\n        if an == bn {\n            a.cmp(b)\n        } else\
    \ {\n            an.cmp(&bn)\n        }\n    });\n    sorted", "    let mut arr\
    \ = arr;\n    arr.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()).then(a.cmp(b)));\n\
    \    arr", "    let mut sorted = arr;\n    sorted.sort_by(|a, b| {\n        if\
    \ count_ones(*a) == count_ones(*b) {\n            a.cmp(b)\n        } else {\n\
    \            count_ones(*a).cmp(&count_ones(*b))\n        }\n    });\n    sorted",
  "    arr.iter()\n        .map(|&n| (-(n as usize).count_ones(), n))\n        .sorted()\n\
    \        .into_iter()\n        .map(|(_, n)| n)\n        .collect()", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n        }\n\
    \    });\n    arr", "    arr.iter()\n        .map(|&e| (e, e.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| match a.1.cmp(&b.1) {\n\
    \            Ordering::Equal => a.0.cmp(&b.0),\n            o => o,\n        })\n\
    \        .into_iter()\n        .map(|t| t.0)\n        .collect()", "    arr.iter()\n\
    \        .enumerate()\n        .map(|(i, &x)| {\n            let r = format!(\"\
    {:b}\", x).chars().fold(0, |acc, ch| {\n                if ch == '1' {\n     \
    \               acc + 1\n                } else {\n                    acc\n \
    \               }\n            });\n            (i, r, x)\n        })\n      \
    \  .sort_by(|&(_, a1, _), &(_, a2, _)| {\n            if a1 == a2 {\n        \
    \        std::cmp::Ordering::Equal\n            } else if a1 < a2 {\n        \
    \        std::cmp::Ordering::Less\n            } else {\n                std::cmp::Ordering::Greater\n\
    \            }\n        })\n        .into_iter()\n        .map(|(_, _, x)| x)\n\
    \        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n    \
    \    let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n    \
    \    if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n        } else {\n\
    \            a.cmp(b)\n        }\n    });\n    arr", "    let n = arr.len();\n\
    \    let mut ones = Vec::new();\n    let mut zeros = Vec::new();\n    let mut\
    \ two = Vec::new();\n    for i in 0..n {\n        let mut k = arr[i];\n      \
    \  let mut m = 0;\n        while k > 0 {\n            m += k % 2;\n          \
    \  k /= 2;\n        }\n        if m == 0 {\n            zeros.push(arr[i]);\n\
    \        } else if m == 1 {\n            ones.push(arr[i]);\n        } else {\n\
    \            two.push(arr[i]);\n        }\n    }\n    zeros.sort();\n    ones.sort();\n\
    \    two.sort();\n    let mut sorted = Vec::new();\n    sorted.append(&mut zeros);\n\
    \    sorted.append(&mut ones);\n    sorted.append(&mut two);\n    sorted", " \
    \   let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_bits = a.count_ones();\n\
    \        let b_bits = b.count_ones();\n        if a_bits == b_bits {\n       \
    \     a.cmp(b)\n        } else {\n            a_bits.cmp(&b_bits)\n        }\n\
    \    });\n    arr", "    // Convert the integers to binary strings, then count\
    \ the number of ones in\n    // each, and then sort the array by count then by\
    \ integer.\n    arr.iter()\n        .map(|n| format!(\"{:b}\", n))\n        .map(|x|\
    \ (x.chars().filter(|&x| x == '1').count(), x.parse::<isize>().unwrap()))\n  \
    \      .sorted_by(|x, y| match x.0.cmp(&y.0) {\n            Ordering::Equal =>\
    \ x.1.cmp(&y.1),\n            ord => ord,\n        })\n        .map(|x| x.1)\n\
    \        .collect()", "    fn get_count_of_ones(n: usize) -> usize {\n       \
    \ let mut ones = 0;\n        let mut m = n;\n        while m > 0 {\n         \
    \   ones += (m & 1) as usize;\n            m >>= 1;\n        }\n        ones\n\
    \    }\n\n    let mut arr: Vec<_> = arr.into_iter().map(|x| x as usize).collect();\n\
    \    arr.sort_by_key(|x| (get_count_of_ones(*x), *x));\n    arr.into_iter().map(|x|\
    \ x as isize).collect()", "    arr.iter()\n        .map(|x| (get_ones(*x), *x))\n\
    \        .collect::<Vec<(usize, isize)>>()\n        .sort_by(|a, b| {\n      \
    \      if a.0 == b.0 {\n                a.1.cmp(&b.1)\n            } else {\n\
    \                a.0.cmp(&b.0)\n            }\n        })\n        .iter()\n \
    \       .map(|&(_, v)| v)\n        .collect()", '    return arr;', "    // your\
    \ code here\n    arr.into_iter().map(|n| {\n        let mut buf = vec![0; 16];\n\
    \        buf[0] = n;\n        let mut tmp = vec![];\n        while buf[0] != 0\
    \ {\n            tmp.push(buf[0] % 2);\n            buf[0] /= 2;\n        }\n\
    \        (tmp.len(), n)\n    }).collect::<Vec<_>>().sort_by(|a, b| {\n       \
    \ match a.0.cmp(&b.0) {\n            Ordering::Equal => a.1.cmp(&b.1),\n     \
    \       ordering => ordering,\n        }\n    }).into_iter().map(|(_, n)| n).collect()",
  "    let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n        if a.count_ones()\
    \ == b.count_ones() {\n            a.cmp(b)\n        } else {\n            a.count_ones().cmp(&b.count_ones())\n\
    \        }\n    });\n    sorted", "    let n = arr.len();\n    let mut sorted_by_ones\
    \ = vec![(0, 0); n];\n    for i in 0..n {\n        let mut num = arr[i];\n   \
    \     let mut count = 0;\n        while num > 0 {\n            if num % 2 == 1\
    \ {\n                count += 1;\n            }\n            num /= 2;\n     \
    \   }\n        sorted_by_ones[i] = (count, arr[i]);\n    }\n    sorted_by_ones.sort();\n\
    \    sorted_by_ones.iter().map(|&(_, num)| num).collect()", "    let mut hm =\
    \ HashMap::new();\n    let mut v: Vec<isize> = Vec::new();\n    for i in arr {\n\
    \        let n = format!(\"{:b}\", i);\n        let ones = n.matches('1').count();\n\
    \        hm.insert(i, ones);\n        v.push(i);\n    }\n    v.sort_by(|a, b|\
    \ {\n        let o1 = hm.get(a).unwrap();\n        let o2 = hm.get(b).unwrap();\n\
    \        o1.cmp(o2).then(a.cmp(b))\n    });\n    v", "    let mut sorted = arr.iter().map(|x|\
    \ (x, x.count_ones())).collect::<Vec<_>>();\n    sorted.sort_by(|a, b| match a.1.cmp(&b.1)\
    \ {\n        Ordering::Equal => a.0.cmp(&b.0),\n        Ordering::Less => Ordering::Less,\n\
    \        Ordering::Greater => Ordering::Greater,\n    });\n    sorted.iter().map(|(x,\
    \ _)| *x).collect()", "    fn one_count(x: isize) -> usize {\n        x.count_ones()\
    \ as usize\n    }\n\n    fn from_iter<I: IntoIterator<Item = T>, T: Ord>(iter:\
    \ I) -> BinaryHeap<T> {\n        BinaryHeap::from(iter)\n    }\n\n    fn to_vec<T:\
    \ Ord>(heap: BinaryHeap<T>) -> Vec<T> {\n        let mut v = heap.into_sorted_vec();\n\
    \        v.reverse();\n        v\n    }\n\n    fn sort(arr: Vec<isize>) -> Vec<isize>\
    \ {\n        arr.into_iter()\n            .map(|x| (one_count(x), x))\n      \
    \      .collect::<BinaryHeap<_>>()\n            .into_sorted_vec()\n         \
    \   .into_iter()\n            .map(|(_, x)| x)\n            .collect()\n    }\n\
    \n    fn sort_harder(arr: Vec<isize>) -> Vec<isize> {\n        arr.into_iter()\n\
    \            .map(|x| (one_count(x), x))\n            .collect::<BinaryHeap<_>>()\n\
    \            .into_sorted_vec()\n            .into_iter()\n            .map(|(_,\
    \ x)| x)\n            .collect()\n    }\n\n    fn sort_harder2(arr: Vec<isize>)\
    \ -> Vec<isize> {\n        arr.into_iter()\n            .map(|x| (one_count(x),\
    \ x))\n            .collect::<BinaryHeap<_>>()\n            .into_sorted_vec()\n\
    \            .into_iter()\n            .map(|(_, x)| x)\n            .collect()\n\
    \    }\n\n    fn sort_harder3(arr: Vec<isize>) -> Vec<isize> {\n        arr.into_iter()\n\
    \            .map(|x| (one_count(x), x))\n            .collect::<BinaryHeap<_>>()\n\
    \            .into_sorted_vec()\n            .into_iter()\n            .map(|(_,\
    \ x)| x)\n", "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n   \
    \     .sorted_by(|x, y| match x.1.cmp(&y.1) {\n            Ordering::Equal =>\
    \ x.0.cmp(&y.0),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        })\n        .map(|x| x.0)\n        .collect()",
  "    let mut dec: Vec<_> = arr.clone();\n    let mut binary: Vec<_> = arr.clone();\n\
    \    dec.sort();\n    binary.sort_by(|x, y| {\n        format!(\"{:b}\", x).chars().filter(|c|\
    \ *c == '1').count()\n            .cmp(&format!(\"{:b}\", y).chars().filter(|c|\
    \ *c == '1').count())\n    });\n    binary.sort_by(|x, y| format!(\"{:b}\", x).cmp(&format!(\"\
    {:b}\", y)));\n    binary", "    let mut count_ones = Vec::new();\n    for &i\
    \ in &arr {\n        count_ones.push(((i as u32).count_ones(), i));\n    }\n \
    \   count_ones.sort();\n    count_ones.iter().map(|x| x.1).collect()", "    let\
    \ mut data = arr.clone();\n    data.sort_by(|a, b| {\n        let (a_ones, a_dec)\
    \ = num_ones(*a);\n        let (b_ones, b_dec) = num_ones(*b);\n        if a_ones\
    \ == b_ones {\n            a_dec.cmp(&b_dec)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    data", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    arr", "    let mut result\
    \ = arr.clone();\n    result.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n        }\n\
    \    });\n    result", "    let mut ones: HashMap<isize, usize> = HashMap::new();\n\
    \    let mut zeros: HashMap<isize, usize> = HashMap::new();\n    for n in arr\
    \ {\n        let x = n.abs();\n        if n < 0 {\n            *zeros.entry(x).or_insert(0)\
    \ += x.count_ones() as usize;\n        } else {\n            *ones.entry(x).or_insert(0)\
    \ += x.count_ones() as usize;\n        }\n    }\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for (n, c) in ones.iter() {\n        result.push(*n);\n \
    \       result.push(*n);\n        let mut i = 0;\n        while i < *c {\n   \
    \         result.push(*n);\n            i += 1;\n        }\n    }\n    for (n,\
    \ c) in zeros.iter() {\n        result.push(-*n);\n        result.push(-*n);\n\
    \        let mut i = 0;\n        while i < *c {\n            result.push(-*n);\n\
    \            i += 1;\n        }\n    }\n    result", "    let mut ones: Vec<_>\
    \ = arr.iter().map(|&i| (i.count_ones(), i)).collect();\n    ones.sort();\n  \
    \  ones.iter().map(|&(_, i)| i).collect()", "    let mut v = arr.into_iter().map(|num|\
    \ (ones(num), num)).collect::<Vec<_>>();\n    v.sort();\n    v.into_iter().map(|(_,\
    \ num)| num).collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n \
    \       let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n \
    \       if ones_a == ones_b {\n            a.cmp(b)\n        } else {\n      \
    \      ones_a.cmp(&ones_b)\n        }\n    });\n    arr", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let (ones_a, int_a) = (a.count_ones(), *a);\n\
    \        let (ones_b, int_b) = (b.count_ones(), *b);\n        if ones_a == ones_b\
    \ {\n            int_a.cmp(&int_b)\n        } else {\n            ones_a.cmp(&ones_b)\n\
    \        }\n    });\n    arr", "    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| count_ones(a).cmp(&count_ones(b)).then(a.cmp(b)));\n    res"]
stop_tokens:
- "\n}"
