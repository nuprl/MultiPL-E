name: HumanEval_93_encode
language: rust
results:
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encode_message = String::new();\n    let mut\
    \ vowels = String::from(\"aeiouAEIOU\");\n    let mut alphabet = String::from(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    for c in message.chars()\
    \ {\n        match c {\n            'a'...'z' => {\n                let index\
    \ = alphabet.find(c).unwrap();\n                encode_message.push(alphabet.chars().nth(index\
    \ + 2).unwrap());\n            },\n            'A'...'Z' => {\n              \
    \  let index = alphabet.find(c).unwrap();\n                encode_message.push(alphabet.chars().nth(index\
    \ + 2).unwrap());\n            },\n            _ => {\n                encode_message.push(c);\n\
    \            }\n        }\n    }\n    encode_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpoj3e67tc.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    /// get list of vowels\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    /// convert string to mutable array\n    let mut message\
    \ = message.chars().collect::<Vec<char>>();\n    /// iterate through message\n\
    \    for (index, char) in message.iter_mut().enumerate() {\n        if vowels.contains(char)\
    \ {\n            /// replace vowels in message\n            let new_char = if\
    \ char == &'u' {\n                'a'\n            } else {\n                ///\
    \ replace char with one 2 ahead of its char code\n                char.to_ascii_uppercase()\
    \ as u8 + 2\n            };\n            message[index] = new_char as char;\n\
    \        } else {\n            /// convert any other char to uppercase\n     \
    \       message[index] = char.to_ascii_uppercase();\n        }\n    }\n    message.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0658]: attributes on expressions are experimental\n  --> /tmp/tmpck13cd4_.rs:23:17\n\
    \   |\n23 |                 /// replace char with one 2 ahead of its char code\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\
    \ for more information\n   = help: `///` is for documentation comments. For a\
    \ plain comment, use `//`.\n\nerror[E0658]: attributes on expressions are experimental\n\
    \  --> /tmp/tmpck13cd4_.rs:28:13\n   |\n28 |             /// convert any other\
    \ char to uppercase\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\
    \ for more information\n   = help: `///` is for documentation comments. For a\
    \ plain comment, use `//`.\n\nwarning: unused doc comment\n  --> /tmp/tmpck13cd4_.rs:12:5\n\
    \   |\n12 |     /// get list of vowels\n   |     ^^^^^^^^^^^^^^^^^^^^^^\n13 |\
    \     let vowels = ['a', 'e', 'i', 'o', 'u'];\n   |     ---------------------------------------\
    \ rustdoc does not generate documentation for statements\n   |\n   = note: `#[warn(unused_doc_comments)]`\
    \ on by default\n   = help: use `//` for a plain comment\n\nwarning: unused doc\
    \ comment\n  --> /tmp/tmpck13cd4_.rs:14:5\n   |\n14 |     /// convert string to\
    \ mutable array\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n15 |     let mut\
    \ message = message.chars().collect::<Vec<char>>();\n   |     ---------------------------------------------------------\
    \ rustdoc does not generate documentation for statements\n   |\n   = help: use\
    \ `//` for a plain comment\n\nwarning: unused doc comment\n  --> /tmp/tmpck13cd4_.rs:16:5\n\
    \   |\n16 |       /// iterate through message\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    17 | /     for (index, char) in message.iter_mut().enumerate() {\n18 | |     \
    \    if vowels.contains(char) {\n19 | |             /// replace vowels in message\n\
    20 | |             let new_char = if char == &'u' {\n...  |\n30 | |         }\n\
    31 | |     }\n   | |_____- rustdoc does not generate documentation for expressions\n\
    \   |\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut word = String::new();\n    for c in message.chars()\
    \ {\n        word.push(match c {\n            'a' => 'c',\n            'A' =>\
    \ 'C',\n            'e' => 'g',\n            'E' => 'G',\n            'i' => 'k',\n\
    \            'I' => 'K',\n            'o' => 'q',\n            'O' => 'Q',\n \
    \           'u' => 'y',\n            'U' => 'Y',\n            x => x.to_ascii_uppercase()\n\
    \        });\n    }\n    word\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp95qsv3dd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    for c in message.chars()\
    \ {\n        if !c.is_alphabetic() {\n            s.push(c);\n            continue;\n\
    \        }\n        let mut e = c.to_ascii_lowercase();\n        match e {\n \
    \           'a' => e = 'c',\n            'e' => e = 'g',\n            'i' => e\
    \ = 'k',\n            'o' => e = 'q',\n            'u' => e = 'y',\n         \
    \   _ => {},\n        }\n        if c.is_lowercase() {\n            s.push(e);\n\
    \        } else {\n            s.push(e.to_ascii_uppercase());\n        }\n  \
    \  }\n    s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp1g6a6dbq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| char_2_ahead(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_2_ahead` in this scope\n  -->\
    \ /tmp/tmp86cmdldh.rs:12:29\n   |\n12 |     message.chars().map(|c| char_2_ahead(c)).collect()\n\
    \   |                             ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message.chars();\n    for letter\
    \ in new_message.clone() {\n        letter.is_lowercase();\n    }\n    new_message.collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpg7pl53us.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        let n = c.to_ascii_lowercase();\n        if n\
    \ == 'a' {\n            encoded_message.push('c');\n        } else if n == 'e'\
    \ {\n            encoded_message.push('g');\n        } else if n == 'i' {\n  \
    \          encoded_message.push('k');\n        } else if n == 'o' {\n        \
    \    encoded_message.push('q');\n        } else if n == 'u' {\n            encoded_message.push('y');\n\
    \        } else if c.is_lowercase() {\n            encoded_message.push(c);\n\
    \        } else if c.is_uppercase() {\n            encoded_message.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpikdpcp8q.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  message.chars().map(|c| match c {\n    'a'|'e'|'i'|'o'|'u'\
    \ => {\n      match c {\n        'a' => 'c',\n        'e' => 'g',\n        'i'\
    \ => 'k',\n        'o' => 'q',\n        'u' => 'y',\n        _ => panic!(\"PANIC\"\
    )\n      }\n    },\n    'A'|'E'|'I'|'O'|'U' => {\n      match c {\n        'A'\
    \ => 'C',\n        'E' => 'G',\n        'I' => 'K',\n        'O' => 'Q',\n   \
    \     'U' => 'Y',\n        _ => panic!(\"PANIC\")\n      }\n    },\n    _ => {\n\
    \      match c.is_ascii_lowercase() {\n        true => c.to_ascii_uppercase(),\n\
    \        false => c.to_ascii_lowercase()\n      }\n    }\n  }).collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpjj3o70ul.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    const VOWELS: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n\
    \    message.chars().map(|c| {\n        match c {\n            c if VOWELS.contains(&c)\
    \ => {\n                let mut output = (c as u8) + 2;\n                if output\
    \ > 'u' as u8 {\n                    output -= 26;\n                }\n      \
    \          output as char\n            },\n            c if c.is_ascii_uppercase()\
    \ => c.to_ascii_lowercase(),\n            c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpd772n0ef.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    /// Writes a character to a string and skips next 2\
    \ vowels.\n    fn write_char(output: &mut String, c: char, next_vowel: usize)\
    \ {\n        output.push(c);\n        if let Some(vowel) = is_vowel(c) {\n   \
    \         match vowel {\n                Vowel::A => output.push('C'),\n     \
    \           Vowel::E => output.push('G'),\n                Vowel::I => output.push('K'),\n\
    \                Vowel::O => output.push('O'),\n                Vowel::U => output.push('U'),\n\
    \            }\n        }\n    }\n\n    let mut output = String::new();\n    for\
    \ (i, c) in message.chars().enumerate() {\n        if let Some(vowel) = is_vowel(c)\
    \ {\n            let mut j = i + 1;\n            let next_vowel = match vowel\
    \ {\n                Vowel::A => 1,\n                Vowel::E => 2,\n        \
    \        Vowel::I => 1,\n                Vowel::O => 2,\n                Vowel::U\
    \ => 1,\n            };\n            let mut skip = 0;\n            while skip\
    \ < next_vowel {\n                if let Some(vowel) = is_vowel(message.chars().nth(j).unwrap())\
    \ {\n                    skip += 1;\n                }\n                j += 1;\n\
    \            }\n            let mut k = i;\n            while k < j {\n      \
    \          write_char(&mut output, message.chars().nth(k).unwrap(), next_vowel);\n\
    \                k += 1;\n            }\n        } else {\n            write_char(&mut\
    \ output, c, 0);\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Vowel`\n  -->\
    \ /tmp/tmp5zl_qq41.rs:17:17\n   |\n17 |                 Vowel::A => output.push('C'),\n\
    \   |                 ^^^^^ use of undeclared type `Vowel`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:18:17\n\
    \   |\n18 |                 Vowel::E => output.push('G'),\n   |              \
    \   ^^^^^ use of undeclared type `Vowel`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:19:17\n   |\n19 |    \
    \             Vowel::I => output.push('K'),\n   |                 ^^^^^ use of\
    \ undeclared type `Vowel`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:20:17\n   |\n20 |                 Vowel::O\
    \ => output.push('O'),\n   |                 ^^^^^ use of undeclared type `Vowel`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:21:17\n\
    \   |\n21 |                 Vowel::U => output.push('U'),\n   |              \
    \   ^^^^^ use of undeclared type `Vowel`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:31:17\n   |\n31 |    \
    \             Vowel::A => 1,\n   |                 ^^^^^ use of undeclared type\
    \ `Vowel`\n\nerror[E0433]: failed to resolve: use of undeclared type `Vowel`\n\
    \  --> /tmp/tmp5zl_qq41.rs:32:17\n   |\n32 |                 Vowel::E => 2,\n\
    \   |                 ^^^^^ use of undeclared type `Vowel`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:33:17\n\
    \   |\n33 |                 Vowel::I => 1,\n   |                 ^^^^^ use of\
    \ undeclared type `Vowel`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:34:17\n   |\n34 |                 Vowel::O\
    \ => 2,\n   |                 ^^^^^ use of undeclared type `Vowel`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Vowel`\n  --> /tmp/tmp5zl_qq41.rs:35:17\n\
    \   |\n35 |                 Vowel::U => 1,\n   |                 ^^^^^ use of\
    \ undeclared type `Vowel`\n\nerror[E0425]:"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: encode the message\n    String::new()\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmp_wdxws28.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|character| {\n        match character\
    \ {\n            'a' | 'A' => 'C',\n            'e' | 'E' => 'G',\n          \
    \  'i' | 'I' => 'K',\n            'o' | 'O' => 'Q',\n            'u' | 'U' =>\
    \ 'Y',\n            'y' | 'Y' => 'A',\n            _ => character.to_uppercase().to_string().chars().next().unwrap()\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp2qw3_3vd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let vowel_indices\
    \ = get_vowel_indices();\n    for c in message.chars() {\n        let encoded_char\
    \ = if c.is_ascii_lowercase() {\n            c.to_ascii_uppercase()\n        }\
    \ else if c.is_ascii_uppercase() {\n            c.to_ascii_lowercase()\n     \
    \   } else {\n            c\n        };\n        if vowel_indices.contains(&(encoded_char\
    \ as u8)) {\n            let index = get_index_after_shifting(encoded_char as\
    \ u8, 2);\n            encoded.push(index as char);\n        } else {\n      \
    \      encoded.push(encoded_char);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_vowel_indices` in this scope\n\
    \  --> /tmp/tmpg7kuhvge.rs:13:25\n   |\n13 |     let vowel_indices = get_vowel_indices();\n\
    \   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_index_after_shifting` in this scope\n  --> /tmp/tmpg7kuhvge.rs:23:25\n\
    \   |\n23 |             let index = get_index_after_shifting(encoded_char as u8,\
    \ 2);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ encoded = String::new();\n    for character in message.chars() {\n        let\
    \ mut index = 0;\n        let mut found = false;\n        while !found && index\
    \ < vowels.len() {\n            if character == vowels[index] {\n            \
    \    found = true;\n            } else {\n                index += 1;\n      \
    \      }\n        }\n        if found {\n            let mut real_index = index\
    \ + 2;\n            if real_index >= vowels.len() {\n                real_index\
    \ -= vowels.len();\n            }\n            encoded.push(vowels[real_index]);\n\
    \        } else {\n            encoded.push(character);\n        }\n    }\n  \
    \  encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpz5u_xjrt.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    String::from(\"not implemented\")\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"not implemented\"`,\n right: `\"tgst\"`', /tmp/tmpv6w1tf3b.rs:17:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| match c {\n        'a' => 'c',\n\
    \        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'y',\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n      \
    \  'O' => 'Q',\n        'U' => 'Y',\n        c => c.to_ascii_uppercase(),\n  \
    \  }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpj54kvueq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmpyez11git.rs:12:29\n\
    \   |\n12 |     message.chars().map(|c| encode_char(c)).collect()\n   |      \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut temp_index\
    \ = 0;\n    let mut temp_char = ' ';\n    let mut is_capitalized = false;\n  \
    \  let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n    for i in message.chars()\
    \ {\n        if i.is_uppercase() {\n            is_capitalized = true;\n     \
    \   }\n        if is_capitalized {\n            temp_char = i.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        } else {\n            temp_char = i;\n        }\n        if vowels.contains(&temp_char)\
    \ {\n            for j in vowels.iter() {\n                if temp_char == *j\
    \ {\n                    temp_index = vowels.iter().position(|&k| k == *j).unwrap();\n\
    \                    temp_index += 2;\n                    temp_index %= 5;\n\
    \                    temp_char = vowels[temp_index];\n                    break;\n\
    \                }\n            }\n        }\n        if is_capitalized {\n  \
    \          temp_char = temp_char.to_uppercase().collect::<Vec<char>>()[0];\n \
    \       }\n        res.push(temp_char);\n        is_capitalized = false;\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TOST\"`,\n right: `\"tgst\"`', /tmp/tmpyw7dd3q6.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|character| match character {\n\
    \        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' =>\
    \ 'q',\n        'u' => 'y',\n        'A' => 'C',\n        'E' => 'G',\n      \
    \  'I' => 'K',\n        'O' => 'Q',\n        'U' => 'Y',\n        c => c,\n  \
    \  }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmphr8l0gjl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let alp_index = ((c as u8) - b'a' + b'A') as char;\n        if alp_index\
    \ != c {\n            encoded.push(alp_index);\n        } else {\n           \
    \ let alp_index = ((c as u8) - b'A' + b'a') as char;\n            encoded.push(alp_index);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6tvemukm.rs:14:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let index = vowels.iter().position(|&v| v == c).unwrap();\n \
    \           let next_vowel = vowels[(index + 2) % vowels.len()];\n           \
    \ encoded.push(next_vowel);\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpu35y21a8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::from(\"\");\n   \
    \ for c in message.chars() {\n        encoded_message.push(match c {\n       \
    \     'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n        \
    \    'o' => 'q',\n            'u' => 'y',\n            c => c.to_uppercase().next().unwrap_or(c),\n\
    \        });\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpxulu39oz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c == ' ' {\n            result.push(' ');\n        } else {\n\
    \            let n = c as u8;\n            let mut d = n - 65;\n            if\
    \ n > 122 {\n                d = n - 97;\n            }\n            let t = (d\
    \ + 2) % 26;\n            if n > 90 {\n                result.push((t + 97) as\
    \ char);\n            } else {\n                result.push((t + 65) as char);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp12ut3hfj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmpykufoyaz.rs:12:29\n\
    \   |\n12 |     message.chars().map(|c| encode_char(c)).collect()\n   |      \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|x| {\n        match x {\n    \
    \        'A' => 'C',\n            'a' => 'c',\n            'E' => 'G',\n     \
    \       'e' => 'g',\n            'I' => 'K',\n            'i' => 'k',\n      \
    \      'O' => 'Q',\n            'o' => 'q',\n            'U' => 'S',\n       \
    \     'u' => 's',\n            ' ' => ' ',\n            _ => x.to_ascii_uppercase(),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmppu3v73vp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let char_map: HashMap<char, char> = \"aeiou\".chars().zip(\"\
    ecigu\".chars()).collect();\n    message.chars().map(|c| {\n        match char_map.get(&c)\
    \ {\n            Some(mapped_char) => mapped_char.to_ascii_uppercase(),\n    \
    \        None => c.to_ascii_uppercase()\n        }\n    }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp2nkrmg90.rs:12:19\n\
    \   |\n12 |     let char_map: HashMap<char, char> = \"aeiou\".chars().zip(\"ecigu\"\
    .chars()).collect();\n   |                   ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for ch in message.chars() {\n        if\
    \ vowels.contains(&ch) {\n            let mut num = ch as u8;\n            num\
    \ += 2;\n            new_message.push((num as char).to_lowercase().next().unwrap());\n\
    \        } else {\n            if ch.is_lowercase() {\n                new_message.push(ch.to_uppercase().next().unwrap());\n\
    \            } else {\n                new_message.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpgz8h2jle.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let cipher = Cipher::new();\n    cipher.encode(message)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cipher`\n  -->\
    \ /tmp/tmp_djr8vl2.rs:12:18\n   |\n12 |     let cipher = Cipher::new();\n   |\
    \                  ^^^^^^ use of undeclared type `Cipher`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut v: Vec<char> = Vec::new();\n    let mut e:\
    \ Vec<char> = Vec::new();\n    let mut vowels: Vec<char> = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    for c in message.chars() {\n        if c.is_alphabetic() {\n\
    \            v.push(c);\n        }\n    }\n    for c in v {\n        if c.is_uppercase()\
    \ {\n            e.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            e.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        }\n    }\n    for (i, c) in e.iter().enumerate() {\n        if vowels.contains(c)\
    \ {\n            e[i] = vowels[(vowels.iter().position(|&r| r == *c).unwrap()\
    \ + 2) % 5];\n        }\n    }\n    e.iter().collect()\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp6y_hxn03.rs:14:9\n\
    \   |\n14 |     let mut vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n \
    \  |         ----^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0502]: cannot\
    \ borrow `e` as mutable because it is also borrowed as immutable\n  --> /tmp/tmp6y_hxn03.rs:29:13\n\
    \   |\n27 |     for (i, c) in e.iter().enumerate() {\n   |                   --------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n28 |         if vowels.contains(c)\
    \ {\n29 |             e[i] = vowels[(vowels.iter().position(|&r| r == *c).unwrap()\
    \ + 2) % 5];\n   |             ^ mutable borrow occurs here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    let alpha\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels\
    \ = Vec::new();\n    for letter in alpha.iter() {\n        if is_vowel(*letter)\
    \ {\n            vowels.push(*letter);\n        }\n    }\n    for c in message.chars()\
    \ {\n        let mut c_up = c.to_uppercase().next().unwrap();\n        let mut\
    \ idx: i32 = 0;\n        if is_vowel(c_up) {\n            idx = vowels.iter().position(|&r|\
    \ r == c_up).unwrap() as i32;\n            if idx == (vowels.len() - 1) as i32\
    \ {\n                c_up = vowels[0];\n            } else {\n               \
    \ c_up = vowels[(idx + 2) as usize];\n            }\n        }\n        result.push(c_up);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpo8j7ko7c.rs:16:12\n\
    \   |\n16 |         if is_vowel(*letter) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpo8j7ko7c.rs:23:12\n   |\n23 |         if is_vowel(c_up) {\n   |\
    \            ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        if let Some(l) =\
    \ c.to_ascii_lowercase().next() {\n            if vowels.contains(&l) {\n    \
    \            let mut n = l as u8 + 2;\n                if n > 0x7A {\n       \
    \             n -= 0x7A - 0x61 + 1;\n                }\n                return\
    \ (n as char).to_ascii_uppercase();\n            }\n        }\n        return\
    \ c.to_ascii_uppercase();\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpg4j9w4bm.rs:14:16\n\
    \   |\n14 |             if vowels.contains(&l) {\n   |                ^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `next` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpg4j9w4bm.rs:13:49\n   |\n13 |         if\
    \ let Some(l) = c.to_ascii_lowercase().next() {\n   |                        \
    \                         ^^^^ method not found in `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| if c.is_lowercase() { c.to_uppercase().next().unwrap()\
    \ } else { c.to_lowercase().next().unwrap() }).collect()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpv5t5_1b7.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // let message_lowercase = message.to_lowercase();\n\
    \    let message_lowercase = message.to_lowercase();\n    // let mut encoded_string\
    \ = String::new();\n    let mut encoded_string = String::new();\n    for c in\
    \ message_lowercase.chars() {\n        match c {\n            'a' => encoded_string.push('c'),\n\
    \            'e' => encoded_string.push('g'),\n            'i' => encoded_string.push('k'),\n\
    \            'o' => encoded_string.push('q'),\n            'u' => encoded_string.push('s'),\n\
    \            'y' => encoded_string.push('a'),\n            'z' => encoded_string.push('b'),\n\
    \            _ => encoded_string.push(c),\n        }\n    }\n    encoded_string\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"msdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp6m5aodtk.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  \
    \  let mut new_message = String::new();\n    for c in message.chars() {\n    \
    \    let letter = c.to_string().to_lowercase();\n        let letter_index = alphabet.find(letter.as_str()).unwrap();\n\
    \        if is_vowel(letter.as_str()) {\n            let next_letter_index = (letter_index\
    \ + 2) % 26;\n            let next_letter = alphabet.chars().nth(next_letter_index).unwrap();\n\
    \            new_message.push(next_letter);\n        } else {\n            let\
    \ next_letter_index = letter_index;\n            let next_letter = alphabet.chars().nth(next_letter_index).unwrap();\n\
    \            new_message.push(next_letter);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpceha6nc6.rs:17:12\n\
    \   |\n17 |         if is_vowel(letter.as_str()) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let msg = message.chars();\n    let mut encoded_message\
    \ = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for i in\
    \ msg {\n        if i.is_ascii_lowercase() {\n            if vowels.contains(&i)\
    \ {\n                let mut new_i = i as u8 + 2;\n                if new_i >\
    \ 122 {\n                    new_i = new_i - 26;\n                }\n        \
    \        encoded_message.push((new_i as char).to_ascii_uppercase());\n       \
    \     } else {\n                encoded_message.push(i.to_ascii_uppercase());\n\
    \            }\n        } else {\n            if vowels.contains(&i.to_ascii_lowercase())\
    \ {\n                let mut new_i = i as u8 + 2;\n                if new_i >\
    \ 90 {\n                    new_i = new_i - 26;\n                }\n         \
    \       encoded_message.push((new_i as char).to_ascii_lowercase());\n        \
    \    } else {\n                encoded_message.push(i.to_ascii_lowercase());\n\
    \            }\n        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for ch\
    \ in message.chars() {\n        let mut encoded_ch = ch;\n        if ch.is_lowercase()\
    \ {\n            encoded_ch = ch.to_uppercase().to_string().chars().next().unwrap();\n\
    \        } else if ch.is_uppercase() {\n            encoded_ch = ch.to_lowercase().to_string().chars().next().unwrap();\n\
    \        }\n\n        if ch == 'a' {\n            encoded_ch = 'c';\n        }\
    \ else if ch == 'e' {\n            encoded_ch = 'g';\n        } else if ch ==\
    \ 'i' {\n            encoded_ch = 'k';\n        } else if ch == 'o' {\n      \
    \      encoded_ch = 'q';\n        } else if ch == 'u' {\n            encoded_ch\
    \ = 'y';\n        } else if ch == 'A' {\n            encoded_ch = 'C';\n     \
    \   } else if ch == 'E' {\n            encoded_ch = 'G';\n        } else if ch\
    \ == 'I' {\n            encoded_ch = 'K';\n        } else if ch == 'O' {\n   \
    \         encoded_ch = 'Q';\n        } else if ch == 'U' {\n            encoded_ch\
    \ = 'Y';\n        }\n\n        encoded_message.push(encoded_ch);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpst5r6ay1.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut output = String::new();\n    for c in message.chars() {\n        let mut\
    \ char_str = c.to_string();\n        if c.is_alphabetic() {\n            char_str\
    \ = char_str.to_lowercase();\n            char_str = char_str.chars().next().unwrap().to_string();\n\
    \            if vowels.contains(&c) {\n                let c_idx = vowels.iter().position(|&r|\
    \ r == c).unwrap();\n                let next_char = vowels[(c_idx + 2) % vowels.len()];\n\
    \                char_str = next_char.to_string();\n            }\n        }\n\
    \        output.push_str(&char_str.to_uppercase());\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpm8myvyil.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpr59v88yd.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(char_encode).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `char_encode` in this scope\n  --> /tmp/tmpxxrntu8b.rs:12:25\n\
    \   |\n12 |     message.chars().map(char_encode).collect()\n   |             \
    \            ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    return message.chars().map(|c| \n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c\n   \
    \     }\n    ).map(|c| \n        if let Some(i) = \"aeiou\".find(c) {\n      \
    \      (i+2) as u8\n        } else {\n            c as u8\n        }\n    ).map(|b|\
    \ b as char).collect::<String>();\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t\\u{3}st\"`,\n right: `\"tgst\"`', /tmp/tmpuaavu_qk.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  let vowel_map = map_vowels();\n  let mut encoded = \"\
    \".to_string();\n  for c in message.chars() {\n    let char_lower = c.to_lowercase().next().unwrap();\n\
    \    if vowel_map.contains_key(&char_lower) {\n      encoded.push(vowel_map[&char_lower]);\n\
    \    } else {\n      encoded.push(char_lower);\n    }\n  }\n  encoded\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `map_vowels` in this scope\n  --> /tmp/tmpn2ggqzd2.rs:12:19\n\
    \   |\n12 |   let vowel_map = map_vowels();\n   |                   ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let alphabet = vec![\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\",\n        \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n    ];\n\
    \    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        let mut character = c.to_string();\n        if alphabet.contains(&character.as_str())\
    \ {\n            if vowels.contains(&character.as_str()) {\n                let\
    \ index = alphabet.iter().position(|&x| x == character.as_str()).unwrap();\n \
    \               let new_index = if index + 2 > 25 { index + 2 - 26 } else { index\
    \ + 2 };\n                character = alphabet[new_index].to_string();\n     \
    \       }\n            character = if character.is_lowercase() {\n           \
    \     character.to_uppercase()\n            } else {\n                character.to_lowercase()\n\
    \            };\n        }\n        encoded_message.push_str(character.as_str());\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp079dm5ex.rs:26:38\n   |\n26 |          \
    \   character = if character.is_lowercase() {\n   |                          \
    \            ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = message.chars();\n    let mut\
    \ encoded_message = String::new();\n    while let Some(c) = new_message.next()\
    \ {\n        match c {\n            'A' => encoded_message.push('C'),\n      \
    \      'a' => encoded_message.push('c'),\n            'E' => encoded_message.push('G'),\n\
    \            'e' => encoded_message.push('g'),\n            'I' => encoded_message.push('K'),\n\
    \            'i' => encoded_message.push('k'),\n            'O' => encoded_message.push('Q'),\n\
    \            'o' => encoded_message.push('q'),\n            'U' => encoded_message.push('S'),\n\
    \            'u' => encoded_message.push('s'),\n            _ => encoded_message.push(c),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp5cnys8_2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    return message.chars().map(|c| if c.is_ascii_alphabetic()\
    \ {\n        let mut c = c.to_ascii_lowercase();\n        if c == 'a' {\n    \
    \        c = 'c';\n        } else if c == 'e' {\n            c = 'g';\n      \
    \  } else if c == 'i' {\n            c = 'k';\n        } else if c == 'o' {\n\
    \            c = 'q';\n        } else if c == 'u' {\n            c = 'w';\n  \
    \      } else {\n            c = (c as u8 + 2) as char;\n        }\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c\n    }).collect::<String>();\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp6q5isnwn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // your code goes here\n    String::new()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmp1z25uy94.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        encoded.push(if is_vowel(c) {\n            shift_char(c, 2)\n   \
    \     } else {\n            c\n        });\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpnmu8c91u.rs:14:25\n\
    \   |\n14 |         encoded.push(if is_vowel(c) {\n   |                      \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `shift_char`\
    \ in this scope\n  --> /tmp/tmpnmu8c91u.rs:15:13\n   |\n15 |             shift_char(c,\
    \ 2)\n   |             ^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::from(\"\");\n    let message\
    \ = message.to_lowercase();\n    let mut message_iter = message.chars();\n   \
    \ while let Some(letter) = message_iter.next() {\n        if letter == 'a' {\n\
    \            encoded.push('c');\n        } else if letter == 'e' {\n         \
    \   encoded.push('g');\n        } else if letter == 'i' {\n            encoded.push('k');\n\
    \        } else if letter == 'o' {\n            encoded.push('q');\n        }\
    \ else if letter == 'u' {\n            encoded.push('y');\n        } else if letter\
    \ == 'y' {\n            encoded.push('b');\n        } else {\n            encoded.push(letter);\n\
    \        }\n    }\n    encoded.to_uppercase()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp83nvkmd8.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO write your code here\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmp1s05w8py.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut coded = message.clone();\n    // iterate through\
    \ each character of the message and transform it\n    for (i, character) in message.chars().enumerate()\
    \ {\n        // swap case of the letter in the message\n        let mut case_changed\
    \ = character.to_uppercase().to_string();\n        if case_changed == character.to_string()\
    \ {\n            case_changed = character.to_lowercase().to_string();\n      \
    \  }\n        // replace the vowel with the appropriate character\n        let\
    \ transformed_character: String;\n        match case_changed.as_ref() {\n    \
    \        \"a\" => transformed_character = String::from(\"c\"),\n            \"\
    e\" => transformed_character = String::from(\"g\"),\n            \"i\" => transformed_character\
    \ = String::from(\"k\"),\n            \"o\" => transformed_character = String::from(\"\
    o\"),\n            \"u\" => transformed_character = String::from(\"w\"),\n   \
    \         _ => transformed_character = case_changed.clone(),\n        }\n    \
    \    // replace the character at the index with the transformed character\n  \
    \      coded.replace_range(i..i+1, transformed_character.as_ref());\n    }\n \
    \   coded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpwv246jjo.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: Implement\n    let mut output = String::new();\n\
    \    let mut v = Vec::new();\n    v.push(b'e');\n    v.push(b'i');\n    v.push(b'o');\n\
    \    v.push(b'u');\n    v.push(b'a');\n    for i in message.into_bytes() {\n \
    \       if i >= b'a' && i <= b'z' || i >= b'A' && i <= b'Z' {\n            output.push(if\
    \ i <= b'Z' { i + 32 } else { i } as char);\n        } else {\n            output.push(i\
    \ as char);\n        }\n    }\n    let mut index = 0;\n    for item in output.into_bytes()\
    \ {\n        if v.contains(&item) {\n            match index % v.len() {\n   \
    \             0 => {\n                    if item == b'a' {\n                \
    \        v.push(b'c');\n                    } else {\n                       \
    \ v.push(item + 2);\n                    }\n                }\n              \
    \  1 => {\n                    if item == b'e' {\n                        v.push(b'g');\n\
    \                    } else {\n                        v.push(item + 2);\n   \
    \                 }\n                }\n                2 => {\n             \
    \       if item == b'i' {\n                        v.push(b'k');\n           \
    \         } else {\n                        v.push(item + 2);\n              \
    \      }\n                }\n                3 => {\n                    if item\
    \ == b'o' {\n                        v.push(b'm');\n                    } else\
    \ {\n                        v.push(item + 2);\n                    }\n      \
    \          }\n                4 => {\n                    if item == b'u' {\n\
    \                        v.push(b'w');\n                    } else {\n       \
    \                 v.push(item + 2);\n                    }\n                }\n\
    \                _ => {\n                    v.push(item);\n                }\n\
    \            }\n            index += 1;\n        } else {\n            v.push(item);\n\
    \        }\n    }\n    v.into_iter().map(|item| {\n        if item >= b'a' &&\
    \ item <= b'z' {\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz_ap5g2v.rs:87:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n75 |     v.into_iter().map(|item|\
    \ {\n   |                      -       - unclosed delimiter\n   |            \
    \          |\n   |                      unclosed delimiter\n76 |         if item\
    \ >= b'a' && item <= b'z' {\n   |                                         - this\
    \ delimiter might not be properly closed...\n77 | \n78 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n87 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz_ap5g2v.rs:75:5\n   |\n11 |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n75 | /     v.into_iter().map(|item| {\n76 | | \
    \        if item >= b'a' && item <= b'z' {\n77 | |\n78 | | }\n...  |\n86 | | \
    \    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"\
    k dQnT kNqW wHcT Tq wRkTg\"));\n87 | | }\n   | |__^ expected struct `String`,\
    \ found struct `Map`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Map<std::vec::IntoIter<u8>, [closure@/tmp/tmpz_ap5g2v.rs:75:23:\
    \ 87:3]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // let mut encoded_message = message.chars().map(|char|\
    \ {\n    //     if char.is_ascii_uppercase() {\n    //         char.to_ascii_lowercase()\n\
    \    //     } else {\n    //         char.to_ascii_uppercase()\n    //     }\n\
    \    // }).collect::<String>();\n\n    // for i in 0..encoded_message.len() {\n\
    \    //     if encoded_message.chars().nth(i).unwrap().is_ascii_alphabetic() {\n\
    \    //         let char = encoded_message.chars().nth(i).unwrap();\n    //  \
    \       let new_char = match char {\n    //             'a' => 'c',\n    //  \
    \           'e' => 'g',\n    //             'i' => 'k',\n    //             'o'\
    \ => 'q',\n    //             'u' => 'w',\n    //             _ => char\n    //\
    \         };\n    //         encoded_message.replace_range(i..i+1, &new_char.to_string());\n\
    \    //     }\n    // }\n\n    // encoded_message\n\n    message.chars().map(|char|\
    \ {\n        if char.is_ascii_uppercase() {\n            char.to_ascii_lowercase()\n\
    \        } else {\n            char.to_ascii_uppercase()\n        }\n    }).map(|char|\
    \ {\n        match char {\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n \
    \           _ => char\n        }\n    }).collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp1zspnj86.rs:58:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut msg = message.chars();\n    let mut coded_msg\
    \ = String::new();\n    for character in msg {\n        if character.is_alphabetic()\
    \ {\n            let new_char = match character.is_lowercase() {\n           \
    \     true => {\n                    let index = alphabet.iter().position(|&x|\
    \ x == character).unwrap();\n                    if vowels.contains(&character)\
    \ {\n                        alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \                    } else {\n                        alphabet[(index + 2) %\
    \ alphabet.len()].to_uppercase().next().unwrap()\n                    }\n    \
    \            },\n                false => {\n                    let index = alphabet.iter().position(|&x|\
    \ x == character.to_lowercase().next().unwrap()).unwrap();\n                 \
    \   if vowels.contains(&character.to_lowercase().next().unwrap()) {\n        \
    \                alphabet[(index + 2) % alphabet.len()]\n                    }\
    \ else {\n                        alphabet[(index + 2) % alphabet.len()]\n   \
    \                 }\n                }\n            };\n            coded_msg.push(new_char);\n\
    \        } else {\n            coded_msg.push(character);\n        }\n    }\n\
    \    coded_msg\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:18:33\n\
    \   |\n18 |                     let index = alphabet.iter().position(|&x| x ==\
    \ character).unwrap();\n   |                                 ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vowels` in this scope\n  -->\
    \ /tmp/tmpfp25ut4w.rs:19:24\n   |\n19 |                     if vowels.contains(&character)\
    \ {\n   |                        ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:20:25\n\
    \   |\n20 |                         alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:20:48\n\
    \   |\n20 |                         alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \   |                                                ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:22:25\n\
    \   |\n22 |                         alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:22:48\n\
    \   |\n22 |                         alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \   |                                                ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpfp25ut4w.rs:26:33\n\
    \   |\n26 |                     let index = alphabet.iter().position(|&x| x ==\
    \ character.to_lowercase().next().unwrap()).unwrap();\n   |                  \
    \               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `vowels` in this scope\n  --> /tmp/tmpfp25ut4w.rs:27:24\n   |\n27 |  \
    \                   if vowels.contains(&character.to_lowercase().next().unwrap())\
    \ {\n   |                        ^^^^^^ not f"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let base_char:\
    \ char = 'a';\n    let base_upper_char: char = 'A';\n    let mut char_count =\
    \ 0;\n    for ch in message.chars() {\n        if !ch.is_alphabetic() {\n    \
    \        result.push(ch);\n            continue;\n        }\n        match ch\
    \ {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n                if ch.is_uppercase()\
    \ {\n                    result.push((((ch as u8 - base_upper_char as u8 + 2)\
    \ % 26) as u8 + base_upper_char as u8) as char);\n                } else {\n \
    \                   result.push((((ch as u8 - base_char as u8 + 2) % 26) as u8\
    \ + base_char as u8) as char);\n                }\n            },\n          \
    \  _ => {\n                if ch.is_uppercase() {\n                    result.push(((ch\
    \ as u8 - base_upper_char as u8 + 1) % 26) as u8 as char);\n                }\
    \ else {\n                    result.push(((ch as u8 - base_char as u8 + 1) %\
    \ 26) as u8 as char);\n                }\n            }\n        }\n        char_count\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{14}\\u{5}\\u{13}\\u{14}\"`,\n right: `\"tgst\"`', /tmp/tmpr2frs8lw.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for character\
    \ in message.chars() {\n        if character.is_lowercase() {\n            let\
    \ encoded_character = encode_character(character);\n            result.push(encoded_character.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            let encoded_character = encode_character(character);\n\
    \            result.push(encoded_character.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_character` in this scope\n \
    \ --> /tmp/tmpl3ct0ilt.rs:15:37\n   |\n15 |             let encoded_character\
    \ = encode_character(character);\n   |                                     ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `encode_character`\
    \ in this scope\n  --> /tmp/tmpl3ct0ilt.rs:18:37\n   |\n18 |             let encoded_character\
    \ = encode_character(character);\n   |                                     ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let mut encoded = String::new();\n\
    \    for char in message.chars() {\n        if vowels.contains(char) {\n     \
    \       encoded.push(((char as u8) + 2) as char);\n        } else {\n        \
    \    encoded.push(char);\n        }\n    }\n    encoded\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpighil5q6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n     \
    \       'o' => 'q',\n            'u' => 'y',\n            'A' => 'C',\n      \
    \      'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n       \
    \     'U' => 'Y',\n            _ => c.to_ascii_uppercase(),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp_02zg4l2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let vowels2\
    \ = ['c', 'f', 'j', 'n', 'r'];\n    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        let mut index = vowels.iter().position(|&x|\
    \ x == character);\n        if index != None {\n            encoded_message.push(vowels2[index.unwrap()]);\n\
    \        } else {\n            index = vowels2.iter().position(|&x| x == character);\n\
    \            if index != None {\n                encoded_message.push(vowels[index.unwrap()]);\n\
    \            } else {\n                encoded_message.push(character);\n    \
    \        }\n        }\n    }\n    return encoded_message;\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpgbmemb6_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwm4v2zzw.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    for c in\
    \ message.chars() {\n        new_message.push(if let Some(vowel) = get_next_vowel(c)\
    \ {\n            vowel\n        } else {\n            c\n        });\n    }\n\
    \    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_next_vowel` in this scope\n  -->\
    \ /tmp/tmp_wsgo0us.rs:14:47\n   |\n14 |         new_message.push(if let Some(vowel)\
    \ = get_next_vowel(c) {\n   |                                               ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            output.push(increment_char(c, 2));\n        } else {\n      \
    \      output.push(if c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n\
    \            } else {\n                c.to_lowercase().next().unwrap()\n    \
    \        });\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `increment_char` in this scope\n  -->\
    \ /tmp/tmpunn45f10.rs:16:25\n   |\n16 |             output.push(increment_char(c,\
    \ 2));\n   |                         ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        match\
    \ c {\n            x if vowels.contains(&x) => {\n                let mut new_c\
    \ = x as u8 + 2;\n                if new_c >= vowels[vowels.len() - 1] as u8 {\n\
    \                    new_c -= vowels.len() as u8;\n                }\n       \
    \         encoded.push(new_c as char);\n            },\n            x if x.is_lowercase()\
    \ => encoded.push(x.to_uppercase().to_string().chars().nth(0).unwrap()),\n   \
    \         x if x.is_uppercase() => encoded.push(x.to_lowercase().to_string().chars().nth(0).unwrap()),\n\
    \            _ => encoded.push(c),\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpv8m7_2v_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n     \
    \           encoded.push(encode_char(c, b'a'));\n            } else {\n      \
    \          encoded.push(encode_char(c, b'A'));\n            }\n        } else\
    \ {\n            encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmp46llwca6.rs:16:30\n\
    \   |\n16 |                 encoded.push(encode_char(c, b'a'));\n   |        \
    \                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `encode_char` in this scope\n  --> /tmp/tmp46llwca6.rs:18:30\n\
    \   |\n18 |                 encoded.push(encode_char(c, b'A'));\n   |        \
    \                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpia2305ym.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            // If it's a vowel, it needs to advance by two\n            if\
    \ c.is_lowercase() {\n                match c {\n                    'a' => 'c',\n\
    \                    'e' => 'g',\n                    'i' => 'k',\n          \
    \          'o' => 'q',\n                    'u' => 'y',\n                    _\
    \ => {\n                        // If it's not a vowel, it's just going to \n\
    \                        // toggle to uppercase if it's lowercase and \n     \
    \                   // lowercase if it's uppercase\n                        if\
    \ c.is_lowercase() {\n                            c.to_uppercase().next().unwrap()\n\
    \                        } else {\n                            c.to_lowercase().next().unwrap()\n\
    \                        }\n                    }\n                }\n       \
    \     } else {\n                match c {\n                    'A' => 'C',\n \
    \                   'E' => 'G',\n                    'I' => 'K',\n           \
    \         'O' => 'Q',\n                    'U' => 'Y',\n                    _\
    \ => {\n                        if c.is_lowercase() {\n                      \
    \      c.to_uppercase().next().unwrap()\n                        } else {\n  \
    \                          c.to_lowercase().next().unwrap()\n                \
    \        }\n                    }\n                }\n            }\n        }\
    \ else {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpryv9hd4f.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let number = c as u8 - 'a' as u8;\n            let new_number\
    \ = number + 2;\n            let new_char = (new_number % 26 + 'a' as u8) as char;\n\
    \            encoded.push(new_char);\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp0s2e5tbf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let alphabet: Vec<char> = vec!['a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let vowels: Vec<char> = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut encoded_message: String = String::new();\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            let mut\
    \ index = alphabet.iter().position(|&a| a == c).unwrap();\n            index +=\
    \ 2;\n            if index > 25 {\n                index = index - 25;\n     \
    \       }\n            encoded_message.push(alphabet[index]);\n        } else\
    \ {\n            encoded_message.push(c);\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpm0ikmy0r.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        encoded_message.push(match c {\n            'A'\
    \ => 'C',\n            'a' => 'c',\n            'E' => 'G',\n            'e' =>\
    \ 'g',\n            'I' => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n\
    \            'o' => 'q',\n            'U' => 'S',\n            'u' => 's',\n \
    \           _ => c,\n        });\n    }\n    encoded_message\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpx65qdml2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = String::from(\"AEIOUaeiou\");\n    message.chars().map(|c|\
    \ {\n        if vowels.contains(c) {\n            let mut num: u8 = c as u8;\n\
    \            let mut x = 2;\n            while x > 0 {\n                num +=\
    \ 1;\n                if num == 90 {\n                    num = 65;\n        \
    \        } else if num == 122 {\n                    num = 97;\n             \
    \   }\n                x -= 1;\n            }\n            return (num as char).to_string();\n\
    \        } else if c.is_uppercase() {\n            return c.to_lowercase().to_string();\n\
    \        } else if c.is_lowercase() {\n            return c.to_uppercase().to_string();\n\
    \        } else {\n            return c.to_string();\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpamicd4ql.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\";\n    let vowels = \"aeiou\";\n    let message_upper\
    \ = message.to_uppercase();\n    let mut letter_counter = 0;\n    for c in message_upper.chars()\
    \ {\n        match vowels.contains(c) {\n            true => result.push(alphabet.chars().skip(alphabet.find(c).unwrap()\
    \ + 3).next().unwrap()),\n            false => result.push(alphabet.chars().skip(alphabet.find(c).unwrap()).next().unwrap())\n\
    \        }\n        letter_counter += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpn3ha_mxk.rs:20:73\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let result = message.chars().map(|c| {\n        match\
    \ c {\n            'A' => 'C',\n            'a' => 'c',\n            'E' => 'G',\n\
    \            'e' => 'g',\n            'I' => 'K',\n            'i' => 'k',\n \
    \           'O' => 'Q',\n            'o' => 'q',\n            'U' => 'S',\n  \
    \          'u' => 's',\n            c @ _ => c,\n        }\n    }).collect::<String>();\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpl0qmx3j4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpz1llvbnd.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  // TODO\n  \"\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpvs9eg_v3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c == 'a' {\n            encoded.push('c');\n        } else if\
    \ c == 'e' {\n            encoded.push('g');\n        } else if c == 'i' {\n \
    \           encoded.push('k');\n        } else if c == 'o' {\n            encoded.push('q');\n\
    \        } else if c == 'u' {\n            encoded.push('y');\n        } else\
    \ if c == 'A' {\n            encoded.push('C');\n        } else if c == 'E' {\n\
    \            encoded.push('G');\n        } else if c == 'I' {\n            encoded.push('K');\n\
    \        } else if c == 'O' {\n            encoded.push('Q');\n        } else\
    \ if c == 'U' {\n            encoded.push('Y');\n        } else {\n          \
    \  encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpz8t2hwjq.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s: String = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a' | 'A' => s.push('C'),\n            'e'\
    \ | 'E' => s.push('G'),\n            'i' | 'I' => s.push('K'),\n            'o'\
    \ | 'O' => s.push('M'),\n            'u' | 'U' => s.push('Q'),\n            _\
    \ => s.push(c),\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpmcchydzv.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO Implement this function\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1vbhoqr_.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let characters = message.chars();\n    let result =\
    \ characters.map(|c| {\n        match c {\n            'a' => 'c',\n         \
    \   'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n          \
    \  'u' => 'w',\n            'A' => 'C',\n            'E' => 'G',\n           \
    \ 'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n            'a'...'z'\
    \ => ((c as u8) + 2) as char,\n            'A'...'Z' => ((c as u8) + 2) as char,\n\
    \            _ => c,\n        }\n    });\n    result.collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpgt85i8tf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let upper_alphabet = ['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let lower_alphabet = ['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ result = String::new();\n    for letter in message.chars() {\n        let mut\
    \ l = letter;\n        if let Some(index) = upper_alphabet.iter().position(|&x|\
    \ x == letter) {\n            if let Some(vowel_index) = vowels.iter().position(|&x|\
    \ x == letter.to_lowercase().next().unwrap()) {\n                l = upper_alphabet[(index\
    \ + 2) % upper_alphabet.len()].to_lowercase().next().unwrap();\n            }\
    \ else {\n                l = upper_alphabet[(index + 2) % upper_alphabet.len()];\n\
    \            }\n        } else if let Some(index) = lower_alphabet.iter().position(|&x|\
    \ x == letter) {\n            if let Some(vowel_index) = vowels.iter().position(|&x|\
    \ x == letter) {\n                l = lower_alphabet[(index + 2) % lower_alphabet.len()];\n\
    \            } else {\n                l = lower_alphabet[(index + 2) % lower_alphabet.len()].to_uppercase().next().unwrap();\n\
    \            }\n        }\n        result.push(l);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VgUV\"`,\n right: `\"tgst\"`', /tmp/tmp6n2i8grg.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let message_bytes\
    \ = message.into_bytes();\n    let vowel_chars = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    for byte in message_bytes {\n        let byte_lower_char = byte.to_ascii_lowercase()\
    \ as char;\n        if vowel_chars.contains(&byte_lower_char) {\n            let\
    \ i = match byte_lower_char {\n                'a' => 'c',\n                'e'\
    \ => 'g',\n                'i' => 'k',\n                'o' => 'q',\n        \
    \        'u' => 'y',\n                _ => byte_lower_char,\n            };\n\
    \            encoded.push(i);\n        } else {\n            let byte_lower =\
    \ byte.to_ascii_lowercase();\n            let byte_upper = byte.to_ascii_uppercase();\n\
    \            encoded.push(match byte {\n                b if b == byte_lower =>\
    \ byte_upper as char,\n                b if b == byte_upper => byte_lower as char,\n\
    \                _ => byte as char,\n            });\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"myDcSkR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp5yzdnn4j.rs:43:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = message.chars().map(|x| swap_case(x)).collect::<String>();\n\
    \    result = message.chars().map(|x| replace_vowel(x)).collect::<String>();\n\
    \    return result;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap_case` in this scope\n  --> /tmp/tmpfo9wf_nl.rs:12:46\n\
    \   |\n12 |     let mut result = message.chars().map(|x| swap_case(x)).collect::<String>();\n\
    \   |                                              ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `replace_vowel` in this scope\n\
    \  --> /tmp/tmpfo9wf_nl.rs:13:38\n   |\n13 |     result = message.chars().map(|x|\
    \ replace_vowel(x)).collect::<String>();\n   |                               \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        match\
    \ c {\n            c if vowels.contains(&c) => {\n                let mut x =\
    \ c as u8;\n                x += 2;\n                let c = x as char;\n    \
    \            encoded_message.push(c);\n            }\n            _ => encoded_message.push(c.to_ascii_uppercase()),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpx0_8_wzx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Here, we create a lookup table for the encoded vowels\n\
    \    let encoded_vowels = [\"S\", \"T\", \"D\", \"F\", \"G\", \"H\", \"J\", \"\
    K\", \"L\"];\n    // The encoded string that we will return\n    let mut encoded_string\
    \ = String::new();\n    // A vector of all english alphabet letters\n    let alphabet\
    \ = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\n           \
    \         'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n      \
    \              'Y', 'Z'];\n    // A vector of all english alphabet vowels\n  \
    \  let vowels = ['A', 'E', 'I', 'O', 'U'];\n    // The vowels that will be encoded\n\
    \    let mut encoded_vowels = ['A', 'E', 'I', 'O', 'U'];\n    // The position\
    \ of the vowels in the alphabet vector\n    let mut vowel_pos = vec![];\n    //\
    \ A vector of all the encoded vowels\n    let mut encoded_letters = vec![];\n\
    \    // We first find the positions of all vowels in the alphabet\n    for j in\
    \ 0..5 {\n        for i in 0..26 {\n            if vowels[j] == alphabet[i] {\n\
    \                vowel_pos.push(i);\n            }\n        }\n    }\n    // We\
    \ use this information to create a vector of all the encoded vowels\n    for i\
    \ in 0..5 {\n        if vowel_pos[i] + 2 > 25 {\n            encoded_letters.push(alphabet[vowel_pos[i]\
    \ + 2 - 26]);\n        } else {\n            encoded_letters.push(alphabet[vowel_pos[i]\
    \ + 2]);\n        }\n    }\n    // We do this in reverse order so we can swap\
    \ the cases of all letters\n    for i in 0..5 {\n        encoded_vowels[i] = encoded_letters[4\
    \ - i];\n    }\n    // We loop through the message and swap case\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsls484fa.rs:45:5\n   |\n\
    11 |   fn encode(message: String) -> String {\n   |                          \
    \       ------ expected `String` because of return type\n...\n45 | /     for i\
    \ in 0..5 {\n46 | |         encoded_vowels[i] = encoded_letters[4 - i];\n47 |\
    \ |     }\n   | |_____^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let map = [\n        ('a', 'c'), ('e', 'g'), ('i',\
    \ 'k'), ('o', 'q'), ('u', 'w'), ('y', 'a'),\n        ('A', 'C'), ('E', 'G'), ('I',\
    \ 'K'), ('O', 'Q'), ('U', 'W'), ('Y', 'A'),\n    ];\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            let\
    \ mut inserted = false;\n            for (c1, c2) in map.iter() {\n          \
    \      if c == *c1 {\n                    result.push(*c2);\n                \
    \    inserted = true;\n                    break;\n                }\n       \
    \     }\n            if !inserted {\n                result.push(c);\n       \
    \     }\n        } else {\n            result.push(c);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpnzrj6otj.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6chxkpif.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  let mut encoded = String::new();\n  for c in message.chars()\
    \ {\n    let c = match c {\n      'A' => 'C',\n      'E' => 'G',\n      'I' =>\
    \ 'K',\n      'O' => 'Q',\n      'U' => 'S',\n      'a' => 'c',\n      'e' =>\
    \ 'g',\n      'i' => 'k',\n      'o' => 'q',\n      'u' => 's',\n      c => c.to_ascii_uppercase(),\n\
    \    };\n    encoded.push(c);\n  }\n  encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpmhfdsfhd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::from(\"\");\n   \
    \ let mut iter = message.chars();\n    while let Some(mut c) = iter.next() {\n\
    \        c = match c {\n            'a' => 'c',\n            'e' => 'g',\n   \
    \         'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n    \
    \        'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n     \
    \       'O' => 'Q',\n            'U' => 'Y',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        encoded_message.push(c);\n    }\n    encoded_message\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpwtdm_a_h.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for x in message.chars()\
    \ {\n        match x {\n            'a' => encoded.push('c'),\n            'e'\
    \ => encoded.push('g'),\n            'i' => encoded.push('k'),\n            'o'\
    \ => encoded.push('q'),\n            'u' => encoded.push('s'),\n            'A'\
    \ => encoded.push('C'),\n            'E' => encoded.push('G'),\n            'I'\
    \ => encoded.push('K'),\n            'O' => encoded.push('Q'),\n            'U'\
    \ => encoded.push('S'),\n            _ => encoded.push(x),\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp89nws8w2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // message\n    //     .chars()\n    //     .map(|c|\
    \ {\n    //         if c.is_ascii_lowercase() {\n    //             (c as u8 +\
    \ 2 - 97) % 26 + 97\n    //         } else {\n    //             (c as u8 + 2\
    \ - 65) % 26 + 65\n    //         }\n    //     })\n    //     .collect()\n  \
    \  let mut new_message = String::new();\n    for c in message.chars() {\n    \
    \    if c.is_ascii_lowercase() {\n            let i = (c as u8 + 2 - 97) % 26\
    \ + 97;\n            new_message.push(i as char);\n        } else {\n        \
    \    let i = (c as u8 + 2 - 65) % 26 + 65;\n            new_message.push(i as\
    \ char);\n        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpego08c_o.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| match c {\n        'a' => 'c',\n\
    \        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'w',\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n      \
    \  'O' => 'Q',\n        'U' => 'W',\n        _ => if c.is_uppercase() { c.to_lowercase().nth(0).unwrap()\
    \ } else { c.to_uppercase().nth(0).unwrap() }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpsy4obhuv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    for c in\
    \ message.chars() {\n        if c.is_ascii_lowercase() {\n            new_message.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            new_message.push(c.to_ascii_lowercase());\n\
    \        } else {\n            new_message.push(c);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpnq13jz2z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let message_chars:\
    \ Vec<char> = message.chars().collect();\n    for character in message_chars {\n\
    \        let encoded_char = match character {\n            'a' => 'c',\n     \
    \       'A' => 'C',\n            'e' => 'g',\n            'E' => 'G',\n      \
    \      'i' => 'k',\n            'I' => 'K',\n            'o' => 'q',\n       \
    \     'O' => 'Q',\n            'u' => 'y',\n            'U' => 'Y',\n        \
    \    'w' => 'y',\n            'W' => 'Y',\n            _ => character.to_ascii_uppercase(),\n\
    \        };\n        encoded_message.push(encoded_char);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp0w21p_az.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    return \"\";\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwkno8578.rs:12:12\n   |\n\
    11 | fn encode(message: String) -> String {\n   |                            \
    \   ------ expected `String` because of return type\n12 |     return \"\";\n \
    \  |            ^^- help: try using a conversion method: `.to_string()`\n   |\
    \            |\n   |            expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        let mut c = if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'y',\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpbx_5io4n.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    let lowercase\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let uppercase = ['A', 'E', 'I', 'O', 'U'];\n\
    \    for i in message.chars() {\n        let mut mapped = ' ';\n        for j\
    \ in 0..lowercase.len() {\n            if i == lowercase[j] {\n              \
    \  mapped = lowercase[(j + 2) % lowercase.len()];\n                break;\n  \
    \          } else if i == uppercase[j] {\n                mapped = uppercase[(j\
    \ + 2) % uppercase.len()];\n                break;\n            }\n        }\n\
    \        if mapped == ' ' {\n            if i.is_lowercase() {\n             \
    \   result.push(i.to_uppercase().next().unwrap());\n            } else {\n   \
    \             result.push(i.to_lowercase().next().unwrap());\n            }\n\
    \        } else {\n            result.push(mapped);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tOst\"`,\n right: `\"tgst\"`', /tmp/tmpkg2ng69o.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        if c.is_ascii_uppercase() {\n            encoded_message.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmps8is4j7u.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = \"\".to_string();\n    for c in message.chars()\
    \ {\n        encoded += &match c {\n            'a' => \"c\",\n            'A'\
    \ => \"C\",\n            'e' => \"g\",\n            'E' => \"G\",\n          \
    \  'i' => \"k\",\n            'I' => \"K\",\n            'o' => \"q\",\n     \
    \       'O' => \"Q\",\n            'u' => \"s\",\n            'U' => \"S\",\n\
    \            'y' => \"a\",\n            'Y' => \"A\",\n            x => x.to_uppercase().to_string().as_str(),\n\
    \        }.to_string();\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp2dj_d07f.rs:27:18\n\
    \   |\n14 |           encoded += &match c {\n   |  _____________________-\n15\
    \ | |             'a' => \"c\",\n16 | |             'A' => \"C\",\n17 | |    \
    \         'e' => \"g\",\n...  |\n27 | |             x => x.to_uppercase().to_string().as_str(),\n\
    \   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^        - temporary value\
    \ is freed at the end of this statement\n   | |                  |\n   | |   \
    \               creates a temporary which is freed while still in use\n28 | |\
    \         }.to_string();\n   | |_____________________- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a'...'z' => {\n                result.push(if\
    \ c == 'z' { 'B' } else { \n                    ((c as u8 + 2) as char).to_uppercase().nth(0).unwrap()\n\
    \                });\n            },\n            'A'...'Z' => {\n           \
    \     result.push(if c == 'Z' { 'b' } else { \n                    ((c as u8 +\
    \ 2) as char).to_lowercase().nth(0).unwrap()\n                });\n          \
    \  },\n            _ => result.push(c),\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vguv\"`,\n right: `\"tgst\"`', /tmp/tmp49h_nc3x.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for (i, ch) in\
    \ message.chars().enumerate() {\n        let mut new_ch = ch;\n        if ch.is_ascii_alphabetic()\
    \ {\n            if ch.is_ascii_lowercase() {\n                new_ch = ch.to_ascii_uppercase();\n\
    \            } else {\n                new_ch = ch.to_ascii_lowercase();\n   \
    \         }\n            if VOWELS.contains(&new_ch) {\n                new_ch\
    \ = shift_char(new_ch, 2);\n            }\n        }\n        encoded.push(new_ch);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmpjs6yv7vu.rs:21:16\n\
    \   |\n21 |             if VOWELS.contains(&new_ch) {\n   |                ^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `shift_char` in\
    \ this scope\n  --> /tmp/tmpjs6yv7vu.rs:22:26\n   |\n22 |                 new_ch\
    \ = shift_char(new_ch, 2);\n   |                          ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n     \
    \       'O' => 'Q',\n            'U' => 'W',\n            'a' => 'c',\n      \
    \      'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n       \
    \     'u' => 'w',\n            ch  => ch.to_ascii_uppercase(),\n        }\n  \
    \  }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp1yaf3pwt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut code = String::new();\n    for c in message.chars()\
    \ {\n        let mut letter = c;\n        if let Some(case) = is_letter(c) {\n\
    \            letter = encode_letter(letter, case);\n        }\n        code.push(letter);\n\
    \    }\n    code\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpuoz1uoqk.rs:15:29\n\
    \   |\n15 |         if let Some(case) = is_letter(c) {\n   |                 \
    \            ^^^^^^^^^ help: a local variable with a similar name exists: `letter`\n\
    \nerror[E0425]: cannot find function `encode_letter` in this scope\n  --> /tmp/tmpuoz1uoqk.rs:16:22\n\
    \   |\n16 |             letter = encode_letter(letter, case);\n   |          \
    \            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // unimplemented!()\n    let mut encoded_message =\
    \ String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for i in\
    \ message.chars() {\n        if i.is_lowercase() {\n            encoded_message.push(i.to_uppercase().next().unwrap());\n\
    \        } else if i.is_uppercase() {\n            encoded_message.push(i.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(i);\n        }\n    }\n  \
    \  for (i, c) in encoded_message.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.remove(i);\n            encoded_message.insert(i,\
    \ (c as u8 + 2) as char);\n        }\n    }\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `encoded_message` as mutable because it is\
    \ also borrowed as immutable\n  --> /tmp/tmpih6h2edn.rs:26:13\n   |\n24 |    \
    \ for (i, c) in encoded_message.chars().enumerate() {\n   |                  \
    \ -----------------------------------\n   |                   |\n   |        \
    \           immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n25 |         if vowels.contains(&c) {\n26 |             encoded_message.remove(i);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `encoded_message` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpih6h2edn.rs:27:13\n   |\n24 |     for (i, c) in encoded_message.chars().enumerate()\
    \ {\n   |                   -----------------------------------\n   |        \
    \           |\n   |                   immutable borrow occurs here\n   |     \
    \              immutable borrow later used here\n...\n27 |             encoded_message.insert(i,\
    \ (c as u8 + 2) as char);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let characters: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for character in characters\
    \ {\n        let ascii_value = character as u8;\n        let encoded_character\
    \ = match character {\n            // Upper case\n            'A' => 'C',\n  \
    \          'B' => 'D',\n            'C' => 'E',\n            'D' => 'F',\n   \
    \         'E' => 'G',\n            'F' => 'H',\n            'G' => 'I',\n    \
    \        'H' => 'J',\n            'I' => 'K',\n            'J' => 'L',\n     \
    \       'K' => 'M',\n            'L' => 'N',\n            'M' => 'O',\n      \
    \      'N' => 'P',\n            'O' => 'Q',\n            'P' => 'R',\n       \
    \     'Q' => 'S',\n            'R' => 'T',\n            'S' => 'U',\n        \
    \    'T' => 'V',\n            'U' => 'W',\n            'V' => 'X',\n         \
    \   'W' => 'Y',\n            'X' => 'Z',\n            'Y' => 'A',\n          \
    \  'Z' => 'B',\n            // Lower case\n            'a' => 'c',\n         \
    \   'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n          \
    \  'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n           \
    \ 'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n            'k'\
    \ => 'm',\n            'l' => 'n',\n            'm' => 'o',\n            'n' =>\
    \ 'p',\n            'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n\
    \            'r' => 't',\n            's' => 'u',\n            't' => 'v',\n \
    \           'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3g4bjveb.rs:78:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for character in characters\
    \ {\n   |                                 - unclosed delimiter\n15 |         let\
    \ ascii_value = character as u8;\n16 |         let encoded_character = match character\
    \ {\n   |                                                 - this delimiter might\
    \ not be properly closed...\n...\n69 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n78 | }\n   |   ^\n\nerror: expected one of `.`,\
    \ `;`, `?`, `else`, or an operator, found keyword `fn`\n  --> /tmp/tmp3g4bjveb.rs:71:1\n\
    \   |\n69 | }\n   |  - expected one of `.`, `;`, `?`, `else`, or an operator\n\
    70 | \n71 | fn main() {\n   | ^^ unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3g4bjveb.rs:14:5\n   |\n11 |   fn encode(message: String)\
    \ -> String {\n   |                                 ------ expected `String` because\
    \ of return type\n...\n14 | /     for character in characters {\n15 | |      \
    \   let ascii_value = character as u8;\n16 | |         let encoded_character =\
    \ match character {\n17 | |             // Upper case\n...  |\n77 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    78 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = message.to_lowercase();\n    let mut\
    \ vowels = String::new();\n    for i in 0..message.len() {\n        let c = message.chars().nth(i).unwrap();\n\
    \        if is_vowel(c) {\n            result.remove(i);\n            vowels.push(encode_vowel(c));\n\
    \        }\n    }\n    result.push_str(&vowels);\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7uob6ohc.rs:16:12\n\
    \   |\n16 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `encode_vowel` in this scope\n \
    \ --> /tmp/tmp7uob6ohc.rs:18:25\n   |\n18 |             vowels.push(encode_vowel(c));\n\
    \   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut ret = String::new();\n    let mut first = true;\n\
    \    for c in message.chars() {\n        if first {\n            ret.push(c.to_ascii_uppercase());\n\
    \            first = false;\n        } else {\n            ret.push(c.to_ascii_lowercase());\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Test\"`,\n right: `\"tgst\"`', /tmp/tmpi8sgy33d.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        encoded_message.push(match c {\n            'a'\
    \ | 'A' => 'C',\n            'e' | 'E' => 'G',\n            'i' | 'I' => 'K',\n\
    \            'o' | 'O' => 'M',\n            'u' | 'U' => 'Q',\n            'b'\
    \ | 'B' => 'D',\n            'c' | 'C' => 'E',\n            'd' | 'D' => 'F',\n\
    \            'f' | 'F' => 'H',\n            'g' | 'G' => 'I',\n            'h'\
    \ | 'H' => 'J',\n            'j' | 'J' => 'L',\n            'k' | 'K' => 'M',\n\
    \            'l' | 'L' => 'N',\n            'm' | 'M' => 'O',\n            'n'\
    \ | 'N' => 'P',\n            'p' | 'P' => 'R',\n            'q' | 'Q' => 'S',\n\
    \            'r' | 'R' => 'T',\n            's' | 'S' => 'U',\n            't'\
    \ | 'T' => 'V',\n            'v' | 'V' => 'X',\n            'w' | 'W' => 'Y',\n\
    \            'x' | 'X' => 'Z',\n            'y' | 'Y' => 'A',\n            'z'\
    \ | 'Z' => 'B',\n            _ => ' ',\n        });\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpq9b4gdge.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'A' | 'a' => 'C',\n            'E' | 'e' => 'G',\n            'I' | 'i'\
    \ => 'K',\n            'O' | 'o' => 'Q',\n            'U' | 'u' => 'S',\n    \
    \        'Y' | 'y' => 'A',\n            _ => {\n                match c.is_lowercase()\
    \ {\n                    true => c.to_uppercase().next().unwrap(),\n         \
    \           false => c.to_lowercase().next().unwrap(),\n                }\n  \
    \          }\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpr9gybnp6.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut skip =\
    \ false;\n    for (index, character) in message.chars().enumerate() {\n      \
    \  if skip {\n            skip = false;\n            continue;\n        }\n  \
    \      let new_char = match character {\n            'a' => 'c',\n           \
    \ 'A' => 'C',\n            'e' => 'g',\n            'E' => 'G',\n            'i'\
    \ => 'k',\n            'I' => 'K',\n            'o' => 'q',\n            'O' =>\
    \ 'Q',\n            'u' => 'y',\n            'U' => 'Y',\n            ' ' => '\
    \ ',\n            x if x.is_uppercase() => {\n                x.to_ascii_lowercase()\n\
    \            },\n            x if x.is_lowercase() => {\n                x.to_ascii_uppercase()\n\
    \            },\n            _ => character\n        };\n        result.push(new_char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmply_rc0i_.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let message =\
    \ message.to_lowercase();\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    for c in message.chars() {\n        match c {\n           \
    \ 'a' => encoded.push_str(\"c\"),\n            'e' => encoded.push_str(\"g\"),\n\
    \            'i' => encoded.push_str(\"k\"),\n            'o' => encoded.push_str(\"\
    q\"),\n            'u' => encoded.push_str(\"s\"),\n            _ => encoded.push(c)\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"msdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp4vwfyfg9.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppk30oz8u.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message_vec: Vec<char> = message.chars().collect();\n\
    \    let mut result: Vec<char> = Vec::new();\n    let letters: Vec<char> = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let shift: i32 = 2;\n    let a_int: i32 = 'a' as i32;\n\
    \    let z_int: i32 = 'z' as i32;\n    let A_int: i32 = 'A' as i32;\n    let Z_int:\
    \ i32 = 'Z' as i32;\n\n    for ch in message_vec {\n        if ch.is_lowercase()\
    \ {\n            let mut ch_int: i32 = ch as i32;\n            ch_int += shift;\n\
    \            if ch_int > z_int {\n                ch_int -= 26;\n            }\n\
    \            if letters.contains(&ch) {\n                result.push(letters[(ch_int\
    \ - a_int) as usize]);\n            } else {\n                result.push(ch_int\
    \ as u8 as char);\n            }\n        } else if ch.is_uppercase() {\n    \
    \        let mut ch_int: i32 = ch as i32;\n            ch_int += shift;\n    \
    \        if ch_int > Z_int {\n                ch_int -= 26;\n            }\n \
    \           if letters.contains(&ch.to_lowercase().next().unwrap()) {\n      \
    \          result.push(letters[(ch_int - a_int) as usize].to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(ch_int as u8 as char);\n  \
    \          }\n        } else {\n            result.push(ch);\n        }\n    }\n\
    \    let mut result_string: String = String::new();\n    for ch in result {\n\
    \        result_string.push(ch);\n    }\n    result_string\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 18446744073709551590', /tmp/tmpcsfszo9m.rs:40:29\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message_chars = message.chars();\n    let mut\
    \ message_string = String::new();\n    while let Some(mut a) = message_chars.next()\
    \ {\n        match a {\n            'A' => a = 'C',\n            'a' => a = 'c',\n\
    \            'B' => a = 'D',\n            'b' => a = 'd',\n            'C' =>\
    \ a = 'E',\n            'c' => a = 'e',\n            'D' => a = 'F',\n       \
    \     'd' => a = 'f',\n            'E' => a = 'G',\n            'e' => a = 'g',\n\
    \            'F' => a = 'H',\n            'f' => a = 'h',\n            'G' =>\
    \ a = 'I',\n            'g' => a = 'i',\n            'H' => a = 'J',\n       \
    \     'h' => a = 'j',\n            'I' => a = 'K',\n            'i' => a = 'k',\n\
    \            'J' => a = 'L',\n            'j' => a = 'l',\n            'K' =>\
    \ a = 'M',\n            'k' => a = 'm',\n            'L' => a = 'N',\n       \
    \     'l' => a = 'n',\n            'M' => a = 'O',\n            'm' => a = 'o',\n\
    \            'N' => a = 'P',\n            'n' => a = 'p',\n            'O' =>\
    \ a = 'Q',\n            'o' => a = 'q',\n            'P' => a = 'R',\n       \
    \     'p' => a = 'r',\n            'Q' => a = 'S',\n            'q' => a = 's',\n\
    \            'R' => a = 'T',\n            'r' => a = 't',\n            'S' =>\
    \ a = 'U',\n            's' => a = 'u',\n            'T' => a = 'V',\n       \
    \     't' => a = 'v',\n            'U' => a = 'W',\n            'u' => a = 'w',\n\
    \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpks8i0wjg.rs:68:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     while let Some(mut a) =\
    \ message_chars.next() {\n   |                                               \
    \   - unclosed delimiter\n15 |         match a {\n   |                 - this\
    \ delimiter might not be properly closed...\n...\n59 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n68 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpks8i0wjg.rs:14:5\n   |\n11 |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n14 | /     while let Some(mut a) = message_chars.next()\
    \ {\n15 | |         match a {\n16 | |             'A' => a = 'C',\n17 | |    \
    \         'a' => a = 'c',\n...  |\n67 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    68 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut encrypted_message = Vec::new();\n    for c in message.chars() {\n      \
    \  if vowels.contains(&c) {\n            encrypted_message.push(vowels[(vowels.iter().position(|&v|\
    \ v == c).unwrap() + 2) % 5]);\n        } else {\n            encrypted_message.push(c);\n\
    \        }\n    }\n    encrypted_message.iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmplvsdvaff.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for character in message.chars() {\n   \
    \     if vowels.contains(&character) {\n            let new_char = match character\
    \ {\n                'a' => 'c',\n                'e' => 'g',\n              \
    \  'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n   \
    \             _ => ' ',\n            };\n            encoded.push(new_char);\n\
    \        } else {\n            if character.is_lowercase() {\n               \
    \ encoded.push(character.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \            } else {\n                encoded.push(character.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpgdz_v60p.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'a' | 'e' | 'i' | 'o' | 'u' => ((c as u8) + 2) as char,\n           \
    \ _ => c,\n        }\n    }).map(|c| {\n        match c {\n            'a' ...\
    \ 'z' => ((c as u8) - 32) as char,\n            'A' ... 'Z' => ((c as u8) + 32)\
    \ as char,\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpsios82q8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  \
    \  let mut new_message = String::new();\n    for c in message.chars() {\n    \
    \    match c {\n            'a' ... 'z' => {\n                let new_char = if\
    \ c.is_uppercase() {\n                    alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c.to_lowercase().nth(0).unwrap()).unwrap() + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n\
    \                } else {\n                    alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c).unwrap() + 2) % 26)).collect::<String>()\n                };\n     \
    \           new_message.push_str(&new_char);\n            },\n            'A'\
    \ ... 'Z' => {\n                let new_char = if c.is_lowercase() {\n       \
    \             alphabet.chars().nth(((alphabet.chars().position(|x| x == c.to_lowercase().nth(0).unwrap()).unwrap()\
    \ + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n                } else\
    \ {\n                    alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c.to_lowercase().nth(0).unwrap()).unwrap() + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n\
    \                };\n                new_message.push_str(&new_char);\n      \
    \      },\n            _ => { new_message.push(c); }\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpx7v4elcv.rs:16:17\n\
    \   |\n16 |             'a' ... 'z' => {\n   |                 ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpx7v4elcv.rs:18:42\n\
    \   |\n18 | ...   alphabet.chars().nth(((alphabet.chars().position(|x| x == c.to_lowercase().nth(0).unwrap()).unwrap()\
    \ + 2) % 26)).unwrap().to_upperc...\n   |                            ^       \
    \                                                                            \
    \     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n18 -                     alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c.to_lowercase().nth(0).unwrap()).unwrap() + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n\
    18 +                     alphabet.chars().nth((alphabet.chars().position(|x| x\
    \ == c.to_lowercase().nth(0).unwrap()).unwrap() + 2) % 26).unwrap().to_uppercase().collect::<String>()\n\
    \   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpx7v4elcv.rs:20:42\n\
    \   |\n20 |                     alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c).unwrap() + 2) % 26)).collect::<String>()\n   |                     \
    \                     ^                                                      \
    \   ^\n   |\nhelp: remove these parentheses\n   |\n20 -                     alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c).unwrap() + 2) % 26)).collect::<String>()\n20 +                     alphabet.chars().nth((alphabet.chars().position(|x|\
    \ x == c).unwrap() + 2) % 26).collect::<String>()\n   | \n\nwarning: `...` range\
    \ patterns are deprecated\n  --> /tmp/tmpx7v4elcv.rs:24:17\n   |\n24 |       \
    \      'A' ... 'Z' => {"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        let c = if is_vowel(c) {\n            get_next_vowel(c,\
    \ 2)\n        } else {\n            c\n        };\n        encoded_message.push(c.to_ascii_uppercase());\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsdneqk99.rs:14:20\n\
    \   |\n14 |         let c = if is_vowel(c) {\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `get_next_vowel`\
    \ in this scope\n  --> /tmp/tmpsdneqk99.rs:15:13\n   |\n15 |             get_next_vowel(c,\
    \ 2)\n   |             ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'a' => 'c',\n            'A' => 'C',\n            'e' => 'g',\n     \
    \       'E' => 'G',\n            'i' => 'k',\n            'I' => 'K',\n      \
    \      'o' => 'q',\n            'O' => 'Q',\n            'u' => 'y',\n       \
    \     'U' => 'Y',\n            ' ' => ' ',\n            _ => match c.is_uppercase()\
    \ {\n                true => (c as u8 + 2 - 'A' as u8) as char,\n            \
    \    false => (c as u8 + 2 - 'a' as u8) as char,\n            }\n        }\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{15}G\\u{14}\\u{15}\"`,\n right: `\"tgst\"`', /tmp/tmp2fd22b41.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::from(\"\");\n    for c in\
    \ message.chars() {\n        if c.is_lowercase() {\n            encoded.push(c.to_uppercase().collect::<String>());\n\
    \        } else if c.is_uppercase() {\n            encoded.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpufw40bpu.rs:15:26\n   |\n\
    15 |             encoded.push(c.to_uppercase().collect::<String>());\n   |   \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufw40bpu.rs:17:26\n\
    \   |\n17 |             encoded.push(c.to_lowercase().collect::<String>());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO\n    \"\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpk8tvogzu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let new_message = message.chars().map(|ch| {\n    \
    \    if ch.is_alphabetic() {\n            let key = match ch.is_uppercase() {\n\
    \                true => (b'A' as u8, b'Z' as u8),\n                false => (b'a'\
    \ as u8, b'z' as u8),\n            };\n            let c = ch as u8;\n       \
    \     let tmp = c + 2;\n            let tmp2 = match tmp {\n                x\
    \ if x > key.1 => x - 26,\n                _ => tmp,\n            };\n       \
    \     tmp2 as char\n        } else {\n            ch\n        }\n    }).collect::<String>();\n\
    \    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmph7aavnx3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = Vec::with_capacity(message_chars.len());\n    for\
    \ c in message_chars {\n        if is_vowel(c) {\n            let encoded_c =\
    \ if c == 'u' {\n                'a'\n            } else {\n                (c\
    \ as u8 + 2) as char\n            };\n            encoded_message.push(encoded_c.to_uppercase().to_string());\n\
    \        } else {\n            encoded_message.push(c.to_lowercase().to_string());\n\
    \        }\n    }\n    encoded_message.join(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpr6kjd5jd.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut final_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let new_vowel = match c {\n                'a' => 'c',\n    \
    \            'e' => 'g',\n                'i' => 'k',\n                'o' =>\
    \ 'q',\n                'u' => 'y',\n                _ => c,\n            };\n\
    \            final_message.push(new_vowel);\n        } else {\n            let\
    \ new_char = match c {\n                'A'...'Z' => c.to_ascii_lowercase(),\n\
    \                'a'...'z' => c.to_ascii_uppercase(),\n                _ => c,\n\
    \            };\n            final_message.push(new_char);\n        }\n    }\n\
    \    final_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpcmhpeepf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut encoded = message.chars().map(|c| {\n        match c {\n            'A'...'Z'\
    \ => {\n                (((c as u8) - 65 + 13) % 26 + 65) as char\n          \
    \  },\n            'a'...'z' => {\n                let offset = if vowels.contains(&c)\
    \ { 2 } else { 0 };\n                (((c as u8) - 97 + 13 + offset) % 26 + 97)\
    \ as char\n            },\n            _ => c\n        }\n    }).collect::<String>();\n\
    \    encoded.make_ascii_uppercase();\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"GRFG\"`,\n right: `\"tgst\"`', /tmp/tmpf9j8z583.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        encoded_message.push(match character {\n     \
    \       'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n      \
    \      'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n       \
    \     'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n        \
    \    'U' => 'W',\n            c => c.to_ascii_uppercase(),\n        });\n    }\n\
    \    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpw11ekrg7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let mut temp = (c as u8 + 2) as char;\n            if temp >\
    \ 'z' {\n                temp = (temp as u8 - 26) as char;\n            }\n  \
    \          result.push(temp);\n        } else if c.is_ascii_lowercase() {\n  \
    \          result.push(c.to_ascii_uppercase());\n        } else {\n          \
    \  result.push(c.to_ascii_lowercase());\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpoehl73z9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let code = c as u8;\n       \
    \     let new_char = if code <= 109 {\n                code + 2\n            }\
    \ else {\n                code - 24\n            };\n            result.push(new_char\
    \ as char);\n        } else {\n            result.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmptts0rfca.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        match c {\n    \
    \        'a' ... 'w' => (c as u8 + 2) as char,\n            'x' => 'a',\n    \
    \        'y' => 'b',\n            'z' => 'c',\n            'A' ... 'W' => (c as\
    \ u8 + 2) as char,\n            'X' => 'A',\n            'Y' => 'B',\n       \
    \     'Z' => 'C',\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpj04h2lb6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n        if\
    \ letter.is_lowercase() {\n            encoded_message.push(letter.to_uppercase().next().unwrap());\n\
    \        } else if letter.is_uppercase() {\n            encoded_message.push(letter.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    }\n\
    \    for vowel in vowels.iter() {\n        encoded_message = encoded_message.replace(*vowel,\
    \ \"\");\n    }\n    for vowel in vowels.iter() {\n        let l = vowel.to_string().to_uppercase().chars().next().unwrap();\n\
    \        let mut next = l;\n        for _ in 0..2 {\n            next = next.to_string().to_uppercase().chars().next().unwrap();\n\
    \        }\n        let l = vowel.to_string().to_lowercase().chars().next().unwrap();\n\
    \        let mut next_low = l;\n        for _ in 0..2 {\n            next_low\
    \ = next_low.to_string().to_lowercase().chars().next().unwrap();\n        }\n\
    \        encoded_message = encoded_message.replace(vowel, &next.to_string());\n\
    \        encoded_message = encoded_message.replace(&l.to_string(), &next_low.to_string());\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmpl51rcsb4.rs:37:43\n\
    \    |\n37  |         encoded_message = encoded_message.replace(vowel, &next.to_string());\n\
    \    |                                           ^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n    |\n    = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n    = help: the trait `Pattern<'a>` is implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|ch| {\n        match ch {\n  \
    \          'a' | 'e' | 'i' | 'o' | 'u' => encode_vowel(ch),\n            _ =>\
    \ encode_other(ch),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_vowel` in this scope\n  -->\
    \ /tmp/tmpy8l5hna8.rs:14:44\n   |\n14 |             'a' | 'e' | 'i' | 'o' | 'u'\
    \ => encode_vowel(ch),\n   |                                            ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `encode_other`\
    \ in this scope\n  --> /tmp/tmpy8l5hna8.rs:15:18\n   |\n15 |             _ =>\
    \ encode_other(ch),\n   |                  ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Split the message into an array of characters\n\
    \    let chars: Vec<char> = message.chars().collect();\n    // Iterate through\
    \ each character in the message and perform operations\n    let mut encoded_string\
    \ = \"\".to_string();\n    for ch in chars {\n        let mut encoded_char = ch;\n\
    \        // If the character is a vowel, increment it by 2 places\n        if\
    \ (ch == 'a') || (ch == 'e') || (ch == 'i') || (ch == 'o') || (ch == 'u') {\n\
    \            encoded_char = (ch as u8 + 2) as char;\n        }\n        // If\
    \ the character is a lowercase letter, convert it to uppercase\n        if ch.is_ascii_lowercase()\
    \ {\n            encoded_char = ch.to_ascii_uppercase();\n        }\n        //\
    \ If the character is a uppercase letter, convert it to lowercase\n        if\
    \ ch.is_ascii_uppercase() {\n            encoded_char = ch.to_ascii_lowercase();\n\
    \        }\n        // Append the encoded character to the output string\n   \
    \     encoded_string.push(encoded_char);\n    }\n    // Return the encoded string\n\
    \    encoded_string\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpny71wyp_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in message.chars()\
    \ {\n        if c == 'a' {\n            encrypted.push('c');\n        } else if\
    \ c == 'A' {\n            encrypted.push('C');\n        } else if c == 'e' {\n\
    \            encrypted.push('g');\n        } else if c == 'E' {\n            encrypted.push('G');\n\
    \        } else if c == 'i' {\n            encrypted.push('k');\n        } else\
    \ if c == 'I' {\n            encrypted.push('K');\n        } else if c == 'o'\
    \ {\n            encrypted.push('q');\n        } else if c == 'O' {\n        \
    \    encrypted.push('Q');\n        } else if c == 'u' {\n            encrypted.push('y');\n\
    \        } else if c == 'U' {\n            encrypted.push('Y');\n        } else\
    \ if c.is_lowercase() {\n            encrypted.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            encrypted.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encrypted.push(c);\n        }\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp9k43tcfe.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = message.chars().map(|c| encode_character(c));\n\
    \    let result: String = encoded_message.collect();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_character` in this scope\n \
    \ --> /tmp/tmpu7omp1ub.rs:12:55\n   |\n12 |     let mut encoded_message = message.chars().map(|c|\
    \ encode_character(c));\n   |                                                \
    \       ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    return\
    \ encoded;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp8wn2iuy6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_lowercase() {\n            output.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            output.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    return output;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp5al6enin.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut ret = String::new();\n    for c in message.chars()\
    \ {\n        if is_vowel(c) {\n            let v = shift_two(c);\n           \
    \ ret.push(v);\n        } else {\n            let x = shift_case(c);\n       \
    \     ret.push(x);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2iolz8du.rs:14:12\n\
    \   |\n14 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `shift_two` in this scope\n  -->\
    \ /tmp/tmp2iolz8du.rs:15:21\n   |\n15 |             let v = shift_two(c);\n  \
    \ |                     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `shift_case` in this scope\n  --> /tmp/tmp2iolz8du.rs:18:21\n\
    \   |\n18 |             let x = shift_case(c);\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        let x = match c {\n            'a' => 'c',\n \
    \           'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n  \
    \          'u' => 'w',\n            x if x.is_uppercase() => x.to_lowercase().next().unwrap(),\n\
    \            x if x.is_lowercase() => x.to_uppercase().next().unwrap(),\n    \
    \        _ => c,\n        };\n        encoded_message.push(x);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpmhpp13ca.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let alpabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            if c.is_ascii_lowercase()\
    \ {\n                if alpabet.contains(&c) {\n                    result.push(alpabet[(c\
    \ as usize + 2) % 26]);\n                } else {\n                    result.push(c);\n\
    \                }\n            } else {\n                result.push(c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            if c.is_ascii_lowercase() {\n  \
    \              if alpabet.contains(&c) {\n                    result.push(alpabet[(c\
    \ as usize + 2) % 26].to_ascii_uppercase());\n                } else {\n     \
    \               result.push(c);\n                }\n            } else {\n   \
    \             result.push(c.to_ascii_uppercase());\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpsbjvm2wp.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let mut\
    \ vowels = HashSet::new();\n    vowels.insert('a');\n    vowels.insert('e');\n\
    \    vowels.insert('i');\n    vowels.insert('o');\n    vowels.insert('u');\n \
    \   vowels.insert('A');\n    vowels.insert('E');\n    vowels.insert('I');\n  \
    \  vowels.insert('O');\n    vowels.insert('U');\n    for c in message.chars()\
    \ {\n        if c.is_lowercase() {\n            encoded_message.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  let mut new_message = String::new();\n    for c in encoded_message.chars()\
    \ {\n        if vowels.contains(&c) {\n            new_message.push(get_next_vowel(c));\n\
    \        } else {\n            new_message.push(c);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpf5de836l.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find function `get_next_vowel` in this scope\n  --> /tmp/tmpf5de836l.rs:36:30\n\
    \   |\n36 |             new_message.push(get_next_vowel(c));\n   |           \
    \                   ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        if is_vowel(character) {\n            encoded_message.push(get_next_vowel(character));\n\
    \        } else {\n            if is_upper(character) {\n                encoded_message.push(get_lower(character));\n\
    \            } else {\n                encoded_message.push(get_upper(character));\n\
    \            }\n        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpe4yn2h58.rs:14:12\n\
    \   |\n14 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `get_next_vowel` in this\
    \ scope\n  --> /tmp/tmpe4yn2h58.rs:15:34\n   |\n15 |             encoded_message.push(get_next_vowel(character));\n\
    \   |                                  ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_upper` in this scope\n  --> /tmp/tmpe4yn2h58.rs:17:16\n\
    \   |\n17 |             if is_upper(character) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `get_lower` in\
    \ this scope\n  --> /tmp/tmpe4yn2h58.rs:18:38\n   |\n18 |                 encoded_message.push(get_lower(character));\n\
    \   |                                      ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `get_upper` in this scope\n  --> /tmp/tmpe4yn2h58.rs:20:38\n\
    \   |\n20 |                 encoded_message.push(get_upper(character));\n   |\
    \                                      ^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // do some cool stuff and return a string here\n  \
    \  let map = |c: char| {\n        let c = c.to_lowercase().next().unwrap();\n\
    \        match c {\n            'a' => 'c',\n            'e' => 'g',\n       \
    \     'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n        \
    \    other => other,\n        }\n    };\n    message.chars().map(map).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp1m08glle.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut msg = message.clone();\n    let mut new_msg\
    \ = String::new();\n    for c in msg.chars() {\n        if c.is_alphabetic() {\n\
    \            new_msg.push(match c {\n                'a' => 'c',\n           \
    \     'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 'y',\n                _ => c.to_ascii_uppercase(),\n \
    \           });\n        } else {\n            new_msg.push(c);\n        }\n \
    \   }\n    new_msg\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpkshhm982.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::from(\"\");\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for i in message.to_lowercase().chars() {\n\
    \        if vowels.contains(&i) {\n            encoded.push((i as u8 + 2) as char);\n\
    \        } else {\n            encoded.push(i);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mwdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpe466l3ek.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        if is_vowel(c) {\n\
    \            encode_vowel(c)\n        } else {\n            encode_other(c)\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp26xqi43k.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `encode_vowel` in this scope\n \
    \ --> /tmp/tmp26xqi43k.rs:14:13\n   |\n14 |             encode_vowel(c)\n   |\
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `encode_other` in this scope\n  --> /tmp/tmp26xqi43k.rs:16:13\n   |\n\
    16 |             encode_other(c)\n   |             ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ out = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            out.push((c as u8 + 2) as char);\n        } else {\n        \
    \    out.push(c);\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpwhoa13xt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: Implement!\n    \"\".to_string()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmp3t97b0ir.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let swap_case = |c: char| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else {\n        \
    \    c.to_lowercase().next().unwrap()\n        }\n    };\n\n    let encode_char\
    \ = |c: char| {\n        if c.is_alphabetic() {\n            let start = if c.is_lowercase()\
    \ { b'a' } else { b'A' };\n            let encoded = (c as u8) + 2 - start;\n\
    \            if encoded > b'z' - start {\n                (start + (encoded -\
    \ (b'z' - start + 1))) as char\n            } else {\n                encoded\
    \ as char\n            }\n        } else {\n            c\n        }\n    };\n\
    \n    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        if c.is_alphabetic() {\n            encoded_message.push(swap_case(c));\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n\n\
    \    encoded_message.chars().map(encode_char).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{15}\\u{6}\\u{14}\\u{15}\"`,\n right: `\"tgst\"`', /tmp/tmp_qg2rkoz.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let alphabet: Vec<&str> = \"abcdefghijklmnopqrstuvwxyz\"\
    .split(\"\").collect();\n    let mut new_message = String::new();\n    for character\
    \ in message.chars() {\n        if character.is_alphabetic() {\n            let\
    \ character_index = get_index(character);\n            if character.is_lowercase()\
    \ {\n                let new_index = get_new_index(character_index);\n       \
    \         new_message.push_str(alphabet[new_index]);\n            } else {\n \
    \               let new_index = get_new_index(character_index);\n            \
    \    new_message.push_str(alphabet[new_index].to_uppercase().as_str());\n    \
    \        }\n        } else {\n            new_message.push(character);\n     \
    \   }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmppb0qh4rb.rs:16:35\n\
    \   |\n16 |             let character_index = get_index(character);\n   |    \
    \                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_new_index` in this scope\n  --> /tmp/tmppb0qh4rb.rs:18:33\n\
    \   |\n18 |                 let new_index = get_new_index(character_index);\n\
    \   |                                 ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `get_new_index` in this scope\n  --> /tmp/tmppb0qh4rb.rs:21:33\n\
    \   |\n21 |                 let new_index = get_new_index(character_index);\n\
    \   |                                 ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut s = String::new();\n    for i in message.chars()\
    \ {\n        let res = if is_vowel(i) {\n            match next_vowel(i) {\n \
    \               Some(v) => v,\n                None => ' ',\n            }\n \
    \       } else {\n            i\n        };\n        s.push(res);\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6aq2vvp1.rs:14:22\n\
    \   |\n14 |         let res = if is_vowel(i) {\n   |                      ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `next_vowel` in\
    \ this scope\n  --> /tmp/tmp6aq2vvp1.rs:15:19\n   |\n15 |             match next_vowel(i)\
    \ {\n   |                   ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut message_encoded = String::new();\n    for c\
    \ in message.chars() {\n        let x: u8 = c as u8;\n        let x_encoded: u8;\n\
    \        if x >= 97 && x <= 122 {\n            x_encoded = x - 32;\n        }\
    \ else if x >= 65 && x <= 90 {\n            x_encoded = x + 32;\n        } else\
    \ {\n            x_encoded = x;\n        }\n        let y: char = x_encoded as\
    \ char;\n        match y {\n            'A' => message_encoded.push('C'),\n  \
    \          'E' => message_encoded.push('G'),\n            'I' => message_encoded.push('K'),\n\
    \            'O' => message_encoded.push('Q'),\n            'U' => message_encoded.push('S'),\n\
    \            'Y' => message_encoded.push('A'),\n            _ => message_encoded.push(y),\n\
    \        }\n    }\n    message_encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpj0lfzy77.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_string = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for ch in message.chars() {\n        if ch.is_ascii_lowercase()\
    \ {\n            encoded_string.push(ch.to_ascii_uppercase());\n        } else\
    \ if ch.is_ascii_uppercase() {\n            encoded_string.push(ch.to_ascii_lowercase());\n\
    \        } else {\n            encoded_string.push(ch);\n        }\n    }\n  \
    \  encoded_string\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmprqmvzo9f.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_x04561t.rs:12:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    for c in message.chars()\
    \ {\n        let l = c.to_lowercase().to_string();\n        if l == \"a\" {\n\
    \            output.push('c');\n        } else if l == \"e\" {\n            output.push('g');\n\
    \        } else if l == \"i\" {\n            output.push('k');\n        } else\
    \ if l == \"o\" {\n            output.push('q');\n        } else if l == \"u\"\
    \ {\n            output.push('s');\n        } else if c.is_lowercase() {\n   \
    \         output.push(((c as u8) + 2) as char);\n        } else {\n          \
    \  output.push(((c as u8) - 32 + 2) as char);\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6g56\"`,\n right: `\"tgst\"`', /tmp/tmpm23phe6e.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let letters = \"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut result =\
    \ String::new();\n    for c in message.chars() {\n        if vowels.contains(c)\
    \ {\n            result.push_str(&letters[\n                (letters.find(c).unwrap()\
    \ + 2) % letters.len()..\n                (letters.find(c).unwrap() + 3) % letters.len()\n\
    \            ])\n        } else if letters.contains(c) {\n            result.push_str(&letters[\n\
    \                (letters.find(c).unwrap() + letters.len() / 2) % letters.len()..\n\
    \                (letters.find(c).unwrap() + letters.len() / 2 + 1) % letters.len()\n\
    \            ])\n        } else {\n            result.push(c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp2cnwx57o.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.push(next_vowel(c));\n        } else {\n    \
    \        encoded_message.push(next_char(c));\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `next_vowel` in this scope\n  --> /tmp/tmpkeoq4w77.rs:16:34\n\
    \   |\n16 |             encoded_message.push(next_vowel(c));\n   |           \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `next_char` in this scope\n  --> /tmp/tmpkeoq4w77.rs:18:34\n \
    \  |\n18 |             encoded_message.push(next_char(c));\n   |             \
    \                     ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for character\
    \ in message.chars() {\n        let replaced = match character {\n           \
    \ 'A' => 'C',\n            'a' => 'c',\n            'E' => 'G',\n            'e'\
    \ => 'g',\n            'I' => 'K',\n            'i' => 'k',\n            'O' =>\
    \ 'Q',\n            'o' => 'q',\n            'U' => 'S',\n            'u' => 's',\n\
    \            'Y' => 'A',\n            'y' => 'a',\n            _ => character,\n\
    \        };\n        result.push(replaced);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpd4glxgi1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        let mut c = if c.is_uppercase()\
    \ { c.to_lowercase().next().unwrap() } else { c };\n        if c == 'a' {\n  \
    \          c = 'c';\n        } else if c == 'e' {\n            c = 'g';\n    \
    \    } else if c == 'i' {\n            c = 'k';\n        } else if c == 'o' {\n\
    \            c = 'q';\n        } else if c == 'u' {\n            c = 'y';\n  \
    \      }\n        c\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp0im63ufw.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|l| {\n        let mut new_char\
    \ = if l.is_ascii_lowercase() { l.to_ascii_uppercase() } else { l.to_ascii_lowercase()\
    \ };\n        match new_char {\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           _ => new_char\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpm7_mhyoz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    const VOWELS: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let vowels = &VOWELS;\n    let mut encoded_string = String::new();\n    for\
    \ c in message.chars() {\n        let mut char_encoded = c;\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                char_encoded = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \            }\n            if vowels.contains(&char_encoded) {\n            \
    \    char_encoded = c_ahead(char_encoded, 2);\n            }\n        }\n    \
    \    encoded_string.push(char_encoded);\n    }\n    encoded_string\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `c_ahead` in this scope\n  --> /tmp/tmpb09zt5g6.rs:22:32\n\
    \   |\n22 |                 char_encoded = c_ahead(char_encoded, 2);\n   |   \
    \                             ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(if c.is_uppercase()\
    \ {\n                match c {\n                    'A' => 'C',\n            \
    \        'E' => 'G',\n                    'I' => 'K',\n                    'O'\
    \ => 'Q',\n                    'U' => 'Y',\n                    'Z' => 'B',\n\
    \                    _ => (c as u8 + 2) as char,\n                }\n        \
    \    } else {\n                match c {\n                    'a' => 'c',\n  \
    \                  'e' => 'g',\n                    'i' => 'k',\n            \
    \        'o' => 'q',\n                    'u' => 'y',\n                    'z'\
    \ => 'b',\n                    _ => (c as u8 + 2) as char,\n                }\n\
    \            });\n        } else {\n            result.push(c);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpe7nyig7c.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Your code here\n    let mut new_message = String::new();\n\
    \    let mut new_char: char;\n    for character in message.chars() {\n       \
    \ if character.is_alphabetic() {\n            if character.is_uppercase() {\n\
    \                if character == 'A' {\n                    new_char = 'C';\n\
    \                } else if character == 'E' {\n                    new_char =\
    \ 'G';\n                } else if character == 'I' {\n                    new_char\
    \ = 'K';\n                } else if character == 'O' {\n                    new_char\
    \ = 'Q';\n                } else if character == 'U' {\n                    new_char\
    \ = 'Y';\n                } else {\n                    new_char = character.to_ascii_lowercase();\n\
    \                }\n            } else {\n                if character == 'a'\
    \ {\n                    new_char = 'c';\n                } else if character\
    \ == 'e' {\n                    new_char = 'g';\n                } else if character\
    \ == 'i' {\n                    new_char = 'k';\n                } else if character\
    \ == 'o' {\n                    new_char = 'q';\n                } else if character\
    \ == 'u' {\n                    new_char = 'y';\n                } else {\n  \
    \                  new_char = character.to_ascii_uppercase();\n              \
    \  }\n            }\n        } else {\n            new_char = character;\n   \
    \     }\n        new_message.push(new_char);\n    }\n    new_message\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpp4jka5zc.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // Your code here!\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkgay7nnn.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut code = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            code.push(match c {\n       \
    \         'a' => 'c',\n                'e' => 'g',\n                'i' => 'k',\n\
    \                'o' => 'q',\n                'u' => 'y',\n                _ \
    \  => c.to_uppercase().next().unwrap()\n            });\n        }\n    }\n  \
    \  code\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpb3t6vddu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut encoded_message = String::new();\n    for letter in message.chars()\
    \ {\n        match letter {\n            'a'..='z' => {\n                let letter_idx\
    \ = alphabet.find(letter).unwrap();\n                let is_vowel = vowels.find(letter).is_some();\n\
    \                if is_vowel {\n                    let encoded_idx = (letter_idx\
    \ + 2) % alphabet.len();\n                    encoded_message.push(alphabet.chars().nth(encoded_idx).unwrap());\n\
    \                } else {\n                    encoded_message.push(letter);\n\
    \                }\n            },\n            'A'..='Z' => {\n             \
    \   let letter_idx = alphabet.find(letter.to_ascii_lowercase()).unwrap();\n  \
    \              let is_vowel = vowels.find(letter.to_ascii_lowercase()).is_some();\n\
    \                if is_vowel {\n                    let encoded_idx = (letter_idx\
    \ + 2) % alphabet.len();\n                    encoded_message.push(alphabet.chars().nth(encoded_idx).unwrap().to_ascii_uppercase());\n\
    \                } else {\n                    encoded_message.push(letter);\n\
    \                }\n            },\n            _ => encoded_message.push(letter),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpw1bib4cy.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO\n    \"\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmph8e4nm5_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let new_message = message.chars().map(|x| {\n     \
    \   if x.is_alphabetic() {\n            match x.to_lowercase().next().unwrap()\
    \ {\n                'a' => 'c',\n                'e' => 'g',\n              \
    \  'i' => 'k',\n                'o' => 'q',\n                'u' => 'w',\n   \
    \             x => x,\n            }\n        } else {\n            x\n      \
    \  }\n    });\n    let message: String = new_message.collect();\n    message.to_uppercase()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpude_rdzy.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let lower_vowels = ['a', 'e', 'i', 'o', 'u'];\n   \
    \ let upper_vowels = ['A', 'E', 'I', 'O', 'U'];\n    let mut encoded_message =\
    \ String::new();\n    for letter in message.chars() {\n        if lower_vowels.contains(&letter)\
    \ {\n            encoded_message.push(letter.to_ascii_uppercase());\n        }\
    \ else if upper_vowels.contains(&letter) {\n            encoded_message.push(letter.to_ascii_lowercase());\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    }\n\
    \    for (i, letter) in encoded_message.chars().enumerate() {\n        if letter\
    \ == 'A' {\n            encoded_message.replace_range(i..i+1, \"C\");\n      \
    \  } else if letter == 'B' {\n            encoded_message.replace_range(i..i+1,\
    \ \"D\");\n        } else if letter == 'C' {\n            encoded_message.replace_range(i..i+1,\
    \ \"E\");\n        } else if letter == 'D' {\n            encoded_message.replace_range(i..i+1,\
    \ \"F\");\n        } else if letter == 'E' {\n            encoded_message.replace_range(i..i+1,\
    \ \"G\");\n        } else if letter == 'F' {\n            encoded_message.replace_range(i..i+1,\
    \ \"H\");\n        } else if letter == 'G' {\n            encoded_message.replace_range(i..i+1,\
    \ \"I\");\n        } else if letter == 'H' {\n            encoded_message.replace_range(i..i+1,\
    \ \"J\");\n        } else if letter == 'I' {\n            encoded_message.replace_range(i..i+1,\
    \ \"K\");\n        } else if letter == 'J' {\n            encoded_message.replace_range(i..i+1,\
    \ \"L\");\n        } else if letter == 'K' {\n            encoded_message.replace_range(i..i+1,\
    \ \"\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmcnrucom.rs:55:109\n\
    \   |\n55 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    56 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut ret = String::new();\n    for c in message.chars()\
    \ {\n        if !c.is_alphabetic() {\n            ret.push(c);\n            continue;\n\
    \        }\n        let mut e = c;\n        if c.is_uppercase() {\n          \
    \  e = e.to_lowercase().next().unwrap();\n        } else {\n            e = e.to_uppercase().next().unwrap();\n\
    \        }\n        match e {\n            'a' => ret.push('c'),\n           \
    \ 'e' => ret.push('g'),\n            'i' => ret.push('k'),\n            'o' =>\
    \ ret.push('q'),\n            'u' => ret.push('s'),\n            'y' => ret.push('a'),\n\
    \            _ => ret.push(e),\n        }\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpr_nwyaxk.rs:40:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // your code goes here\n    let vowels = [ \"a\", \"\
    e\", \"i\", \"o\", \"u\" ];\n    let mut encoded_message = String::new();\n  \
    \  for c in message.chars() {\n        if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n            if c.is_lowercase() {\n                let mut i = vowels.iter().position(|&r|\
    \ r == c.to_lowercase().to_string().as_str()).unwrap();\n                i = i\
    \ + 2;\n                if i > 4 {\n                    i = i - 5;\n         \
    \       }\n                encoded_message.push_str(vowels[i]);\n            }\
    \ else {\n                let mut i = vowels.iter().position(|&r| r == c.to_lowercase().to_string().as_str()).unwrap();\n\
    \                i = i + 2;\n                if i > 4 {\n                    i\
    \ = i - 5;\n                }\n                encoded_message.push_str(vowels[i].to_uppercase().as_str());\n\
    \            }\n        } else {\n            encoded_message.push(c);\n     \
    \   }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TOST\"`,\n right: `\"tgst\"`', /tmp/tmpzhcajoxq.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2r1w4h9b.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let message = message.into_bytes();\n    let mut index\
    \ = 0;\n    let mut buffer = vec![];\n    for c in message {\n        index +=\
    \ 1;\n        let c = match c {\n            c if c >= 'a' as u8 && c <= 'z' as\
    \ u8 => c - 0x20,\n            c if c >= 'A' as u8 && c <= 'Z' as u8 => c + 0x20,\n\
    \            c if c == 'a' as u8 || c == 'e' as u8 || c == 'i' as u8 || c == 'o'\
    \ as u8 || c == 'u' as u8 || c == 'A' as u8 || c == 'E' as u8 || c == 'I' as u8\
    \ || c == 'O' as u8 || c == 'U' as u8 => c + 2,\n            c => c,\n       \
    \ };\n        buffer.push(c);\n    }\n    String::from_utf8(buffer).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpsz6yn7_f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut output = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_lowercase() {\n            output.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            output.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpwtofgicl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut iter = message.chars();\n    let mut encoded_message\
    \ = String::new();\n    while let Some(c) = iter.next() {\n        match c {\n\
    \            'a' => encoded_message.push('c'),\n            'e' => encoded_message.push('g'),\n\
    \            'i' => encoded_message.push('k'),\n            'o' => encoded_message.push('q'),\n\
    \            'u' => encoded_message.push('s'),\n            'y' => encoded_message.push('a'),\n\
    \            _ => encoded_message.push(c),\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmphxrvl26l.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        let lower = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        let uppercase\
    \ = c.is_uppercase();\n        if alphabet.contains(lower) {\n            let\
    \ index = alphabet.find(lower).unwrap();\n            let (mut next, _) = alphabet.split_at(index);\n\
    \            next = next.chars().rev().take(2).collect::<Vec<char>>();\n     \
    \       next.reverse();\n            let res = next[0];\n            if uppercase\
    \ {\n                res.to_uppercase().collect::<Vec<char>>()[0]\n          \
    \  } else {\n                res\n            }\n        } else {\n          \
    \  c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcreb8o7z.rs:19:20\n   |\n\
    18 |             let (mut next, _) = alphabet.split_at(index);\n   |         \
    \         -------- expected due to the type of this binding\n19 |            \
    \ next = next.chars().rev().take(2).collect::<Vec<char>>();\n   |            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `Vec`\n   |\n   = note: expected reference `&str`\n                 found\
    \ struct `Vec<char>`\n\nerror[E0599]: no method named `reverse` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpcreb8o7z.rs:20:18\n   |\n20 |   \
    \          next.reverse();\n   |                  ^^^^^^^ method not found in\
    \ `&str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpcreb8o7z.rs:21:23\n   |\n21 |             let res = next[0];\n   | \
    \                      ^^^^^^^ string indices are ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n   =\
    \ note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more\
    \ information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut msg = String::new();\n    for c in message.chars()\
    \ {\n        let upper = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c\n        };\n        let lower = if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        match upper {\n            'A' => msg.push('C'),\n\
    \            'E' => msg.push('G'),\n            'I' => msg.push('K'),\n      \
    \      'O' => msg.push('M'),\n            'U' => msg.push('Q'),\n            _\
    \ => msg.push(lower),\n        }\n    }\n    msg\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpok74yota.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxlgi4w8u.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut output = String::new();\n    for c in message.chars() {\n        let mut\
    \ c = c.to_ascii_lowercase();\n        if c == ' ' {\n            output.push('\
    \ ');\n            continue;\n        }\n        if let Some(index) = vowels.iter().position(|&v|\
    \ v == c) {\n            c = vowels[(index + 2) % vowels.len()];\n        }\n\
    \        output.push(c);\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tost\"`,\n right: `\"tgst\"`', /tmp/tmpzv8_2j16.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let encoded = message.chars().map(|c| {\n        let\
    \ base = match c.is_lowercase() {\n            true => 'a',\n            false\
    \ => 'A',\n        };\n        let mut new_c = c.to_lowercase().next().unwrap();\n\
    \        let offset = match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => 2,\n\
    \            _ => 0,\n        };\n        if offset != 0 {\n            new_c\
    \ = new_c.wrapping_add(offset);\n        }\n        (new_c as u8 - base as u8\
    \ + base as u8) as char\n    });\n    encoded.collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpq5ucqybt.rs:23:27\n   |\n23 |             new_c\
    \ = new_c.wrapping_add(offset);\n   |                           ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let mut next = c.to_ascii_lowercase();\n\
    \            match next {\n                'a' | 'c' | 'e' | 'g' | 'i' | 'k' |\
    \ 'm' | 'o' | 'q' | 's' | 'u' | 'w' | 'y' => {\n                    next = next.wrapping_add(2);\n\
    \                }\n                'b' | 'd' | 'f' | 'h' | 'j' | 'l' | 'n' |\
    \ 'p' | 'r' | 't' | 'v' | 'x' | 'z' => {\n                    next = next.wrapping_add(1);\n\
    \                }\n                _ => {}\n            }\n            if c.is_lowercase()\
    \ {\n                encoded.push(next);\n            } else {\n             \
    \   encoded.push(next.to_ascii_uppercase());\n            }\n        } else {\n\
    \            encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvhknv2qz.rs:18:33\n   |\n18 |                 \
    \    next = next.wrapping_add(2);\n   |                                 ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `wrapping_add` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpvhknv2qz.rs:21:33\n   |\n\
    21 |                     next = next.wrapping_add(1);\n   |                  \
    \               ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n  message.chars().map(|c| if is_vowel(c) { encode_vowel(c)\
    \ } else { encode_consonant(c) }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpv0kyu0eg.rs:12:30\n\
    \   |\n12 |   message.chars().map(|c| if is_vowel(c) { encode_vowel(c) } else\
    \ { encode_consonant(c) }).collect()\n   |                              ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `encode_vowel`\
    \ in this scope\n  --> /tmp/tmpv0kyu0eg.rs:12:44\n   |\n12 |   message.chars().map(|c|\
    \ if is_vowel(c) { encode_vowel(c) } else { encode_consonant(c) }).collect()\n\
    \   |                                            ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `encode_consonant` in this scope\n\
    \  --> /tmp/tmpv0kyu0eg.rs:12:69\n   |\n12 |   message.chars().map(|c| if is_vowel(c)\
    \ { encode_vowel(c) } else { encode_consonant(c) }).collect()\n   |          \
    \                                                           ^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let chars: Vec<char> = message.chars().collect();\n\
    \    let mut result: Vec<char> = Vec::new();\n    for char in chars {\n      \
    \  match char {\n            'A' | 'a' => result.push('c'),\n            'E' |\
    \ 'e' => result.push('g'),\n            'I' | 'i' => result.push('k'),\n     \
    \       'O' | 'o' => result.push('q'),\n            'U' | 'u' => result.push('s'),\n\
    \            _ => result.push(char),\n        }\n    }\n    result.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmphcjf_y48.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut out = String::new();\n    let mut l = false;\n\
    \    for c in message.chars() {\n        l = !l;\n        if l {\n           \
    \ out.push(c.to_uppercase().next().unwrap());\n        } else {\n            out.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TeSt\"`,\n right: `\"tgst\"`', /tmp/tmpiufzt_uo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO: Implement me!\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfy21oi0n.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res = String::new();\n    for letter in message.chars()\
    \ {\n        if letter.is_uppercase() {\n            res.push(letter.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else if letter.is_lowercase() {\n            res.push(letter.to_uppercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            res.push(letter);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpdoz740cr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    for char\
    \ in message.chars() {\n        result.push(match char {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'w',\n            'y' => 'a',\n            'A' => 'C',\n  \
    \          'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n   \
    \         'U' => 'W',\n            'Y' => 'A',\n            x => x.to_ascii_uppercase(),\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpgb785h9x.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    message.chars().map(|c| {\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            let index = vowels.iter().position(|&r| r == c.to_string().as_str()).unwrap();\n\
    \            let mut new_index = index + 2;\n            if new_index > 4 {\n\
    \                new_index = new_index - 5;\n            }\n            vowels[new_index].chars().next().unwrap()\n\
    \        } else {\n            if c.is_ascii_uppercase() {\n                c.to_ascii_lowercase()\n\
    \            } else {\n                c.to_ascii_uppercase()\n            }\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp9iizm9ij.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| {\n        let unicode = c\
    \ as u32;\n        if unicode >= 65 && unicode <= 90 {\n            let new_unicode\
    \ = unicode + 2;\n            let new_unicode = if new_unicode > 90 {\n      \
    \          (new_unicode - 90) + 64\n            } else {\n                new_unicode\n\
    \            };\n            return (new_unicode as u8) as char;\n        } else\
    \ if unicode >= 97 && unicode <= 122 {\n            let new_unicode = unicode\
    \ + 2;\n            let new_unicode = if new_unicode > 122 {\n               \
    \ (new_unicode - 122) + 96\n            } else {\n                new_unicode\n\
    \            };\n            return (new_unicode as u8) as char;\n        } else\
    \ {\n            return c;\n        }\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpclptlk9f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.into_bytes().iter().map(|b| {\n        if b\
    \ >= &b'a' && b <= &b'z' {\n            b - 1\n        } else if b >= &b'A' &&\
    \ b <= &b'Z' {\n            b + 1\n        } else {\n            *b\n        }\n\
    \    }).map(|b| {\n        if b == b'u' || b == b'U' {\n            b - 24\n \
    \       } else if b == b'v' || b == b'V' {\n            b - 22\n        } else\
    \ if b == b'i' || b == b'I' {\n            b + 2\n        } else if b == b'e'\
    \ || b == b'E' {\n            b + 4\n        } else if b == b'o' || b == b'O'\
    \ {\n            b + 2\n        } else {\n            b\n        }\n    }).map(|b|\
    \ b as char).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"=FT=\"`,\n right: `\"tgst\"`', /tmp/tmp1097nvrx.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if\
    \ vowels.contains(&c) {\n            encoded_message.push(vowels[((vowels.iter().position(|&x|\
    \ x == c).unwrap() + 2) % 5) as usize]);\n        } else {\n            if c.is_uppercase()\
    \ {\n                encoded_message.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                encoded_message.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \            }\n        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpkzkx4blw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut swap = message.chars().map(|c| match c {\n\
    \        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' =>\
    \ 'q',\n        'u' => 'w',\n        'A' => 'C',\n        'E' => 'G',\n      \
    \  'I' => 'K',\n        'O' => 'Q',\n        'U' => 'W',\n        _ => c,\n  \
    \  }).collect::<String>();\n    swap.make_ascii_uppercase();\n    swap\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpvtge1g9q.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded_message = String::new();\n    let vowels\
    \ = \"aeiou\";\n    for c in message.chars() {\n        if vowels.contains(c)\
    \ {\n            let i = vowels.find(c).unwrap();\n            encoded_message.push(vowels.chars().nth(i\
    \ + 2).unwrap());\n        } else {\n            encoded_message.push(c);\n  \
    \      }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpuxfk8qf0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    const VOWELS: [char; 10] = ['a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U'];\n    const ENGLISH_ALPHABET: [char; 26] = [\n    \
    \    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    ];\n  \
    \  let mut c_message = message.chars();\n    let mut encoded_message = String::new();\n\
    \    loop {\n        match c_message.next() {\n            Some(c) => {\n    \
    \            let mut char_index = ENGLISH_ALPHABET.iter().position(|&r| r == c);\n\
    \                if char_index.is_some() {\n                    char_index = Some(char_index.unwrap()\
    \ + 2);\n                    let c_index = char_index.unwrap() % 26;\n       \
    \             let next_char = ENGLISH_ALPHABET[c_index];\n                   \
    \ encoded_message.push(next_char);\n                } else {\n               \
    \     encoded_message.push(c);\n                }\n            }\n           \
    \ None => {\n                break;\n            }\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp1js1mn5_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvn1l04v2.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let letters = message.chars().map(|c| {\n        let\
    \ mut i = c.to_ascii_lowercase() as i8;\n        if i > 109 {\n            i -=\
    \ 26;\n        }\n        if i == 97 || i == 101 || i == 105 || i == 111 || i\
    \ == 117 {\n            i += 2;\n        }\n        (i as u8) as char\n    });\n\
    \    letters.collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ZgYZ\"`,\n right: `\"tgst\"`', /tmp/tmp8q7nzwrb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut new_message = String::new();\n    for ch in\
    \ message.chars() {\n        let c: char = match ch {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'w',\n            'A' => 'C',\n            'E' => 'G',\n  \
    \          'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n   \
    \         _ => ch,\n        };\n        new_message.push(c);\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpnsrus8na.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoder = Vec::new();\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut skip_letters = HashSet::new();\n    for (idx,\
    \ ch) in message.to_lowercase().chars().enumerate() {\n        if ch == ' ' {\n\
    \            skip_letters.insert(idx);\n            encoder.push(ch);\n      \
    \  } else if vowels.contains(&ch) {\n            encoder.push(match ch {\n   \
    \             'a' => 'c',\n                'e' => 'g',\n                'i' =>\
    \ 'k',\n                'o' => 'q',\n                'u' => 'y',\n           \
    \     _ => ch,\n            });\n            if idx + 1 < message.len() {\n  \
    \              skip_letters.insert(idx + 1);\n            }\n            if idx\
    \ + 2 < message.len() {\n                skip_letters.insert(idx + 2);\n     \
    \       }\n        } else {\n            encoder.push(ch);\n        }\n    }\n\
    \    let mut encoded = String::new();\n    for (idx, ch) in message.chars().enumerate()\
    \ {\n        if skip_letters.contains(&idx) {\n            encoded.push(ch);\n\
    \        } else {\n            encoded.push(encoder[idx]);\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp0rrymoxy.rs:14:28\n   |\n14 |     let mut skip_letters = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut enc_message = String::new();\n    let mut idx:\
    \ i8 = 0;\n    for c in message.chars() {\n        if c.is_ascii_uppercase() {\n\
    \            idx = c as i8 - 'A' as i8;\n            if c == 'Y' {\n         \
    \       enc_message.push('A');\n            } else if c == 'Z' {\n           \
    \     enc_message.push('B');\n            } else {\n                enc_message.push((idx\
    \ + 2 + 'A' as i8) as u8 as char);\n            }\n        } else if c.is_ascii_lowercase()\
    \ {\n            idx = c as i8 - 'a' as i8;\n            if c == 'y' {\n     \
    \           enc_message.push('a');\n            } else if c == 'z' {\n       \
    \         enc_message.push('b');\n            } else {\n                enc_message.push((idx\
    \ + 2 + 'a' as i8) as u8 as char);\n            }\n        } else {\n        \
    \    enc_message.push(c);\n        }\n    }\n    enc_message\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmphmegp0qm.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let new_char = match c {\n            'A' | 'a' => 'C',\n       \
    \     'E' | 'e' => 'G',\n            'I' | 'i' => 'K',\n            'O' | 'o'\
    \ => 'Q',\n            'U' | 'u' => 'S',\n            'Y' | 'y' => 'A',\n    \
    \        'z' => 'b',\n            'x' => 'z',\n            'Z' => 'B',\n     \
    \       'X' => 'Z',\n            ' ' => ' ',\n            c if c.is_ascii_lowercase()\
    \ => ((c as u8) + 2) as char,\n            c if c.is_ascii_uppercase() => ((c\
    \ as u8) + 2) as char,\n            _ => c,\n        };\n        encoded.push(new_char);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp_3c1_w30.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpizqii9go.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_lowercase() {\n            result.push(ch.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_uppercase() {\n            result.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpey9nrpwl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmp0up_scfo.rs:12:29\n\
    \   |\n12 |     message.chars().map(|c| encode_char(c)).collect()\n   |      \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n\
    /// 'TGST'\n/// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
    \ String) -> String {\n    let mut res: String = String::new();\n    let base\
    \ = 'a' as u8;\n    let len = 'z' as u8 - base + 1;\n    for c in message.chars()\
    \ {\n        let lowercase = c.to_lowercase().next().unwrap();\n        if c.is_ascii_lowercase()\
    \ {\n            if is_vowel(lowercase) {\n                let shift = (lowercase\
    \ as u8 - base + 2) % len;\n                res.push((shift + base) as char);\n\
    \            } else {\n                res.push(lowercase);\n            }\n \
    \       } else {\n            if is_vowel(lowercase) {\n                let shift\
    \ = (lowercase as u8 - base + 2) % len;\n                res.push((shift + base)\
    \ as char);\n            } else {\n                res.push(lowercase);\n    \
    \        }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp9r5qolrn.rs:18:16\n\
    \   |\n18 |             if is_vowel(lowercase) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmp9r5qolrn.rs:25:16\n   |\n25 |             if is_vowel(lowercase)\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
