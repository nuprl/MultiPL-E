name: HumanEval_40_triples_sum_to_zero
language: rust
results:
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut b: usize = 0;\n    let mut c: usize = 0;\n\
    \    let mut set: HashSet<isize> = HashSet::new();\n    for n in l {\n       \
    \ set.insert(n);\n    }\n    let set_l = set.len();\n    let l_l = l.len();\n\
    \    if set_l >= 3 && l_l >= 3 {\n        for a in 0..set_l {\n            for\
    \ b in a + 1..set_l {\n                for c in b + 1..set_l {\n             \
    \       let a_s = set.get(&l[a]);\n                    let b_s = set.get(&l[b]);\n\
    \                    let c_s = set.get(&l[c]);\n                    if a_s.is_some()\
    \ && b_s.is_some() && c_s.is_some() {\n                        if (*a_s.unwrap()\
    \ + *b_s.unwrap() + *c_s.unwrap()) == 0 {\n                            return\
    \ true;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpflsj4r_3.rs:17:18\n\
    \   |\n17 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpflsj4r_3.rs:17:35\n\
    \   |\n17 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triple = false;\n    for i in 0..l.len()\
    \ {\n        for j in i+1..l.len() {\n            for k in j+1..l.len() {\n  \
    \              if l[i] + l[j] + l[k] == 0 {\n                    triple = true;\n\
    \                }\n            }\n        }\n    }\n    triple\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // The two variables a and b are used to store the\
    \ two values in the\n    // triple.\n    let mut a = 0;\n    let mut b = 0;\n\
    \    let mut left = 0;\n    let mut right = l.len() - 1;\n    let mut val = 0;\n\
    \    for _i in 0..l.len() {\n        for _j in _i + 1..l.len() {\n           \
    \ for _k in _j + 1..l.len() {\n                a = l[_i];\n                b =\
    \ l[_j];\n                val = l[_k];\n                if (a + b + val) == 0\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi33c9jws.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l = l;\n    let mut res = false;\n    for\
    \ i in 0..l.len() {\n        for j in i + 1..l.len() {\n            for k in j\
    \ + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n             \
    \       res = true;\n                }\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpultu1pwl.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // let mut threes = l.chunks(3);\n    let chunks:\
    \ Vec<Vec<isize>> = l.chunks(3).map(|x| x.to_vec()).collect();\n    for c in chunks\
    \ {\n        if c.len() == 3 && c[0] + c[1] + c[2] == 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq4l1m3qw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9so33lsd.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    for i in 0..l.len() {\n        for j in (i + 1)..l.len() {\n            for\
    \ k in (j + 1)..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n    \
    \                return true;\n                }\n            }\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    for (i, _) in l.iter().enumerate() {\n        for (j, _) in l.iter().enumerate()\
    \ {\n            for (k, _) in l.iter().enumerate() {\n                if i ==\
    \ j || i == k || j == k {\n                    continue;\n                }\n\
    \                if l[i] + l[j] + l[k] == 0 {\n                    return true;\n\
    \                }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // (1). You must use `find_two_sum_to_zero` as a\
    \ helper function!\n    // YOUR CODE HERE!\n    for i in 0..l.len() {\n      \
    \  let mut temp = Vec::new();\n        for j in 0..l.len() {\n            if i\
    \ != j {\n                temp.push(l[j]);\n            }\n        }\n       \
    \ if find_two_sum_to_zero(temp) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_two_sum_to_zero` in this scope\n\
    \  --> /tmp/tmpb7xiy696.rs:24:12\n   |\n24 |         if find_two_sum_to_zero(temp)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut seen: HashSet<isize> = HashSet::new();\n\
    \    for num in l {\n        let rsum = -num;\n        if seen.contains(&rsum)\
    \ {\n            return true;\n        }\n        for &prev in seen.iter() {\n\
    \            if seen.contains(&(rsum - prev)) {\n                return true;\n\
    \            }\n        }\n        seen.insert(num);\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpd9gg62k9.rs:15:19\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpd9gg62k9.rs:15:36\n\
    \   |\n15 |     let mut seen: HashSet<isize> = HashSet::new();\n   |         \
    \                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // I have no idea how this works. It seems to have\
    \ something to do with\n    // three nested loops.\n    // It looks like it returns\
    \ false if there's no way to pair the first \n    // thing in the list with a\
    \ second thing such that the difference between\n    // the first and second things\
    \ is in the list. Otherwise, it returns true.\n    // If there's no way for the\
    \ difference to be in the list, then there's no\n    // way for the sum to be\
    \ zero.\n    for i in 0..l.len() {\n        for j in i + 1..l.len() {\n      \
    \      for k in 0..l.len() {\n                if l[i] - l[j] == l[k] {\n     \
    \               return true;\n                }\n            }\n        }\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphnkz_9vt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() {\n        for j in i + 1..l.len() {\n            for\
    \ k in j + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \ }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l = l;\n    l.sort();\n    l.dedup();\n \
    \   return l.iter().any(|x| l.iter().any(|y| l.iter().any(|z| x != y && y != z\
    \ && z != x && x + y + z == 0)));\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7q__42tf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: replace the above unimplemented! with your\
    \ implementation\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqykytn5b.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Checks the size of the list.\n    if l.len() <\
    \ 3 {\n        return false;\n    }\n    // Checks if there's three consecutive\
    \ numbers that sum to zero.\n    for i in 0..l.len() - 2 {\n        if l[i] +\
    \ l[i + 1] + l[i + 2] == 0 {\n            return true;\n        }\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp33wgek2a.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() - 2 {\n        for j in i + 1..l.len() - 1 {\n      \
    \      for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpseqnl0f1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2uto92n_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l_clone = l.clone();\n    l_clone.sort();\n\
    \    for (i, x) in l_clone.iter().enumerate() {\n        let mut l_clone_clone\
    \ = l_clone.clone();\n        l_clone_clone.remove(i);\n        if two_sum_to_zero(l_clone_clone,\
    \ -x) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `two_sum_to_zero` in this scope\n  -->\
    \ /tmp/tmpxvebcugz.rs:20:12\n   |\n20 |         if two_sum_to_zero(l_clone_clone,\
    \ -x) {\n   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l.iter() {\n        for j in l.iter() {\n\
    \            for k in l.iter() {\n                if i != j && j != k && i !=\
    \ k && i + j + k == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfwdjpvm0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    let mut l = l;\n    l.sort();\n\n    let mut i = 0;\n    while i < l.len()\
    \ - 2 {\n        let mut j = i + 1;\n        let mut k = l.len() - 1;\n      \
    \  while j < k {\n            let sum = l[i] + l[j] + l[k];\n            if sum\
    \ == 0 {\n                return true;\n            }\n            if sum < 0\
    \ {\n                j += 1;\n            } else {\n                k -= 1;\n\
    \            }\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3btpu23w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l2 = l.clone();\n    let mut l3 = l.clone();\n\
    \    l2.sort();\n    l3.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = 0;\n    let mut distinct = true;\n    while (i < l2.len() - 2) && distinct\
    \ {\n        j = i + 1;\n        while (j < l2.len() - 1) && distinct {\n    \
    \        k = j + 1;\n            while (k < l2.len()) && distinct {\n        \
    \        if l2[i] + l2[j] + l2[k] == 0 {\n                    if l3[i] == l3[j]\
    \ || l3[i] == l3[k] || l3[j] == l3[k] {\n                        distinct = false;\n\
    \                    } else {\n                        return true;\n        \
    \            }\n                }\n                k += 1;\n            }\n  \
    \          j += 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_wn8o6ld.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // your code here\n    let mut num = l.clone();\n\
    \    num.sort();\n    let mut i = 0;\n    while i < num.len() - 2 {\n        let\
    \ a = num[i];\n        let mut j = i + 1;\n        let mut k = num.len() - 1;\n\
    \        while j < k {\n            let b = num[j];\n            let c = num[k];\n\
    \            if a + b + c == 0 {\n                return true;\n            }\
    \ else if a + b + c > 0 {\n                k -= 1;\n            } else {\n   \
    \             j += 1;\n            }\n        }\n        i += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppoignsm2.rs:19:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpx7464cz_.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().any(|(i, &a)| {\n        l.iter().enumerate().any(|(j,\
    \ &b)| {\n            l.iter().enumerate().any(|(k, &c)| {\n                i\
    \ != j && i != k && j != k && a + b + c == 0\n            })\n        })\n   \
    \ })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut found = false;\n    let mut x = 0;\n    while\
    \ !found && x < l.len() {\n        let mut y = x + 1;\n        while !found &&\
    \ y < l.len() {\n            let mut z = y + 1;\n            while !found && z\
    \ < l.len() {\n                found = l[x] + l[y] + l[z] == 0;\n            \
    \    z += 1;\n            }\n            y += 1;\n        }\n        x += 1;\n\
    \    }\n    found\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Sum all possible combinations of three integers\
    \ in the list.\n    let mut sum = false;\n    for i in 0..l.len() {\n        for\
    \ j in i + 1..l.len() {\n            for k in j + 1..l.len() {\n             \
    \   // If any combination sums to zero, return true.\n                if l[i]\
    \ + l[j] + l[k] == 0 {\n                    sum = true;\n                }\n \
    \           }\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut x = l.clone();\n    x.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < x.len() - 2 {\n\
    \        j = i + 1;\n        k = x.len() - 1;\n        while j < k {\n       \
    \     if x[i] + x[j] + x[k] == 0 {\n                return true;\n           \
    \ } else if x[i] + x[j] + x[k] < 0 {\n                j += 1;\n            } else\
    \ {\n                k -= 1;\n            }\n        }\n        i += 1;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu4aeidb2.rs:20:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: write code here\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw43b2irq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpknmyc0n6.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sorted_list = l.clone();\n    sorted_list.sort();\n\
    \    for i in 0..(sorted_list.len() - 2) {\n        for j in (i + 1)..(sorted_list.len()\
    \ - 1) {\n            for k in (j + 1)..sorted_list.len() {\n                if\
    \ sorted_list[i] + sorted_list[j] + sorted_list[k] == 0 {\n                  \
    \  return true;\n                }\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyd97qfyp.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n  // TODO: implement this function\n  false\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk47had9y.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut res = false;\n    for (x, i) in l.iter().enumerate()\
    \ {\n        for (y, j) in l.iter().enumerate() {\n            for (z, k) in l.iter().enumerate()\
    \ {\n                if x != y && y != z && x != z {\n                    if *i\
    \ + *j + *k == 0 {\n                        res = true;\n                    }\n\
    \                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // why vec? b/c you don't know the length\n    //\
    \ m: HashMap<_, _>\n    let mut m: HashMap<isize, isize> = HashMap::new();\n \
    \   // insert into hash map\n    for num in l {\n        if m.contains_key(&num)\
    \ {\n            let v = m.get_mut(&num).unwrap();\n            *v += 1;\n   \
    \     } else {\n            m.insert(num, 1);\n        }\n    }\n    // checks\
    \ if the key exists in map, then checks if there are 3 of the key\n    // if true,\
    \ return true\n    for (key, _) in m.iter() {\n        if m.contains_key(&(-1\
    \ * key)) {\n            if (key != 0 && m.get(&(-1 * key)).unwrap() > &1) ||\
    \ (key == 0 && m.get(&(-1 * key)).unwrap() > &2) {\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp9i_dbxw2.rs:17:16\n\
    \   |\n17 |     let mut m: HashMap<isize, isize> = HashMap::new();\n   |     \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp9i_dbxw2.rs:17:40\n\
    \   |\n17 |     let mut m: HashMap<isize, isize> = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4751lz9n.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    // triples_sum_to_zero([1,\
    \ 2, 3, 7])\n    for a in l.iter() {\n        for b in l.iter() {\n          \
    \  for c in l.iter() {\n                if (a == b) || (a == c) || (b == c) {\n\
    \                    continue;\n                } else if (a + b + c) == 0 {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpomu1vqpf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmputbd2upq.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Counts the number of times an item occurs in the\
    \ list.\n    let count = |n| {\n        l.iter().filter(|x| **x == n).count()\n\
    \    };\n\n    // Returns true if there are two distinct elements that add to\
    \ zero.\n    let twos_add_to_zero = |n| {\n        count(-n) >= 1\n    };\n\n\
    \    // Returns true if there are three distinct elements that add to zero.\n\
    \    let threes_add_to_zero = |n| {\n        count(-n - n) >= 1\n    };\n\n  \
    \  // Returns true if there are 3 elements that add to zero.\n    l.iter().any(|x|\
    \ twos_add_to_zero(*x) || threes_add_to_zero(*x))\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp5qtsngpi.rs:21:29\n\
    \   |\n21 |     let twos_add_to_zero = |n| {\n   |                           \
    \  ^ consider giving this closure parameter a type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut list = l;\n    list.sort();\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut k = list.len() - 1;\n    while i < j\
    \ && j < k {\n        let sum = list[i] + list[j] + list[k];\n        if sum ==\
    \ 0 {\n            return true;\n        } else if sum < 0 {\n            j +=\
    \ 1;\n        } else {\n            k -= 1;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // replace this with your code\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpngcec75m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() {\n        for j in (i + 1)..l.len() {\n            for\
    \ k in (j + 1)..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n    \
    \                return true;\n                }\n            }\n        }\n \
    \   }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO implement this function\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprlkne7k3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.len() > 2\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6l63aujh.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    if l.len() < 3 {\n        return false;\n\
    \    }\n    for (i, n) in l.iter().enumerate() {\n        for (j, m) in l.iter().enumerate()\
    \ {\n            for (k, p) in l.iter().enumerate() {\n                if i !=\
    \ j && i != k && j != k && *n + *m + *p == 0 {\n                    return true;\n\
    \                }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplhwtm5jz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    let mut l = l;\n    l.sort();\n\
    \    for (i, n) in l.iter().enumerate() {\n        if i != 0 && *n == l[i - 1]\
    \ {\n            continue;\n        }\n        for (j, m) in l.iter().enumerate()\
    \ {\n            if j != 0 && *m == l[j - 1] {\n                continue;\n  \
    \          }\n            if i == j {\n                continue;\n           \
    \ }\n            let k = -n - m;\n            if i > j {\n                if l[j..i].contains(&k)\
    \ {\n                    return true;\n                }\n            } else {\n\
    \                if l[i..j].contains(&k) {\n                    return true;\n\
    \                }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj_99p1wg.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2kwlvc6o.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut res = false;\n    let mut i = 0;\n    while\
    \ i < l.len() - 2 {\n        let mut j = i + 1;\n        while j < l.len() - 1\
    \ {\n            let mut k = j + 1;\n            while k < l.len() {\n       \
    \         if l[i] + l[j] + l[k] == 0 {\n                    res = true;\n    \
    \            }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpiajmhxbx.rs:17:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut temp = l.clone();\n    temp.sort();\n   \
    \ let mut result = false;\n    for i in 0..temp.len() - 2 {\n        let mut j\
    \ = i + 1;\n        let mut k = temp.len() - 1;\n        while j < k {\n     \
    \       if temp[i] + temp[j] + temp[k] == 0 {\n                result = true;\n\
    \                break;\n            } else if temp[i] + temp[j] + temp[k] < 0\
    \ {\n                j += 1;\n            } else {\n                k -= 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1w472lz9.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for a in l.iter() {\n        for b in l.iter() {\n\
    \            for c in l.iter() {\n                if a + b + c == 0 {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpym9ohu0n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().any(|(i, &a)| {\n        l.iter().enumerate().any(|(j,\
    \ &b)| {\n            i != j && l.iter().any(|&c| {\n                a + b + c\
    \ == 0\n            })\n        })\n    })\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //assign bools to check for\n    let mut zero_triple\
    \ = false;\n    let mut less_than_zero = false;\n    let mut greater_than_zero\
    \ = false;\n    //loop and check for triples\n    for i in l {\n        if i ==\
    \ 0 {\n            zero_triple = true;\n        } else if i < 0 {\n          \
    \  less_than_zero = true;\n        } else {\n            greater_than_zero = true;\n\
    \        }\n    }\n    //return boolean\n    zero_triple && (less_than_zero &&\
    \ greater_than_zero)\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprlxmanda.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n  for x in &l {\n    for y in &l {\n      for z in &l\
    \ {\n        if x == y || y == z || x == z {\n          continue;\n        }\n\
    \        if x + y + z == 0 {\n          return true;\n        }\n      }\n   \
    \ }\n  }\n  false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfgsuqoov.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: Implement this function.\n    false\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphkmlog47.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let len = l.len();\n    let mut list = l;\n    list.sort();\n\
    \    for (i, x) in list.iter().enumerate() {\n        for (j, y) in list.iter().enumerate()\
    \ {\n            if i == j {\n                continue;\n            }\n     \
    \       for (k, z) in list.iter().enumerate() {\n                if i == k ||\
    \ j == k {\n                    continue;\n                }\n               \
    \ if *x + *y + *z == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let l_len = l.len();\n    if l_len < 3 {\n      \
    \  return false;\n    }\n    for i in 0..l_len {\n        for j in (i + 1)..l_len\
    \ {\n            for k in (j + 1)..l_len {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Write a function that returns True if there are\
    \ three elements\n    // in a vector that sum to zero.\n    //\n    // How many\
    \ distinct triples of elements (x, y, z) are there?\n    //\n    // There are\
    \ three different types of triples:\n    // (a) all elements are distinct, e.g.\
    \ (1, 2, -3)\n    // (b) two elements are the same, e.g. (1, 2, -3)\n    // (c)\
    \ all elements are the same, e.g. (1, 1, -2)\n    //\n    // Here's an example\
    \ illustrating the three types of triples:\n    //    1  2  3  4  5  6  7  8 \
    \ 9  10\n    //  1 .\n    //  2 . .\n    //  3 . . .\n    //  4 . . . .\n    //\
    \  5 . . . . .\n    //  6 . . . . . .\n    //  7 . . . . . . .\n    //  8 . .\
    \ . . . . . .\n    //  9 . . . . . . . . .\n    // 10 . . . . . . . . . .\n  \
    \  //\n    // We can handle (a) by sorting the list. When the list is sorted,\
    \ we can\n    // test each triple in O(1) time, so we only need to consider all\n\
    \    // distinct triples.\n    //\n    // For example, to test the above (1, 2,\
    \ -3) triple, we look for the value\n    // -3 in the list, which is the 2nd element.\
    \ Thus, the triple is the\n    // following: 1, 2, -3.\n    //\n    // How many\
    \ distinct triples are there? We can count them by counting the\n    // number\
    \ of distinct triples that start with each element. Each triple\n    // starts\
    \ with some element, and that element is guaranteed to be unique.\n    //\n  \
    \  // For example, the above (1, 2, -3) triple starts with 1, which is the\n \
    \   // first element. If the list only has one element, then there are no\n  \
    \  // triples of type (a). If the list has two elements, then there is\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuv7xticd.rs:14:42\n   |\n\
    14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -------------------\
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l.iter() {\n        for j in l.iter() {\n\
    \            for k in l.iter() {\n                if i == j || i == k || j ==\
    \ k {\n                    continue;\n                } else if i + j + k == 0\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyggli9jg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    return triples_sum_to_target(l, 0);\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `triples_sum_to_target` in this scope\n\
    \  --> /tmp/tmpk5tmz5px.rs:15:12\n   |\n15 |     return triples_sum_to_target(l,\
    \ 0);\n   |            ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if (x != y) && (y != z) && (x\
    \ != z) && (x + y + z == 0) {\n                    return true;\n            \
    \    }\n            }\n        }\n    }\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpshu980qe.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //The code below is an example of iteration over\
    \ the list\n    //for i in 0..l.len() {\n    //    print!(\"{} \", l[i]);\n  \
    \  //}\n    //println!(\"\");\n    true\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnn6i4gt2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // It is a good idea to write a function that takes\
    \ a sorted list and\n    // determines if there are any three numbers in the list\
    \ that sum to\n    // zero.\n    //\n    // Hint: look at the difference between\
    \ `for` and `while` loops.\n    //\n    // Hint: the binary search algorithm is\
    \ important for this problem\n    // (and many others). You can get an idea of\
    \ how it works by reading\n    // the overview on Wikipedia.\n    //\n    // Hint:\
    \ the binary search routine is included in the `vec.rs` file\n    // that we've\
    \ given you. You should be familiar with what it does.\n    //\n    // Hint: in\
    \ order to make the binary search routine work, the input\n    // list must be\
    \ in sorted order.\n    //\n    // Hint: the signature of the binary search routine\
    \ is:\n    //\n    //     fn binary_search(l: &Vec<isize>, target: isize) -> Option<usize>\n\
    \    //\n    // Hint: the signature of the sort routine is:\n    //\n    //  \
    \   fn sort(l: &mut Vec<isize>)\n    //\n    // Hint: sorting the list is not\
    \ sufficient: you must do it *in place*.\n    // That is, you can't save a copy\
    \ of the sorted list and then use that\n    // copy.\n    //\n    // Hint: you'll\
    \ probably want to use `sort` and `binary_search` in your\n    // solution.\n\n\
    \    // YOUR CODE HERE\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvq40xw67.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: implement triples_sum_to_zero\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2wvvrks5.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut g = vec![];\n    let mut b = vec![];\n  \
    \  for i in l {\n        if i > 0 {\n            g.push(i);\n        } else if\
    \ i < 0 {\n            b.push(i);\n        }\n    }\n    for i in g {\n      \
    \  for j in b.iter() {\n            if l.contains(&(i + j)) {\n              \
    \  return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpv40zilwf.rs:26:16\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n17  |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n26  |        \
    \     if l.contains(&(i + j)) {\n    |                ^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `l`\n    = note: borrow occurs due to deref coercion\
    \ to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n17  |     for i in &l {\n    | \
    \             +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut new_l = l.clone();\n    new_l.sort();\n \
    \   for x in 0..new_l.len() {\n        for y in (x + 1)..new_l.len() {\n     \
    \       let target = -(new_l[x] + new_l[y]);\n            if target >= new_l[y]\
    \ && new_l.contains(&target) {\n                return true;\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in &l {\n        for y in &l {\n          \
    \  for z in &l {\n                if x != y && y != z && x != z && x + y + z ==\
    \ 0 {\n                    return true;\n                }\n            }\n  \
    \      }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8sxsn2x5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if x != y && y != z && x !=\
    \ z && x + y + z == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyi7saaqy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: implement me!\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnlyqxb52.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: Implement this!\n    let mut found = false;\n\
    \    for i in 0..l.len() {\n        for j in i+1..l.len() {\n            for k\
    \ in j+1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n          \
    \          found = true;\n                }\n            }\n        }\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    for (index1, n1) in\
    \ l.iter().enumerate() {\n        for (index2, n2) in l.iter().enumerate() {\n\
    \            if index1 != index2 {\n                for (index3, n3) in l.iter().enumerate()\
    \ {\n                    if index1 != index3 && index2 != index3 {\n         \
    \               if n1 + n2 + n3 == 0 {\n                            result = true;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut aux: Vec<isize> = l.clone();\n    aux.sort();\n\
    \    let zero = 0;\n    aux.binary_search(&zero).is_ok() && {\n        let mut\
    \ i = 0;\n        let mut j = aux.len() - 1;\n        while i < j {\n        \
    \    if i == j {\n                return false;\n            }\n            if\
    \ aux[i] + aux[j] == zero {\n                return true;\n            } else\
    \ if aux[i] + aux[j] < zero {\n                i += 1;\n            } else {\n\
    \                j -= 1;\n            }\n        }\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4cr24sb.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut m: Vec<isize> = l.clone();\n    let len =\
    \ m.len();\n    m.sort();\n    for i in 0..len - 2 {\n        let (mut low, mut\
    \ high) = (i + 1, len - 1);\n        while low < high {\n            let sum =\
    \ m[i] + m[low] + m[high];\n            if sum == 0 {\n                return\
    \ true;\n            } else if sum < 0 {\n                low += 1;\n        \
    \    } else {\n                high -= 1;\n            }\n        }\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphfs9i2ls.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: Implement me!\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe70se1bb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplkzt66ia.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // REPLACE THIS WITH YOUR CODE\n    true\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp92ekssg9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    // let's find the largest abs_val in the list.\n    let largest = abs_max(l);\n\
    \n    // let's create a list of counters, the length of this list is\n    // (largest\
    \ + 1).\n    let mut counters = vec![0; largest as usize + 1];\n\n    // now let's\
    \ loop over all the elements of the list and increment\n    // the counter at\
    \ index i to know that we've seen it already.\n    for x in l {\n        let idx\
    \ = x + largest;\n        if idx < 0 || idx as usize >= counters.len() {\n   \
    \         panic!(\"uh oh\");\n        }\n        counters[idx as usize] += 1;\n\
    \    }\n\n    // now let's loop over the counters and see if we can find triples.\n\
    \    for i in 0..counters.len() {\n        for j in 0..counters.len() {\n    \
    \        for k in 0..counters.len() {\n                if counters[i] >= 1 &&\
    \ counters[j] >= 1 && counters[k] >= 1 && i as isize - j as isize == k as isize\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n    }\n\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs_max` in this scope\n  --> /tmp/tmpbxsegn7s.rs:20:19\n\
    \   |\n20 |     let largest = abs_max(l);\n   |                   ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: implementation\n    let mut flag = false;\n\
    \    for i in 0..l.len() {\n        for j in i+1..l.len() {\n            for k\
    \ in j+1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n          \
    \          flag = true;\n                }\n            }\n        }\n    }\n\
    \    flag\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l2 = l.clone();\n    l2.sort();\n    for\
    \ i in 0..l2.len() {\n        for j in (i + 1)..l2.len() {\n            let sum\
    \ = l2[i] + l2[j];\n            if binary_search(&l2, -sum) {\n              \
    \  return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_search` in this scope\n  -->\
    \ /tmp/tmpoogl7rt0.rs:20:16\n   |\n20 |             if binary_search(&l2, -sum)\
    \ {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //your code here\n    false\n}\n\nfn main() {\n \
    \   let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmm06prcg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for a in l.iter() {\n        for b in l.iter() {\n\
    \            for c in l.iter() {\n                if a + b + c == 0 {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz9oakneh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // check for the trivial case where there are less\
    \ than 3 elements\n    if l.len() < 3 {\n        return false;\n    }\n\n    //\
    \ a triplet is a list of three elements\n    // l.choose_multiple(3) generates\
    \ all the possible triplets from l\n    // l.choose_multiple(3).any() returns\
    \ true if any of the elements\n    // of the triplets generated sum to zero\n\
    \    l.choose_multiple(3).any(|triplet| triplet.iter().sum::<isize>() == 0)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `choose_multiple` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp6xapyadm.rs:24:7\n   |\n24 |     l.choose_multiple(3).any(|triplet|\
    \ triplet.iter().sum::<isize>() == 0)\n   |       ^^^^^^^^^^^^^^^ method not found\
    \ in `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut zero_sum_exists = false;\n    for i in 0..l.len()\
    \ {\n        for j in i + 1..l.len() {\n            for k in j + 1..l.len() {\n\
    \                if l[i] + l[j] + l[k] == 0 {\n                    zero_sum_exists\
    \ = true;\n                }\n            }\n        }\n    }\n    zero_sum_exists\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if x != y && y != z && x !=\
    \ z && x + y + z == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj6byy15q.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_lqurktn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut has_zero: bool = false;\n    let mut has_neg:\
    \ bool = false;\n    let mut has_pos: bool = false;\n    for i in l {\n      \
    \  if i == 0 {\n            has_zero = true;\n        } else if i < 0 {\n    \
    \        has_neg = true;\n        } else {\n            has_pos = true;\n    \
    \    }\n    }\n    if has_zero && has_neg && has_pos {\n        return true;\n\
    \    }\n    for a in l.iter() {\n        for b in l.iter() {\n            for\
    \ c in l.iter() {\n                if a != b && b != c && a != c && a + b + c\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpv93fyj9m.rs:30:14\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n18  |     for i in l {\n    |             \
    \ - `l` moved due to this implicit call to `.into_iter()`\n...\n30  |     for\
    \ a in l.iter() {\n    |              ^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `l`\n    = note: borrow occurs due to deref coercion to `[isize]`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n18  |     for i in &l {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut set: HashSet<isize> = HashSet::new();\n \
    \   let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    for i in 0..l.len()\
    \ {\n        for j in 0..l.len() {\n            for k in 0..l.len() {\n      \
    \          if l[i] + l[j] + l[k] == 0 {\n                    set.insert(l[i]);\n\
    \                    set.insert(l[j]);\n                    set.insert(l[k]);\n\
    \                }\n            }\n        }\n    }\n    if set.len() == 3 {\n\
    \        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpr83xp13f.rs:15:18\n\
    \   |\n15 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpr83xp13f.rs:15:35\n\
    \   |\n15 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    l.iter().enumerate().flat_map(|(i,\
    \ &x)| l.iter().enumerate().filter(move |(j, _)| i < j)\n                    \
    \                        .map(move |(_, &y)| (x, y))).any(|(x, y)| l.contains(&(-x\
    \ - y)))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptizyrhra.rs:16:91\n   |\n\
    16 |     l.iter().enumerate().flat_map(|(i, &x)| l.iter().enumerate().filter(move\
    \ |(j, _)| i < j)\n   |                                                      \
    \                                     ^ expected `usize`, found `&usize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n16 |     l.iter().enumerate().flat_map(|(i,\
    \ &x)| l.iter().enumerate().filter(move |(j, _)| i < *j)\n   |               \
    \                                                                            +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let n = l.len();\n    let mut i = 0;\n    while i\
    \ < n - 2 {\n        let mut j = i + 1;\n        while j < n - 1 {\n         \
    \   let mut k = j + 1;\n            while k < n {\n                if l[i] + l[j]\
    \ + l[k] == 0 {\n                    return true;\n                }\n       \
    \         k += 1;\n            }\n            j += 1;\n        }\n        i +=\
    \ 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp32fldrmb.rs:17:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for idx1 in 0..l.len() {\n        for idx2 in idx1\
    \ + 1..l.len() {\n            for idx3 in idx2 + 1..l.len() {\n              \
    \  if l[idx1] + l[idx2] + l[idx3] == 0 {\n                    return true;\n \
    \               }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for a in 0..l.len() {\n        for b in a + 1..l.len()\
    \ {\n            for c in b + 1..l.len() {\n                if l[a] + l[b] + l[c]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: implement this function!\n    false\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7egxvs88.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut l = l;\n    l.sort();\n    let mut first\
    \ = 0;\n    let mut second = 1;\n    let mut third = 2;\n    while third < l.len()\
    \ {\n        let sum = l[first] + l[second] + l[third];\n        if sum == 0 {\n\
    \            return true;\n        } else if sum < 0 {\n            second +=\
    \ 1;\n        } else {\n            first += 1;\n        }\n        if second\
    \ == third {\n            third += 1;\n            second = first + 1;\n     \
    \   }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmpmafgsxxk.rs:21:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut n = 0;\n    for i in l.iter() {\n       \
    \ for j in l.iter() {\n            for k in l.iter() {\n                if i !=\
    \ j && j != k && i != k && i + j + k == 0 {\n                    n += 1;\n   \
    \             }\n            }\n        }\n    }\n    if n > 0 {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo3a323nr.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n  for (i, v) in l.iter().enumerate() {\n    for (j, w)\
    \ in l.iter().enumerate() {\n      for (k, x) in l.iter().enumerate() {\n    \
    \    if i != j && i != k && j != k && v + w + x == 0 {\n          return true;\n\
    \        }\n      }\n    }\n  }\n  false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut empty_vec = Vec::new();\n\
    \    for a in l.iter() {\n        sum = 0;\n        for b in l.iter() {\n    \
    \        sum = 0;\n            for c in l.iter() {\n                sum = a +\
    \ b + c;\n                if sum == 0 {\n                    return true;\n  \
    \              }\n            }\n        }\n    }\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmprxvty6u5.rs:16:25\n\
    \   |\n16 |     let mut empty_vec = Vec::new();\n   |         -------------  \
    \ ^^^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |    \
    \     consider giving `empty_vec` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut i: usize = 0;\n    while i < l.len() - 2 {\n        let mut j: usize\
    \ = i + 1;\n        while j < l.len() - 1 {\n            let mut k: usize = j\
    \ + 1;\n            while k < l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n              \
    \  k += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: your code here\n    true\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk40wjnt8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // declaring variables\n    let mut i: usize = 0;\n\
    \    let mut j: usize = 0;\n    let mut k: usize = 0;\n    let mut result: bool\
    \ = false;\n\n    // checking if the list is empty or has less than 3 elements\n\
    \    if l.len() < 3 {\n        return result;\n    }\n\n    // checking the elements\
    \ of the list\n    for i in 0..l.len() {\n        for j in 0..l.len() {\n    \
    \        for k in 0..l.len() {\n                if i != j && i != k && j != k\
    \ {\n                    if l[i] + l[j] + l[k] == 0 {\n                      \
    \  result = true;\n                    }\n                }\n            }\n \
    \       }\n    }\n\n    return result;\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut skip_set = HashSet::new();\n    for (i, &elem) in l.iter().enumerate()\
    \ {\n        if skip_set.contains(&elem) {\n            continue;\n        }\n\
    \        let mut sum_set = HashSet::new();\n        for &elem2 in l.iter().skip(i\
    \ + 1) {\n            if sum_set.contains(&(-elem - elem2)) {\n              \
    \  return true;\n            }\n            sum_set.insert(elem2);\n        }\n\
    \        skip_set.insert(elem);\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8p34p233.rs:18:24\n   |\n18 |     let mut skip_set = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8p34p233.rs:23:27\n\
    \   |\n23 |         let mut sum_set = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s = HashSet::new();\n    let mut results\
    \ = HashSet::new();\n    for i in l {\n        for j in s.iter() {\n         \
    \   if i + j == 0 {\n                results.insert(j);\n            }\n     \
    \   }\n        s.insert(i);\n    }\n    results.len() == 3\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpndp1qarr.rs:15:17\n   |\n15 |     let mut s = HashSet::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpndp1qarr.rs:16:23\n\
    \   |\n16 |     let mut results = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i + 1..l.len()\
    \ {\n            for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() - 2 {\n        for j in i + 1..l.len()\
    \ - 1 {\n            for k in j + 1..l.len() {\n                if l[i] + l[j]\
    \ + l[k] == 0 {\n                    return true;\n                }\n       \
    \     }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpz7sfukhy.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    /*\n    let mut hash_map = HashMap::new();\n    for\
    \ num in l {\n        match hash_map.get(&num) {\n            Some(&x) => {\n\
    \                return true;\n            }\n            None => {\n        \
    \        hash_map.insert(-num, 1);\n            }\n        }\n    }\n    false\n\
    \    */\n    let l_len = l.len();\n    for i in 0..l_len {\n        for j in i\
    \ + 1..l_len {\n            for k in j + 1..l_len {\n                if l[i] +\
    \ l[j] + l[k] == 0 {\n                    return true;\n                }\n  \
    \          }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmhwbco8z.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //  Sort the input.\n    let mut l = l;\n    l.sort();\n\
    \n    //  Consider each triple in the sorted list.\n    for i in 0..l.len() {\n\
    \        let a = l[i];\n        let mut j = i + 1;\n        let mut k = l.len()\
    \ - 1;\n        while j < k {\n            let b = l[j];\n            let c =\
    \ l[k];\n            if a + b + c == 0 {\n                return true;\n     \
    \       } else if a + b + c < 0 {\n                j += 1;\n            } else\
    \ {\n                k -= 1;\n            }\n        }\n    }\n\n    false\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjmaomu5d.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut set: HashSet<isize> = HashSet::new();\n \
    \   let mut l: Vec<isize> = l;\n    l.sort();\n    let mut i = 0;\n    while i\
    \ < l.len() {\n        let mut j = i + 1;\n        while j < l.len() {\n     \
    \       if set.contains(&(-l[i] - l[j])) {\n                return true;\n   \
    \         }\n            j += 1;\n        }\n        set.insert(l[i]);\n     \
    \   i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpayko4ksa.rs:15:18\n\
    \   |\n15 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpayko4ksa.rs:15:35\n\
    \   |\n15 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for (i, x) in l.iter().enumerate() {\n        for\
    \ (j, y) in l.iter().enumerate() {\n            for (k, z) in l.iter().enumerate()\
    \ {\n                if i != j && i != k && j != k && x + y + z == 0 {\n     \
    \               return true;\n                }\n            }\n        }\n  \
    \  }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if x != y && y != z && x !=\
    \ z && *x + *y + *z == 0 {\n                    return true;\n               \
    \ }\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprnu7jb3b.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // fill in the code here\n    let mut new_l: Vec<isize>\
    \ = Vec::new();\n    let mut check: bool = false;\n    for k in 0..l.len() {\n\
    \        new_l.push(l[k] * -1);\n    }\n    for i in 0..l.len() {\n        for\
    \ j in 0..new_l.len() {\n            if l[i] + new_l[j] == 0 {\n             \
    \   check = true;\n            }\n        }\n    }\n    check\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaqn_orv_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8r0fun3f.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    for elem in &l {\n \
    \       for elem2 in &l {\n            for elem3 in &l {\n                if elem\
    \ != elem2 && elem != elem3 && elem2 != elem3 {\n                    if elem +\
    \ elem2 + elem3 == 0 {\n                        result = true;\n             \
    \       }\n                }\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpszd__ten.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for a in l.iter() {\n        for b in l.iter() {\n\
    \            for c in l.iter() {\n                if (a != b) && (b != c) && (a\
    \ != c) && (a + b + c == 0) {\n                    return true;\n            \
    \    }\n            }\n        }\n    }\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzy27vpid.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l.iter() {\n        for j in l.iter() {\n\
    \            for k in l.iter() {\n                if i == j || i == k || j ==\
    \ k {\n                    continue;\n                }\n                if i\
    \ + j + k == 0 {\n                    return true;\n                }\n      \
    \      }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ot8dfnv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpju_l2g_4.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.len() > 2\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1w2q45r6.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppib6e0m4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let l = l;\n    let zero = 0;\n    let mut triples_sum_to_zero\
    \ = false;\n    if l.len() < 3 {\n        return triples_sum_to_zero;\n    } else\
    \ {\n        for i in 0..l.len() {\n            for j in i+1..l.len() {\n    \
    \            for k in j+1..l.len() {\n                    if l[i] + l[j] + l[k]\
    \ == zero {\n                        triples_sum_to_zero = true;\n           \
    \         }\n                }\n            }\n        }\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Hint: check for the case when there are less than\
    \ 3 elements\n    if l.len() < 3 {\n        return false;\n    }\n    // Hint:\
    \ you might want to sort the list and then look for triples\n    let mut l = l;\n\
    \    l.sort();\n    // Hint: there is a naive solution that iterates over all\n\
    \    // the triples in the list, and computes their sum.\n    // There is a better\
    \ solution that uses the sorted list.\n    // Consider the first element in the\
    \ list, say l[0]. The\n    // other two elements must sum to -l[0]. Look for the\
    \ pair\n    // that has this sum by checking for elements that are\n    // greater\
    \ than l[0] and their opposites.\n    for i in 0..l.len() {\n        let first\
    \ = l[i];\n        for j in i + 1..l.len() {\n            let second = l[j];\n\
    \            let third = -first - second;\n            if l.contains(&third) {\n\
    \                return true;\n            }\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let mut a_vec = Vec::new();\n\
    \    let mut b_vec = Vec::new();\n    let mut c_vec = Vec::new();\n    let mut\
    \ a_set = HashSet::new();\n    let mut b_set = HashSet::new();\n    let mut c_set\
    \ = HashSet::new();\n    let mut ab_hash = HashMap::new();\n    let mut bc_hash\
    \ = HashMap::new();\n    for i in 0..l.len() {\n        a_vec.push(l[i]);\n  \
    \      b_vec.push(l[i]);\n        c_vec.push(l[i]);\n    }\n    for i in 0..l.len()\
    \ {\n        for j in i + 1..l.len() {\n            let sum = l[i] + l[j];\n \
    \           let diff = l[i] - l[j];\n            if ab_hash.contains_key(&sum)\
    \ {\n                let mut ab_set = ab_hash.get_mut(&sum).unwrap();\n      \
    \          ab_set.insert(i);\n                ab_set.insert(j);\n            }\
    \ else {\n                let mut ab_set = HashSet::new();\n                ab_set.insert(i);\n\
    \                ab_set.insert(j);\n                ab_hash.insert(sum, ab_set);\n\
    \            }\n            if bc_hash.contains_key(&diff) {\n               \
    \ let mut bc_set = bc_hash.get_mut(&diff).unwrap();\n                bc_set.insert(i);\n\
    \                bc_set.insert(j);\n            } else {\n                let\
    \ mut bc_set = HashSet::new();\n                bc_set.insert(i);\n          \
    \      bc_set.insert(j);\n                bc_hash.insert(diff, bc_set);\n    \
    \        }\n        }\n    }\n    for i in 0..l.len() {\n        if i == 0 {\n\
    \            a_set.insert(i);\n        } else {\n            a_set.insert(i -\
    \ 1);\n            a_set.insert(i);\n        }\n        if b_set.len() > 0\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0awjfmpw.rs:76:3\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |            \
    \                                   - unclosed delimiter\n...\n55 |     for i\
    \ in 0..l.len() {\n   |                         - this delimiter might not be\
    \ properly closed...\n...\n63 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n76 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmp0awjfmpw.rs:63:1\n   |\n62 |         if b_set.len() > 0\n   |      \
    \   -- this `if` expression has a condition, but no block\n63 | }\n   | ^ expected\
    \ `{`\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0awjfmpw.rs:19:21\n   |\n19 |     let mut a_set = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp0awjfmpw.rs:20:21\n\
    \   |\n20 |     let mut b_set = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp0awjfmpw.rs:21:21\n   |\n21\
    \ |     let mut c_set = HashSet::new();\n   |                     ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmp0awjfmpw.rs:22:23\n   |\n22 |  \
    \   let mut ab_hash = HashMap::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmp0awjfmpw.rs:23:23\n   |\n23 |  \
    \   let mut bc_hash = HashMap::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collecti"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // Base case:\n    if l.len() < 3 {\n        return\
    \ false;\n    }\n    let mut l_sorted = l.clone();\n    l_sorted.sort();\n   \
    \ // The invariant is that l_sorted will be sorted at the end of the loop\n  \
    \  for (i, x) in l_sorted.iter().enumerate() {\n        let (left, right) = l_sorted.split_at(i);\n\
    \        let mut left_i = left.len() - 1;\n        let mut right_i = 0;\n    \
    \    // The invariant is that for the left and right variables,\n        // sum_to_zero(x,\
    \ left[left_i], right[right_i]) will be true for the end of the loop\n       \
    \ while left_i >= 0 && right_i < right.len() {\n            let sum = x + left[left_i]\
    \ + right[right_i];\n            if sum == 0 {\n                return true;\n\
    \            } else if sum < 0 {\n                left_i -= 1;\n            }\
    \ else {\n                right_i += 1;\n            }\n        }\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpc6asvxcp.rs:24:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    let mut l = l;\n    l.sort();\n\
    \    let mut i = 0;\n    while i < l.len() {\n        let mut j = i + 1;\n   \
    \     let mut k = l.len() - 1;\n        while j < k {\n            if l[i] + l[j]\
    \ + l[k] == 0 {\n                return true;\n            } else if l[i] + l[j]\
    \ + l[k] < 0 {\n                j += 1;\n            } else {\n              \
    \  k -= 1;\n            }\n        }\n        i += 1;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for (i, num1) in l.iter().enumerate() {\n       \
    \ for (j, num2) in l.iter().enumerate() {\n            for (k, num3) in l.iter().enumerate()\
    \ {\n                if (i != j && j != k && i != k) && (*num1 + *num2 + *num3\
    \ == 0) {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc0qdgc6b.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    if l.len() < 3 {\n \
    \       return result;\n    }\n    for i in 0..l.len() - 2 {\n        for j in\
    \ i + 1..l.len() - 1 {\n            for k in j + 1..l.len() {\n              \
    \  if l[i] + l[j] + l[k] == 0 {\n                    result = true;\n        \
    \        }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut sumset = HashSet::new();\n\
    \    let mut tset = HashSet::new();\n    for i in l {\n        sumset.insert(i);\n\
    \    }\n    for a in sumset.iter() {\n        for b in sumset.iter() {\n     \
    \       sum = a + b;\n            tset.insert(sum);\n        }\n    }\n    for\
    \ a in tset.iter() {\n        if sumset.contains(&(-a)) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpg2rwrs3j.rs:16:22\n   |\n16 |     let mut sumset = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpg2rwrs3j.rs:17:20\n\
    \   |\n17 |     let mut tset = HashSet::new();\n   |                    ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if x != y && y != z && x !=\
    \ z && x + y + z == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi0luygyi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.len() < 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp90gpqjq9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut l_copy = l.clone();\n    l_copy.sort();\n    for i in 0..l_copy.len()\
    \ - 2 {\n        let mut low = i + 1;\n        let mut high = l_copy.len() - 1;\n\
    \        while low < high {\n            let curr_sum = l_copy[i] + l_copy[low]\
    \ + l_copy[high];\n            if curr_sum == 0 {\n                return true;\n\
    \            } else if curr_sum < 0 {\n                low += 1;\n           \
    \ } else {\n                high -= 1;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO: implement this function\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzafq7gni.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp67cmycd1.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    let mut n = 0;\n    while\
    \ n < l.len() {\n        let mut m = n + 1;\n        while m < l.len() {\n   \
    \         let mut o = m + 1;\n            while o < l.len() {\n              \
    \  if l[n] + l[m] + l[o] == 0 {\n                    count += 1;\n           \
    \     }\n                o += 1;\n            }\n            m += 1;\n       \
    \ }\n        n += 1;\n    }\n    if count >= 1 {\n        return true;\n    }\
    \ else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    for i in 0..l.len() {\n        for j in i+1..l.len() {\n            for k\
    \ in j+1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n          \
    \          return true;\n                }\n            }\n        }\n    }\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in (i + 1)..l.len()\
    \ {\n            for k in (j + 1)..l.len() {\n                if l[i] + l[j] +\
    \ l[k] == 0 {\n                    return true;\n                }\n         \
    \   }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // we'll sort the list l first,\n    // so that we\
    \ can use a binary search to look for the 'other' element\n    // that completes\
    \ the triple.\n    let mut l = l;\n    l.sort();\n    // invariant:\n    // at\
    \ this point, we know that the first two elements in l are not the\n    // two\
    \ distinct elements that sum to zero with a third element.\n    // However, there\
    \ might be two elements to the right of l[2] that sum to\n    // zero with l[2].\n\
    \    // For example, say we are looking at [-1, 0, 1, 2].\n    // The two distinct\
    \ elements that sum to zero with l[2] are -1 and 1.\n    // The two distinct elements\
    \ that sum to zero with l[3] are -1 and 2.\n    for i in 2..l.len() {\n      \
    \  // We can now use a binary search for the other element.\n        let find\
    \ = -(l[i]);\n        if bin_search(&l, i, find) {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bin_search` in this scope\n  --> /tmp/tmp5e_fu6a7.rs:31:12\n\
    \   |\n31 |         if bin_search(&l, i, find) {\n   |            ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = false;\n    let mut i = 0;\n    let\
    \ mut j = 1;\n    let mut k = 2;\n    let len = l.len();\n    if len < 3 {\n \
    \       return false;\n    }\n    while (i < len - 2) {\n        while (j < len\
    \ - 1) {\n            while (k < len) {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    sum = true;\n                }\n               \
    \ k += 1;\n            }\n            j += 1;\n            k = j + 1;\n      \
    \  }\n        i += 1;\n        j = i + 1;\n        k = j + 1;\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len()\
    \ {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for x in l.iter() {\n        for y in l.iter() {\n\
    \            for z in l.iter() {\n                if x != y && y != z && x !=\
    \ z && x + y + z == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5re_44pt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut three = false;\n    let mut counter = 0;\n\
    \    while counter < l.len() && !three {\n        let mut sum = 0;\n        for\
    \ i in counter + 1..l.len() {\n            sum = l[counter] + l[i];\n        \
    \    for j in i + 1..l.len() {\n                if l[j] == -sum {\n          \
    \          three = true;\n                }\n            }\n        }\n      \
    \  counter += 1;\n    }\n    three\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut zero = false;\n    for i in 0..l.len() {\n\
    \        for j in 0..l.len() {\n            for k in 0..l.len() {\n          \
    \      if (i != j) && (j != k) && (i != k) {\n                    if l[i] + l[j]\
    \ + l[k] == 0 {\n                        zero = true;\n                    }\n\
    \                }\n            }\n        }\n    }\n    zero\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut j = 1;\n    let mut k\
    \ = 2;\n    let mut result = false;\n    let mut inner = 0;\n    let mut outer\
    \ = 0;\n    let mut inner2 = 0;\n    let mut outer2 = 0;\n    let mut inner3 =\
    \ 0;\n    let mut outer3 = 0;\n    let mut inner4 = 0;\n    let mut outer4 = 0;\n\
    \    let mut inner5 = 0;\n    let mut outer5 = 0;\n    let mut inner6 = 0;\n \
    \   let mut outer6 = 0;\n    let mut inner7 = 0;\n    let mut outer7 = 0;\n  \
    \  let mut inner8 = 0;\n    let mut outer8 = 0;\n    let mut inner9 = 0;\n   \
    \ let mut outer9 = 0;\n    let mut inner10 = 0;\n    let mut outer10 = 0;\n  \
    \  let mut inner11 = 0;\n    let mut outer11 = 0;\n    let mut inner12 = 0;\n\
    \    let mut outer12 = 0;\n    let mut inner13 = 0;\n    let mut outer13 = 0;\n\
    \    let mut inner14 = 0;\n    let mut outer14 = 0;\n    let mut inner15 = 0;\n\
    \    let mut outer15 = 0;\n    let mut inner16 = 0;\n    let mut outer16 = 0;\n\
    \    let mut inner17 = 0;\n    let mut outer17 = 0;\n    let mut inner18 = 0;\n\
    \    let mut outer18 = 0;\n    let mut inner19 = 0;\n    let mut outer19 = 0;\n\
    \    let mut inner20 = 0;\n    let mut outer20 = 0;\n    let mut inner21 = 0;\n\
    \    let mut outer21 = 0;\n    let mut inner22 = 0;\n    let mut outer22 = 0;\n\
    \    let mut inner23 = 0;\n    let mut outer23 = 0;\n    let mut inner24 = 0;\n\
    \    let mut outer24 = 0;\n    let mut inner25 = 0;\n    let mut outer25 = 0;\n\
    \    let mut inner26 = 0;\n    let mut outer26 = 0;\n    let mut inner27 = 0;\n\
    \    let mut outer\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp41lygnee.rs:72:18\n   |\n\
    72 |     let mut outer\n   |                  ^ help: add `;` here\n73 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41lygnee.rs:14:42\n\
    \   |\n14 | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -------------------\
    \                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut s: Vec<isize> = l.clone();\n    s.sort();\n\
    \    let n = s.len();\n    if n < 3 {\n        return false;\n    }\n\n    for\
    \ (i, &a) in s.iter().enumerate() {\n        let (mut j, mut k) = (i + 1, n -\
    \ 1);\n        while j < k {\n            let sum = a + s[j] + s[k];\n       \
    \     if sum == 0 {\n                return true;\n            } else if sum <\
    \ 0 {\n                j += 1;\n            } else {\n                k -= 1;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut found = false;\n    for i in 0..l.len() {\n\
    \        for j in i + 1..l.len() {\n            for k in j + 1..l.len() {\n  \
    \              if l[i] + l[j] + l[k] == 0 {\n                    found = true;\n\
    \                }\n            }\n        }\n    }\n    found\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm0m249_h.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sorted_list = l.clone();\n    sorted_list.sort();\n\
    \    for i in 0..sorted_list.len() - 2 {\n        let j = i + 1;\n        let\
    \ k = sorted_list.len() - 1;\n        while j < k {\n            let sum = sorted_list[i]\
    \ + sorted_list[j] + sorted_list[k];\n            if sum == 0 {\n            \
    \    return true;\n            } else if sum < 0 {\n                j += 1;\n\
    \            } else {\n                k -= 1;\n            }\n        }\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n \
    \   assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `j`\n  --> /tmp/tmpa7o91ltn.rs:25:17\n\
    \   |\n18 |         let j = i + 1;\n   |             -\n   |             |\n \
    \  |             first assignment to `j`\n   |             help: consider making\
    \ this binding mutable: `mut j`\n...\n25 |                 j += 1;\n   |     \
    \            ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `k`\n  --> /tmp/tmpa7o91ltn.rs:27:17\n\
    \   |\n19 |         let k = sorted_list.len() - 1;\n   |             -\n   | \
    \            |\n   |             first assignment to `k`\n   |             help:\
    \ consider making this binding mutable: `mut k`\n...\n27 |                 k -=\
    \ 1;\n   |                 ^^^^^^ cannot assign twice to immutable variable\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let mut i = 0;\n   \
    \ while i < l.len() - 2 {\n        let mut j = i + 1;\n        while j < l.len()\
    \ - 1 {\n            let mut k = j + 1;\n            while k < l.len() {\n   \
    \             if l[i] + l[j] + l[k] == 0 {\n                    result = true;\n\
    \                }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptznf10kf.rs:17:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //i is going to be the index of the first element\
    \ in a triple\n    for i in 0..l.len() {\n        //j is going to be the index\
    \ of the second element in a triple\n        for j in i+1..l.len() {\n       \
    \     //if l[i] + l[j] equals 0 - l[k], then l[i], l[j], and l[k] will\n     \
    \       //sum to zero\n            if l.contains(&(0 - l[i] - l[j])) && i != j\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut b = false;\n    let mut m = l.len();\n  \
    \  while m >= 3 {\n        let idx = m - 1;\n        let x = l[idx];\n       \
    \ m -= 1;\n        let mut j = m;\n        while j >= 2 {\n            let idx\
    \ = j - 1;\n            let y = l[idx];\n            j -= 1;\n            let\
    \ mut k = j;\n            while k >= 1 {\n                let idx = k - 1;\n \
    \               let z = l[idx];\n                k -= 1;\n                if x\
    \ + y + z == 0 {\n                    b = true;\n                }\n         \
    \   }\n        }\n    }\n    b\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    let mut nums: Vec<isize> = l.clone();\n    nums.sort();\n    for i in 0..(nums.len()\
    \ - 2) {\n        if nums[i] == nums[i + 1] && nums[i] == nums[i + 2] {\n    \
    \        continue;\n        }\n        if i > 0 && nums[i] == nums[i - 1] {\n\
    \            continue;\n        }\n        let mut start = i + 1;\n        let\
    \ mut end = nums.len() - 1;\n        while start < end {\n            let sum\
    \ = nums[i] + nums[start] + nums[end];\n            if sum == 0 {\n          \
    \      return true;\n            } else if sum > 0 {\n                end -= 1;\n\
    \            } else {\n                start += 1;\n            }\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let mut index = 0;\n\
    \    let len = l.len();\n    let mut counter = 0;\n    for i in 0..len {\n   \
    \     let mut sublist = l.clone();\n        sublist.remove(i);\n        for j\
    \ in 0..sublist.len() {\n            let mut subsublist = sublist.clone();\n \
    \           subsublist.remove(j);\n            for k in 0..subsublist.len() {\n\
    \                if subsublist[k] + sublist[j] + l[i] == 0 {\n               \
    \     result = true;\n                }\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = false;\n    for i in 0..l.len() {\n\
    \        for j in i+1..l.len() {\n            for k in j+1..l.len() {\n      \
    \          if l[i] + l[j] + l[k] == 0 {\n                    sum = true;\n   \
    \             }\n            }\n        }\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l.iter() {\n        for j in l.iter() {\n\
    \            for k in l.iter() {\n                if i != j && j != k && i !=\
    \ k && i + j + k == 0 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm4t5wh1u.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\
    \    for x in l.iter() {\n        for y in l.iter() {\n            for z in l.iter()\
    \ {\n                if x == y || x == z || y == z {\n                    continue;\n\
    \                }\n                if x + y + z == 0 {\n                    return\
    \ true;\n                }\n            }\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpefmgg186.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().enumerate().any(|(a, &aa)| {\n        l.iter().enumerate().any(|(b,\
    \ &bb)| {\n            l.iter().enumerate().any(|(c, &cc)| {\n               \
    \ a != b && a != c && b != c && aa + bb + cc == 0\n            })\n        })\n\
    \    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // print!(\"{:?}\", l);\n    for i in l.iter() {\n\
    \        for j in l.iter() {\n            for k in l.iter() {\n              \
    \  if (i != j) && (j != k) && (i != k) && (i + j + k == 0) {\n               \
    \     // print!(\"{} + {} + {} = 0\", i, j, k);\n                    return true;\n\
    \                }\n            }\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvis014z0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpighirv4o.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplb313wkj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2t51b1rb.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph9edwimz.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4thakxj7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu30ywx92.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // your code here\n    let mut x = 0;\n    let mut\
    \ y = 0;\n    let mut z = 0;\n    for i in l.iter() {\n        for j in l.iter()\
    \ {\n            for k in l.iter() {\n                if i + j + k == 0 {\n  \
    \                  x = *i;\n                    y = *j;\n                    z\
    \ = *k;\n                }\n            }\n        }\n    }\n    if x + y + z\
    \ == 0 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeote89dr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpi64h7bp2.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5frlm2af.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // your code here\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_4otqr6g.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut has_zero: bool = false;\n    let mut l2:\
    \ Vec<isize> = Vec::new();\n    for num in l {\n        if num == 0 {\n      \
    \      has_zero = true;\n        } else {\n            l2.push(num);\n       \
    \ }\n    }\n    l2.sort();\n    let mut i: usize = 0;\n    while i < l2.len()\
    \ - 2 {\n        let l2_slice: &[isize] = &l2[i + 1..];\n        if find_pair_that_sums_to_zero(l2[i],\
    \ l2_slice) {\n            return true;\n        }\n        i += 1;\n    }\n \
    \   has_zero && l2.len() >= 2\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_pair_that_sums_to_zero` in this\
    \ scope\n  --> /tmp/tmpy6uc9it0.rs:28:12\n   |\n28 |         if find_pair_that_sums_to_zero(l2[i],\
    \ l2_slice) {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let length = l.len();\n\
    \    for x in 0..length {\n        for y in (x + 1)..length {\n            for\
    \ z in (y + 1)..length {\n                if l[x] + l[y] + l[z] == 0 {\n     \
    \               result = true;\n                }\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // go through the list and check if any 3 of them\
    \ add up to 0\n    for a in 0..l.len() {\n        for b in a + 1..l.len() {\n\
    \            for c in b + 1..l.len() {\n                if l[a] + l[b] + l[c]\
    \ == 0 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // you can use this function to sort your list\n\
    \    fn sort(l: &mut Vec<isize>) {\n        sort_slice(l)\n    }\n\n    // this\
    \ function is already complete\n    fn triples_sum_to_zero_slice(l: &[isize])\
    \ -> bool {\n        if l.len() < 3 {\n            return false;\n        }\n\
    \        for i in 0..l.len() {\n            let mut j = i + 1;\n            let\
    \ mut k = l.len() - 1;\n            while j < k {\n                let curr_sum\
    \ = l[i] + l[j] + l[k];\n                if curr_sum == 0 {\n                \
    \    return true;\n                } else if curr_sum < 0 {\n                \
    \    j += 1;\n                } else {\n                    k -= 1;\n        \
    \        }\n            }\n        }\n        false\n    }\n\n    // add your\
    \ code here\n    let mut l_ = l.clone();\n    sort(&mut l_);\n    triples_sum_to_zero_slice(&l_)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_slice` in this scope\n  --> /tmp/tmpnsjz8v2p.rs:17:9\n\
    \   |\n17 |         sort_slice(l)\n   |         ^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmcgimtgf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsp1qridc.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    // your solution here\n    false\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1h9rh89n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    //a, b, c = 0;\n    let mut i = 0;\n    let mut j\
    \ = 1;\n    let mut k = 2;\n    for c in l.iter() {\n        for b in l.iter()\
    \ {\n            for a in l.iter() {\n                if i != j && j != k && i\
    \ != k {\n                    if a + b + c == 0 {\n                        return\
    \ true;\n                    }\n                }\n                i += 1;\n \
    \           }\n            j += 1;\n        }\n        k += 1;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcmxxukwd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() - 2 {\n        for j in i + 1..l.len() - 1 {\n      \
    \      for k in j + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    if l.len() < 3 {\n        return false;\n    }\n\n\
    \    for i in 0..l.len() {\n        for j in i + 1..l.len() {\n            for\
    \ k in j + 1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \ }\n\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n  // TODO: implement!\n  true\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppe314stp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut has_triple = false;\n    for i in 0..l.len()\
    \ - 2 {\n        for j in i + 1..l.len() - 1 {\n            for k in j + 1..l.len()\
    \ {\n                if l[i] + l[j] + l[k] == 0 {\n                    has_triple\
    \ = true;\n                }\n            }\n        }\n    }\n    has_triple\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprnjexzci.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in 0..l.len() - 2 {\n        for j in i + 1..l.len()\
    \ - 1 {\n            for k in j + 1..l.len() {\n                if l[i] + l[j]\
    \ + l[k] == 0 {\n                    return true;\n                }\n       \
    \     }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpe_jhbl3u.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    for i in l.iter() {\n        for j in l.iter() {\n\
    \            for k in l.iter() {\n                if *i + *j + *k == 0 {\n   \
    \                 return true;\n                }\n            }\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpscvfflm0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplwevnmtn.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero([1, 3, 5, 0])\n///\
    \ False\n/// >>> triples_sum_to_zero([1, 3, -2, 1])\n/// True\n/// >>> triples_sum_to_zero([1,\
    \ 2, 3, 7])\n/// False\n/// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n///\
    \ True\n/// >>> triples_sum_to_zero([1])\n/// False\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    for i in 0..l.len()\
    \ {\n        for j in (i + 1)..l.len() {\n            for k in (j + 1)..l.len()\
    \ {\n                if l[i] + l[j] + l[k] == 0 {\n                    result\
    \ = true;\n                }\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
