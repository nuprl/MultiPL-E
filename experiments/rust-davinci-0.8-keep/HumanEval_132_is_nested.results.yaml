name: HumanEval_132_is_nested
language: rust
results:
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut brack_cnt = 0;\n    for ch\
    \ in string.chars() {\n        match ch {\n            '[' => brack_cnt += 1,\n\
    \            ']' => brack_cnt -= 1,\n            _ => (),\n        }\n       \
    \ if brack_cnt < 0 {\n            return false;\n        }\n    }\n    brack_cnt\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4s1_1vmv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ x in string.chars() {\n        if x == '[' {\n            stack.push(x);\n \
    \       } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy0no6ezz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut previous_is_opened\
    \ = false;\n    for ch in string.chars() {\n        if ch == '[' {\n         \
    \   if previous_is_opened {\n                count += 1;\n            }\n    \
    \        previous_is_opened = true;\n        } else {\n            previous_is_opened\
    \ = false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdtpro0pk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.pop() == None {\n            \
    \        return false;\n                }\n            }\n            _ => return\
    \ false,\n        }\n    }\n    if stack.is_empty() {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk4zjyd2w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut cnt = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            cnt += 1;\n        } else {\n        \
    \    cnt -= 1;\n        }\n        if cnt < 0 {\n            return false;\n \
    \       }\n    }\n    cnt == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0le5ffu7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut state = 0;\n\tfor c in string.chars()\
    \ {\n\t\tif c == '[' {\n\t\t\tstate += 1;\n\t\t} else {\n\t\t\tstate -= 1;\n\t\
    \t}\n\t\tif state < 0 {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn state > 0;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0yhubgkq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().filter(|x| vec!['[',\
    \ ']'].contains(x)).collect::<Vec<char>>().len() % 2 == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfmeu8fj5.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let vec = string.chars().collect::<Vec<char>>();\n\
    \    if vec.len() < 2 {\n        return false;\n    }\n    let mut list = Vec::new();\n\
    \    for c in vec {\n        if c == '[' {\n            list.push(c);\n      \
    \  } else {\n            if list.len() == 0 {\n                return false;\n\
    \            }\n            list.pop();\n        }\n    }\n    list.len() > 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprf7nrzm8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut last_was_opening = false;\n\
    \    for c in string.chars() {\n        if c == '[' {\n            if last_was_opening\
    \ {\n                return true;\n            }\n            last_was_opening\
    \ = true;\n        } else {\n            last_was_opening = false;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyi37w_ol.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => depth += 1,\n     \
    \       ']' => depth -= 1,\n            _ => continue,\n        }\n        if\
    \ depth < 0 {\n            return false;\n        }\n    }\n    depth > 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj8md4nug.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxhxuc9bz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else {\n            if let Some(top) = stack.pop() {\n               \
    \ if top != '[' {\n                    return false;\n                }\n    \
    \        } else {\n                return false;\n            }\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwhlzi_8d.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => if stack.pop() != Some('[') {\n                return false;\n\
    \            },\n            _ => return false,\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpivlztbcm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => if stack.pop() != Some('[') {\n                return false;\n\
    \            },\n            _ => return false,\n        }\n    }\n    return\
    \ stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7r4ityfl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    if stack.is_empty() {\n        false\n    } else {\n        true\n    }\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpetl_hv_w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let s = string.to_string();\n    if\
    \ s.is_empty() {\n        return false;\n    }\n\n    let mut stack = vec![];\n\
    \    for bracket in s.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm4_wcv25.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut is_nested = false;\n    let\
    \ brackets: Vec<char> = string.chars().collect();\n    let mut bracket_stack:\
    \ Vec<char> = Vec::new();\n    for bracket in brackets {\n        match bracket\
    \ {\n            '[' => bracket_stack.push(bracket),\n            ']' => {\n \
    \               if bracket_stack.is_empty() {\n                    return false;\n\
    \                }\n                let popped_bracket = bracket_stack.pop().unwrap();\n\
    \                if popped_bracket == '[' {\n                    is_nested = true;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  if bracket_stack.is_empty() {\n        return is_nested;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpldszfnl7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            match stack.pop() {\n                Some(_) =>\
    \ (),\n                None => return false,\n            }\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpilmcsgn6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpzqwm_0qe.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            match stack.pop() {\n                Some(_) =>\
    \ (),\n                None => return false,\n            }\n        }\n    }\n\
    \    return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo6dhijw8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            stack.push(i);\n \
    \       } else {\n            if stack.pop() == None {\n                return\
    \ false;\n            }\n        }\n    }\n    if stack.len() > 0 {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpidv_m88a.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut balance = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            balance += 1;\n       \
    \ } else {\n            balance -= 1;\n        }\n        if balance < 0 {\n \
    \           return false;\n        }\n    }\n    balance > 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpse_2pofp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut nesting = 0;\n    let open\
    \ = '[';\n    let close = ']';\n    for character in string.chars() {\n      \
    \  if character == open {\n            nesting += 1;\n        } else if character\
    \ == close {\n            nesting -= 1;\n        }\n        if nesting < 0 {\n\
    \            return false;\n        }\n    }\n    nesting > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm51pyhny.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \    }\n    stack.len() > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzqfnjanf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut z = 0;\n    for i in string.chars()\
    \ {\n        if i == '[' {\n            z += 1;\n        } else {\n          \
    \  z -= 1;\n        }\n        if z < 0 {\n            return false;\n       \
    \ }\n    }\n    z == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfvr7d3xh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    let mut\
    \ valid = false;\n    for s in string.chars() {\n        match s {\n         \
    \   '[' => counter += 1,\n            ']' => counter -= 1,\n            _ => {},\n\
    \        }\n        if counter == 0 {\n            valid = true;\n        }\n\
    \        if counter < 0 {\n            return false;\n        }\n    }\n    valid\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcy6mpb56.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => depth += 1,\n            ']' => depth\
    \ -= 1,\n            _ => unreachable!(),\n        }\n        if depth < 0 {\n\
    \            return false;\n        }\n    }\n    return depth > 0;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfv2fk6p1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            match stack.pop() {\n                Some('[')\
    \ => (),\n                _ => return false,\n            }\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx1komhh6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                let _ = stack.pop();\n\
    \            }\n            _ => {\n                return false;\n          \
    \  }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpojhzxqdv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut last_open = 0;\n    let mut\
    \ last_close = 0;\n    let mut open = 0;\n    let mut close = 0;\n    for bracket\
    \ in string.chars() {\n        if bracket == '[' {\n            last_open = open;\n\
    \            open += 1;\n        } else {\n            last_close = close;\n \
    \           close += 1;\n        }\n        if last_open < last_close {\n    \
    \        return false;\n        }\n    }\n    return open > close;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd7ob2mh3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some('[') = stack.pop() {\n    \
    \                continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => continue,\n     \
    \   }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5nfbnji7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprvxfvi2_.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.len() >\
    \ 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr857rf3t.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return !stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeonmhoh0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut level = 0;\n    for char in\
    \ string.chars() {\n        match char {\n            '[' => level += 1,\n   \
    \         ']' => {\n                if level == 0 {\n                    return\
    \ false;\n                }\n                level -= 1;\n            }\n    \
    \        _ => panic!(\"Illegal char in input\"),\n        }\n    }\n    level\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdxu99_is.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut right_brackets = 0;\n    for c in string.chars() {\n        if c == '['\
    \ {\n            stack.push(c);\n        } else {\n            if !stack.is_empty()\
    \ {\n                stack.pop();\n            } else {\n                right_brackets\
    \ += 1;\n            }\n        }\n    }\n    !stack.is_empty() || right_brackets\
    \ == 1\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1wjvsuou.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnw5uqium.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open = 0;\n    let mut closed\
    \ = 0;\n    let mut valid = false;\n    for i in string.chars() {\n        if\
    \ i == '[' {\n            open += 1;\n        } else if i == ']' {\n         \
    \   closed += 1;\n        }\n        if closed > open {\n            return false;\n\
    \        }\n        if open > closed {\n            valid = true;\n        }\n\
    \    }\n    valid\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmzmz1tn2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            counter += 1;\n       \
    \ } else {\n            counter -= 1;\n        }\n        if counter < 0 {\n \
    \           return false;\n        }\n    }\n    return counter == 0;\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjq6nykvm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut arr: Vec<char> = string.chars().collect();\n\
    \    let mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    for i in\
    \ arr.iter() {\n        if *i == '[' {\n            open_brackets += 1;\n    \
    \    } else {\n            closed_brackets += 1;\n        }\n    }\n    if open_brackets\
    \ == closed_brackets {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpja83f41_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut cnt = 0i32;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            cnt += 1;\n        } else\
    \ {\n            cnt -= 1;\n        }\n        if cnt < 0 {\n            return\
    \ false;\n        }\n    }\n    cnt == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfb7u9vh3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => counter += 1,\n   \
    \         ']' => counter -= 1,\n            _ => (),\n        }\n        if counter\
    \ < 0 {\n            return false;\n        }\n    }\n    if counter == 0 {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu3li08ht.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut found_nested = false;\n    for character in string.chars() {\n        if\
    \ character == '[' {\n            stack.push(character);\n        } else if character\
    \ == ']' {\n            match stack.pop() {\n                Some(_) => found_nested\
    \ = true,\n                None => return false,\n            }\n        }\n \
    \   }\n    found_nested\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8t9gtim6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // TODO!\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0axb_sl9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if let Some(last) = stack.last() {\n          \
    \  if last == &'[' && c == ']' {\n                stack.pop();\n            }\
    \ else {\n                stack.push(c);\n            }\n        } else {\n  \
    \          stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps1lic4y8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut chars = string.chars();\n\
    \    let mut stack = Vec::new();\n    while let Some(c) = chars.next() {\n   \
    \     if c == '[' {\n            stack.push(c);\n        } else {\n          \
    \  if let Some(last) = stack.pop() {\n                if last != '[' {\n     \
    \               return false;\n                }\n            } else {\n     \
    \           return false;\n            }\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphz21m79e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut brackets = [('[', ']'), ('(', ')'), ('{', '}')];\n    let mut res = false;\n\
    \    let mut cnt = 0;\n    for c in string.chars() {\n        if stack.is_empty()\
    \ {\n            stack.push(c);\n        } else {\n            let a = stack.pop().unwrap();\n\
    \            if (brackets.contains(&(a, c))) {\n                cnt += 1;\n  \
    \          } else {\n                stack.push(a);\n                stack.push(c);\n\
    \            }\n        }\n    }\n    if cnt > 0 {\n        res = true;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2xs31bv4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open_brackets: i32 = 0;\n\
    \    let mut close_brackets: i32 = 0;\n    for c in string.chars() {\n       \
    \ if c == '[' {\n            open_brackets += 1;\n        } else {\n         \
    \   close_brackets += 1;\n        }\n        if close_brackets > open_brackets\
    \ {\n            return false;\n        }\n    }\n    open_brackets > close_brackets\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4cwq8f8s.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    use std::collections::VecDeque;\n\
    \    let mut vec = VecDeque::new();\n    for c in string.chars() {\n        match\
    \ c {\n            '[' => vec.push_back(c),\n            ']' => {\n          \
    \      if vec.back() == Some(&'[') {\n                    vec.pop_back();\n  \
    \              } else {\n                    vec.push_back(c);\n             \
    \   }\n            }\n            _ => panic!(\"Does not have only square brackets!\"\
    ),\n        }\n    }\n    vec.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl5vsj1oe.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut top = -1;\n    for s in string.chars() {\n        if s == '[' {\n      \
    \      stack.push(s);\n            top += 1;\n        } else if s == ']' {\n \
    \           if top < 0 {\n                return false;\n            }\n     \
    \       top -= 1;\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpghuolxx3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpusctrpyb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    if string.is_empty() {\n        return\
    \ false;\n    }\n    let mut result = false;\n    let mut stack = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            if let Some(&c) = stack.last() {\n               \
    \ if c == '[' {\n                    stack.pop();\n                    result\
    \ = true;\n                }\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprwi6fy3h.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().filter(|ch| *ch ==\
    \ '[' || *ch == ']').collect::<Vec<char>>().windows(2).all(|w| w[0] == '[' &&\
    \ w[1] == ']')\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqpvunt_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |acc, ch| {\n\
    \        match acc {\n            1 => return true,\n            0 => match ch\
    \ {\n                '[' => acc + 1,\n                ']' => acc - 1,\n      \
    \          _ => acc,\n            },\n            -1 => return false,\n      \
    \      _ => match ch {\n                '[' => acc + 1,\n                ']' =>\
    \ acc - 1,\n                _ => acc,\n            },\n        }\n    }) == 1\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkobnoqi1.rs:13:25\n   |\n\
    13 |             1 => return true,\n   |                         ^^^^ expected\
    \ integer, found `bool`\n   |\nnote: return type inferred to be `{integer}` here\n\
    \  --> /tmp/tmpkobnoqi1.rs:13:25\n   |\n13 |             1 => return true,\n \
    \  |                         ^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut v: Vec<char> = Vec::new();\n\
    \    let mut res = false;\n    for c in string.chars() {\n        if c == '['\
    \ {\n            v.push(c);\n        } else {\n            if v.len() > 0 {\n\
    \                res = true;\n                v.pop();\n            }\n      \
    \  }\n    }\n    res\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0c46g7mh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut result = false;\n    for item in string.chars() {\n        if item == '['\
    \ {\n            stack.push(item);\n        } else {\n            if stack.is_empty()\
    \ {\n                break;\n            } else {\n                stack.pop();\n\
    \                result = true;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04wdgg77.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut cnt = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => cnt += 1,\n            ']' => cnt -=\
    \ 1,\n            _ => panic!(\"Invalid char\"),\n        }\n        if cnt <\
    \ 0 {\n            return false;\n        }\n    }\n    cnt == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4z0ym7cc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(prev) = stack.pop() {\n   \
    \                 if prev != '[' {\n                        return false;\n  \
    \                  }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa8s248dk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = Vec::new();\n\tfor c\
    \ in string.chars() {\n\t\tif c == '[' {\n\t\t\tstack.push(c);\n\t\t} else if\
    \ c == ']' {\n\t\t\tif stack.is_empty() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    \tstack.pop();\n\t\t}\n\t}\n\tif stack.is_empty() {\n\t\treturn true;\n\t}\n\t\
    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6lap_toa.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            stack.push(i);\n \
    \       } else {\n            match stack.pop() {\n                Some(_) =>\
    \ (),\n                None => return false,\n            }\n        }\n    }\n\
    \    return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsitci30o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if let Some(top) = stack.last() {\n        \
    \    if *top == '[' && ch == ']' {\n                stack.pop();\n           \
    \ } else {\n                stack.push(ch);\n            }\n        } else {\n\
    \            stack.push(ch);\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfunz7k8m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpjyg0i8b2.rs:11:21\n   |\n11 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ i = 0;\n    let chars = string.chars().collect::<Vec<char>>();\n    while i\
    \ < chars.len() {\n        if chars[i] == '[' {\n            stack.push(i);\n\
    \        } else {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \        i += 1;\n    }\n    if stack.len() == 0 {\n        return false;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0e3q0w2l.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // !string.contains(\"[]\") && string.contains(\"\
    [[\")\n    !string.contains(\"[]\") && string.contains(\"[[\")\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpty29k6fp.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets = Vec::new();\n \
    \   for s in string.chars() {\n        if s == '[' {\n            brackets.push(s);\n\
    \        } else if s == ']' {\n            if let Some(_) = brackets.pop() {\n\
    \                continue;\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    brackets.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl35c0r2u.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => ()\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpljhls7vq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ b in string.chars() {\n        if b == '[' {\n            stack.push(b);\n \
    \       } else if b == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3efxx1s_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut depth = 0;\n\tlet mut open =\
    \ 0;\n\tfor c in string.chars() {\n\t\tif c == '[' {\n\t\t\tdepth += 1;\n\t\t\t\
    open += 1;\n\t\t} else {\n\t\t\tif depth == 0 {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tif depth == 1 {\n\t\t\t\topen -= 1;\n\t\t\t}\n\t\t\tdepth -= 1;\n\t\t\
    }\n\t}\n\topen > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6cop70xs.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx91c7dnm.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let s = string.chars().collect::<Vec<char>>();\n\
    \    let mut stack = vec![];\n    for c in s {\n        if c == '[' {\n      \
    \      stack.push(c);\n        } else {\n            if stack.is_empty() {\n \
    \               return false;\n            }\n            stack.pop();\n     \
    \   }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiq7d0481.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if !stack.is_empty() {\n            stack.pop();\n        } else\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk9dl7exm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let c = string.chars().nth(i).unwrap();\n\
    \        match c {\n            '[' => stack.push(c),\n            ']' => {\n\
    \                if let Some(top) = stack.pop() {\n                    if top\
    \ != '[' {\n                        return false;\n                    }\n   \
    \             } else {\n                    return false;\n                }\n\
    \            }\n            _ => (),\n        }\n        i += 1;\n    }\n    if\
    \ stack.len() > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6znu6rqc.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut s = String::new();\n\tfor c\
    \ in string.chars() {\n\t\tif c == '[' {\n\t\t\ts.push(c);\n\t\t} else if !s.is_empty()\
    \ {\n\t\t\ts.pop();\n\t\t}\n\t}\n\ts.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeawff85c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for bracket\
    \ in string.chars() {\n        match bracket {\n            '[' => stack.push(bracket),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => continue,\n                    None => return false,\n        \
    \        }\n            }\n            _ => return false,\n        }\n    }\n\
    \    if stack.len() > 0 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2xvxq_th.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            count += 1;\n      \
    \  } else {\n            count -= 1;\n        }\n        if count < 0 {\n    \
    \        return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n \
    \   let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3iwzley.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(x) = stack.pop() {\n      \
    \              if x != '[' {\n                        return false;\n        \
    \            }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy_6xh73u.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => (),\n        }\n        if count < 0 {\n           \
    \ return false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk7mnxf58.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut last_bracket: char = '_';\n    for i in string.chars() {\n        if last_bracket\
    \ == '[' && i == ']' {\n            stack.pop();\n        } else {\n         \
    \   stack.push(i);\n        }\n        last_bracket = i;\n    }\n    stack.len()\
    \ != 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprda4k1rg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiwt1zn8w.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => if stack.is_empty() || stack.pop().unwrap() != '[' { return\
    \ false; },\n            _ => continue,\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcc0de9ox.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            counter += 1;\n       \
    \ } else {\n            counter -= 1;\n        }\n        if counter < 0 {\n \
    \           return false;\n        }\n    }\n    counter == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4dfc0v4i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut list = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            list.push(c);\n    \
    \    } else if c == ']' {\n            if let Some(x) = list.pop() {\n       \
    \         if x != '[' {\n                    return false;\n                }\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \    }\n    return list.len() > 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv_5qx359.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets = Vec::new();\n \
    \   for c in string.chars() {\n        if c == '[' {\n            brackets.push(c);\n\
    \        } else if c == ']' {\n            if let Some(last) = brackets.pop()\
    \ {\n                if last != '[' {\n                    return false;\n   \
    \             }\n            } else {\n                return false;\n       \
    \     }\n        }\n    }\n    brackets.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2yt9s9ga.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                if let Some('[') = stack.pop()\
    \ {\n                    continue;\n                }\n                return\
    \ false;\n            }\n            _ => panic!(\"Unexpected char: {}\", c),\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn2orc7di.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for char in\
    \ string.chars() {\n        match char {\n            '[' => count += 1,\n   \
    \         ']' => {\n                if count == 0 {\n                    return\
    \ false;\n                }\n                count -= 1;\n            }\n    \
    \        _ => {}\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk32z60q9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut invalid = false;\n    for c in string.chars() {\n        match c {\n   \
    \         '[' => stack.push(c),\n            ']' => {\n                match stack.pop()\
    \ {\n                    Some(_) => {\n                        invalid = false;\n\
    \                    },\n                    None => {\n                     \
    \   invalid = true;\n                    }\n                }\n            },\n\
    \            _ => {}\n        }\n    }\n    return invalid;\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7iofvot2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => continue,\n                    None => return false,\n        \
    \        }\n            }\n            _ => continue,\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ylf6xoa.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut opening = 0;\n    let mut\
    \ closing = 0;\n    let mut nested = false;\n    for c in string.chars() {\n \
    \       if c == '[' {\n            opening += 1;\n        } else {\n         \
    \   closing += 1;\n        }\n        if closing > opening {\n            return\
    \ false;\n        }\n        if opening > 0 && closing > 0 {\n            nested\
    \ = true;\n        }\n    }\n    return opening == closing && nested;\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplmabdlgp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut count = 0;\n\tlet mut is_nested\
    \ = false;\n\tfor bracket in string.chars() {\n\t\tif bracket == '[' {\n\t\t\t\
    count += 1;\n\t\t} else {\n\t\t\tcount -= 1;\n\t\t}\n\t\tif count > 1 || count\
    \ < 0 {\n\t\t\treturn false;\n\t\t}\n\t\tif count == 1 {\n\t\t\tis_nested = true;\n\
    \t\t}\n\t}\n\treturn is_nested;\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu7wqydln.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for c in\
    \ string.chars() {\n        match c {\n            '[' => counter += 1,\n    \
    \        ']' => counter -= 1,\n            _ => (),\n        }\n        if counter\
    \ < 0 {\n            return false;\n        }\n    }\n    counter > 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp69vdo6zm.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut seq = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            seq.push(ch);\n\
    \        } else if ch == ']' {\n            match seq.pop() {\n              \
    \  Some('[') => (),\n                _ => return false,\n            }\n     \
    \   }\n    }\n    seq.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppfndefmy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for x\
    \ in string.chars() {\n        match x {\n            '[' => stack.push(x),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                let x = stack.pop().unwrap();\n\
    \                if x != '[' {\n                    return false;\n          \
    \      }\n            }\n            _ => continue,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9nh5hyci.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => depth += 1,\n     \
    \       ']' => {\n                if depth > 0 {\n                    depth -=\
    \ 1;\n                } else {\n                    return false;\n          \
    \      }\n            }\n            _ => continue,\n        }\n    }\n    depth\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpab_i1ouv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    if stack.is_empty() {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppmbqh_us.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut tmp = String::new();\n   \
    \ for i in string.chars() {\n        match i {\n            '[' => tmp.push(i),\n\
    \            ']' => {\n                if tmp.is_empty() {\n                 \
    \   return false;\n                }\n                tmp.pop();\n           \
    \ }\n            _ => panic!(\"the string contains a character that is not a bracket\"\
    ),\n        }\n    }\n    tmp.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj9_zkf7r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut last_was_left = false;\n \
    \   let mut last_was_right = false;\n    for c in string.chars() {\n        if\
    \ c == '[' {\n            if last_was_right {\n                return true;\n\
    \            }\n            last_was_left = true;\n            last_was_right\
    \ = false;\n        } else {\n            if last_was_left {\n               \
    \ return true;\n            }\n            last_was_left = false;\n          \
    \  last_was_right = true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb4ar8cyp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // Split the string into a vector\
    \ of characters\n    let chars = string.chars().collect::<Vec<char>>();\n    //\
    \ Create a stack to store character\n    let mut stack = Vec::new();\n    // Traverse\
    \ the given expression to find matching parenthesis\n    for c in chars {\n  \
    \      // If we see an opening bracket, we push it into the stack\n        if\
    \ c == '[' {\n            stack.push(c);\n        }\n        // If we see a closing\
    \ bracket, we pop from the stack and if\n        // the popped character is not\
    \ an opening bracket, then there\n        // is a mismatch. This happens for expressions\
    \ like \"]\".\n        else if !stack.is_empty() && stack.pop().unwrap() == '['\
    \ {\n            return true;\n        }\n    }\n    // If we see an opening bracket\
    \ without a matching closing\n    // bracket in expression.\n    false\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9y_2uzs_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = String::new();\n \
    \   for c in string.chars() {\n        if stack.len() > 0 && &stack[stack.len()\
    \ - 1..] == \"[\" && c == ']' {\n            stack.pop();\n        } else {\n\
    \            stack.push(c);\n        }\n    }\n    stack.len() > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1hp0934j.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut current_max = 0;\n    let mut current_level = 0;\n    for char in string.chars()\
    \ {\n        match char {\n            '[' => {\n                current_level\
    \ += 1;\n                if current_level > current_max {\n                  \
    \  current_max = current_level;\n                }\n                stack.push(char);\n\
    \            }\n            ']' => {\n                current_level -= 1;\n  \
    \              if current_level < 0 {\n                    return false;\n   \
    \             }\n                if stack.is_empty() {\n                    return\
    \ false;\n                }\n                stack.pop();\n            }\n   \
    \         _ => {\n                return false;\n            }\n        }\n  \
    \  }\n    return current_max > 1;\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpntu7e45f.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    stack.len() > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdtw0z_mi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if let Some('[') = stack.pop() {\n            continue;\n       \
    \ } else {\n            return false;\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0wp9lifb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            match stack.pop() {\n                Some(b) =>\
    \ {\n                    if b != '[' {\n                        return false;\n\
    \                    }\n                }\n                None => return false,\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpli_4u735.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut bracket_stack = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            bracket_stack.push(c);\n\
    \        } else if c == ']' {\n            if bracket_stack.is_empty() {\n   \
    \             return false;\n            } else {\n                bracket_stack.pop();\n\
    \            }\n        }\n    }\n    !bracket_stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwsevortq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4c5k03jo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some('[') = stack.pop() {\n\n  \
    \              } else {\n                    return false;\n                }\n\
    \            },\n            _ => return false,\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp66fqvtey.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // Write code here\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    for c in string.chars() {\n        if c == '['\
    \ {\n            stack.push(c);\n        } else {\n            if let Some(c2)\
    \ = stack.pop() {\n                if c2 != '[' {\n                    return\
    \ false;\n                }\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz9rt28fo.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let valid_pair = |a, b| (a == '['\
    \ && b == ']') || (a == '{' && b == '}') || (a == '(' && b == ')');\n    let mut\
    \ stack = vec![];\n    for c in string.chars() {\n        if let Some(p) = stack.pop()\
    \ {\n            if !valid_pair(p, c) {\n                stack.push(p);\n    \
    \            stack.push(c);\n            }\n        } else {\n            stack.push(c);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr_nzk7hv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                if stack.pop().unwrap()\
    \ != '[' {\n                    return false;\n                }\n           \
    \ }\n            _ => {\n                return false;\n            }\n      \
    \  }\n    }\n    stack.len() > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi4uz6yfr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut string = string;\n    string.retain(|c|\
    \ c == '[' || c == ']');\n    let len = string.len();\n    if len < 2 {\n    \
    \    return false;\n    }\n    let mut brackets = Vec::new();\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => brackets.push(c),\n            ']'\
    \ => {\n                if brackets.is_empty() {\n                    return false;\n\
    \                }\n                let last = brackets.last().unwrap();\n   \
    \             if *last == '[' {\n                    brackets.pop();\n       \
    \         } else {\n                    return false;\n                }\n   \
    \         }\n            _ => return false,\n        }\n    }\n    brackets.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7rwv5k1w.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut opened_brackets = 0;\n   \
    \ let mut closed_brackets = 0;\n    for ch in string.chars() {\n        if ch\
    \ == '[' {\n            opened_brackets += 1;\n        } else {\n            closed_brackets\
    \ += 1;\n        }\n        if closed_brackets > opened_brackets {\n         \
    \   return false;\n        }\n    }\n    if opened_brackets == closed_brackets\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphdpvqteb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    let mut\
    \ nested: bool = false;\n    for ch in string.chars() {\n        if ch == '['\
    \ {\n            count += 1;\n        } else {\n            count -= 1;\n    \
    \    }\n        if count > 1 {\n            nested = true;\n        }\n    }\n\
    \    nested\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg6ebwg45.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for bracket\
    \ in string.chars() {\n        match bracket {\n            '[' => stack.push(bracket),\n\
    \            ']' => if stack.is_empty() {\n                return false;\n   \
    \         } else {\n                stack.pop();\n            },\n           \
    \ _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl1989_ah.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut outer = 0;\n    let mut inner\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            outer\
    \ += 1;\n        } else if c == ']' {\n            if inner > 0 {\n          \
    \      inner -= 1;\n            } else {\n                outer -= 1;\n      \
    \      }\n        }\n        if outer < 0 {\n            return false;\n     \
    \   }\n    }\n    return (outer == 0) && (inner == 0);\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc1xfrhfk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => return false,\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph402wi9v.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ seq = vec![];\n    for ch in string.chars() {\n        if ch == '[' {\n    \
    \        stack.push(ch);\n        } else {\n            if stack.len() > 0 {\n\
    \                stack.pop();\n                seq.push(ch);\n            }\n\
    \        }\n    }\n    if stack.len() == 0 {\n        seq.iter().map(|&ch| ch).any(|ch|\
    \ ch == ']')\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8_rcdt79.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  return !stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphvk8gfvz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for ch\
    \ in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n \
    \       } else {\n            if let Some(_) = stack.pop() {\n               \
    \ continue;\n            } else {\n                return false;\n           \
    \ }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk8iubinm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => count += 1,\n     \
    \       ']' => count -= 1,\n            _ => (),\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    count > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyrvpd121.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open_brackets = 0;\n    let\
    \ mut closed_brackets = 0;\n    for c in string.chars() {\n        if c == '['\
    \ {\n            open_brackets += 1;\n        } else {\n            closed_brackets\
    \ += 1;\n        }\n        if closed_brackets > open_brackets {\n           \
    \ return false;\n        }\n    }\n    open_brackets > closed_brackets\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfnvbfwww.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ i = 0;\n    let n = string.len();\n    let mut found = false;\n    while i <\
    \ n {\n        let ch = string.chars().nth(i).unwrap();\n        if ch == '['\
    \ {\n            stack.push(ch);\n        } else {\n            match stack.pop()\
    \ {\n                Some(a) => {\n                    if a == '[' {\n       \
    \                 found = true;\n                    }\n                }\n  \
    \              None => {\n                    return false;\n                }\n\
    \            }\n        }\n        i += 1;\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp64kr7xbx.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stk = vec![];\n    for c in\
    \ string.chars() {\n        match c {\n            '[' => stk.push(c),\n     \
    \       ']' => {\n                match stk.pop() {\n                    Some('[')\
    \ => (),\n                    _ => return false,\n                }\n        \
    \    }\n            _ => (),\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe9z7a0qs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut n = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            n += 1;\n        } else {\n          \
    \  n -= 1;\n        }\n        if n < 0 {\n            return false;\n       \
    \ }\n    }\n    n == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsnrqkc4g.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().collect::<Vec<char>>().iter().fold(0,\
    \ |acc, x| if *x == '[' { acc + 1 } else { acc - 1 }).abs() == 1\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpro3r5mwo.rs:11:110\n   |\n11 |     string.chars().collect::<Vec<char>>().iter().fold(0,\
    \ |acc, x| if *x == '[' { acc + 1 } else { acc - 1 }).abs() == 1\n   |       \
    \                                                                            \
    \                           ^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = String::new();\n\tfor\
    \ c in string.chars() {\n\t\tmatch c {\n\t\t\t'[' => stack.push(c),\n\t\t\t']'\
    \ => {\n\t\t\t\tif stack.pop() == None {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\
    \t\t\t},\n\t\t\t_ => (),\n\t\t}\n\t}\n\tif stack.len() == 0 {\n\t\treturn true;\n\
    \t}\n\tfalse\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6deqy98p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => unreachable!(),\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoy48q9j3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ b in string.chars() {\n        if b == '[' {\n            stack.push(b);\n \
    \       } else if b == ']' {\n            if let Some(_) = stack.pop() {\n   \
    \             continue;\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    if stack.len() > 0 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxy17q4v9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() > 0 {\n                \
    \    stack.pop();\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpprhfp_j1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ is_nested = false;\n    for c in string.chars() {\n        if c == '[' {\n \
    \           stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                break;\n            }\n            stack.pop();\n       \
    \     is_nested = true;\n        }\n    }\n    is_nested\n}\n\nfn main() {\n \
    \   let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp42_dlmrl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    let mut\
    \ i = 0;\n    while i < string.len() {\n        let (c, _) = string.char_indices().nth(i).unwrap();\n\
    \        if c == '[' {\n            counter += 1;\n        } else {\n        \
    \    counter -= 1;\n        }\n        if counter < 0 {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    if counter > 0 {\n        return false;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_nested;\n \
    \   assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp113527ju.rs:15:17\n   |\n\
    15 |         if c == '[' {\n   |                 ^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for ch\
    \ in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n \
    \       } else {\n            if stack.pop() == None {\n                return\
    \ false;\n            }\n        }\n    }\n    if stack.len() == 0 {\n       \
    \ return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx710_gzo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open_brackets = 0;\n    let\
    \ mut nested = false;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            open_brackets += 1;\n        } else {\n            if open_brackets\
    \ > 0 {\n                nested = true;\n            }\n            open_brackets\
    \ -= 1;\n        }\n    }\n    return nested;\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmirj7as6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if let Some(last) = stack.last() {\n          \
    \  if *last == '[' && c == ']' {\n                stack.pop();\n            }\
    \ else {\n                stack.push(c);\n            }\n        } else {\n  \
    \          stack.push(c);\n        }\n    }\n    return stack.len() != 0;\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp81l5f6qe.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.last() == Some(&'[') {\n     \
    \               stack.pop();\n                } else {\n                    stack.push(c);\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7wxpok9y.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets: Vec<char> = Vec::new();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        match string.chars().nth(i)\
    \ {\n            Some('[') => brackets.push('['),\n            Some(']') => if\
    \ brackets.pop() != Some('[') {\n                return false;\n            },\n\
    \            _ => (),\n        }\n        i += 1;\n    }\n    brackets.len() >\
    \ 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkv94jzcm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => count += 1,\n   \
    \         ']' => count -= 1,\n            _ => return false,\n        }\n    \
    \    if count < 0 {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1gcbibf5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |mut count,\
    \ c| {\n        if c == '[' {\n            count += 1;\n        } else {\n   \
    \         count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n        count\n    }) == 0\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_1zx_ea1.rs:18:20\n   |\n\
    18 |             return false;\n   |                    ^^^^^ expected integer,\
    \ found `bool`\n   |\nnote: return type inferred to be `{integer}` here\n  -->\
    \ /tmp/tmp_1zx_ea1.rs:18:20\n   |\n18 |             return false;\n   |      \
    \              ^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    for ch\
    \ in string.chars() {\n        match ch {\n            '[' => count += 1,\n  \
    \          ']' => count -= 1,\n            _ => {}\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    return count == 0;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1o1s3_k8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets: Vec<char> = string.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for bracket in brackets {\n \
    \       if stack.len() > 0 && bracket == ']' && stack[stack.len() - 1] == '['\
    \ {\n            stack.pop();\n        } else {\n            stack.push(bracket);\n\
    \        }\n    }\n    stack.len() > 0\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf2s46fkz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut chars: Vec<char> = string.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for c in chars {\n        match\
    \ c {\n            '[' => stack.push(c),\n            ']' => {\n             \
    \   if stack.len() > 0 {\n                    stack.pop();\n                }\
    \ else {\n                    return false;\n                }\n            }\n\
    \            _ => (),\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbp0hcg1u.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut result = true;\n    let mut\
    \ brackets = vec![];\n    let mut index = 0;\n    while index < string.len() {\n\
    \        let character = string.chars().nth(index).unwrap();\n        if character\
    \ == '[' {\n            brackets.push(character);\n        } else {\n        \
    \    if brackets.len() > 0 {\n                brackets.pop();\n            } else\
    \ {\n                result = false;\n                break;\n            }\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp130g_3fs.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // TODO\n    let brackets = vec!['[',\
    \ ']'];\n    let chars: Vec<char> = string.chars().collect();\n    let mut result\
    \ = true;\n    let mut open_brackets = 0;\n    for char in chars {\n        if\
    \ brackets.contains(&char) {\n            if char == '[' {\n                open_brackets\
    \ += 1;\n            } else {\n                if open_brackets == 0 {\n     \
    \               result = false;\n                    break;\n                }\
    \ else {\n                    open_brackets -= 1;\n                }\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv7awijaf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let string = string.into_bytes();\n\
    \    let mut stack = Vec::new();\n    for item in string {\n        if let Some(last)\
    \ = stack.last() {\n            if *last == b'[' && item == b']' {\n         \
    \       stack.pop();\n            } else {\n                stack.push(item);\n\
    \            }\n        } else {\n            stack.push(item);\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpauiafvaz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for ch\
    \ in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n \
    \       } else {\n            match stack.pop() {\n                Some('[') =>\
    \ continue,\n                _ => return false,\n            }\n        }\n  \
    \  }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyheiff_d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for bracket\
    \ in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            match stack.pop() {\n                Some(_) =>\
    \ {},\n                None => return false,\n            }\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwnb58ydg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut vec: Vec<char> = Vec::new();\n\
    \    let mut n = 0;\n    for ch in string.chars() {\n        if ch == '[' {\n\
    \            n += 1;\n            vec.push(ch);\n        } else if n == 0 {\n\
    \            return false;\n        } else {\n            n -= 1;\n          \
    \  vec.push(ch);\n        }\n    }\n    if n == 0 {\n        let mut result =\
    \ false;\n        for i in 1..vec.len() {\n            if vec[i - 1] == '[' &&\
    \ vec[i] == ']' {\n                result = true;\n                break;\n  \
    \          }\n        }\n        result\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt5um5har.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut buffer = Vec::new();\n   \
    \ for c in string.chars() {\n        match c {\n            '[' => buffer.push(c),\n\
    \            ']' => {\n                if let Some(p) = buffer.pop() {\n     \
    \               if p != '[' {\n                        return false;\n       \
    \             }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => unreachable!(),\n        }\n\
    \    }\n    buffer.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxpoc0775.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ item in string.chars() {\n        if item == '[' {\n            stack.push(item);\n\
    \        } else if item == ']' {\n            if let Some(x) = stack.pop() {\n\
    \                if x != '[' {\n                    return false;\n          \
    \      }\n            } else {\n                return false;\n            }\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpknzoxysq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut n = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            n += 1;\n        } else {\n          \
    \  n -= 1;\n        }\n        if n < 0 {\n            return false;\n       \
    \ }\n    }\n    n == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpowqd83b7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    if string.is_empty() {\n        return\
    \ false;\n    }\n    let mut found_open = false;\n    let mut found_nested = false;\n\
    \    let mut counter = 0;\n    for c in string.chars() {\n        if c == '['\
    \ {\n            if found_open {\n                found_nested = true;\n     \
    \       }\n            found_open = true;\n            counter += 1;\n       \
    \ } else {\n            counter -= 1;\n        }\n        if counter < 0 {\n \
    \           return false;\n        }\n    }\n    found_nested && counter == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplpruwct3.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ character in string.chars() {\n        match character {\n            '[' =>\
    \ stack.push(character),\n            ']' => if let Some('[') = stack.pop() {\n\
    \                // continue\n            } else {\n                return false;\n\
    \            },\n            _ => (),\n        }\n    }\n    if stack.is_empty()\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp478wocor.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 { return false\
    \ }\n    let mut stack = vec![];\n    let mut res = false;\n    for ch in string.chars()\
    \ {\n        if ch == '[' {\n            stack.push(ch);\n        } else {\n \
    \           if let Some(top) = stack.pop() {\n                if top == '[' {\n\
    \                    res = true;\n                }\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxfgrdkew.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpllnzwtl_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return stack.len()\
    \ > 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2mkput3b.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return !stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpngmv4btv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpynzj7hi6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut prev\
    \ = 0;\n    for ch in string.chars() {\n        match ch {\n            '[' =>\
    \ count += 1,\n            ']' => {\n                count -= 1;\n           \
    \     if count == 0 {\n                    return true;\n                }\n \
    \           }\n            _ => {}\n        }\n        if count < prev {\n   \
    \         return false;\n        }\n        prev = count;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6eebp4v0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => if let Some(_) = stack.pop() {\n                continue;\n\
    \            } else {\n                return false;\n            },\n       \
    \     _ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxyuwy9ss.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = String::new();\n\tlet\
    \ mut str = String::new();\n\tfor c in string.chars() {\n\t\tif c == '[' {\n\t\
    \t\tstack.push(c);\n\t\t} else {\n\t\t\tif !stack.is_empty() {\n\t\t\t\tstr.push(stack.pop().unwrap());\n\
    \t\t\t}\n\t\t}\n\t}\n\tif stack.is_empty() {\n\t\treturn true;\n\t} else {\n\t\
    \tstr.push_str(&stack);\n\t\treturn str.contains(\"[[\") || str.contains(\"]]\"\
    );\n\t}\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpylwjhxmc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return !stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpmweqypnd.rs:11:21\n   |\n11 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0oklkls6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    if count == 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2r4m52vr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut sum = 0;\n    for i in string.chars()\
    \ {\n        match i {\n            '[' => sum += 1,\n            ']' => sum -=\
    \ 1,\n            _ => sum,\n        }\n        if sum < 0 {\n            return\
    \ false;\n        }\n    }\n    sum == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpkp10b2je.rs:16:18\n\
    \   |\n13 | /         match i {\n14 | |             '[' => sum += 1,\n   | | \
    \                   -------- this is found to be of type `()`\n15 | |        \
    \     ']' => sum -= 1,\n   | |                    -------- this is found to be\
    \ of type `()`\n16 | |             _ => sum,\n   | |                  ^^^ expected\
    \ `()`, found integer\n17 | |         }\n   | |_________- `match` arms have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    Some(_) => return false,\n         \
    \           None => return false,\n                }\n            }\n        \
    \    _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeakrvsu5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => continue,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4vffqjg9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpt4dlnt27.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            depth += 1;\n        } else {\n      \
    \      depth -= 1;\n        }\n        if depth < 0 {\n            return false;\n\
    \        }\n    }\n    depth > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3ml52gv2.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let brackets = string.chars().filter(|c|\
    \ *c == '[' || *c == ']').collect::<Vec<char>>();\n    if brackets.len() == 0\
    \ {\n        return false;\n    }\n\n    let sum = brackets.iter().fold(0, |sum,\
    \ &bracket| match bracket {\n        '[' => sum + 1,\n        ']' => sum - 1,\n\
    \        _ => panic!(),\n    });\n\n    if sum != 0 {\n        return false;\n\
    \    }\n\n    let start_brackets = brackets.iter().filter(|&c| *c == '[').count();\n\
    \    let end_brackets = brackets.iter().filter(|&c| *c == ']').count();\n\n  \
    \  if start_brackets != end_brackets {\n        return false;\n    }\n\n    brackets.iter().fold(vec![],\
    \ |mut stack, &bracket| {\n        match bracket {\n            '[' => stack.push(bracket),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return stack;\n                }\n\n                let last_bracket = stack.pop().unwrap();\n\
    \                if last_bracket == ']' {\n                    stack.push(last_bracket);\n\
    \                    stack.push(bracket);\n                }\n            }\n\
    \            _ => panic!(),\n        }\n\n        stack\n    }).len() == 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkp2psrn9.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut count = 0;\n\tfor c in string.chars()\
    \ {\n\t\tmatch c {\n\t\t\t'[' => count += 1,\n\t\t\t']' => count -= 1,\n\t\t\t\
    _ => (),\n\t\t}\n\t\tif count < 0 {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcount\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp84p9a0v0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut sum = 0;\n    for i in string.chars()\
    \ {\n        if i == '[' {\n            sum += 1;\n        } else {\n        \
    \    sum -= 1;\n        }\n        if sum < 0 {\n            return false;\n \
    \       }\n    }\n    sum > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz2olckjl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().filter(|&x| x == '['\
    \ || x == ']').collect::<Vec<char>>().windows(2).any(|x| x[0] == '[' && x[1] ==\
    \ ']')\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp92fp5dw0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut brackets = vec![];\n    let valid_brackets = vec!['[', ']'];\n    for char\
    \ in string.chars() {\n        if valid_brackets.contains(&char) {\n         \
    \   brackets.push(char);\n        }\n    }\n    for bracket in brackets {\n  \
    \      if stack.is_empty() {\n            stack.push(bracket);\n        } else\
    \ {\n            if stack.last().unwrap() == &'[' && bracket == ']' {\n      \
    \          stack.pop();\n            } else {\n                stack.push(bracket);\n\
    \            }\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp04ck5ewe.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for char\
    \ in string.chars() {\n        if char == '[' {\n            stack.push(char);\n\
    \        } else if char == ']' {\n            if stack.is_empty() {\n        \
    \        return false;\n            }\n            stack.pop();\n        }\n \
    \   }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpng07_vdj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut chars = string.chars();\n\
    \    let mut stack = Vec::new();\n    while let Some(c) = chars.next() {\n   \
    \     if c == '[' {\n            stack.push(c);\n        } else {\n          \
    \  if stack.is_empty() {\n                return false;\n            }\n     \
    \       stack.pop();\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4v_4argi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut n = 0;\n    let mut is_nested\
    \ = false;\n    for ch in string.chars() {\n        match ch {\n            '['\
    \ => n += 1,\n            ']' => n -= 1,\n            _ => unreachable!(),\n \
    \       }\n        if n == 1 {\n            is_nested = true;\n        }\n   \
    \     if n < 0 {\n            break;\n        }\n    }\n    is_nested\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqprbflkw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => panic!(\"Invalid input\"),\n        }\n        if count\
    \ == 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbm83g4bh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut found_open = false;\n    let\
    \ mut found_closed = false;\n    for b in string.chars() {\n        if b == '['\
    \ {\n            found_open = true;\n        } else if b == ']' {\n          \
    \  found_closed = true;\n        }\n    }\n    found_open && found_closed\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_7nelnfs.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut left_count = 0;\n    let mut\
    \ right_count = 0;\n    for s in string.chars() {\n        if s == '[' {\n   \
    \         left_count += 1;\n        } else {\n            right_count += 1;\n\
    \        }\n        if right_count > left_count {\n            return false;\n\
    \        }\n    }\n    return right_count < left_count;\n}\n\nfn main() {\n  \
    \  let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg7rq5b46.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut cnt: usize = 0;\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => cnt += 1,\n     \
    \       ']' => cnt -= 1,\n            _ => {}\n        }\n        if cnt < 0 {\n\
    \            return false;\n        }\n    }\n    return cnt > 0;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk1vr0c7e.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if stack.is_empty() {\n            stack.push(c);\n\
    \        } else {\n            let last = stack.last().unwrap();\n           \
    \ if (last == &'[') && (c == ']') {\n                stack.pop();\n          \
    \  } else {\n                stack.push(c);\n            }\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjyb8ftol.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ elem in string.chars() {\n        if elem == '[' {\n            stack.push(elem);\n\
    \        } else if !stack.is_empty() {\n            stack.pop();\n        } else\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdepfv2ma.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    for _ in string.chars() {\n      \
    \  match string.find('[') {\n            Some(x) => { \n                match\
    \ string.find(']') {\n                    Some(y) => { \n                    \
    \    if x > y {\n                            return false;\n                 \
    \       }\n                    },\n                    None => { return false;\
    \ }\n                }\n            },\n            None => { return false; }\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwq12htm2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut i = 0;\n    let mut depth\
    \ = 0;\n    while i < string.len() {\n        match string.chars().nth(i).unwrap()\
    \ {\n            '[' => depth += 1,\n            ']' => depth -= 1,\n        \
    \    _ => ()\n        }\n        if depth < 0 {\n            return false;\n \
    \       }\n        i += 1;\n    }\n    depth > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkg2yz5fq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ chars = string.chars();\n    while let Some(bracket) = chars.next() {\n    \
    \    match bracket {\n            '[' => stack.push(bracket),\n            ']'\
    \ => {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpicjez97n.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if !stack.is_empty() {\n            stack.pop();\n        } else\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwsz34s_9.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                let last = stack.pop().unwrap();\n\
    \                if last != '[' {\n                    return false;\n       \
    \         }\n            }\n            _ => panic!(\"invalid input\"),\n    \
    \    }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaxzigayb.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n\tlet mut i: i8 = 0;\n\tfor c in string.chars()\
    \ {\n\t\tmatch c {\n\t\t\t'[' => i += 1,\n\t\t\t']' => i -= 1,\n\t\t\t_ => ()\n\
    \t\t}\n\t\tif i < 0 {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn i == 0;\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjsv6c65n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp66ajclil.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => (),\n        }\n        if count < 0 {\n           \
    \ return false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0bh2jd3g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(_) = stack.pop() {\n      \
    \              continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => panic!(\"Invalid\
    \ character!\"),\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo_4i15wj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzpuucgwg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptft1nwpi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open_nested_count = 0;\n \
    \   let mut open_count = 0;\n    let mut closed_count = 0;\n    for character\
    \ in string.chars() {\n        match character {\n            '[' => {\n     \
    \           open_count += 1;\n                open_nested_count += 1;\n      \
    \      }\n            ']' => {\n                closed_count += 1;\n         \
    \       if open_nested_count > 0 {\n                    open_nested_count -= 1;\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ if open_count == closed_count && open_nested_count == 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjydwqxmi.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn4ir2ffl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    return string.contains(\"[]\");\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpccgx1x3y.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.len() == 0 {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    for c in stack {\n        if c == '[' {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwinbidkb.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => count += 1,\n     \
    \       ']' => count -= 1,\n            _ => return false,\n        }\n      \
    \  if count < 0 {\n            return false;\n        }\n    }\n    count == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw3fn4_u2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut iter = string.chars();\n \
    \   let mut stack = Vec::new();\n    while let Some(c) = iter.next() {\n     \
    \   match c {\n            '[' => stack.push(c),\n            ']' => {\n     \
    \           match stack.pop() {\n                    Some(_) => continue,\n  \
    \                  None => return false,\n                }\n            }\n \
    \           _ => continue,\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ckf_yst.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    use std::collections::VecDeque;\n\
    \    let mut stack = VecDeque::new();\n    for ch in string.chars() {\n      \
    \  match ch {\n            '[' => stack.push_back(ch),\n            ']' => {\n\
    \                match stack.pop_back() {\n                    Some('[') => (),\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4rjoli_6.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut opening_brackets: Vec<char>\
    \ = Vec::new();\n    let mut closing_brackets: Vec<char> = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            opening_brackets.push(c);\n\
    \        } else {\n            closing_brackets.push(c);\n        }\n    }\n \
    \   if opening_brackets.len() == 0 || closing_brackets.len() == 0 {\n        return\
    \ false;\n    }\n    opening_brackets.sort();\n    closing_brackets.sort();\n\
    \    opening_brackets == closing_brackets\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppvrgq7oy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                let last = stack.pop().unwrap();\n\
    \                if last != '[' {\n                    return false;\n       \
    \         }\n            }\n            _ => continue,\n        }\n    }\n   \
    \ !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwjkfa699.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
