name: HumanEval_60_sum_to_n
language: rust
prompt: "/// sum_to_n is a function that sums numbers from 1 to n.\n/// >>> sum_to_n(30)\n\
  /// 465\n/// >>> sum_to_n(100)\n/// 5050\n/// >>> sum_to_n(5)\n/// 15\n/// >>> sum_to_n(10)\n\
  /// 55\n/// >>> sum_to_n(1)\n/// 1\nfn sum_to_n(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n \
  \   assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"
completions: ["  let mut sum = 0;\n  for i in 1..n+1 {\n    sum += i;\n  }\n  sum",
  "    if n < 1 {\n        panic!(\"Invalid input. n = {}\", n);\n    }\n    if n\
    \ == 1 {\n        return 1;\n    }\n    n + sum_to_n(n - 1)", "    let mut res\
    \ = 0;\n    for i in 1..(n + 1) {\n        res += i;\n    }\n    res", "    let\
    \ mut sum = 0;\n    for num in 1..n + 1 {\n        sum += num;\n    }\n    sum",
  "    let mut total = 0;\n    for i in 1..(n + 1) {\n        total += i;\n    }\n\
    \    total", '    (1..n+1).sum()', '    unimplemented!()', "    if n == 1 {\n\
    \        return 1;\n    } else {\n        return n + sum_to_n(n - 1);\n    }",
  "    let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum",
  "    // TODO\n    n * (n + 1) / 2", "    let mut x = 0;\n    for i in 1..n+1 {\n\
    \        x += i;\n    }\n    x", "    let mut sum = 0;\n    for i in 1..n+1 {\n\
    \        sum += i;\n    }\n    sum", '    n * (n + 1) / 2', "    let mut res =\
    \ 0;\n    for i in 1..n + 1 {\n        res += i;\n    }\n    res", '    sum_n(n)',
  '    unimplemented!();', "    if n == 1 {\n        return 1;\n    }\n    let mut\
    \ sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum", "   \
    \ let mut sum = 0;\n    for x in 1..n+1 {\n        sum += x;\n    }\n    sum",
  "    let mut res = 0;\n    for i in 1..n + 1 {\n        res += i;\n    }\n    res",
  "    // YOUR CODE HERE\n    let mut total = 0;\n    let mut i = 1;\n    while i\
    \ <= n {\n        total += i;\n        i += 1;\n    }\n    total", "    let mut\
    \ sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum", "   \
    \ let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum",
  "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum",
  "    let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum",
  "    if n == 1 {\n        1\n    } else {\n        n + sum_to_n(n - 1)\n    }",
  '    (1..n + 1).sum()', '    0', "    if n == 1 {\n        return 1;\n    }\n  \
    \  n + sum_to_n(n - 1)", "    let mut sum = 0;\n    for i in 1..n+1 {\n      \
    \  sum += i;\n    }\n    sum", '    n * (n + 1) / 2', "    // you should use a\
    \ for loop here\n    // the range is from 1 to n\n    let mut sum = 0;\n    for\
    \ i in 1..(n+1) {\n        sum += i;\n    }\n    sum", "    // compute the sum\
    \ of the numbers 1..n\n    (1..n+1).fold(0, |a,b| a+b)", "    let mut result =\
    \ 0;\n    for i in 1..(n + 1) {\n        result += i;\n    }\n    result", " \
    \   // Uncomment the println! lines to help trace your code.\n    // println!(\"\
    n is: {}\", n);\n    // println!(\"\");\n    // println!(\"\");\n    // println!(\"\
    \");\n    // println!(\"\");\n    if n == 1 {\n        // println!(\"base case:\
    \ {}\", n);\n        return n;\n    }\n    // println!(\"previous value is: {}\"\
    , sum_to_n(n - 1));\n    // println!(\"current value is: {}\", n);\n    // println!(\"\
    \");\n    return sum_to_n(n - 1) + n;", "  if n == 1 { return 1; }\n  n + sum_to_n(n\
    \ - 1)", '    unimplemented!();', "    let mut sum = 0;\n    for i in 1..n + 1\
    \ {\n        sum += i;\n    }\n    sum", "    if n <= 0 {\n        0\n    } else\
    \ {\n        n + sum_to_n(n - 1)\n    }", "    // unimplemented!()\n    // let\
    \ mut i = 1;\n    // let mut sum = 0;\n    // while i <= n {\n    //     sum +=\
    \ i;\n    //     i += 1;\n    // }\n    // sum\n    // let mut i = 1;\n    //\
    \ let mut sum = 0;\n    // while i <= n {\n    //     sum += i;\n    //     i\
    \ += 1;\n    // }\n    // sum\n    // let mut i = 1;\n    // let mut sum = 0;\n\
    \    // while i <= n {\n    //     sum += i;\n    //     i += 1;\n    // }\n \
    \   // sum\n    let mut i = 1;\n    let mut sum = 0;\n    while i <= n {\n   \
    \     sum += i;\n        i += 1;\n    }\n    sum", "    let mut sum = 0;\n   \
    \ for i in 1..n+1 {\n        sum += i;\n    }\n    sum", "    let mut ret = 0;\n\
    \    for i in 1..n + 1 {\n        ret += i;\n    }\n    ret", "    let sum = n\
    \ * (n + 1) / 2;\n    sum", "    let mut sum = 0;\n    for i in 1..n+1 {\n   \
    \     sum += i;\n    }\n    sum", "    let mut sum = 0;\n    for i in 1..n+1 {\n\
    \        sum += i;\n    }\n    sum", "    if n == 1 {\n        return 1;\n   \
    \ }\n    return n + sum_to_n(n - 1);", '    (1..n+1).fold(0, |x, acc| acc + x)',
  "    let mut result = 0;\n    for i in 1..(n + 1) {\n        result += i;\n    }\n\
    \    result", "    if n == 1 {\n        return 1;\n    }\n    return n + sum_to_n(n\
    \ - 1);", "    if n < 0 {\n        panic!(\"n cannot be negative\");\n    } else\
    \ if n == 0 {\n        return 0;\n    }\n    n + sum_to_n(n - 1)", '    0', " \
    \   let mut counter = 0;\n    let mut sum = 0;\n    while counter < n {\n    \
    \    counter += 1;\n        sum += counter;\n    }\n    sum", "    // TODO: return\
    \ the sum of numbers from 1 to n\n    unimplemented!();", "    // TODO: Replace\
    \ the following line with your code.\n    unimplemented!()", "    if n < 1 {\n\
    \        panic!(\"n must be greater than 1\")\n    } else {\n        let mut sum\
    \ = 0;\n        for i in 1..n + 1 {\n            sum += i;\n        }\n      \
    \  sum\n    }", "    // let result = (1..n + 1).fold(0, |acc, x| acc + x);\n \
    \   // result\n    (1..n + 1).sum()", "    if n <= 0 {\n        return 0;\n  \
    \  }\n    if n == 1 {\n        return 1;\n    }\n    return n + sum_to_n(n - 1);",
  "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum",
  "    match n {\n        1 => 1,\n        _ => n + sum_to_n(n - 1),\n    }", "  \
    \  if n == 1 {\n        1\n    } else {\n        n + sum_to_n(n - 1)\n    }",
  '    (1 + n) * n / 2', "    // TODO\n    0", "    // \u4E0D\u80FD\u7528\u4E58\u6CD5\
    \u9700\u8981\u5FAA\u73AF\u52A0\n    //let mut sum = 1;\n    //for i in 2..n +\
    \ 1 {\n    //    sum += i;\n    //}\n    //sum\n    (1 + n) * n / 2", "    //\
    \ your code here\n    if n == 1 {\n        1\n    } else {\n        n + sum_to_n(n\
    \ - 1)\n    }", "    if n == 1 {\n        1\n    } else {\n        n + sum_to_n(n\
    \ - 1)\n    }", '    (1..n + 1).sum()', "    // TODO\n    0", '    (1..n+1).sum()',
  '    return 0;', "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum +=\
    \ i;\n    }\n    sum", "    let mut sum = 0;\n    for i in 1..(n + 1) {\n    \
    \    sum += i;\n    }\n    sum", '    unimplemented!()', "    if n == 1 {\n  \
    \      return 1;\n    } else {\n        return n + sum_to_n(n - 1);\n    }", '    unimplemented!();',
  "    // TODO\n    0", "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum\
    \ += i;\n    }\n    sum", "    let res = n * (n + 1) / 2;\n    res", "    if n\
    \ == 1 {\n        1\n    } else {\n        n + sum_to_n(n - 1)\n    }", "    //\
    \ base case\n    if n == 1 {\n        return 1;\n    }\n    // recursive case\n\
    \    else {\n        return n + sum_to_n(n - 1);\n    }", '    unimplemented!()',
  "    if n < 1 {\n        panic!(\"n must be >= 1\");\n    }\n    let mut result\
    \ = 0;\n    for i in 1..(n + 1) {\n        result += i;\n    }\n    result", " \
    \   // No need to handle negative numbers, since we can't sum negative numbers\n\
    \    // 1. Create a variable that keeps track of the sum\n    let mut total =\
    \ 0;\n    // 2. Loop from 1 to n\n    for number in 1..n + 1 {\n        // 3.\
    \ Add each number to the total\n        total += number;\n    }\n    // 4. Return\
    \ the total\n    total", "    let mut sum = 0;\n    for num in 1..n+1 {\n    \
    \    sum += num;\n    }\n    sum", "    let mut sum = 0;\n    for i in 1..n+1\
    \ {\n        sum += i;\n    }\n    sum", "    let mut sum = 0;\n    for i in 1..(n\
    \ + 1) {\n        sum += i;\n    }\n    sum", '    unimplemented!();', "    //\
    \ TODO: implement\n    let mut res = 0;\n    for i in 1..n+1 {\n        res +=\
    \ i;\n    }\n    res", "    let mut sum = 0;\n    for i in 1..n+1 {\n        sum\
    \ += i;\n    }\n    sum", "    // TODO: implement sum_to_n\n    let mut acc =\
    \ 0;\n    for i in 1..n+1 {\n        acc += i;\n    }\n    acc", "    let sum\
    \ = (1 + n) * n / 2;\n    println!(\"{}\", sum);\n    sum", '    n * (n + 1) /
    2', "    let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n \
    \   sum", "    // TODO: implement this function.\n    let mut i = 0;\n    let\
    \ mut sum = 0;\n    while i < n {\n        i += 1;\n        sum += i;\n    }\n\
    \    sum", "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n\
    \    }\n    sum", '    unimplemented!()', "    let mut sum = 0;\n    for i in\
    \ 1..n+1 {\n        sum += i;\n    }\n    sum", '    0', "    if n == 1 {\n  \
    \      return 1;\n    }\n    sum_to_n(n - 1) + n", '    (n * (n + 1)) / 2', " \
    \   // FILL IN YOUR CODE HERE\n    n * (n + 1) / 2", '    n * (n + 1) / 2', " \
    \   if n <= 0 {\n        0\n    } else {\n        n + sum_to_n(n - 1)\n    }",
  "    // TODO\n    if n==1{\n        1\n    }else{\n        n+sum_to_n(n-1)\n   \
    \ }", "    let mut sum = 0;\n    for i in 1..(n + 1) {\n        sum += i;\n  \
    \  }\n    sum", "  let mut sum = 0;\n  for i in 1..n+1 {\n    sum += i;\n  }\n\
    \  sum", "    if n == 1 {\n        return 1;\n    } else {\n        return n +\
    \ sum_to_n(n - 1);\n    }", "    if n == 1 {\n        return 1;\n    }\n    return\
    \ n + sum_to_n(n - 1);", "    // we make a new local mutable variable `result`\
    \ to hold the sum.\n    let mut result = 0;\n    // we make a local mutable variable\
    \ `i` to hold the iterator value.\n    let mut i = 1;\n    // we loop over the\
    \ values from `i` to `n`.\n    while i <= n {\n        // we add the iterator\
    \ value to the result.\n        result += i;\n        // we increment the iterator\
    \ value.\n        i += 1;\n    }\n    // we return the result.\n    result", '    unimplemented!()',
  '    return (1 + n) * n / 2;', '    unimplemented!()', "    //unimplemented!()\n\
    \    let mut result = 0;\n    for i in 1..(n+1) {\n        result += i;\n    }\n\
    \    result", "    if n == 1 {\n        1\n    } else {\n        n + sum_to_n(n\
    \ - 1)\n    }", "    // #YOUR_CODE_HERE\n    panic!(\"Unimplemented\");", "  if\
    \ n == 1 {\n    1\n  } else {\n    n + sum_to_n(n - 1)\n  }", "    if n == 1 {\n\
    \        return 1;\n    }\n    n + sum_to_n(n - 1)", '    (n*(n+1))/2', "    if\
    \ n == 1 {\n        1\n    } else {\n        n + sum_to_n(n - 1)\n    }", "  \
    \  let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum",
  '    unimplemented!()', "    let mut total = 0;\n    for i in 1..n + 1 {\n     \
    \   total += i;\n    }\n    total", "    let mut sum = 0;\n    for i in 1..(n\
    \ + 1) {\n        sum += i;\n    }\n    sum", "    let mut total = 0;\n    for\
    \ i in 1..n + 1 {\n        total += i;\n    }\n    total", "    if n == 1 {\n\
    \        1\n    } else {\n        n + sum_to_n(n - 1)\n    }", "    // TODO: implement\n\
    \    n * (n + 1) / 2", "    if n == 1 {\n        return 1;\n    }\n    sum_to_n(n\
    \ - 1) + n", '    (1..n+1).fold(0, |x, y| x + y)', "    if n < 1 {\n        return\
    \ n;\n    }\n    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n\
    \    }\n    sum", "    // YOUR CODE HERE\n    if n <= 0 {\n        return 0;\n\
    \    }\n    return sum_to_n(n - 1) + n;", "    // TODO: Implement me!\n    unimplemented!();",
  "    let mut s = 0;\n    for i in 1..n + 1 {\n        s += i;\n    }\n    s", '    unimplemented!();',
  "    let result = n * (n + 1) / 2;\n    result", "    // TODO: Your code here!\n\
    \    1", "    // This is a fairly messy way to do this.  We need better\n    //\
    \ solutions in later chapters!\n    if n == 1 {\n        return 1;\n    } else\
    \ {\n        return n + sum_to_n(n - 1);\n    }", "    let mut ans = 0;\n    for\
    \ num in 1..n + 1 {\n        ans += num;\n    }\n    ans", '    unimplemented!();',
  "    let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum",
  "    // Your code here\n    let mut sum = 0;\n    for i in 1..n+1 {\n        sum\
    \ += i;\n    }\n    sum", '    unimplemented!();', "    // `n * (n + 1) / 2`\n\
    \    n * (n + 1) / 2", '    return n * (n + 1) / 2;', "    if n == 1 {\n     \
    \   return 1;\n    }\n    return n + sum_to_n(n - 1);", "    // TODO: Replace\
    \ with your implementation.\n    unimplemented!()", '    unimplemented!();', " \
    \   let mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum",
  "    // TODO\n    unimplemented!();", "    let mut result = 0;\n    for i in 1..(n\
    \ + 1) {\n        result += i;\n    }\n    result", "    // let mut sum = 0;\n\
    \    // for i in 1..(n + 1) {\n    //     sum += i;\n    // }\n    // sum\n  \
    \  n * (n + 1) / 2", "    let mut sum = 0;\n    for i in 1..(n + 1) {\n      \
    \  sum += i;\n    }\n    sum", "    let sum = (1..n+1).fold(0, |sum, x| sum +\
    \ x);\n    println!(\"sum_to_n: {}\", sum);\n    sum", '    (n * (n + 1)) / 2',
  "    if n == 1 {\n        return 1;\n    } else {\n        return n + sum_to_n(n\
    \ - 1);\n    }", "    // Rust cheatsheet:\n    // Operator = + - * / % - assignment,\
    \ addition, subtraction, multiplication, division, remainder\n    // Operator\
    \ += -= *= /= %= - self assignment + addition, subtraction, multiplication, division,\
    \ remainder\n    // Operator & && | || ^ ! - bitwise and, and, or, or, xor, not\n\
    \    // Operator &= |= ^= - self assignment bitwise and, or, xor\n    // Operator\
    \ == != > >= < <= - equality, inequality, greater than, greater than or equal,\
    \ less than, less than or equal\n    // Operator << >> - bitwise left/right shift\n\
    \    // Operator <<= >>= - self assignment bitwise left/right shift\n    // Operator\
    \ as - type cast\n    // Operator .. - inclusive range\n    // Operator ... -\
    \ exclusive range\n    // Operator ..= - inclusive range with equal\n    // Operator\
    \ !- - unary negation\n    // Rust cheatsheet:\n    // Operator as - type cast\n\
    \    // Operator .. - inclusive range\n    // Operator ... - exclusive range\n\
    \    // Operator ..= - inclusive range with equal\n    // Operator !- - unary\
    \ negation\n    // Operator .. - inclusive range\n    // Operator ... - exclusive\
    \ range\n    // Operator ..= - inclusive range with equal\n    // Operator !-\
    \ - unary negation\n    // Operator .. - inclusive range\n    // Operator ...\
    \ - exclusive range\n    // Operator ..= - inclusive range with equal\n    //\
    \ Operator !- - unary negation\n    // Operator .. - inclusive range\n    // Operator\
    \ ... - exclusive range\n    // Operator ..= - inclusive range with equal\n  \
    \  // Operator !- - unary negation\n    // Operator .. - inclusive range\n   \
    \ // Operator ... - exclusive range\n    // Operator ..= - inclusive range with\
    \ equal\n    // Operator !- - unary negation\n    // Operator .. - inclusive range\n\
    \    // Operator ... - exclusive range\n    // Operator ..= - inclusive range\
    \ with equal\n    // Operator !- - unary negation\n    // Operator .. - inclusive\
    \ range\n    // Operator ... - exclusive range\n    // Operator ..= - inclusive\
    \ range with equal\n    // Operator !- - unary negation\n    // Operator .. -\
    \ inclusive range\n    // Operator ... - exclusive range\n    // Operator ..",
  '    (1..n+1).sum()', "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum\
    \ += i;\n    }\n    sum", "    let mut total = 0;\n    for i in 1..n+1 {\n   \
    \     total += i;\n    }\n    total", "    // TODO: implement this\n    return\
    \ 0;", "    // Write the code here\n    n * (n + 1) / 2", "    let mut sum = 0;\n\
    \    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum", '    unimplemented!();',
  "    let mut sum = 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum",
  '    return n * (n + 1) / 2;', "    let mut sum = 0;\n    for i in 1..n + 1 {\n\
    \        sum += i;\n    }\n    sum", "    let mut output = 0;\n    let mut k =\
    \ 0;\n    while k <= n {\n        output = output + k;\n        k = k + 1;\n \
    \   }\n    output", "    let mut total = 0;\n    for i in 1..n + 1 {\n       \
    \ total += i;\n    }\n    total", "    let mut sum = 0;\n    for i in 1..n + 1\
    \ {\n        sum += i;\n    }\n    sum", "    let mut sum = 0;\n    for i in 1..(n\
    \ + 1) {\n        sum += i;\n    }\n    sum", "    let mut res = 0;\n    for i\
    \ in 1..n + 1 {\n        res += i;\n    }\n    res", "    // TODO: Implement it\n\
    \    return 0;", '    n * (n + 1) / 2', '    (n * (n + 1)) / 2', "    if n ==\
    \ 1 {\n        1\n    } else {\n        n + sum_to_n(n - 1)\n    }", "    let\
    \ mut i = 0;\n    let mut sum = 0;\n    for _ in 0..n {\n        i += 1;\n   \
    \     sum += i;\n    }\n    sum", '    return (n + 1) * n / 2;', "    /* YOUR\
    \ CODE HERE */\n    let temp = (n*(n+1))/2;\n    return temp;", "    let sum =\
    \ (1..n + 1).fold(0, |sum, x| sum + x);\n    sum", "    let mut sum = 0;\n   \
    \ for i in 1..n+1 {\n        sum += i;\n    }\n    sum", "    // TODO: implement\
    \ function\n\n    // Sum of 1 to n is equal to (n * (n + 1)) / 2\n    (n * (n\
    \ + 1)) / 2", '    unimplemented!()', "    let mut sum = 0;\n    for i in 1..(n\
    \ + 1) {\n        sum += i;\n    }\n    sum", "    // YOUR CODE HERE\n    panic!(\"\
    sum_to_n is not implemented!\");", '    return n*(n+1)/2;', "    let mut sum =\
    \ 0;\n    for i in 1..n + 1 {\n        sum += i;\n    }\n    sum", "    let mut\
    \ result = 0;\n    for num in 1..(n + 1) {\n        result += num;\n    }\n  \
    \  result", "    if n == 1 {\n        return 1;\n    } else {\n        return\
    \ n + sum_to_n(n - 1);\n    }", '    n * (n + 1) / 2', '  0', "    let mut total\
    \ = 0;\n    for i in 1..n + 1 {\n        total += i;\n    }\n    total", "   \
    \ if n == 1 {\n        return 1;\n    }\n    return n + sum_to_n(n - 1);", " \
    \   // \u521D\u59CB\u5316\u4E00\u4E2A\u7D2F\u52A0\u5668\u4E3A 0\n    let mut acc\
    \ = 0;\n    // \u56E0\u4E3A i \u4F1A\u5728\u5FAA\u73AF\u7ED3\u675F\u540E\u88AB\
    \u6D88\u8017\uFF0C\u6240\u4EE5\u8981\u4F7F\u7528 `let mut`\n    for i in 1..n+1\
    \ {\n        // \u7D2F\u52A0\u5668\u6BCF\u6B21\u52A0\u4E0A i\n        acc += i;\n\
    \    }\n    // \u8FD4\u56DE\u7D2F\u52A0\u5668\n    acc", "    // TODO: implement\
    \ sum_to_n\n    0", '    n * (n + 1) / 2', "    // Write your code here\n    let\
    \ sum = n*(n+1)/2;\n    sum", '    n*(n+1)/2', '    (1..n + 1).sum()', "    let\
    \ mut sum = 0;\n    for i in 1..n+1 {\n        sum += i;\n    }\n    sum", " \
    \   // Extra info:\n    // 1 + 2 + 3 + 4 + ... + n\n    // = n + (n-1) + (n-2)\
    \ + ... + 1\n    // = (n + 1) + (n + 2) + ... + n\n    // = (n + 1) * (n / 2)\n\
    \    // - if n is even: (n + 1) * (n / 2) = (n + 1) * (n / 2) = (n + 1) * (n /\
    \ 2)\n    // - if n is odd: (n + 1) * (n / 2) = (n + 1) * ((n - 1) / 2) + (n +\
    \ 1) / 2\n    //                (n + 1) * (n / 2) = (n^2 - n + 2n + 1) / 2\n \
    \   //                (n + 1) * (n / 2) = (n^2 + n + 2) / 2\n    //          \
    \      (n + 1) * (n / 2) = (n^2 + n + 2) / 2\n    if n % 2 == 0 {\n        (n\
    \ + 1) * (n / 2)\n    } else {\n        (n + 1) * ((n - 1) / 2) + (n + 1) / 2\n\
    \    }", '    panic!("not implemented");', "    let mut sum = 0;\n    for i in\
    \ 1..n + 1 {\n        sum += i;\n    }\n    sum", "    if n < 1 {\n        n\n\
    \    } else {\n        n + sum_to_n(n - 1)\n    }"]
stop_tokens:
- "\n}"
