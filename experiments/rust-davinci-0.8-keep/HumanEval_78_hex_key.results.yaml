name: HumanEval_78_hex_key
language: rust
results:
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut acc = 0;\n    for c in num.chars() {\n        if let\
    \ Some(d) = c.to_digit(16) {\n            if d == 2 || d == 3 || d == 5 || d ==\
    \ 7 || d == 11 || d == 13 {\n                acc += 1;\n            }\n      \
    \  }\n    }\n    acc\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let str = match num.as_str() {\n        \"A\" => \"10\",\n \
    \       \"B\" => \"11\",\n        \"C\" => \"12\",\n        \"D\" => \"13\",\n\
    \        \"E\" => \"14\",\n        \"F\" => \"15\",\n        _ => \"\",\n    };\n\
    \    let mut r: Vec<_> = str.chars().map(|d| d.to_digit(16).unwrap()).collect();\n\
    \    r.sort();\n    let mut count = 0;\n    for item in r {\n        if is_prime(item)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyho9uqee.rs:31:12\n\
    \   |\n31 |         if is_prime(item) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        match\
    \ ch {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n       \
    \     _ => ()\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let valid_chars = \"123456789ABCDEF\";\n    let mut result =\
    \ 0;\n    for i in num.chars() {\n        if valid_chars.contains(i) {\n     \
    \       let mut num = i.to_digit(16).unwrap() as isize;\n            if num >\
    \ 1 {\n                for j in 2..num {\n                    if num % j == 0\
    \ {\n                        num = 0;\n                        break;\n      \
    \              }\n                }\n                result += num;\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `1`', /tmp/tmp8syana7i.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_key: isize = 0xABCDEF;\n    let mut result: isize =\
    \ 0;\n    for c in num.chars() {\n        let c = c as u8;\n        let n = if\
    \ c >= 0x30 && c <= 0x39 {\n            c - 0x30\n        } else if c >= 0x41\
    \ && c <= 0x46 {\n            c - 0x37\n        } else {\n            continue;\n\
    \        };\n        if (hex_key >> n) & 1 == 1 {\n            result += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpb_4jxscv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let prime_arr = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        for p in prime_arr.iter()\
    \ {\n            if c == *p {\n                count += 1;\n            }\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|&c| {\n        match c {\n            '2'\
    \ | '3' | '5' | '7' | 'B' | 'D' => true,\n            _ => false,\n        }\n\
    \    }).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let hex_primes = ['2', '3', '5', '7',\
    \ 'B', 'D'];\n    let mut num = num.chars();\n    while let Some(c) = num.next()\
    \ {\n        if hex_primes.contains(&c) {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // create hex values array\n    let mut hex_values: Vec<char>\
    \ = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D',\
    \ 'E', 'F'];\n    // create prime values array\n    let mut prime_values: Vec<char>\
    \ = vec!['2', '3', '5', '7', 'B', 'D'];\n    // initialize counter\n    let mut\
    \ prime_count: isize = 0;\n    // loop through hex values\n    for hv in hex_values\
    \ {\n        // initialize pattern\n        let pattern = format!(\"{}{}\", num,\
    \ hv);\n        // check if prime\n        if (pattern.parse::<isize>().unwrap()).is_prime()\
    \ {\n            // increment counter\n            prime_count += 1;\n       \
    \ }\n    }\n    // return count\n    return prime_count;\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp5454ovq8.rs:29:48\n   |\n29 |         if (pattern.parse::<isize>().unwrap()).is_prime()\
    \ {\n   |                                                ^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|&c| \"2357BD\".contains(c)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c.is_ascii_digit()\
    \ {\n            let n = c.to_digit(16).unwrap();\n            if is_prime(n as\
    \ isize) {\n                count += 1;\n            }\n        } else {\n   \
    \         let n = c as u8 - 65 + 10;\n            if is_prime(n as isize) {\n\
    \                count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpikpi54ri.rs:22:16\n\
    \   |\n22 |             if is_prime(n as isize) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmpikpi54ri.rs:27:16\n   |\n27 |             if is_prime(n\
    \ as isize) {\n   |                ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    0\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp10q8s34m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut res = 0;\n    let mut arr = [0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0];\n    for i in num.chars() {\n        match i {\n  \
    \          '0' => arr[0] += 1,\n            '1' => arr[1] += 1,\n            '2'\
    \ => arr[2] += 1,\n            '3' => arr[3] += 1,\n            '4' => arr[4]\
    \ += 1,\n            '5' => arr[5] += 1,\n            '6' => arr[6] += 1,\n  \
    \          '7' => arr[7] += 1,\n            '8' => arr[8] += 1,\n            '9'\
    \ => arr[9] += 1,\n            'A' => arr[10] += 1,\n            'B' => arr[11]\
    \ += 1,\n            'C' => arr[12] += 1,\n            'D' => arr[13] += 1,\n\
    \            'E' => arr[14] += 1,\n            'F' => arr[15] += 1,\n        \
    \    _ => {}\n        }\n    }\n    for i in arr.iter() {\n        if *i != 0\
    \ {\n            res += 1;\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpe3rqi8fd.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut\
    \ result = 0;\n    for i in num.chars() {\n        if primes.contains(&i) {\n\
    \            result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    for x in num.chars() {\n        match\
    \ x {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => counter += 1,\n      \
    \      _ => {}\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec![0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0];\n    let\
    \ to_int = |n: char| -> isize {\n        match n {\n            '0'..='9' => n\
    \ as isize - '0' as isize,\n            'A'..='F' => 10 + n as isize - 'A' as\
    \ isize,\n            _ => unreachable!(),\n        }\n    };\n    let char_to_isize\
    \ = |c: char| -> isize {\n        to_int(c)\n    };\n    num.chars().map(char_to_isize).filter(|&x|\
    \ primes[x as usize] == 1).count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num = num.chars().collect::<Vec<char>>();\n    for i\
    \ in 0..num.len() {\n        if num[i] as u8 >= 97 {\n            num[i] = num[i].to_ascii_uppercase();\n\
    \        }\n    }\n    num.into_iter().map(|x| match x {\n        '0' => 0,\n\
    \        '1' => 1,\n        '2' => 2,\n        '3' => 3,\n        '4' => 4,\n\
    \        '5' => 5,\n        '6' => 6,\n        '7' => 7,\n        '8' => 8,\n\
    \        '9' => 9,\n        'A' => 10,\n        'B' => 11,\n        'C' => 12,\n\
    \        'D' => 13,\n        'E' => 14,\n        'F' => 15,\n        _ => 0,\n\
    \    }).filter(|&x| if x < 2 {false} else {(2..(x as usize)).all(|i| x % i as\
    \ isize != 0)}).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        if\
    \ ch == 'A' || ch == 'B' || ch == 'D' {\n            count += 1;\n        }\n\
    \    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpabcskeiw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet mut count = 0;\n\tfor c in num.chars() {\n\t\tif prime_map.contains_key(&c)\
    \ {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tcount\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prime_map` in this scope\n  --> /tmp/tmp1pzidk63.rs:20:6\n\
    \   |\n20 |         if prime_map.contains_key(&c) {\n   |            ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut primes = vec![2, 3, 5, 7, 11,\
    \ 13];\n    let mut digits = num.chars().collect::<Vec<char>>();\n    for digit\
    \ in digits {\n        if digit.is_digit(10) {\n            let di = digit.to_digit(10).unwrap();\n\
    \            if primes.contains(&di) {\n                count += 1;\n        \
    \    }\n        } else {\n            let di = match digit {\n               \
    \ 'A' => 10,\n                'B' => 11,\n                'C' => 12,\n       \
    \         'D' => 13,\n                'E' => 14,\n                'F' => 15,\n\
    \                _ => 0,\n            };\n            if primes.contains(&di)\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut v = Vec::new();\n    for c in num.chars() {\n      \
    \  v.push(c);\n    }\n    v.len() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp1wzloayp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c\
    \ == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n     \
    \       count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    for c in num.chars() {\n        if\
    \ is_prime(char_to_number(c)) {\n            counter += 1;\n        }\n    }\n\
    \    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxm2umwx9.rs:20:12\n\
    \   |\n20 |         if is_prime(char_to_number(c)) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `char_to_number`\
    \ in this scope\n  --> /tmp/tmpxm2umwx9.rs:20:21\n   |\n20 |         if is_prime(char_to_number(c))\
    \ {\n   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let num = num.chars().map(char_to_int).collect::<Vec<isize>>();\n\
    \    let mut prime_count = 0;\n    for i in num {\n        if is_prime(i) {\n\
    \            prime_count += 1;\n        }\n    }\n    prime_count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `char_to_int` in this scope\n  --> /tmp/tmpfrfa29hy.rs:18:31\n\
    \   |\n18 |     let num = num.chars().map(char_to_int).collect::<Vec<isize>>();\n\
    \   |                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpfrfa29hy.rs:21:12\n\
    \   |\n21 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut s = 0;\n    for c in num.chars() {\n        if c ==\
    \ '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n        \
    \    s += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let vec: Vec<char> = num.chars().collect();\n    let mut result:\
    \ isize = 0;\n    for i in vec {\n        if i == '2' || i == '3' || i == '5'\
    \ || i == '7' || i == 'B' || i == 'D' {\n            result += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for i in num.chars() {\n        if i\
    \ == '2' || i == '3' || i == '5' || i == '7' || i == 'B' || i == 'D' {\n     \
    \       count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let\
    \ n = match c {\n            '0' => 0,\n            '1' => 1,\n            '2'\
    \ => 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n\
    \            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n       \
    \     '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => 0,\n        };\n        if is_prime(n) {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpj5n5tys_.rs:39:12\n\
    \   |\n39 |         if is_prime(n) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut copy = num.clone();\n    let\
    \ mut len = copy.len();\n    for c in num.chars() {\n        match c {\n     \
    \       '0' => {},\n            '1' => {},\n            '2' => {count+=1;},\n\
    \            '3' => {count+=1;},\n            '4' => {},\n            '5' => {count+=1;},\n\
    \            '6' => {},\n            '7' => {count+=1;},\n            '8' => {},\n\
    \            '9' => {},\n            'A' => {},\n            'B' => {count+=1;},\n\
    \            'C' => {},\n            'D' => {count+=1;},\n            'E' => {},\n\
    \            'F' => {},\n            _ => {},\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let digits = num.chars().map(|digit| {\n        let value =\
    \ match digit {\n            'A' | 'B' | 'C' | 'D' | 'E' | 'F' => digit as isize\
    \ - 65 + 10,\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8'\
    \ | '9' => digit as isize - 48,\n            _ => -1,\n        };\n        value\n\
    \    });\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let mut counter = 0;\n\
    \    for digit in digits {\n        if primes.contains(&digit) {\n           \
    \ counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut sum = 0;\n    for c in num.chars() {\n        let mut\
    \ key = 0;\n        if c.is_digit(10) {\n            key = c.to_digit(10).unwrap()\
    \ as isize;\n        } else {\n            key = match c {\n                'A'\
    \ => 10,\n                'B' => 11,\n                'C' => 12,\n           \
    \     'D' => 13,\n                'E' => 14,\n                'F' => 15,\n   \
    \             _ => 0,\n            };\n        }\n        if key == 2 || key ==\
    \ 3 || key == 5 || key == 7 || key == 11 || key == 13 {\n            sum += 1;\n\
    \        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let v: Vec<char> = num.chars().collect();\n\
    \    for c in v {\n        match c {\n            '2' => count += 1,\n       \
    \     '3' => count += 1,\n            '5' => count += 1,\n            '7' => count\
    \ += 1,\n            'B' => count += 1,\n            'D' => count += 1,\n    \
    \        _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut v: Vec<isize> = vec![];\n    for i in num.chars() {\n\
    \        let digit = match i {\n            '0' => 0,\n            '1' => 1,\n\
    \            '2' => 2,\n            '3' => 3,\n            '4' => 4,\n       \
    \     '5' => 5,\n            '6' => 6,\n            '7' => 7,\n            '8'\
    \ => 8,\n            '9' => 9,\n            'A' => 10,\n            'B' => 11,\n\
    \            'C' => 12,\n            'D' => 13,\n            'E' => 14,\n    \
    \        'F' => 15,\n            _ => 0,\n        };\n        v.push(digit);\n\
    \    }\n    //println!(\"{:?}\", v);\n    let mut counter = 0;\n    for i in v\
    \ {\n        if i == 2 || i == 3 || i == 5 || i == 7 || i == 11 || i == 13 {\n\
    \            counter += 1;\n        }\n    }\n    return counter;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key: isize = 0;\n    let mut hex_num: Vec<char> = num.chars().collect();\n\
    \    let mut hex_flag: bool = false;\n    if hex_num.len() > 0 {\n        while\
    \ hex_num.len() > 0 {\n            if hex_num[0] == '0' {\n                hex_num.remove(0);\n\
    \            } else {\n                hex_flag = true;\n                break;\n\
    \            }\n        }\n        if hex_flag == true {\n            let mut\
    \ int_arr: Vec<isize> = Vec::new();\n            for c in hex_num {\n        \
    \        match c {\n                    '0' => int_arr.push(0),\n            \
    \        '1' => int_arr.push(1),\n                    '2' => int_arr.push(2),\n\
    \                    '3' => int_arr.push(3),\n                    '4' => int_arr.push(4),\n\
    \                    '5' => int_arr.push(5),\n                    '6' => int_arr.push(6),\n\
    \                    '7' => int_arr.push(7),\n                    '8' => int_arr.push(8),\n\
    \                    '9' => int_arr.push(9),\n                    'A' => int_arr.push(10),\n\
    \                    'B' => int_arr.push(11),\n                    'C' => int_arr.push(12),\n\
    \                    'D' => int_arr.push(13),\n                    'E' => int_arr.push(14),\n\
    \                    'F' => int_arr.push(15),\n                    _ => (),\n\
    \                }\n            }\n            let mut sum: isize = 0;\n     \
    \       let mut index: usize = 0;\n            let mut int_arr_len: usize = int_arr.len();\n\
    \            while int_arr_len > 0 {\n                let int_arr_index: usize\
    \ = int_arr_len - 1;\n                sum += int_arr[int_arr_index] * 16_isize.pow(index);\n\
    \                int_arr_len -= 1;\n                index += 1;\n            }\n\
    \            if sum == 2\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp72uwpgov.rs:73:3\n\
    \   |\n17 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n21 |     if hex_num.len() > 0 {\n   |   \
    \                       - unclosed delimiter\n...\n30 |         if hex_flag ==\
    \ true {\n   |                             - this delimiter might not be properly\
    \ closed...\n...\n63 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n73 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp72uwpgov.rs:63:1\n\
    \   |\n62 |             if sum == 2\n   |             -- this `if` expression\
    \ has a condition, but no block\n63 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp72uwpgov.rs:58:62\n   |\n58 |              \
    \   sum += int_arr[int_arr_index] * 16_isize.pow(index);\n   |               \
    \                                               ^^^^^ expected `u32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n58 |                 sum += int_arr[int_arr_index] * 16_isize.pow(index.try_into().unwrap());\n\
    \   |                                                                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp72uwpgov.rs:21:26\n   |\n21 |\
    \       if hex_num.len() > 0 {\n   |  __________________________^\n22 | |    \
    \     while hex_num.len() > 0 {\n23 | |             if hex_num[0] == '0' {\n24\
    \ | |                 hex_num.remove(0);\n...  |\n72 | |     assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n73 | | }\n   | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut result\
    \ = 0;\n    for n in num.chars() {\n        if n.is_digit(16) {\n            if\
    \ let Some(digit) = n.to_digit(16) {\n                if digit == 0 || digit ==\
    \ 1 {\n                    continue;\n                }\n                if is_prime(digit\
    \ as usize) {\n                    result += 1;\n                }\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpv61qddu8.rs:28:20\n\
    \   |\n28 |                 if is_prime(digit as usize) {\n   |              \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key: isize = 0;\n    for c in num.chars() {\n      \
    \  let c: isize = c.to_digit(16).unwrap() as isize;\n        if c == 1 || c ==\
    \ 0 {\n            continue;\n        }\n        if c == 2 || c == 3 || c == 5\
    \ || c == 7 || c == 11 || c == 13 {\n            key += 1;\n        }\n    }\n\
    \    key\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let hexes = vec![\"0\", \"1\", \"2\"\
    , \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\"\
    , \"E\", \"F\"];\n    let primes = vec![\"2\", \"3\", \"5\", \"7\", \"B\", \"\
    D\"];\n    for i in num.chars() {\n        if hexes.contains(&i.to_string().as_str())\
    \ {\n            if primes.contains(&i.to_string().as_str()) {\n             \
    \   count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key: isize = 0;\n    let result = num.parse::<u32>();\n\
    \    match result {\n        Ok(n) => {\n            if n == 2 || n == 3 || n\
    \ == 5 || n == 7 || n == 11 || n == 13 {\n                key = 1;\n         \
    \   }\n        },\n        Err(_) => {\n            for c in num.chars() {\n \
    \               match c {\n                    '2' | '3' | '5' | '7' | 'B' | 'D'\
    \ => key += 1,\n                    _ => continue,\n                }\n      \
    \      }\n        }\n    }\n    key\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpjf4igyh7.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let nums: Vec<char> = num.chars().collect();\n    let mut key\
    \ = 0;\n    for i in nums {\n        match i {\n            '2' | '3' | '5' |\
    \ '7' | 'B' | 'D' => key += 1,\n            _ => continue,\n        }\n    }\n\
    \    key\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    for x in num.chars() {\n        if\
    \ x.is_digit(10) {\n            counter += 1;\n        } else {\n            match\
    \ x {\n                'B' => counter += 1,\n                'D' => counter +=\
    \ 1,\n                _ => {},\n            }\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpp9ien026.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let num = num.to_uppercase();\n    let mut res = 0;\n    for\
    \ x in num.chars() {\n        if x == '2' || x == '3' || x == '5' || x == '7'\
    \ || x == 'B' || x == 'D' {\n            res += 1;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    match num.as_ref() {\n        \"\" => 0,\n        _ => {\n \
    \           let mut primes = 0;\n            let mut prime = vec![2, 3, 5, 7,\
    \ 11, 13];\n            let mut key: Vec<isize> = num.chars().map(|c| {\n    \
    \            let s = c.to_string();\n                match s.parse::<isize>()\
    \ {\n                    Ok(n) => n,\n                    Err(_) => {\n      \
    \                  let b = match s.as_ref() {\n                            \"\
    A\" => 10,\n                            \"B\" => 11,\n                       \
    \     \"C\" => 12,\n                            \"D\" => 13,\n               \
    \             \"E\" => 14,\n                            \"F\" => 15,\n       \
    \                     _ => 0,\n                        };\n                  \
    \      b\n                    }\n                }\n            }).collect();\n\
    \            key.sort();\n            key.dedup();\n            for e in key {\n\
    \                while e > prime[prime.len() - 1] {\n                    let mut\
    \ i = prime[prime.len() - 1] + 2;\n                    while prime.iter().any(|&x|\
    \ i % x == 0) {\n                        i += 2;\n                    }\n    \
    \                prime.push(i);\n                }\n                if prime.contains(&e)\
    \ {\n                    primes += 1;\n                }\n            }\n    \
    \        primes\n        }\n    }\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpfereyogq.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n        \
    \    _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut sum = 0;\n    let arr_primes = vec![2, 3, 5, 7, 11,\
    \ 13];\n    for s in num.chars() {\n        if (s.is_digit(16)) {\n          \
    \  let n = s.to_digit(16).unwrap();\n            if arr_primes.contains(&n) {\n\
    \                sum += 1;\n            }\n        }\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    let primes_array = [2, 3, 5, 7, 11,\
    \ 13];\n    for i in 0..num.len() {\n        let x = match num.chars().nth(i)\
    \ {\n            Some(x) => x,\n            None => continue,\n        };\n  \
    \      let y = x.to_digit(16).unwrap();\n        if primes_array.contains(&y)\
    \ {\n            primes += 1;\n        }\n    }\n    primes\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // Initialise list of prime digits\n    let prime_digits = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    // Initialise counter\n    let mut count = 0;\n\
    \    // Iterate through hexadecimal string\n    for c in num.chars() {\n     \
    \   // If current character is prime digit, increment counter\n        if prime_digits.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    // Return counter\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let set = [\"2\", \"3\", \"5\", \"\
    7\", \"B\", \"D\"];\n    let tmp = num.to_uppercase();\n    let mut num = tmp.chars();\n\
    \    while let Some(i) = num.next() {\n        if set.contains(&i.to_string().as_str())\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    for i in (0..num.len())\
    \ {\n        let c = num.chars().nth(i).unwrap();\n        let mut n = 0;\n  \
    \      match c {\n            '0' => n = 0,\n            '1' => n = 1,\n     \
    \       '2' => n = 2,\n            '3' => n = 3,\n            '4' => n = 4,\n\
    \            '5' => n = 5,\n            '6' => n = 6,\n            '7' => n =\
    \ 7,\n            '8' => n = 8,\n            '9' => n = 9,\n            'A' =>\
    \ n = 10,\n            'B' => n = 11,\n            'C' => n = 12,\n          \
    \  'D' => n = 13,\n            'E' => n = 14,\n            'F' => n = 15,\n  \
    \          _ => println!(\"ERROR {}\", c),\n        }\n        if primes.contains(&n)\
    \ {\n            println!(\"{} is prime\", n);\n        }\n    }\n    return 0;\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: "11 is prime\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmptsxibjse.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let numbers\
    \ = &[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"\
    A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n    let mut count = 0;\n    for i in\
    \ 0..num.len() {\n        let x = num.chars().nth(i).unwrap().to_string();\n \
    \       if x == \"2\" || x == \"3\" || x == \"5\" || x == \"7\" || x == \"B\"\
    \ || x == \"D\" {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut hex = num.chars();\n    while let Some(key) = hex.next() {\n\
    \        match key {\n            '0' | '1' | '8' => count += 1,\n           \
    \ '2' | '3' | '5' | '7' => count += 1,\n            'B' | 'D' => count += 1,\n\
    \            _ => {},\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpsv1y8qkc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if \"\
    2357BD\".contains(c) {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n        \
    \    _ => continue,\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes: Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n\
    \    let chars: Vec<char> = num.chars().collect();\n    let mut count: isize =\
    \ 0;\n    for item in chars {\n        if primes.contains(&item) {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut cnt = 0;\n    let c: Vec<char> = num.chars().collect();\n\
    \    let mut i = 0;\n    while i < c.len() {\n        if (c[i] == '2') | (c[i]\
    \ == '3') | (c[i] == '5') | (c[i] == '7') | (c[i] == 'B') | (c[i] == 'D') {\n\
    \            cnt += 1;\n        }\n        i += 1;\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut sum = 0;\n    for i in num.chars() {\n        if \"\
    2357BD\".contains(i) {\n            sum += 1;\n        }\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let digits = vec![\"2\", \"3\", \"5\"\
    , \"7\", \"B\", \"D\"];\n    for ch in num.chars() {\n        if digits.contains(&ch.to_string().as_str())\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|c| c.is_digit(16)).filter(|c| *c != '0').filter(|c|\
    \ is_prime(c.to_digit(16).unwrap() as isize)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjyzfv355.rs:18:77\n\
    \   |\n18 |     num.chars().filter(|c| c.is_digit(16)).filter(|c| *c != '0').filter(|c|\
    \ is_prime(c.to_digit(16).unwrap() as isize)).count() as isize\n   |         \
    \                                                                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let primes = [2, 3, 5, 7, 11, 13];\n\
    \    let hexadecimals = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',\
    \ 'B', 'C', 'D', 'E', 'F'];\n    for i in num.chars() {\n        for (index, &prime)\
    \ in primes.iter().enumerate() {\n            if i.to_string() == hexadecimals[prime\
    \ as usize].to_string() {\n                counter += 1;\n            }\n    \
    \    }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    for c in num.chars() {\n        if\
    \ is_prime_hex(c) {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_hex` in this scope\n  -->\
    \ /tmp/tmpdmaao925.rs:20:12\n   |\n20 |         if is_prime_hex(c) {\n   |   \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let num_vec: Vec<char> = num.chars().collect();\n    let mut\
    \ counter: isize = 0;\n    for a in num_vec {\n        let num: u32 = a.to_digit(16).unwrap();\n\
    \        if num % 2 != 0 && num % 3 != 0 && num % 5 != 0 && num % 7 != 0 &&\n\
    \            num % 11 != 0 && num % 13 != 0 {\n            counter += 1;\n   \
    \     }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp8ddpknbc.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let prime_digits = vec!['2', '3', '5', '7', 'B', 'D'];\n   \
    \ let mut count = 0;\n    for c in num.chars() {\n        if prime_digits.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut nums = num.chars();\n    let mut key: isize = 0;\n \
    \   while let Some(c) = nums.next() {\n        match c {\n            '0' | '1'\
    \ | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {\n                let x\
    \ = c.to_digit(16).unwrap();\n                key += if is_prime(x as isize) {\
    \ 1 } else { 0 };\n            }\n            'A' | 'B' | 'C' | 'D' | 'E' | 'F'\
    \ => {\n                let x = c as u8 - b'A' + 10;\n                key += if\
    \ is_prime(x as isize) { 1 } else { 0 };\n            }\n            _ => {}\n\
    \        }\n    }\n    key\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5187pgbe.rs:24:27\n\
    \   |\n24 |                 key += if is_prime(x as isize) { 1 } else { 0 };\n\
    \   |                           ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmp5187pgbe.rs:28:27\n\
    \   |\n28 |                 key += if is_prime(x as isize) { 1 } else { 0 };\n\
    \   |                           ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex: String = String::from(\"0123456789ABCDEF\");\n    let\
    \ mut res: isize = 0;\n    for c in num.chars() {\n        if hex.contains(c)\
    \ {\n            res += match c {\n                '2' | '3' | '5' | '7' | 'B'\
    \ | 'D' => 1,\n                _ => 0,\n            };\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes: HashSet<char> = ['2', '3', '5', '7', 'B', 'D'].iter().cloned().collect();\n\
    \    let mut count: isize = 0;\n    for c in num.chars() {\n        if primes.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpxe_f7u0a.rs:18:21\n\
    \   |\n18 |     let mut primes: HashSet<char> = ['2', '3', '5', '7', 'B', 'D'].iter().cloned().collect();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for n in num.chars() {\n        match\
    \ n {\n            '2' => count += 1,\n            '3' => count += 1,\n      \
    \      '5' => count += 1,\n            '7' => count += 1,\n            'B' =>\
    \ count += 1,\n            'D' => count += 1,\n            _ => {},\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet mut s = 0;\n\tfor c in num.chars() {\n\t\tif c == '2' || c\
    \ == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n\t\t\ts += 1;\n\t\t\
    }\n\t}\n\ts\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut is_prime:\
    \ Vec<bool> = Vec::new();\n    for _ in 0..16 {\n        is_prime.push(false);\n\
    \    }\n    is_prime[2] = true;\n    is_prime[3] = true;\n    is_prime[5] = true;\n\
    \    is_prime[7] = true;\n    is_prime[11] = true;\n    is_prime[13] = true;\n\
    \    let mut result: isize = 0;\n    for c in num.chars() {\n        let digit\
    \ = match c {\n            '0' => 0,\n            '1' => 1,\n            '2' =>\
    \ 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n  \
    \          '6' => 6,\n            '7' => 7,\n            '8' => 8,\n         \
    \   '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => continue,\n        };\n        if is_prime[digit] {\n      \
    \      result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let\
    \ val = match c {\n            '0' => 0,\n            '1' => 1,\n            '2'\
    \ => 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n\
    \            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n       \
    \     '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => -1,\n        };\n        if val > 1 && is_prime(val) {\n   \
    \         count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp8xfh0n9f.rs:39:23\n\
    \   |\n39 |         if val > 1 && is_prime(val) {\n   |                      \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let len = num.len();\n    if len == 0 {\n        return 0;\n\
    \    }\n    let key: Vec<isize> = vec![11, 13, 2, 3, 5, 7];\n    let mut count\
    \ = 0;\n    for i in 0..len {\n        let a = num.chars().nth(i).unwrap().to_digit(16).unwrap();\n\
    \        if key.contains(&(a as isize)) {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n        \
    \    _ => {}\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let hex_str = String::from(\"0123456789ABCDEF\"\
    );\n    let hex_vector: Vec<char> = hex_str.chars().collect();\n    for char in\
    \ num.chars() {\n        for (index, h) in hex_vector.iter().enumerate() {\n \
    \           if *h == char {\n                if (index <= 7 && index >= 1) ||\
    \ (index >= 11 && index <= 13) {\n                    counter += 1;\n        \
    \        }\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `2`', /tmp/tmp39g279yq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_primes = vec![2, 3, 5, 7, 11, 13];\n    let mut count\
    \ = 0;\n    for c in num.chars() {\n        if let Some(i) = c.to_digit(16) {\n\
    \            if hex_primes.contains(&i) {\n                count += 1;\n     \
    \       }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut chars = num.chars();\n    while\
    \ let Some(n) = chars.next() {\n        let mut x = (n as usize) - '0' as usize;\n\
    \        if x > 9 {\n            x -= 7;\n        }\n        let mut is_prime\
    \ = x > 1;\n        for i in 2..x {\n            if x % i == 0 {\n           \
    \     is_prime = false;\n                break;\n            }\n        }\n  \
    \      if is_prime {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet mut count = 0;\n\tfor ch in num.chars() {\n\t\tmatch ch {\n\
    \t\t\t'2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n\t\t\t_ => {},\n\t\t}\n\
    \t}\n\tcount\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let dict: HashMap<char, u32> = [\n        ('0', 0),\n      \
    \  ('1', 1),\n        ('2', 2),\n        ('3', 3),\n        ('4', 4),\n      \
    \  ('5', 5),\n        ('6', 6),\n        ('7', 7),\n        ('8', 8),\n      \
    \  ('9', 9),\n        ('A', 10),\n        ('B', 11),\n        ('C', 12),\n   \
    \     ('D', 13),\n        ('E', 14),\n        ('F', 15),\n    ].iter().cloned().collect();\n\
    \    let mut sum = 0;\n    for c in num.chars() {\n        sum = sum * 16 + dict[&c];\n\
    \    }\n    return sum;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp6h125si3.rs:18:15\n\
    \   |\n18 |     let dict: HashMap<char, u32> = [\n   |               ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let char_vec: Vec<char> = num.chars().collect();\n\
    \    for i in char_vec {\n        if i == '2' || i == '3' || i == '5' || i ==\
    \ '7'\n            || i == 'B' || i == 'D' {\n            count += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|c| \"2357BD\".contains(*c)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    let prime_list = vec![2, 3, 5, 7, 11,\
    \ 13];\n    let mut map = HashMap::new();\n    map.insert('2', 0);\n    map.insert('3',\
    \ 1);\n    map.insert('5', 2);\n    map.insert('7', 3);\n    map.insert('B', 4);\n\
    \    map.insert('D', 5);\n    for c in num.chars() {\n        match map.get(&c)\
    \ {\n            Some(n) => total += prime_list[*n],\n            None => total\
    \ += 0,\n        }\n    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1_ppq_p5.rs:20:19\n   |\n20 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let\
    \ n = c.to_digit(16).unwrap() as isize;\n        if n > 1 && n != 4 && n != 6\
    \ && n != 8 && n != 9 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp0e_dfspi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if is_prime_char(c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_char` in this scope\n  -->\
    \ /tmp/tmp3bwyotb8.rs:20:12\n   |\n20 |         if is_prime_char(c) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut cnt = 0;\n    let primes = vec!['2', '3', '5', '7',\
    \ 'B', 'D'];\n    for c in num.chars() {\n        if primes.contains(&c) {\n \
    \           cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let mut i = 0;\n    let mut hex_digits:\
    \ Vec<char> = Vec::new();\n    let mut hex_digits_primes: Vec<char> = Vec::new();\n\
    \    hex_digits.push('2');\n    hex_digits.push('3');\n    hex_digits.push('5');\n\
    \    hex_digits.push('7');\n    hex_digits.push('B');\n    hex_digits.push('D');\n\
    \    hex_digits_primes.push('2');\n    hex_digits_primes.push('3');\n    hex_digits_primes.push('5');\n\
    \    hex_digits_primes.push('7');\n    hex_digits_primes.push('B');\n    hex_digits_primes.push('D');\n\
    \    while i < num.len() {\n        let ch = num.chars().nth(i).unwrap();\n  \
    \      if hex_digits.contains(&ch) {\n            result += 1;\n        }\n  \
    \      i += 1;\n    }\n    if result == 0 {\n        println!(\"Result is 0\"\
    );\n    } else {\n        println!(\"Result is {}\", result);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: "Result is 1\nResult is 2\nResult is 4\nResult is 2\nResult is 6\nResult\
    \ is 12\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    for c in num.chars() {\n        let\
    \ num = if c.is_digit(10) {\n            c.to_digit(10).unwrap() as isize\n  \
    \      } else {\n            let upper = c.to_ascii_uppercase();\n           \
    \ match upper {\n                'A' => 10,\n                'B' => 11,\n    \
    \            'C' => 12,\n                'D' => 13,\n                'E' => 14,\n\
    \                'F' => 15,\n                _ => 0,\n            }\n        };\n\
    \        if num == 0 {\n            continue;\n        }\n        let mut is_prime\
    \ = true;\n        for d in 2..num {\n            if num % d == 0 {\n        \
    \        is_prime = false;\n                break;\n            }\n        }\n\
    \        if is_prime {\n            primes += 1;\n        }\n    }\n    primes\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `2`', /tmp/tmpscro9umz.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    let\
    \ chars: Vec<char> = num.chars().collect();\n    let mut counter = 0;\n    for\
    \ char in chars {\n        if hex_primes.contains(&char) {\n            counter\
    \ += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let p: String = String::from(\"2357BDF\");\n    num.chars().filter(|c|\
    \ p.contains(c)).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp3yp0fyq5.rs:19:39\n\
    \     |\n19   |     num.chars().filter(|c| p.contains(c)).count() as isize\n \
    \    |                              -------- ^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                              |\n     |                \
    \              required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n19   |     num.chars().filter(|c| p.contains(*c)).count()\
    \ as isize\n     |                                       +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes: HashSet<char> = HashSet::new();\n    primes.insert('2');\n\
    \    primes.insert('3');\n    primes.insert('5');\n    primes.insert('7');\n \
    \   primes.insert('B');\n    primes.insert('D');\n    primes.into_iter().filter(|&x|\
    \ num.contains(x)).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpx1zuc7r8.rs:18:21\n\
    \   |\n18 |     let mut primes: HashSet<char> = HashSet::new();\n   |        \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpx1zuc7r8.rs:18:37\n\
    \   |\n18 |     let mut primes: HashSet<char> = HashSet::new();\n   |        \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet hex_chars = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\tlet hex_chars_primes = vec![2, 3, 5,\
    \ 7, 11, 13];\n\tlet mut key = 0;\n\tfor c in num.chars() {\n\t\tif let Some(index)\
    \ = hex_chars.iter().position(|&ch| ch == c) {\n\t\t\tif hex_chars_primes.contains(&index)\
    \ {\n\t\t\t\tkey += 1;\n\t\t\t}\n\t\t}\n\t}\n\tkey\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let hex_primes = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        if hex_primes.contains(&c)\
    \ {\n            result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    for c in num.chars() {\n        let\
    \ n = match c {\n            '0' => 0,\n            '1' => 1,\n            '2'\
    \ => 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n\
    \            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n       \
    \     '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => unreachable!()\n        };\n        if n == 2 || n == 3 || n\
    \ == 5 || n == 7 || n == 11 || n == 13 {\n            total += 1;\n        }\n\
    \    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        if is_prime(c.to_digit(16).unwrap()\
    \ as isize) {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp35jsnjur.rs:20:12\n\
    \   |\n20 |         if is_prime(c.to_digit(16).unwrap() as isize) {\n   |    \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    // Turn the\
    \ number into a vector of u8 values representing\n    // the hex digits\n    let\
    \ num: Vec<u8> = num.into_bytes();\n    // The hex_primes vector should contain\
    \ the prime numbers\n    // in the hexadecimal system (2, 3, 5, 7, 11 and 13).\n\
    \    let hex_primes = vec![0x2, 0x3, 0x5, 0x7, 0xB, 0xD];\n    // Count the primes\n\
    \    let mut count = 0;\n    for &n in num.iter() {\n        for &p in hex_primes.iter()\
    \ {\n            if n == p {\n                count += 1;\n                break;\n\
    \            }\n        }\n    }\n    count as isize\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp5yedv7u5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_values = \"0123456789ABCDEF\";\n    let mut result =\
    \ 0;\n    let mut i = 0;\n    while i < num.len() {\n        if hex_values.contains(num.get(i..i+1).unwrap())\
    \ {\n            let num_in_hex = hex_values.find(num.get(i..i+1).unwrap()).unwrap();\n\
    \            if is_prime(num_in_hex as isize) {\n                result += 1;\n\
    \            }\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp01cpbmvl.rs:24:16\n\
    \   |\n24 |             if is_prime(num_in_hex as isize) {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.bytes().filter(|&c| \n            if c >= 0x30 && c <= 0x39\
    \ {\n                c - 0x30\n            } else {\n                c - 0x37\n\
    \            } < 17)\n        .map(|c| \n            if c >= 0x30 && c <= 0x39\
    \ {\n                c - 0x30\n            } else {\n                c - 0x37\n\
    \            } as isize)\n        .filter(|&c| {\n            match c {\n    \
    \            0|1 => false,\n                2|3|5|7|11|13 => true,\n         \
    \       _ => (c % 2 != 0) && (c % 3 != 0) && (c % 5 != 0) && (c % 7 != 0) && (c\
    \ % 11 != 0) && (c % 13 != 0)\n            }\n        })\n        .count() as\
    \ isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let valid_primes = vec!['2', '3', '5', '7', 'B', 'D'];\n   \
    \ let result = num.chars().filter(|x| valid_primes.contains(x)).count();\n   \
    \ result as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes: Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n\
    \    let mut cnt: isize = 0;\n    for elem in num.chars() {\n        if primes.contains(&elem)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut value = 0isize;\n    for ch in num.chars() {\n     \
    \   match ch {\n            '0'..='9' => value += 1,\n            'A' => value\
    \ += 0,\n            'B' => value += 1,\n            'C' => value += 0,\n    \
    \        'D' => value += 1,\n            'E' => value += 0,\n            'F' =>\
    \ value += 0,\n            _ => (),\n        }\n    }\n    value\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmprdz8efpn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_digits = vec!['0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let prime_hex_digits = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    if num.len() == 0 {\n        return 0;\n    }\n\
    \    let str_digits = num.chars().collect::<Vec<char>>();\n    let mut prime_count\
    \ = 0;\n    for digit in str_digits {\n        if !hex_digits.contains(&digit)\
    \ {\n            return 0;\n        }\n        if prime_hex_digits.contains(&digit)\
    \ {\n            prime_count += 1;\n        }\n    }\n    prime_count\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_list = num.chars()\n        .filter(|&x| x == '2' ||\
    \ x == '3' || x == '5' || x == '7' || x == 'B' || x == 'D')\n        .collect::<Vec<char>>();\n\
    \    hex_list.len() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().map(|n| {\n        match n {\n            '0'...'9'\
    \ => n.to_digit(16).unwrap() as isize,\n            'A' | 'B' | 'D' => 11,\n \
    \           'C' | 'E' => 13,\n            'F' => 17,\n            _ => 0\n   \
    \     }\n    }).filter(|&x| x > 1 && is_prime(x)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp30tw2nr2.rs:26:29\n\
    \   |\n26 |     }).filter(|&x| x > 1 && is_prime(x)).count() as isize\n   |  \
    \                           ^^^^^^^^ not found in this scope\n\nwarning: `...`\
    \ range patterns are deprecated\n  --> /tmp/tmp30tw2nr2.rs:20:16\n   |\n20 | \
    \            '0'...'9' => n.to_digit(16).unwrap() as isize,\n   |            \
    \    ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet mut i = 0;\n\tfor c in num.chars() {\n\t\tif c == '2' || c\
    \ == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n\t\t\ti += 1;\n\t\t\
    }\n\t}\n\ti\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let key = match num.to_uppercase().as_ref() {\n        \"0\"\
    \ => 0,\n        \"1\" => 1,\n        \"2\" => 2,\n        \"3\" => 3,\n     \
    \   \"4\" => 4,\n        \"5\" => 5,\n        \"6\" => 6,\n        \"7\" => 7,\n\
    \        \"8\" => 8,\n        \"9\" => 9,\n        \"A\" => 10,\n        \"B\"\
    \ => 11,\n        \"C\" => 12,\n        \"D\" => 13,\n        \"E\" => 14,\n \
    \       \"F\" => 15,\n        _ => 0,\n    };\n    key\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp5dsm_wi6.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    for ch in num.chars() {\n        let\
    \ key = match ch {\n            '2' => 2,\n            '3' => 3,\n           \
    \ '5' => 5,\n            '7' => 7,\n            'B' => 11,\n            'D' =>\
    \ 13,\n            _ => 0,\n        };\n        if key != 0 {\n            result\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num = num.as_bytes();\n    let mut total = 0;\n    let\
    \ primes = [2, 3, 5, 7, 11, 13];\n    while let Some(b) = num.pop() {\n      \
    \  total += match b {\n            b'A' | b'B' | b'D' | b'E' => 1,\n         \
    \   b'C' => 0,\n            b'F' => 0,\n            b'1' | b'3' | b'5' | b'7'\
    \ | b'9' => 1,\n            n => 0,\n        };\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop` found for reference `&[u8]` in the\
    \ current scope\n  --> /tmp/tmpkmgcad98.rs:21:29\n   |\n21 |     while let Some(b)\
    \ = num.pop() {\n   |                             ^^^ method not found in `&[u8]`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let prime_arr: [u8;7] = [0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D,\
    \ 0x0F];\n    let num_bytes = num.as_bytes();\n    let mut count = 0;\n    for\
    \ i in 0..num_bytes.len() {\n        let mut found = false;\n        for j in\
    \ 0..prime_arr.len() {\n            if num_bytes[i] == prime_arr[j] {\n      \
    \          found = true;\n                break;\n            }\n        }\n \
    \       if found {\n            count += 1;\n        }\n    }\n    count as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp05dj9p3s.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    let primes_index: Vec<isize> = vec![2,\
    \ 3, 5, 7, 11, 13];\n    for c in num.chars() {\n        let mut c_num = c.to_digit(16).unwrap();\n\
    \        if primes_index.contains(&c_num) {\n            primes += 1;\n      \
    \  }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3x2th59.rs:22:34\n   |\n\
    22 |         if primes_index.contains(&c_num) {\n   |                        \
    \          ^^^^^^ expected `isize`, found `u32`\n   |\n   = note: expected reference\
    \ `&isize`\n              found reference `&u32`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    for i in num.chars() {\n        match\
    \ i {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => result += 1,\n       \
    \     _ => {},\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_prime = vec!['2', '3', '5', '7', 'B', 'D'];\n    let\
    \ mut count = 0;\n    for i in num.chars() {\n        if hex_prime.contains(&i)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\t\n\tlet mut number = num.chars();\n\tlet mut count = 0;\n\tlet\
    \ mut list = vec!['2', '3', '5', '7', 'B', 'D'];\n\t\n\twhile let Some(n) = number.next()\
    \ {\n\t\tif let Some(_) = list.iter().find(|&x| *x == n) {\n\t\t\tcount += 1;\n\
    \t\t}\n\t}\n\tcount\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let base = 16;\n    let mut total: isize = 0;\n    for c in\
    \ num.chars() {\n        let n = c.to_digit(base).unwrap();\n        if n == 2\
    \ || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 {\n            total +=\
    \ 1;\n        }\n    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let mut res = 0;\n\
    \    for ch in num.chars() {\n        let key = if let Ok(n) = ch.to_digit(16)\
    \ {\n            n as isize\n        } else {\n            continue;\n       \
    \ };\n        if primes.contains(&key) {\n            res += 1;\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphwz14wwu.rs:21:26\n   |\n\
    21 |         let key = if let Ok(n) = ch.to_digit(16) {\n   |                \
    \          ^^^^^   --------------- this expression has type `Option<u32>`\n  \
    \ |                          |\n   |                          expected enum `Option`,\
    \ found enum `Result`\n   |\n   = note: expected enum `Option<u32>`\n        \
    \      found enum `Result<_, _>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 { return 0; }\n    let primes = vec![2, 3,\
    \ 5, 7, 11, 13];\n    let chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars().fold(0,\
    \ |acc, c| {\n        if chars.contains(&c) {\n            acc + 1\n        }\
    \ else {\n            acc\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let valid_chars = ['2', '3', '5', '7',\
    \ 'B', 'D'];\n    let num_char_vec: Vec<char> = num.chars().collect();\n    for\
    \ num_char in num_char_vec {\n        for valid_char in valid_chars.iter() {\n\
    \            if num_char == *valid_char {\n                result += 1;\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    for ch in num.chars() {\n        if\
    \ ch == '2' || ch == '3' || ch == '5' || ch == '7' || ch == 'B' || ch == 'D' {\n\
    \            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let prime_key: HashSet<char> = [\n \
    \       '2', '3', '5', '7', 'B', 'D'\n    ].iter().cloned().collect();\n    num.chars().for_each(|x|\
    \ {\n        if prime_key.contains(&x) {\n            count += 1;\n        }\n\
    \    });\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpu_6vzpbr.rs:19:20\n\
    \   |\n19 |     let prime_key: HashSet<char> = [\n   |                    ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    return 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpayrznoh3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut primes = vec![2, 3, 5, 7, 11,\
    \ 13];\n    let mut hex = vec![String::from(\"A\"), String::from(\"B\"), String::from(\"\
    C\"),\n                       String::from(\"D\"), String::from(\"E\"), String::from(\"\
    F\")];\n    for i in num.chars() {\n        if hex.contains(&i.to_string()) ||\n\
    \           primes.contains(&i.to_digit(16).unwrap() as isize) {\n           \
    \ count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvhw_jlvm.rs:24:28\n   |\n\
    24 |            primes.contains(&i.to_digit(16).unwrap() as isize) {\n   |   \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |            \
    \                |\n   |                            expected `&{integer}`, found\
    \ `isize`\n   |                            help: consider borrowing here: `&(&i.to_digit(16).unwrap()\
    \ as isize)`\n\nerror[E0606]: casting `&u32` as `isize` is invalid\n  --> /tmp/tmpvhw_jlvm.rs:24:28\n\
    \   |\n24 |            primes.contains(&i.to_digit(16).unwrap() as isize) {\n\
    \   |                            ------------------------^^^^^^^^^\n   |     \
    \                       |\n   |                            cannot cast `&u32`\
    \ as `isize`\n   |                            help: dereference the expression:\
    \ `*&i.to_digit(16).unwrap()`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let lookup =\n        vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53];\n    let mut count = 0;\n    for c in num.chars() {\n\
    \        if \"0123456789ABCDEF\".contains(c) {\n            let hex = c.to_digit(16).unwrap();\n\
    \            if lookup[hex as usize] == hex {\n                count += 1;\n \
    \           }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp7io8bhbu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    return 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpr8n3xml1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_primes = \"2357BD\";\n    let mut count = 0;\n    for\
    \ x in num.chars() {\n        if hex_primes.contains(x) {\n            count +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let digits: String = \"0123456789ABCDEF\".to_string();\n   \
    \ let primes: String = \"2357BD\".to_string();\n    let mut result: isize = 0;\n\
    \    let mut position: isize = 0;\n    let mut temp_number: isize = 0;\n    let\
    \ mut temp_symbol: String = \"\".to_string();\n    while position < num.len()\
    \ as isize {\n        temp_symbol = String::from(num.get(position as usize..position\
    \ as usize + 1).unwrap());\n        temp_number = digits.find(temp_symbol.as_str()).unwrap()\
    \ as isize;\n        if primes.contains(temp_symbol.as_str()) {\n            result\
    \ += 1;\n        }\n        position += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let is_prime = |n: usize| -> bool {\n        (2..n).all(|x|\
    \ n % x != 0)\n    };\n    let n = num.parse::<isize>().unwrap();\n    (0..16).filter(|&x|\
    \ n >> x & 1 == 1).map(|x| x as usize).filter(|&x| is_prime(x)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp4dgulqqy.rs:21:34\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let hkey = \"0123456789ABCDEF\"\
    ;\n    let chkey: Vec<char> = hkey.chars().collect();\n    let hkey: Vec<usize>\
    \ = chkey.iter().map(|x| x.to_digit(16).unwrap() as usize).collect();\n    let\
    \ num = num.to_uppercase();\n    let bytes = num.as_bytes();\n    //println!(\"\
    {:?}\", bytes);\n    let mut cnt = 0;\n    for (i, _) in bytes.iter().enumerate()\
    \ {\n        let hex = bytes[i] as char;\n        let hexd = hex.to_digit(16).unwrap()\
    \ as usize;\n        if primes.contains(&hkey[hexd]) {\n            cnt += 1;\n\
    \        }\n    }\n    cnt as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    for c in num.chars() {\n        if\
    \ is_prime(convert_to_decimal(c)) {\n            primes += 1;\n        }\n   \
    \ }\n    primes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpccufy0_q.rs:20:12\n\
    \   |\n20 |         if is_prime(convert_to_decimal(c)) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `convert_to_decimal`\
    \ in this scope\n  --> /tmp/tmpccufy0_q.rs:20:21\n   |\n20 |         if is_prime(convert_to_decimal(c))\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let mut counter = 0;\n\
    \    for digit in num.chars() {\n        match digit {\n            '0'..='9'\
    \ => {\n                let num = digit.to_digit(10).unwrap();\n             \
    \   if primes.contains(&num) {\n                    counter += 1;\n          \
    \      }\n            },\n            'A'..='F' => {\n                let num\
    \ = digit.to_digit(16).unwrap();\n                if primes.contains(&num) {\n\
    \                    counter += 1;\n                }\n            },\n      \
    \      _ => ()\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let\
    \ n = c.to_digit(16).unwrap();\n        if n == 3 || n == 5 || n == 7 || n ==\
    \ 11 || n == 13 {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpp5c5hx5q.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut result\
    \ = 0;\n    for ch in num.chars() {\n        let digit = match ch {\n        \
    \    '2' | '3' | '5' | '7' | 'B' | 'D' => 1,\n            _ => 0,\n        };\n\
    \        result += digit;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => counter += 1,\n      \
    \      _ => (),\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let primes:\
    \ Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut count = 0;\n  \
    \  for c in num.chars() {\n        if primes.contains(&c) {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let chars = num.chars().collect::<Vec<char>>();\n    let primes\
    \ = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut total = 0;\n    for c in\
    \ chars {\n        if primes.contains(&c) {\n            total += 1;\n       \
    \ }\n    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if is_prime(c.to_digit(16).unwrap()\
    \ as u32) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgsaw1vif.rs:20:12\n\
    \   |\n20 |         if is_prime(c.to_digit(16).unwrap() as u32) {\n   |      \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let hexadecimal = [0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    let key = num.chars().map(|c|\
    \ {\n        let n = hexadecimal[c.to_digit(16).unwrap() as usize];\n        n\n\
    \    }).filter(|&n| primes.contains(&n)).count() as isize;\n    key\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut res\
    \ = 0;\n    for h_digit in num.chars() {\n        let h_digit = h_digit.to_digit(16).unwrap();\n\
    \        match h_digit {\n            2 | 3 | 5 | 7 | 11 | 13 => res += 1,\n \
    \           _ => {}\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut x = num.as_bytes();\n    x.sort();\n    let x = String::from_utf8(x).unwrap();\n\
    \    if x == \"0123456789\" {\n        return 0;\n    }\n    let mut sum = 0;\n\
    \    for c in x.chars() {\n        if c == '0' || c == '1' {\n            continue;\n\
    \        }\n        if c.is_numeric() {\n            let p = c.to_digit(10).unwrap();\n\
    \            if is_prime(p) {\n                sum += 1;\n            }\n    \
    \    } else {\n            let p = u8::from_str_radix(&c.to_string(), 16).unwrap();\n\
    \            if is_prime(p as u32) {\n                sum += 1;\n            }\n\
    \        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvs7sa2m8.rs:31:16\n\
    \   |\n31 |             if is_prime(p) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpvs7sa2m8.rs:36:16\n   |\n36 |             if is_prime(p as u32)\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvs7sa2m8.rs:20:31\n   |\n20 |     let x = String::from_utf8(x).unwrap();\n\
    \   |                               ^- help: try using a conversion method: `.to_vec()`\n\
    \   |                               |\n   |                               expected\
    \ struct `Vec`, found `&[u8]`\n   |\n   = note: expected struct `Vec<u8>`\n  \
    \         found reference `&[u8]`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // let mut count = 0;\n    // for (i, &c) in num.chars().enumerate()\
    \ {\n    //     match c {\n    //         '2' | '3' | '5' | '7' | 'B' | 'D' =>\
    \ count += 1,\n    //         _ => (),\n    //     }\n    // }\n    // return\
    \ count;\n    // can't use the count variable of isize, so we need a variable\n\
    \    // to store count value\n    // let mut count = 0;\n    // for (i, &c) in\
    \ num.chars().enumerate() {\n    //     if c == '2' || c == '3' || c == '5' ||\
    \ c == '7' || c == 'B' || c == 'D' {\n    //         count += 1;\n    //     }\n\
    \    // }\n    // return count;\n    // since the char type is only 1 bit, can't\
    \ use match, \n    // must use if statement\n    let mut count = 0;\n    for (i,\
    \ &c) in num.chars().enumerate() {\n        if c == '2' || c == '3' || c == '5'\
    \ || c == '7' || c == 'B' || c == 'D' {\n            count += 1;\n        }\n\
    \    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyncf8jll.rs:38:13\n   |\n\
    38 |     for (i, &c) in num.chars().enumerate() {\n   |             ^^     -----------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        let\
    \ n = match ch {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => 1,\n      \
    \      _ => 0,\n        };\n        count += n;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    let primes = vec![2, 3, 5, 7,\
    \ 11, 13];\n    let mut hexes = vec![];\n    for x in num.chars() {\n        match\
    \ x {\n            '0' => hexes.push(0),\n            '1' => hexes.push(1),\n\
    \            '2' => hexes.push(2),\n            '3' => hexes.push(3),\n      \
    \      '4' => hexes.push(4),\n            '5' => hexes.push(5),\n            '6'\
    \ => hexes.push(6),\n            '7' => hexes.push(7),\n            '8' => hexes.push(8),\n\
    \            '9' => hexes.push(9),\n            'A' => hexes.push(10),\n     \
    \       'B' => hexes.push(11),\n            'C' => hexes.push(12),\n         \
    \   'D' => hexes.push(13),\n            'E' => hexes.push(14),\n            'F'\
    \ => hexes.push(15),\n            _ => {}\n        }\n    }\n    for x in hexes\
    \ {\n        if primes.contains(&x) {\n            prime_count += 1;\n       \
    \ }\n    }\n    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut hex = num.chars().filter(|c| c.is_digit(16)).collect::<Vec<char>>();\n\
    \    let mut nums = Vec::new();\n    for c in hex.iter() {\n        if let Some(n)\
    \ = c.to_digit(16) {\n            nums.push(n as isize);\n        }\n    }\n \
    \   let mut count = 0;\n    for n in nums.iter() {\n        if is_prime(n) {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_fkxu7hg.rs:27:12\n\
    \   |\n27 |         if is_prime(n) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let key = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .filter(|x|\
    \ x.is_digit(16))\n        .filter(|x| key.contains(&(x.to_digit(16).unwrap()\
    \ as isize)))\n        .count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut sum = 0;\n    for i in num.chars() {\n        if i ==\
    \ '2' || i == '3' || i == '5' || i == '7' {\n            sum += 1;\n        }\
    \ else if i == 'B' || i == 'D' {\n            sum += 2;\n        }\n    }\n  \
    \  sum\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmplc2rdug6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let nums = vec!['2', '3', '5', '7',\
    \ 'B', 'D'];\n    let num = num.as_bytes();\n    for &c in num {\n        if nums.contains(&(c\
    \ as char)) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() < 2 {\n        return 0;\n    }\n    let num_chars:\
    \ Vec<char> = num.chars().collect();\n    let mut check = 0;\n    let mut count\
    \ = 0;\n    let mut hex_digits = [false; 16];\n    hex_digits[2] = true;\n   \
    \ hex_digits[3] = true;\n    hex_digits[5] = true;\n    hex_digits[7] = true;\n\
    \    hex_digits[11] = true;\n    hex_digits[13] = true;\n    for n in num_chars\
    \ {\n        match n {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' |\
    \ '7' | '8' | '9' => {\n                check = n.to_digit(10).unwrap() as usize;\n\
    \            },\n            'A' => {\n                check = 10;\n         \
    \   },\n            'B' => {\n                check = 11;\n            },\n  \
    \          'C' => {\n                check = 12;\n            },\n           \
    \ 'D' => {\n                check = 13;\n            },\n            'E' => {\n\
    \                check = 14;\n            },\n            'F' => {\n         \
    \       check = 15;\n            },\n            _ => return 0,\n        }\n \
    \       if hex_digits[check] {\n            count += 1;\n        }\n    }\n  \
    \  count as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let _hex = vec!['2', '3', '5', '7',\
    \ 'B', 'D'];\n    if num.is_empty() {\n        count\n    } else {\n        let\
    \ s: Vec<char> = num.chars().collect();\n        for i in s {\n            if\
    \ _hex.contains(&i) {\n                count += 1;\n            }\n        }\n\
    \        count\n    }\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for i in num.chars() {\n        match\
    \ i {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n        \
    \    _ => {},\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let hex_primes = [\"2\", \"3\", \"\
    5\", \"7\", \"B\", \"D\"];\n    let chars: Vec<char> = num.chars().collect();\n\
    \    for c in chars {\n        if hex_primes.contains(&c.to_string().as_str())\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    for ch in num.chars() {\n        if\
    \ ch == 'B' || ch == 'D' {\n            result += 1;\n        }\n        if ch\
    \ == '2' || ch == '3' || ch == '5' || ch == '7' {\n            result += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    num.chars()\n  \
    \      .map(|c| c.to_digit(16).unwrap() as isize)\n        .filter(|d| primes.contains(d))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_key: isize = num.chars().map(|c| c.to_digit(16).unwrap()\
    \ as isize).sum();\n    num.len() as isize - hex_key\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-19`,\n right: `1`', /tmp/tmpykyh8mzf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    for c in num.chars() {\n        if\
    \ c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n   \
    \         primes += 1;\n        }\n    }\n    primes\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let chars = \"0123456789ABCDEF\";\n\
    \    let primes = \"2357BDF\";\n    let mut prime_map = std::collections::HashMap::new();\n\
    \    for c in primes.chars() {\n        prime_map.insert(c, true);\n    }\n  \
    \  for c in num.chars() {\n        if prime_map.contains_key(&c) {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpp_a97m4z.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut res = 0;\n    for c in num.chars() {\n        let num\
    \ = match c {\n            '0' => 0,\n            '1' => 1,\n            '2' =>\
    \ 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n  \
    \          '6' => 6,\n            '7' => 7,\n            '8' => 8,\n         \
    \   '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => 0,\n        };\n        if num == 2 || num == 3 || num == 5\
    \ || num == 7 || num == 11 || num == 13 {\n            res += 1;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let prime = \"2,3,5,7,B,D\".split(\"\
    ,\").map(|x| x.parse::<isize>().unwrap()).collect::<Vec<isize>>();\n    for x\
    \ in num.chars() {\n        match x.to_digit(16) {\n            Some(n) => {\n\
    \                if prime.contains(&(n as isize)) {\n                    result\
    \ += 1;\n                }\n            },\n            None => {}\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp7s1qnfvg.rs:19:69\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let prime_list = vec![2, 3, 5, 7, 11,\
    \ 13];\n    for c in num.chars() {\n        let x = match c {\n            'A'\
    \ => 10,\n            'B' => 11,\n            'C' => 12,\n            'D' => 13,\n\
    \            'E' => 14,\n            'F' => 15,\n            _ => c.to_digit(16).unwrap()\
    \ as usize,\n        };\n        if prime_list.contains(&x) {\n            result\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // TODO: Add your code here\n    0\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpzj3goinz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    let primes = [2, 3, 5, 7, 11, 13];\n\
    \    let mut h2d = HashMap::new();\n    h2d.insert('0', 0);\n    h2d.insert('1',\
    \ 1);\n    h2d.insert('2', 2);\n    h2d.insert('3', 3);\n    h2d.insert('4', 4);\n\
    \    h2d.insert('5', 5);\n    h2d.insert('6', 6);\n    h2d.insert('7', 7);\n \
    \   h2d.insert('8', 8);\n    h2d.insert('9', 9);\n    h2d.insert('A', 10);\n \
    \   h2d.insert('B', 11);\n    h2d.insert('C', 12);\n    h2d.insert('D', 13);\n\
    \    h2d.insert('E', 14);\n    h2d.insert('F', 15);\n    let mut num_vec: Vec<isize>\
    \ = Vec::new();\n    for i in num.chars() {\n        let mut s = String::new();\n\
    \        s.push(i);\n        num_vec.push(h2d.get(&s).unwrap().clone());\n   \
    \ }\n    for i in num_vec {\n        for j in primes.iter() {\n            if\
    \ i == *j {\n                result += 1;\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp924r3o7i.rs:20:19\n   |\n20 |     let mut h2d = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let v: Vec<char> = num.chars().collect();\n    let mut cnt =\
    \ 0;\n    for c in v {\n        if vec!['2', '3', '5', '7', 'B', 'D'].contains(&c)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut\
    \ count = 0;\n    for i in num.chars() {\n        if primes.contains(&i) {\n \
    \           count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for x in num.chars() {\n        if \"\
    2357BD\".contains(x) {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let prime_hex = vec![2, 3, 5, 7, 11, 13];\n    let mut count\
    \ = 0;\n    for i in num.chars() {\n        match i {\n            'A' | 'B' |\
    \ 'C' | 'D' | 'E' | 'F' => {\n                if prime_hex.contains(&(i as u8\
    \ - 48)) {\n                    count += 1;\n                }\n            }\n\
    \            _ => {\n                if prime_hex.contains(&(i as u8 - 48)) {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpqst7d_bt.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    for c in num.chars() {\n        let\
    \ d = match c {\n            '0' => 0,\n            '1' => 1,\n            '2'\
    \ => 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n\
    \            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n       \
    \     '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => -1,\n        };\n        if d == 2 || d == 3 || d == 5 || d\
    \ == 7 || d == 11 || d == 13 {\n            total += 1;\n        }\n    }\n  \
    \  total\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|ch| match ch {\n        '0' => false,\n\
    \        '1' => false,\n        '2' => true,\n        '3' => true,\n        '4'\
    \ => false,\n        '5' => true,\n        '6' => false,\n        '7' => true,\n\
    \        '8' => false,\n        '9' => false,\n        'A' => true,\n        'B'\
    \ => true,\n        'C' => false,\n        'D' => true,\n        'E' => false,\n\
    \        'F' => false,\n        _ => false,\n    }).count() as isize\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpgf5b0z82.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tnum.chars().filter(|&c| \"2357BD\".contains(c)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tif num.len() == 0 {\n\t\treturn 0;\n\t}\n\tlet mut count = 0;\n\
    \tfor symbol in num.chars() {\n\t\tlet digit = match symbol {\n\t\t\t'A' => 10,\n\
    \t\t\t'B' => 11,\n\t\t\t'C' => 12,\n\t\t\t'D' => 13,\n\t\t\t'E' => 14,\n\t\t\t\
    'F' => 15,\n\t\t\t_ => symbol.to_digit(16).unwrap() as usize,\n\t\t};\n\t\tif\
    \ is_prime(digit) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tcount as isize\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2rru9krq.rs:32:6\n\
    \   |\n32 |         if is_prime(digit) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let valid_chars = \"ABCDEFabcdef\";\n    let mut total: isize\
    \ = 0;\n    for c in num.chars() {\n        if valid_chars.contains(c) {\n   \
    \         let d = (c as u8 - 55) as isize;\n            total += d;\n        }\
    \ else {\n            let d = c.to_digit(10).unwrap() as isize;\n            total\
    \ += d;\n        }\n    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `21`,\n right: `1`', /tmp/tmp4a7q7bmd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let key: isize = 0x20;\n    let mut count: isize = 0;\n    for\
    \ i in num.chars() {\n        if is_prime(i as isize - key) {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4z7_08rf.rs:21:12\n\
    \   |\n21 |         if is_prime(i as isize - key) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut temp_count = 0;\n    for i in\
    \ num.chars() {\n        if i != '0' && i != '1' {\n            if temp_count\
    \ == 0 {\n                count += 1;\n            }\n            temp_count +=\
    \ 1;\n        } else {\n            temp_count = 0;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpcw2b1z0_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex: Vec<char> = num.chars().collect();\n    let mut count\
    \ = 0;\n    for c in hex {\n        match c {\n            '0' | '1' | 'A' | 'B'\
    \ | 'C' | 'D' | 'E' | 'F' => count += 1,\n            '2' | '3' | '5' | '7' =>\
    \ count += 1,\n            _ => count += 0,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpfjq6hyef.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // you code starts here\n    let mut x = 0;\n    let mut cnt\
    \ = 0;\n    while x < num.len() {\n        let x1 = num.chars().nth(x).unwrap();\n\
    \        if x1 == '2' || x1 == '3' || x1 == '5' || x1 == '7' || x1 == 'B' || x1\
    \ == 'D' {\n            cnt += 1;\n        }\n        x += 1;\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut digits:\
    \ Vec<char> = vec![];\n    let mut sum = 0;\n    for ch in num.chars() {\n   \
    \     if ch.is_numeric() {\n            digits.push(ch);\n        } else {\n \
    \           digits.push(ch.to_string().to_uppercase().parse::<char>().unwrap());\n\
    \        }\n    }\n    println!(\"digits: {:?}\", digits);\n    let mut primes\
    \ = vec![2, 3, 5, 7, 11, 13];\n    for digit in digits {\n        match digit\
    \ {\n            '0' => sum += 0,\n            '1' => sum += 1,\n            '2'\
    \ => sum += 2,\n            '3' => sum += 3,\n            '4' => sum += 4,\n \
    \           '5' => sum += 5,\n            '6' => sum += 6,\n            '7' =>\
    \ sum += 7,\n            '8' => sum += 8,\n            '9' => sum += 9,\n    \
    \        'A' => sum += 10,\n            'B' => sum += 11,\n            'C' =>\
    \ sum += 12,\n            'D' => sum += 13,\n            'E' => sum += 14,\n \
    \           'F' => sum += 15,\n            _ => {}\n        }\n    }\n    println!(\"\
    sum: {}\", sum);\n    let mut count = 0;\n    while sum > 0 {\n        if sum\
    \ % 10 == 0 {\n            count += 1;\n        }\n        sum /= 10;\n    }\n\
    \    println!(\"count: {}\", count);\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: "digits: ['A', 'B']\nsum: 21\ncount: 0\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpzemuictj.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \    num.chars().filter(|c| hex.contains(c)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpz6ok6b26.rs:18:14\n\
    \   |\n18 |     let hex: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \   |              ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let num_arr: Vec<&str> = num.split(\"\").collect();\n    let\
    \ prime_arr: Vec<&str> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"].to_vec();\n\
    \    let mut sum: isize = 0;\n    for i in 0..num_arr.len() {\n        for x in\
    \ 0..prime_arr.len() {\n            if num_arr[i] == prime_arr[x] {\n        \
    \        sum += 1;\n            }\n        }\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key = 0;\n    for x in num.chars() {\n        if x ==\
    \ '2' || x == '3' || x == '5' || x == '7' || x == 'B' || x == 'D' {\n        \
    \    key += 1;\n        }\n    }\n    key\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|c| HEX_PRIMES.contains(*c)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `HEX_PRIMES` in this scope\n  --> /tmp/tmptvyg7qb_.rs:18:28\n\
    \   |\n18 |     num.chars().filter(|c| HEX_PRIMES.contains(*c)).count() as isize\n\
    \   |                            ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let chrs: Vec<char> = num.chars().collect();\n    let mut count\
    \ = 0;\n    for c in chrs {\n        if c == '2' || c == '3' || c == '5' || c\
    \ == '7' || c == 'B' || c == 'D' {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|x| x.is_numeric() || x.is_alphabetic()).map(|x|\
    \ match x {\n        'A' | 'B' | 'D' => 1,\n        '2' | '3' | '5' | '7' => 1,\n\
    \        _ => 0\n    }).sum()\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpw3gv2hc6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key = 0;\n    for c in num.chars() {\n        let d\
    \ = match c {\n            '0'..='9' => c as isize - '0' as isize,\n         \
    \   'A' => 10,\n            'B' => 11,\n            'C' => 12,\n            'D'\
    \ => 13,\n            'E' => 14,\n            'F' => 15,\n            _ => 0,\n\
    \        };\n        if d > 1 && d < 16 {\n            let mut i = 2;\n      \
    \      while i < d {\n                if d % i == 0 {\n                    break;\n\
    \                }\n                i += 1;\n            }\n            if i ==\
    \ d {\n                key += 1;\n            }\n        }\n    }\n    key\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    let mut digit = 0;\n    for c in num.chars()\
    \ {\n        if let Some(d) = c.to_digit(16) {\n            digit = d as isize;\n\
    \            if digit > 1 && \n                (digit == 2 || digit == 3 || digit\
    \ == 5 || digit == 7 || \n                 digit == 11 || digit == 13) {\n   \
    \             total += 1;\n            }\n        }\n    }\n    total\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.len() == 0 {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    for i in num.chars() {\n        let n = match i {\n            '0'...'9'\
    \ => i as isize - '0' as isize,\n            'A' => 10,\n            'B' => 11,\n\
    \            'C' => 12,\n            'D' => 13,\n            'E' => 14,\n    \
    \        'F' => 15,\n            _ => 0,\n        };\n        let mut is_prime\
    \ = true;\n        if n == 1 {\n            is_prime = false;\n        }\n   \
    \     if n > 1 {\n            for j in 2..n {\n                if n % j == 0 {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n            }\n        }\n        if is_prime {\n            sum +=\
    \ 1;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `2`', /tmp/tmp4yo1htr7.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n\tlet mut count = 0;\n\tlet mut prime = vec![2, 3, 5, 7, 11, 13];\n\
    \tlet mut digit = vec!['2', '3', '5', '7', 'B', 'D'];\n\tlet mut value = vec![];\n\
    \tlet vec: Vec<char> = num.chars().collect();\n\tfor i in 0..vec.len() {\n\t\t\
    if vec[i] == 'A' { value.push(10); }\n\t\telse if vec[i] == 'B' { value.push(11);\
    \ }\n\t\telse if vec[i] == 'C' { value.push(12); }\n\t\telse if vec[i] == 'D'\
    \ { value.push(13); }\n\t\telse if vec[i] == 'E' { value.push(14); }\n\t\telse\
    \ if vec[i] == 'F' { value.push(15); }\n\t\telse { value.push(vec[i].to_digit(10).unwrap()\
    \ as isize); }\n\t}\n\tfor i in 0..digit.len() {\n\t\tfor j in 0..vec.len() {\n\
    \t\t\tif digit[i] == vec[j] { count += 1; }\n\t\t}\n\t}\n\tfor i in 0..prime.len()\
    \ {\n\t\tfor j in 0..value.len() {\n\t\t\tif prime[i] == value[j] { count += 1;\
    \ }\n\t\t}\n\t}\n\tcount\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpwaw6690g.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        let v\
    \ = match c {\n            '0' => 0,\n            '1' => 1,\n            '2' =>\
    \ 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n  \
    \          '6' => 6,\n            '7' => 7,\n            '8' => 8,\n         \
    \   '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => 0,\n        };\n        if v == 2 || v == 3 || v == 5 || v ==\
    \ 7 || v == 11 || v == 13 {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut ans = 0;\n    let str_num = num.as_str();\n    for s\
    \ in str_num.chars() {\n        let n = s.to_digit(16).unwrap() as usize;\n  \
    \      if n > 1 && n % 2 == 1 {\n            ans += 1;\n        }\n    }\n   \
    \ ans\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpzziw7v4e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    for i in num.chars() {\n        let\
    \ x = i.to_digit(16).unwrap();\n        if is_prime(x as i32) {\n            total\
    \ += 1;\n        }\n    }\n    total\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpc3jr6kxz.rs:21:12\n\
    \   |\n21 |         if is_prime(x as i32) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut num_primes = 0;\n    for i in num.chars() {\n      \
    \  let temp_num = match i {\n            '0' => 0,\n            '1' => 1,\n  \
    \          '2' => 2,\n            '3' => 3,\n            '4' => 4,\n         \
    \   '5' => 5,\n            '6' => 6,\n            '7' => 7,\n            '8' =>\
    \ 8,\n            '9' => 9,\n            'A' => 10,\n            'B' => 11,\n\
    \            'C' => 12,\n            'D' => 13,\n            'E' => 14,\n    \
    \        'F' => 15,\n            _ => 0,\n        };\n        if temp_num == 2\
    \ || temp_num == 3 || temp_num == 5 || temp_num == 7 || temp_num == 11 || temp_num\
    \ == 13 {\n            num_primes += 1;\n        }\n    }\n    num_primes\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut r = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => r += 1,\n            _ =>\
    \ ()\n        }\n    }\n    r\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut ret: isize = 0;\n    let mut dic: HashMap<char, isize>\
    \ = HashMap::new();\n    dic.insert('2', 2);\n    dic.insert('3', 3);\n    dic.insert('5',\
    \ 5);\n    dic.insert('7', 7);\n    dic.insert('B', 11);\n    dic.insert('D',\
    \ 13);\n    for c in num.chars() {\n        if dic.contains_key(&c) {\n      \
    \      ret += 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp82se5qd3.rs:19:18\n\
    \   |\n19 |     let mut dic: HashMap<char, isize> = HashMap::new();\n   |    \
    \              ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp82se5qd3.rs:19:41\n\
    \   |\n19 |     let mut dic: HashMap<char, isize> = HashMap::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut sum = 0;\n    let num_vec: Vec<char> = num.chars().collect();\n\
    \    for i in 0..num_vec.len() {\n        let mut val = num_vec[i];\n        if\
    \ val.is_alphabetic() {\n            val = match val {\n                'A' =>\
    \ '1',\n                'B' => '1',\n                'C' => '1',\n           \
    \     'D' => '1',\n                'E' => '1',\n                'F' => '1',\n\
    \                _ => val,\n            };\n        }\n        let val_i: isize\
    \ = val.to_string().parse().unwrap();\n        if is_prime(val_i) {\n        \
    \    sum += 1;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5tkvtwwt.rs:34:12\n\
    \   |\n34 |         if is_prime(val_i) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes: Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n\
    \    let mut prime_count: isize = 0;\n    for ch in num.chars() {\n        if\
    \ primes.contains(&ch) {\n            prime_count += 1;\n        }\n    }\n  \
    \  prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let hex_key = vec!['2', '3', '5', '7',\
    \ 'B', 'D'];\n    for i in num.chars() {\n        if hex_key.contains(&i) {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let\
    \ a = c.to_digit(16).unwrap();\n        let mut is_prime = true;\n        for\
    \ i in 2..a {\n            if a % i == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if is_prime {\n   \
    \         count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpo2cyi_bq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_cnt = 0;\n    for c in num.chars() {\n       \
    \ let mut has_divider = false;\n        match c {\n            'A' | 'B' | 'D'\
    \ | 'E' => {\n                prime_cnt += 1;\n            }\n            '2'\
    \ | '3' | '5' | '7' => {\n                prime_cnt += 1;\n            }\n   \
    \         _ => {}\n        }\n    }\n    prime_cnt\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpepqlbm13.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().map(|x| x.to_digit(16).unwrap() as isize).filter(|&x|\
    \ is_prime(x)).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfowsn4va.rs:18:71\n\
    \   |\n18 |     num.chars().map(|x| x.to_digit(16).unwrap() as isize).filter(|&x|\
    \ is_prime(x)).count() as isize\n   |                                        \
    \                               ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => total += 1,\n        \
    \    _ => (),\n        }\n    }\n    total\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hexes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\
    \ 'A', 'B', 'C', 'D', 'E', 'F'];\n    let mut sum = 0;\n    let mut hex_matrix\
    \ = vec![];\n    let mut hex_str_vec = vec![];\n    let n = num.len();\n    for\
    \ i in 0..n {\n        hex_str_vec.push(num.chars().nth(i).unwrap());\n    }\n\
    \    for i in 0..n {\n        for j in 0..hexes.len() {\n            if hex_str_vec[i]\
    \ == hexes[j] {\n                hex_matrix.push(j as isize);\n            }\n\
    \        }\n    }\n    for i in 0..n {\n        if hex_matrix[i] % 2 != 0 && hex_matrix[i]\
    \ != 1 {\n            let mut c = 0;\n            for j in 1..hex_matrix[i] {\n\
    \                if hex_matrix[i] % j == 0 {\n                    c += 1;\n  \
    \              }\n            }\n            if c == 1 {\n                sum\
    \ += 1;\n            }\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpwbiihj_l.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmpo45dvp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime_count = 0;\n    for c in num.chars() {\n     \
    \   let d = match c {\n            '0' => 0,\n            '1' => 1,\n        \
    \    '2' => 2,\n            '3' => 3,\n            '4' => 4,\n            '5'\
    \ => 5,\n            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n\
    \            '9' => 9,\n            'A' => 10,\n            'B' => 11,\n     \
    \       'C' => 12,\n            'D' => 13,\n            'E' => 14,\n         \
    \   'F' => 15,\n            _ => panic!(\"{} is not a valid hex digit\", c),\n\
    \        };\n        if d == 2 || d == 3 || d == 5 || d == 7 || d == 11 || d ==\
    \ 13 {\n            prime_count += 1;\n        }\n    }\n    prime_count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => ()\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `count`\n  -->\
    \ /tmp/tmp2t082ph9.rs:21:50\n   |\n18 |     let count = 0;\n   |         -----\n\
    \   |         |\n   |         first assignment to `count`\n   |         help:\
    \ consider making this binding mutable: `mut count`\n...\n21 |             '2'\
    \ | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n   |                         \
    \                         ^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = 0;\n    if num.len() > 0 {\n        for i in\
    \ num.chars() {\n            match i {\n                '2' | '3' | '5' | '7'\
    \ | 'B' | 'D' => primes += 1,\n                _ => {}\n            }\n      \
    \  }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut res = 0;\n    let n = num.to_uppercase();\n    for c\
    \ in n.chars() {\n        match c {\n            '2' | '3' | '5' | '7' | 'B' |\
    \ 'D' => res += 1,\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let chars = num.chars();\n    let mut prime = 0;\n    for s\
    \ in chars {\n        match s {\n            '2' => prime += 1,\n            '3'\
    \ => prime += 1,\n            '5' => prime += 1,\n            '7' => prime +=\
    \ 1,\n            'B' => prime += 1,\n            'D' => prime += 1,\n       \
    \     _ => continue,\n        }\n    }\n    prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    // let mut result = 0;\n    // for i in num.chars() {\n    //\
    \     let tmp = match i {\n    //         '2' => 2,\n    //         '3' => 3,\n\
    \    //         '5' => 5,\n    //         '7' => 7,\n    //         'B' => 11,\n\
    \    //         'D' => 13,\n    //         _ => 0,\n    //     };\n    //    \
    \ if tmp != 0 {\n    //         result += 1;\n    //     }\n    // }\n    // result\n\
    \    let mut count = 0;\n    for i in num.chars() {\n        count += match i\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => 1,\n            _ => 0,\n\
    \        };\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut cnt = 0;\n    let mut new_str = String::new();\n   \
    \ for c in num.chars() {\n        match c {\n            'A' | 'B' | 'C' | 'D'\
    \ | 'E' | 'F' => {\n                new_str.push_str(&c.to_string());\n      \
    \      },\n            _ => new_str.push(c),\n        }\n    }\n    let mut num\
    \ = match new_str.parse::<usize>() {\n        Ok(n) => n,\n        Err(_) => 0,\n\
    \    };\n    while num > 0 {\n        if is_prime(num % 10) {\n            cnt\
    \ += 1;\n        }\n        num /= 10;\n    }\n    return cnt;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4kyiye80.rs:33:12\n\
    \   |\n33 |         if is_prime(num % 10) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
