name: HumanEval_3_below_zero
language: rust
results:
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjon4h4ia.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in operations {\n   \
    \     sum += i;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9b7cohvn.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // Return True if at any point the balance goes below\
    \ zero, otherwise return False\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp41o20y2h.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut bal = 0;\n    for o in operations {\n   \
    \     bal += o;\n        if bal < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbsxmh2sv.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl4xocxba.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for val in operations {\n\
    \        balance += val;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for val in operations {\n\
    \        balance += val;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2jh8uuo5.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9gi2q9p4.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl0kgv9h2.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |balance, &op| balance\
    \ + op) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_vbc0vog.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |a, x| a + x) < 0\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprjblorhs.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsnoyjbe0.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpo65ab7ql.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let zero = Rc::new(RefCell::new(0));\n    let mut\
    \ data = operations.iter().map(|x| {\n        if *x < 0 {\n            return\
    \ Data::Withdrawal(Rc::clone(&zero), *x);\n        } else {\n            return\
    \ Data::Deposit(Rc::clone(&zero), *x);\n        }\n    });\n    match data.next()\
    \ {\n        Some(x) => {\n            x.update();\n            while let Some(next)\
    \ = data.next() {\n                next.update();\n                if zero.borrow().clone()\
    \ < 0 {\n                    return true;\n                }\n            }\n\
    \            return false;\n        }\n        None => return false,\n    }\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Data`\n  --> /tmp/tmpfmj9kwph.rs:12:20\n\
    \   |\n12 |             return Data::Withdrawal(Rc::clone(&zero), *x);\n   | \
    \                   ^^^^ use of undeclared type `Data`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Data`\n  --> /tmp/tmpfmj9kwph.rs:14:20\n\
    \   |\n14 |             return Data::Deposit(Rc::clone(&zero), *x);\n   |    \
    \                ^^^^ use of undeclared type `Data`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Rc`\n --> /tmp/tmpfmj9kwph.rs:9:16\n  |\n9\
    \ |     let zero = Rc::new(RefCell::new(0));\n  |                ^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::rc::Rc;\n\
    \  |\n\nerror[E0433]: failed to resolve: use of undeclared type `RefCell`\n -->\
    \ /tmp/tmpfmj9kwph.rs:9:24\n  |\n9 |     let zero = Rc::new(RefCell::new(0));\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::cell::RefCell;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Rc`\n  --> /tmp/tmpfmj9kwph.rs:12:37\n\
    \   |\n12 |             return Data::Withdrawal(Rc::clone(&zero), *x);\n   | \
    \                                    ^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::rc::Rc;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Rc`\n  --> /tmp/tmpfmj9kwph.rs:14:34\n \
    \  |\n14 |             return Data::Deposit(Rc::clone(&zero), *x);\n   |     \
    \                             ^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::rc::Rc;\n   |\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let result = operations.iter().fold(0, |sum, operation|\
    \ sum + operation);\n    result < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvpky64ut.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    return operations.iter().fold(0, |balance, &operation|\
    \ balance + operation) < 0;\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpte4owpwh.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2d91yya8.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf6566n9a.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw7b56usm.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7o4qo8st.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut total = 0;\n    for amount in operations\
    \ {\n        total += amount;\n        if total < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, op| acc + op) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1owah0kc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, &x| {\n        let\
    \ new_balance = acc + x;\n        if new_balance < 0 {\n            return true;\n\
    \        }\n        new_balance\n    }) < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6dnmxlv.rs:12:20\n   |\n\
    12 |             return true;\n   |                    ^^^^ expected `isize`,\
    \ found `bool`\n   |\nnote: return type inferred to be `isize` here\n  --> /tmp/tmpd6dnmxlv.rs:12:20\n\
    \   |\n12 |             return true;\n   |                    ^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp64_94ulv.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // before the below_zero function is called, the\
    \ initial value of the balance\n    // is zero. The fold_while function takes\
    \ the balance variable, then combines\n    // the balance variable with each element\
    \ in the operations Vec.\n    // If the balance variable is greater than zero,\
    \ then it is combined with the\n    // next operation in the Vec.\n    // If the\
    \ balance variable is less than zero, then it breaks from the loop\n    // and\
    \ returns the false value\n    operations.into_iter().fold_while(0, |balance,\
    \ op| {\n        if balance + op >= 0 {\n            FoldWhile::Continue(balance\
    \ + op)\n        } else {\n            FoldWhile::Done(false)\n        }\n   \
    \ })\n    .unwrap_or(true)\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `FoldWhile`\n \
    \ --> /tmp/tmp9op83rng.rs:18:13\n   |\n18 |             FoldWhile::Continue(balance\
    \ + op)\n   |             ^^^^^^^^^ use of undeclared type `FoldWhile`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `FoldWhile`\n  --> /tmp/tmp9op83rng.rs:20:13\n\
    \   |\n20 |             FoldWhile::Done(false)\n   |             ^^^^^^^^^ use\
    \ of undeclared type `FoldWhile`\n\nerror[E0599]: no method named `fold_while`\
    \ found for struct `std::vec::IntoIter` in the current scope\n  --> /tmp/tmp9op83rng.rs:16:28\n\
    \   |\n16 |     operations.into_iter().fold_while(0, |balance, op| {\n   |   \
    \                         ^^^^^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let mut balance = 0;\n\
    \    for operation in operations {\n        balance += operation;\n        if\
    \ balance < 0 {\n            result = true;\n            break;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjb6dkv7h.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpoizjbty5.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |mut acc, n| {\n      \
    \  acc += n;\n        acc < 0\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr3vnuqrc.rs:9:28\n  |\n9 |\
    \     operations.iter().fold(0, |mut acc, n| {\n  |                          \
    \  ^ expected `bool`, found integer\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `bool`\n  --> /tmp/tmpr3vnuqrc.rs:10:9\n   |\n\
    10 |         acc += n;\n   |         ---^^^^^\n   |         |\n   |         cannot\
    \ use `+=` on type `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3vnuqrc.rs:11:15\n\
    \   |\n11 |         acc < 0\n   |               ^ expected `bool`, found integer\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp47d5v4kr.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for op in operations {\n  \
    \      sum += op;\n        if sum < 0 {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut account = 0;\n    for i in operations {\n\
    \        account += i;\n        if account < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut _balance = 0;\n    for _operation in operations\
    \ {\n        _balance += _operation;\n        if _balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqq618jlw.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for oper in operations\
    \ {\n        balance += oper;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, item| {\n       \
    \ acc + item\n    }) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp47leue8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut prev = 0;\n    for operation in operations\
    \ {\n        prev += operation;\n        if prev < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, v| if acc < 0 { acc\
    \ } else { acc + v }) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqbgdn27a.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in &operations {\n \
    \       sum += x;\n        if sum < 0 {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6l4qfof5.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for i in operations {\n\
    \        balance += i;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = 0;\n    for operation in\
    \ operations {\n        current_balance += operation;\n        if current_balance\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph34df5bp.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgpswmqx1.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for n in operations {\n\
    \        balance += n;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9y16_7kn.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2epjqy7t.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, val| acc + val) <\
    \ 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg3y7swxl.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for n in operations {\n   \
    \     sum += n;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, val| acc + val) <\
    \ 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7usu91m5.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, &op| {\n        let\
    \ acc = acc + op;\n        if acc < 0 {\n            return true;\n        }\n\
    \        acc\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpd2oevxjo.rs:9:28\n  |\n9 |\
    \     operations.iter().fold(0, |acc, &op| {\n  |                            ^\
    \ expected `bool`, found integer\n\nerror[E0369]: cannot add `isize` to `bool`\n\
    \  --> /tmp/tmpd2oevxjo.rs:10:23\n   |\n10 |         let acc = acc + op;\n   |\
    \                   --- ^ -- isize\n   |                   |\n   |           \
    \        bool\n\nerror[E0277]: can't compare `bool` with `{integer}`\n  --> /tmp/tmpd2oevxjo.rs:11:16\n\
    \   |\n11 |         if acc < 0 {\n   |                ^ no implementation for\
    \ `bool < {integer}` and `bool > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `bool`\n   = help: the trait `PartialOrd` is implemented\
    \ for `bool`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for i in 0..operations.len()\
    \ {\n        balance += operations[i];\n        if balance < 0 {\n           \
    \ return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for o in operations {\n   \
    \     sum += o;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvdvj3syn.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |sum, value| sum + value)\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8cmmma3z.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for x in operations {\n\
    \        balance += x;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    let mut balance = 0;\n   \
    \ for op in operations {\n        balance += op;\n        if balance < 0 {\n \
    \           return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |sum, x| sum + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq7fpdsef.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut bal: isize = 0;\n    for op in operations\
    \ {\n        bal += op;\n        if bal < 0 {\n            return true;\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    operations.iter().fold(0,\
    \ |sum, i| sum + i) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvlyapibr.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in operations {\n   \
    \     sum += i;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |x, &y| x + y) < 0\n}\n\
    \nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8sdnx17d.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnhhs0b6g.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for value in operations\
    \ {\n        balance += value;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk_yqy4_r.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut bal = 0;\n    for op in operations {\n  \
    \      bal += op;\n        if bal < 0 {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpecqsgyjf.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut balance = 0;\n    while\
    \ i < operations.len() {\n        if balance + operations[i] < 0 {\n         \
    \   return true;\n        }\n        balance += operations[i];\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    return operations.iter().fold(0, |acc, x| acc + x)\
    \ < 0;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg1is9cby.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpi0or4dzm.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for value in operations\
    \ {\n        balance += value;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnhxu1g52.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, v| {\n        if\
    \ acc + v < 0 {\n            return true;\n        }\n        acc + v\n    })\
    \ >= 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppmqcqnbt.rs:11:20\n   |\n\
    11 |             return true;\n   |                    ^^^^ expected `isize`,\
    \ found `bool`\n   |\nnote: return type inferred to be `isize` here\n  --> /tmp/tmppmqcqnbt.rs:11:20\n\
    \   |\n11 |             return true;\n   |                    ^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp91_nh5r9.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for o in operations {\n\
    \        balance += o;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut curr = 0;\n    for op in operations {\n \
    \       curr += op;\n        if curr < 0 {\n            return true;\n       \
    \ }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5bvrlwfe.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpoj5xpec4.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for number in operations {\n\
    \        sum += number;\n        if sum < 0 {\n            return true;\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut bal: isize = 0;\n    for op in operations\
    \ {\n        bal += op;\n        if bal < 0 {\n            return true;\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for i in operations {\n\
    \        balance += i;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6szu7fgg.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, val| {\n        acc\
    \ + val\n    }) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcf_skqui.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |sum, x| sum + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbxj7qrx8.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut res = 0;\n    for i in operations {\n   \
    \     res += i;\n        if res < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2d1_9esh.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphf6pz8l_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut account_balance = 0;\n    for operation in\
    \ operations {\n        account_balance += operation;\n        if account_balance\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6plvxon1.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for i in operations {\n\
    \        balance += i;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO: return correct value\n    false\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsqua2tk9.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for i in operations {\n\
    \        balance += i;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut amount = 0;\n    let mut balance = 0;\n \
    \   for i in operations {\n        amount += i;\n        if amount < balance {\n\
    \            return true;\n        }\n        balance = amount;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjzsf2sz5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut result = 0;\n    for i in operations {\n\
    \        result += i;\n        if result < 0 {\n            return true;\n   \
    \     }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |a, b| a + b) < 0\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq_236wtb.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprxvw7zz_.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpn5eaxdta.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // your code here\n    let mut accumulator = 0;\n\
    \    for i in operations {\n        accumulator += i;\n        if accumulator\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for x in operations {\n\
    \        balance += x;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in operations {\n   \
    \     sum += i;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_py6la3v.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnw_gpc66.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_iet9o9g.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // let mut balance = 0;\n    // for op in operations\
    \ {\n    //     balance += op;\n    //     if balance < 0 {\n    //         return\
    \ true;\n    //     }\n    // }\n    // false\n\n    // or\n    operations.iter().fold(0,\
    \ |b, op| b + op) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbtcbhioh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpotip0g0h.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for num in operations {\n\
    \        balance += num;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for &i in &operations {\n\
    \        balance += i;\n        if balance < 0 {\n            return true;\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpij4prhw0.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, n| acc + n) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr8ur0055.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() == 0 {\n        return false;\n\
    \    }\n    let mut cur_balance = 0;\n    for i in operations {\n        cur_balance\
    \ += i;\n        if cur_balance < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| {\n        if\
    \ acc < 0 {\n            return true;\n        }\n        acc + x\n    }) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpra86jorp.rs:11:20\n   |\n\
    11 |             return true;\n   |                    ^^^^ expected integer,\
    \ found `bool`\n   |\nnote: return type inferred to be `{integer}` here\n  -->\
    \ /tmp/tmpra86jorp.rs:11:20\n   |\n11 |             return true;\n   |       \
    \             ^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ezo4qlp.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut result = false;\n    let mut current_balance\
    \ = 0;\n    for operation in operations {\n        current_balance += operation;\n\
    \        if current_balance < 0 {\n            result = true;\n            break;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl9r8j412.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxvta00i8.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut res = 0;\n    for i in operations {\n   \
    \     res += i;\n        if res < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3k7qkxgp.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO: Implement Me!\n    unimplemented!();\n}\n\
    \nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp767xzz4d.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc4j46vq4.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = 0;\n    for operation in\
    \ operations {\n        current_balance += operation;\n        if current_balance\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp661_k12u.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut acc = 0;\n    for x in operations {\n   \
    \     acc += x;\n        if acc < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO\n    true\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjol3eftw.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // #############\n    // # Task 2.8 #\n    // #############\n\
    \    let mut total = 0;\n    for i in operations {\n        total += i;\n    \
    \    if total < 0 {\n            return true;\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppu25acir.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphs7pm939.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnxtq_tnb.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO: Implement this function.\n    operations.iter().fold(0,\
    \ |acc, x| acc + x) < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp46brjoej.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5dipwx0d.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut acc = 0;\n    for i in operations {\n   \
    \     acc += i;\n        if acc < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzz_u2od5.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // the starting balance is 0\n    let mut balance\
    \ = 0;\n    for op in operations {\n        balance += op;\n        if balance\
    \ < 0 {\n            return true;\n        }\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut count = 0;\n    for op in operations {\n\
    \        count += op;\n        if count < 0 {\n            return true;\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpifw5x53x.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpc3qn0g0r.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in operations {\n   \
    \     sum += i;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp246ekvf_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut total = 0;\n    for item in operations {\n\
    \        total += item;\n        if total < 0 {\n            return true;\n  \
    \      }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzm41sjd7.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for (index, operation)\
    \ in operations.iter().enumerate() {\n        balance += operation;\n        if\
    \ balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for &operation in &operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |sum, &x| sum + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp31ujfnox.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(0, |acc, x| acc + x) < 0\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9arad24h.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for val in operations {\n\
    \        balance += val;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for elem in operations\
    \ {\n        balance += elem;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut running_total = 0;\n    for operation in\
    \ operations {\n        running_total += operation;\n        if running_total\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in operations {\n   \
    \     sum += i;\n        if sum < 0 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpet6v2nlq.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return True. Otherwise it should return False.\n/// >>> below_zero([1,\
    \ 2, 3])\n/// False\n/// >>> below_zero([1, 2, -4, 5])\n/// True\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // HINT: You can use accumulator (https://en.wikipedia.org/wiki/Accumulator_(computer_science))\n\
    \    // variable for this task:\n    // acc = 0\n    // for val in vec {\n   \
    \ //   acc += val\n    // }\n    let mut acc = 0;\n    for op in operations {\n\
    \        acc += op;\n        if acc < 0 {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
