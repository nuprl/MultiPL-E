name: HumanEval_12_longest
language: rust
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n/// 'a'\n\
  /// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
  \ -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ['    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())',
  '    unimplemented!()', '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ &strings[0];\n    for s in &strings {\n        if s.len() > longest.len() {\n\
    \            longest = s;\n        }\n    }\n    Some(longest.to_string())", '    unimplemented!()',
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    Some(longest_string.to_string())",
  "    let mut longest_so_far = None;\n    for s in strings {\n        longest_so_far\
    \ = Some(match longest_so_far {\n            None => s,\n            Some(ref\
    \ so_far) => if s.len() > so_far.len() { s } else { so_far.clone() },\n      \
    \  });\n    }\n    longest_so_far", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max_len = 0;\n    let mut max_str = &strings[0];\n\
    \    for i in 1..strings.len() {\n        if strings[i].len() > max_len {\n  \
    \          max_len = strings[i].len();\n            max_str = &strings[i];\n \
    \       }\n    }\n    Some(max_str.to_string())", '    strings.into_iter().max_by_key(|s|
    s.len()).cloned()', "    // Implement `longest` here\n    if strings.len() ==\
    \ 0 {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings.iter() {\n        if s.len() > longest.len() {\n       \
    \     longest = s.clone();\n        }\n    }\n    Some(longest)", "    let mut\
    \ longest = None;\n    for string in strings {\n        match longest {\n    \
    \        None => longest = Some(string),\n            Some(cur) => {\n       \
    \         if string.len() > cur.len() {\n                    longest = Some(string);\n\
    \                }\n            }\n        }\n    }\n    longest", '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!()', "    if strings.is_empty() {\n \
    \       return None;\n    }\n    let mut max_len = 0;\n    let mut max_index =\
    \ 0;\n    for (i, s) in strings.iter().enumerate() {\n        if s.len() > max_len\
    \ {\n            max_len = s.len();\n            max_index = i;\n        }\n \
    \   }\n    Some(strings[max_index].clone())", '    strings.into_iter().max_by_key(|string|
    string.len()).clone()', "    // TODO: implement longest(strings) here\n    let\
    \ mut output: Option<String> = None;\n    let mut max: usize = 0;\n    for i in\
    \ 0..strings.len() {\n        if max < strings[i].len() {\n            max = strings[i].len();\n\
    \            output = Some(strings[i].clone());\n        }\n    }\n    output",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut result =\
    \ None;\n    for string in strings {\n        if result.is_none() || string.len()\
    \ > result.unwrap().len() {\n            result = Some(string);\n        }\n \
    \   }\n    result", "    let mut longest = String::new();\n    for string in strings\
    \ {\n        if string.len() > longest.len() {\n            longest = string;\n\
    \        }\n    }\n    if longest.is_empty() {\n        None\n    } else {\n \
    \       Some(longest)\n    }", "    match strings.len() {\n        0 => None,\n\
    \        1 => Some(strings[0].clone()),\n        _ => {\n            let mut first\
    \ = strings[0].clone();\n            for string in strings {\n               \
    \ if string.len() > first.len() {\n                    first = string.clone();\n\
    \                }\n            }\n            Some(first)\n        }\n    }",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_length\
    \ = 0;\n    let mut longest_word = &strings[0];\n    for string in strings {\n\
    \        if string.len() > longest_length {\n            longest_length = string.len();\n\
    \            longest_word = &string;\n        }\n    }\n    Some(longest_word.to_string())",
  "    let mut longest = None;\n    for s in strings {\n        longest = match longest\
    \ {\n            None => Some(s),\n            Some(ref mut l) => {\n        \
    \        if s.len() > l.len() {\n                    *l = s;\n               \
    \ }\n                Some(l.clone())\n            }\n        }\n    }\n    longest",
  '    strings.into_iter().max_by_key(|s| s.len()).map(Clone::clone)', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = strings[0].len();\n  \
    \  let mut max_index = 0;\n    for (i, s) in strings.iter().enumerate() {\n  \
    \      if s.len() > max_len {\n            max_len = s.len();\n            max_index\
    \ = i;\n        }\n    }\n    Some(strings[max_index].clone())", "    let mut\
    \ len: Option<usize> = None;\n    let mut index: Option<usize> = None;\n    for\
    \ (i, string) in strings.iter().enumerate() {\n        if let Some(l) = len {\n\
    \            if string.len() > l {\n                len = Some(string.len());\n\
    \                index = Some(i);\n            }\n        } else {\n         \
    \   len = Some(string.len());\n            index = Some(i);\n        }\n    }\n\
    \    if let Some(i) = index {\n        Some(strings[i].clone())\n    } else {\n\
    \        None\n    }", '    unimplemented!();', '    unimplemented!()', "    //\
    \ Get max length\n    let max_len = strings.iter().map(|x| x.len()).max();\n \
    \   // Filter\n    let filtered = strings.into_iter().filter(|x| x.len() == max_len);\n\
    \    // Return\n    filtered.collect::<Vec<String>>().first().cloned()", "   \
    \ let mut longest_so_far = None;\n    for s in strings {\n        if longest_so_far.is_none()\
    \ || longest_so_far.as_ref().unwrap().len() < s.len() {\n            longest_so_far\
    \ = Some(s);\n        }\n    }\n    longest_so_far", "    let mut longest = strings.first().cloned();\n\
    \    for string in strings {\n        longest = match longest {\n            Some(s)\
    \ => Some(match s.len().cmp(&string.len()) {\n                Ordering::Greater\
    \ => s,\n                _ => string,\n            }),\n            None => Some(string),\n\
    \        }\n    }\n    longest", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut strings_iter = strings.iter();\n    let mut max_len\
    \ = 0;\n    let mut max_string = &strings_iter.next().unwrap();\n    for s in\
    \ strings_iter {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_string = s;\n        }\n    }\n    Some(max_string.to_string())",
  '    unimplemented!()', "    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = String::new();\n    for s in strings {\n   \
    \     if s.len() > longest_string.len() {\n            longest_string = s;\n \
    \       }\n    }\n    Some(longest_string)", "    let mut result = String::new();\n\
    \    for s in strings {\n        if s.len() > result.len() {\n            result\
    \ = s;\n        }\n    }\n    if result.len() == 0 {\n        None\n    } else\
    \ {\n        Some(result)\n    }", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest = &strings[0];\n    for s in &strings {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    Some(longest.to_string())", '    strings.into_iter().max_by_key(|s|
    s.len()).or(None)', "    // TODO(you)\n    // unimplemented!()\n    let mut result\
    \ = strings.clone();\n    if result.len() == 0 {\n        None\n    } else {\n\
    \        result.sort_by(|a, b| b.len().cmp(&a.len()));\n        Some(result[0].clone())\n\
    \    }", "    strings.into_iter().fold(None, |x, y| {\n        match x {\n   \
    \         None => Some(y),\n            Some(a) => if a.len() > y.len() { Some(a)\
    \ } else { Some(y) },\n        }\n    })", '    unimplemented!()', "    // TODO:\
    \ implement this function.\n    let mut longest_string = String::new();\n    for\
    \ string in strings {\n        if string.len() > longest_string.len() {\n    \
    \        longest_string = string;\n        }\n    }\n    if longest_string.len()\
    \ == 0 {\n        None\n    } else {\n        Some(longest_string)\n    }", " \
    \   let mut answer = None;\n    for s in strings {\n        match answer {\n \
    \           None => answer = Some(s),\n            Some(t) => if s.len() > t.len()\
    \ {\n                answer = Some(s);\n            }\n        }\n    }\n    answer",
  "    let mut max_len = 0;\n    let mut longest_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    longest_string = Some(s);\n        }\n    }\n    longest_string", '    unimplemented!();',
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_length\
    \ = 0;\n    let mut longest_string = String::new();\n    for string in strings\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            longest_string = string;\n        }\n    }\n    Some(longest_string)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \    Some(longest)", "    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() > 0 {\n        Some(longest)\n    } else {\n    \
    \    None\n    }", '    unimplemented!();', "    strings.into_iter().fold(None,\
    \ |best, s| {\n        match best {\n            None => Some(s),\n          \
    \  Some(r) => if r.len() < s.len() { Some(s) } else { Some(r) }\n        }\n \
    \   })", '    unimplemented!()', '    strings.into_iter().max_by_key(|s| s.len()).map(|s|
    s.to_string())', "    // TODO: fill the function definition here\n    None", '    unimplemented!();',
  "    // Write code here\n    None", "    let mut longest = None;\n    for string\
    \ in strings {\n        longest = match longest {\n            None => Some(string),\n\
    \            Some(s) => if s.len() > string.len() {\n                Some(s)\n\
    \            } else {\n                Some(string)\n            }\n        }\n\
    \    }\n    longest", "    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_str = String::new();\n    for s\
    \ in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = s;\n        }\n    }\n    Some(max_str)", '    None', " \
    \   let mut longest_str = None;\n    let mut longest_str_len = 0;\n    for s in\
    \ strings {\n        if s.len() > longest_str_len {\n            longest_str =\
    \ Some(s);\n            longest_str_len = s.len();\n        }\n    }\n    longest_str",
  "    strings.into_iter().fold(None, |acc, x| {\n        match acc {\n          \
    \  None => Some(x),\n            Some(y) => if x.len() > y.len() { Some(x) } else\
    \ { Some(y) },\n        }\n    })", "    let mut longest_word = String::new();\n\
    \    for string in strings {\n        if string.len() > longest_word.len() {\n\
    \            longest_word = string;\n        }\n    }\n    if longest_word.is_empty()\
    \ {\n        None\n    } else {\n        Some(longest_word)\n    }", "    let\
    \ mut longest = None;\n    for x in strings {\n        match longest {\n     \
    \       None => longest = Some(x),\n            Some(ref s) => if x.len() > s.len()\
    \ {\n                longest = Some(x);\n            }\n        }\n    }\n   \
    \ longest", "    // TODO\n    unimplemented!()", '    None', '    unimplemented!()',
  "    let mut strings_ = strings;\n    strings_.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    strings_.pop()", '    unimplemented!()', '    unimplemented!()', "    if\
    \ strings.is_empty() {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(longest)", "    let mut result = None;\n  \
    \  for string in strings {\n        match result {\n            None => result\
    \ = Some(string),\n            Some(longest) => if string.len() > longest.len()\
    \ {\n                result = Some(string);\n            },\n        }\n    }\n\
    \    result", "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest_string = strings[0].clone();\n    for s in strings {\n        if\
    \ s.len() > longest_string.len() {\n            longest_string = s;\n        }\n\
    \    }\n    Some(longest_string)", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest_string = &strings[0];\n    for current_string\
    \ in &strings {\n        if current_string.len() > longest_string.len() {\n  \
    \          longest_string = current_string;\n        }\n    }\n    Some(longest_string.to_string())",
  '    strings.into_iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_string = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > max_string.len() {\n       \
    \     max_string = string;\n        }\n    }\n    Some(max_string.to_string())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_word\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest_word.len() {\n            longest_word = string.clone();\n       \
    \ }\n    }\n    Some(longest_word)", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut l = &strings[0];\n    for s in &strings {\n      \
    \  if s.len() > l.len() {\n            l = s;\n        }\n    }\n    Some(l.to_string())",
  '    unimplemented!();', "    let mut longest_string = None;\n    let mut longest_string_length\
    \ = 0;\n    for string in strings {\n        if string.len() > longest_string_length\
    \ {\n            longest_string = Some(string);\n            longest_string_length\
    \ = string.len();\n        }\n    }\n    longest_string", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings.iter() {\n        if s.len() > longest.len() {\n       \
    \     longest = s.clone();\n        }\n    }\n    Some(longest)", "    // Find\
    \ the longest string in strings, return None in case of empty list.\n    // TODO:\
    \ replace this with your code\n    None", '    unimplemented!()', '    strings.into_iter().max_by_key(|s|
    s.len()).map(|s| s.to_string())', "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest_string = strings[0].clone();\n    for s in\
    \ strings {\n        if s.len() > longest_string.len() {\n            longest_string\
    \ = s;\n        }\n    }\n    Some(longest_string)", "    match strings.len()\
    \ {\n        0 => None,\n        _ => {\n            let mut result = strings[0].clone();\n\
    \            for s in strings {\n                if s.len() > result.len() {\n\
    \                    result = s;\n                }\n            }\n         \
    \   Some(result)\n        }\n    }", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    // TODO #1\n    None", "    match strings.is_empty() {\n        true => None,\n\
    \        false => {\n            let mut result = String::new();\n           \
    \ for x in strings {\n                if x.len() > result.len() {\n          \
    \          result = x;\n                }\n            }\n            Some(result)\n\
    \        }\n    }", "    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.to_string())", "    let mut longest = \"\".to_string();\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    if longest.len() == 0 {\n        None\n    } else\
    \ {\n        Some(longest)\n    }", '    None', "    // TODO: implement this function\n\
    \    None", "    let mut longest_string = String::new();\n    let mut longest_length\
    \ = 0;\n    for s in strings {\n        if s.len() > longest_length {\n      \
    \      longest_string = s;\n            longest_length = s.len();\n        }\n\
    \    }\n    if longest_length == 0 {\n        None\n    } else {\n        Some(longest_string)\n\
    \    }", '    None', "    let mut longest_string = None;\n    for s in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(s),\n\
    \            Some(v) => {\n                if v.len() < s.len() {\n          \
    \          longest_string = Some(s);\n                }\n            }\n     \
    \   }\n    }\n    longest_string", "    let mut result = String::new();\n    for\
    \ s in strings {\n        if s.len() > result.len() {\n            result = s;\n\
    \        }\n    }\n    if result.len() == 0 {\n        None\n    } else {\n  \
    \      Some(result)\n    }", "    // TODO: Implement me.\n    return None;", " \
    \   let mut result = None;\n    let mut size: usize = 0;\n    for s in strings\
    \ {\n        if s.len() > size {\n            result = Some(s);\n            size\
    \ = s.len();\n        }\n    }\n    result", "    match strings.len() {\n    \
    \    0 => None,\n        _ => {\n            let mut long = strings[0].clone();\n\
    \            for s in strings {\n                if s.len() > long.len() {\n \
    \                   long = s;\n                }\n            }\n            Some(long)\n\
    \        }\n    }", "    let mut longest_len = 0;\n    let mut result = None;\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            result = Some(s);\n        }\n    }\n    result", " \
    \   // here, strings has type Vec<String>, i.e. vector of strings.\n    if strings.is_empty()\
    \ {\n        None\n    } else {\n        // If a vector is not empty, calling\
    \ get(0) will return the first item in the vector.\n        let mut tmp = strings.get(0).unwrap();\n\
    \        // strings.iter() returns an iterator over the vector.\n        for string\
    \ in strings.iter() {\n            if string.len() > tmp.len() {\n           \
    \     tmp = string;\n            }\n        }\n        Some(tmp.to_string())\n\
    \    }", "    strings.into_iter().fold(None, |acc, x| {\n        match acc {\n\
    \            None => Some(x),\n            Some(longest) => if x.len() > longest.len()\
    \ {\n                Some(x)\n            } else {\n                Some(longest)\n\
    \            }\n        }\n    })", "    let mut longest_string = None;\n    for\
    \ string in strings {\n        if longest_string.as_ref().map_or(true, |v| v.len()\
    \ < string.len()) {\n            longest_string = Some(string);\n        }\n \
    \   }\n    longest_string", "    // FIXME: Implement\n    None", "    let mut\
    \ longest = None;\n    for s in strings {\n        match longest {\n         \
    \   None => longest = Some(s),\n            Some(s_longest) => {\n           \
    \     if s.len() > s_longest.len() {\n                    longest = Some(s);\n\
    \                }\n            }\n        }\n    }\n    longest", "    let mut\
    \ result = None;\n    for string in strings {\n        match result {\n      \
    \      None => result = Some(string),\n            Some(ref r) => if string.len()\
    \ > r.len() {\n                result = Some(string);\n            }\n       \
    \ }\n    }\n    result", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut result = &strings[0];\n    for string in &strings {\n    \
    \    if string.len() > result.len() {\n            result = string;\n        }\n\
    \    }\n    Some(result.to_string())", '    unimplemented!();', "    let mut long\
    \ = None;\n    for s in strings {\n        match long {\n            None => long\
    \ = Some(s),\n            Some(ref l) => if s.len() > l.len() { long = Some(s)\
    \ },\n        }\n    }\n    long", "    let mut longest_string = None;\n    for\
    \ string in strings {\n        match longest_string {\n            None => longest_string\
    \ = Some(string),\n            Some(ref string_ref) => {\n                if string.len()\
    \ > string_ref.len() {\n                    longest_string = Some(string);\n \
    \               }\n            }\n        }\n    }\n    longest_string", '    None',
  "    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut strings = strings;\n            strings.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \            let s = strings.pop().unwrap();\n            Some(s)\n        }\n\
    \    }", "    let mut longest = None;\n    for s in strings {\n        match longest\
    \ {\n            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  '    strings.into_iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest_string = &strings[0];\n\
    \    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    Some(longest_string.to_string())",
  "    // todo!()\n    match strings.len() {\n        0 => None,\n        _ => {\n\
    \            let mut long = strings[0].clone();\n            for i in strings\
    \ {\n                if i.len() > long.len() {\n                    long = i.clone();\n\
    \                }\n            }\n            Some(long)\n        }\n    }",
  '    unimplemented!();', "    if strings.is_empty() {\n        return None;\n  \
    \  }\n    let mut max = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > max.len() {\n            max = s;\n        }\n    }\n    Some(max.to_string())",
  "    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref mut l) => {\n  \
    \              if s.len() > l.len() {\n                    *l = s;\n         \
    \       }\n            }\n        }\n    }\n    longest", '    strings.into_iter().max_by_key(|x|
    x.len()).cloned()', "    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut length = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > length {\n            length = s.len();\n          \
    \  index = i;\n        }\n    }\n    Some(strings[index].clone())", "    let mut\
    \ longest = None;\n    for string in strings {\n        longest = match longest\
    \ {\n            None => Some(string),\n            Some(current) => if string.len()\
    \ > current.len() {\n                Some(string)\n            } else {\n    \
    \            Some(current)\n            }\n        }\n    }\n    longest", " \
    \   if strings.is_empty() {\n        return None;\n    }\n    strings.iter().fold(None,\
    \ |acc, x| {\n        match acc {\n            None => Some(x.clone()),\n    \
    \        Some(y) => Some(if x.len() > y.len() { x.clone() } else { y })\n    \
    \    }\n    })", "    let mut longest_string: Option<String> = None;\n    for\
    \ s in strings {\n        if longest_string.is_none() || s.len() > longest_string.unwrap().len()\
    \ {\n            longest_string = Some(s);\n        }\n    }\n    longest_string",
  '    unimplemented!()', "    let mut length = 0;\n    let mut longest = None;\n\
    \    for s in strings {\n        if s.len() > length {\n            length = s.len();\n\
    \            longest = Some(s);\n        }\n    }\n    longest", "    strings.into_iter().fold(None,\
    \ |prev, next| match prev {\n        None => Some(next),\n        Some(s) => Some(if\
    \ s.len() > next.len() { s } else { next }),\n    })", "    match strings.len()\
    \ {\n        0 => None,\n        _ => {\n            let mut max = &strings[0];\n\
    \            for i in 1..strings.len() {\n                if strings[i].len()\
    \ > max.len() {\n                    max = &strings[i];\n                }\n \
    \           }\n            Some(max.to_string())\n        }\n    }", '    strings.into_iter().max_by_key(|s|
    s.len()).or(None)', "    if strings.is_empty() {\n        return None;\n    }\n\
    \    strings.iter().fold(None, |acc, cur| {\n        match acc {\n           \
    \ None => Some(cur.clone()),\n            Some(acc) => {\n                if acc.len()\
    \ < cur.len() {\n                    Some(cur.clone())\n                } else\
    \ {\n                    Some(acc)\n                }\n            }\n       \
    \ }\n    })", "    match strings.len() {\n        0 => None,\n        _ => {\n\
    \            let mut iter = strings.iter();\n            let mut longest_string\
    \ = iter.next().unwrap();\n            for string in iter {\n                if\
    \ string.len() > longest_string.len() {\n                    longest_string =\
    \ string;\n                }\n            }\n            Some(longest_string.to_string())\n\
    \        }\n    }", '    strings.into_iter().max_by_key(|s| s.len()).clone()',
  "    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }", "    let mut longest_str = None;\n\
    \    let mut longest_len = 0;\n    for s in strings {\n        if s.len() > longest_len\
    \ {\n            longest_str = Some(s);\n            longest_len = s.len();\n\
    \        }\n    }\n    longest_str", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max = &strings[0];\n    for s in &strings {\n    \
    \    if s.len() > max.len() {\n            max = s;\n        }\n    }\n    Some(max.to_string())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut result =\
    \ strings[0].clone();\n    for string in strings {\n        if string.len() >\
    \ result.len() {\n            result = string;\n        }\n    }\n    Some(result)",
  "    let mut max_len = 0;\n    let mut max_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = Some(s);\n        }\n    }\n    max_string", "    let mut res\
    \ = None;\n    for s in strings {\n        match res {\n            None => res\
    \ = Some(s),\n            Some(ref str) => {\n                if s.len() > str.len()\
    \ {\n                    res = Some(s);\n                }\n            }\n  \
    \      }\n    }\n    res", '    unimplemented!();', '    unimplemented!()', " \
    \   let mut biggest_size = 0;\n    let mut longest_string = String::new();\n \
    \   for s in strings {\n        if s.len() > biggest_size {\n            biggest_size\
    \ = s.len();\n            longest_string = s;\n        }\n    }\n    if biggest_size\
    \ == 0 {\n        None\n    } else {\n        Some(longest_string)\n    }", " \
    \   // You need to implement this\n    let mut longest = None;\n    for string\
    \ in strings {\n        if longest.is_none() || string.len() > longest.as_ref().unwrap().len()\
    \ {\n            longest = Some(string);\n        }\n    }\n    longest", "  \
    \  let mut max_length = 0;\n    let mut longest = None;\n    for string in strings\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            longest = Some(string);\n        }\n    }\n    longest", "    let\
    \ mut longest = None;\n    for string in strings {\n        longest = match longest\
    \ {\n            None => Some(string),\n            Some(l) => {\n           \
    \     if l.len() > string.len() {\n                    Some(l)\n             \
    \   } else {\n                    Some(string)\n                }\n          \
    \  }\n        }\n    }\n    longest", "    // TODO: Replace the implementation\
    \ with a correct one.\n    unimplemented!()", "    let mut longest_str = None;\n\
    \    let mut max_len = 0;\n    for s in strings {\n        if s.len() > max_len\
    \ {\n            max_len = s.len();\n            longest_str = Some(s);\n    \
    \    }\n    }\n    longest_str", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max_len = 0;\n    let mut max_str = \"\".to_string();\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_str = s;\n        }\n    }\n    Some(max_str)", '    strings.into_iter().max().map(|x|
    x.to_string())', "    let mut longest = None;\n    for s in strings {\n      \
    \  match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ ls) => {\n                if s.len() > ls.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest",
  "    strings.into_iter().fold(None, |longest, s| {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            Some(s)\n      \
    \  } else {\n            longest\n        }\n    })", "    let mut longest_string:\
    \ Option<String> = None;\n    for s in strings {\n        if longest_string.is_none()\
    \ || longest_string.as_ref().unwrap().len() < s.len() {\n            longest_string\
    \ = Some(s);\n        }\n    }\n    longest_string", "    let mut longest_string\
    \ = None;\n    let mut max_len = 0;\n    for string in strings {\n        if string.len()\
    \ > max_len {\n            max_len = string.len();\n            longest_string\
    \ = Some(string);\n        }\n    }\n    longest_string", "    // TODO\n    unimplemented!()",
  "    let mut max_length = 0;\n    let mut max_string = String::new();\n    for string\
    \ in strings {\n        if string.len() > max_length {\n            max_length\
    \ = string.len();\n            max_string = string;\n        }\n    }\n    if\
    \ max_length == 0 {\n        None\n    } else {\n        Some(max_string)\n  \
    \  }", '    unimplemented!()', "    strings.into_iter().fold(None, |acc, x| {\n\
    \        match acc {\n            None => Some(x),\n            Some(y) => if\
    \ x.len() >= y.len() { Some(x) } else { Some(y) },\n        }\n    })", "    let\
    \ mut max_length = 0;\n    let mut output = String::new();\n    for s in strings\
    \ {\n        if s.len() > max_length {\n            max_length = s.len();\n  \
    \          output = s;\n        }\n    }\n    match output.len() {\n        0\
    \ => None,\n        _ => Some(output),\n    }", '    strings.into_iter().max().cloned()',
  "    // TODO\n    if strings.len() == 0 {\n        return None;\n    }\n    let\
    \ mut longest = strings[0].clone();\n    for i in 1..strings.len() {\n       \
    \ if strings[i].len() > longest.len() {\n            longest = strings[i].clone();\n\
    \        }\n    }\n    Some(longest)", '    unimplemented!()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for (i, _) in strings.iter().enumerate() {\n        if longest.len() < strings[i].len()\
    \ {\n            longest = strings[i].clone();\n        }\n    }\n    Some(longest)",
  '    unimplemented!()', '    unimplemented!();', '    unimplemented!();', "    //\
    \ Imperative solution\n    //\n    // let mut max = None;\n    // for i in strings\
    \ {\n        // if max.is_none() || i.len() > max.unwrap().len() {\n         \
    \   // max = Some(i);\n        // }\n    // }\n    // max\n\n    // Functional\
    \ solution\n    strings.into_iter().fold(None, |max, i| {\n        match max {\n\
    \            None => Some(i),\n            Some(m) => Some(if i.len() > m.len()\
    \ { i } else { m })\n        }\n    })", "    // TODO: Shorten the code\n    if\
    \ strings.len() == 0 {\n        return None;\n    }\n    let mut max = strings[0].clone();\n\
    \    for i in strings {\n        if i.len() > max.len() {\n            max = i;\n\
    \        }\n    }\n    Some(max)", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max_len = 0;\n    let mut max_str = &strings[0];\n\
    \    for s in &strings {\n        if s.len() > max_len {\n            max_len\
    \ = s.len();\n            max_str = s;\n        }\n    }\n    Some(max_str.to_string())",
  "    // YOUR CODE HERE\n    let mut longest = String::new();\n    for string in\
    \ strings {\n        if string.len() > longest.len() {\n            longest =\
    \ string;\n        }\n    }\n    if longest.len() == 0 {\n        None\n    }\
    \ else {\n        Some(longest)\n    }", '    unimplemented!()', '    unimplemented!()',
  "    let mut max_len = 0;\n    let mut max_str = String::new();\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_str = s;\n        }\n    }\n    if max_len > 0 {\n        Some(max_str)\n\
    \    } else {\n        None\n    }", "    let mut max_length = 0;\n    let mut\
    \ max_string = None;\n    for s in strings {\n        if s.len() > max_length\
    \ {\n            max_length = s.len();\n            max_string = Some(s);\n  \
    \      }\n    }\n    max_string", "    let mut max = String::new();\n    for string\
    \ in strings {\n        if string.len() > max.len() {\n            max = string;\n\
    \        }\n    }\n    if !max.is_empty() {\n        Some(max)\n    } else {\n\
    \        None\n    }", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let first = strings[0].clone();\n            let\
    \ mut iter = strings.iter();\n            iter.next();\n            match iter.max_by_key(|s|\
    \ s.len()) {\n                Some(s) => if s.len() > first.len() { Some(s.clone())\
    \ } else { Some(first) },\n                None => Some(first),\n            }\n\
    \        }\n    }", "    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut tmp = &strings[0];\n    for string in &strings {\n        if string.len()\
    \ > tmp.len() {\n            tmp = string;\n        }\n    }\n    Some(tmp.to_string())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for string in strings {\n        if string.len() >\
    \ longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)",
  '    strings.into_iter().max().cloned()', "    let mut longest = String::new();\n\
    \    for string in strings {\n        if string.len() > longest.len() {\n    \
    \        longest = string;\n        }\n    }\n    if longest.is_empty() {\n  \
    \      None\n    } else {\n        Some(longest)\n    }", '    unimplemented!()',
  "    // TODO\n    match strings.len() {\n        0 => None,\n        _ => {\n  \
    \          let mut x = strings[0].clone();\n            for j in strings {\n \
    \               if j.len() > x.len() {\n                    x = j.clone();\n \
    \               }\n            }\n            Some(x)\n        }\n    }", '    unimplemented!();',
  '    strings.into_iter().max_by_key(|string| string.len()).into()', '    unimplemented!()',
  '    strings.into_iter().max_by_key(|s| s.len()).cloned()', '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!();', "    let mut result = None;\n \
    \   for s in strings {\n        match result {\n            None => result = Some(s),\n\
    \            Some(longest) => {\n                if s.len() > longest.len() {\n\
    \                    result = Some(s);\n                }\n            }\n   \
    \     }\n    }\n    result", '    unimplemented!();', "    // TODO find the longest\
    \ string. If there are multiple strings with the same\n    // length, return the\
    \ first one. If the vector is empty, return None.\n    None", "    let mut longest_so_far\
    \ = String::new();\n    for string in strings {\n        if string.len() > longest_so_far.len()\
    \ {\n            longest_so_far = string;\n        }\n    }\n    match longest_so_far.len()\
    \ {\n        0 => None,\n        _ => Some(longest_so_far),\n    }", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(longest)", "    let mut longest_string: Option<String>\
    \ = None;\n    for s in strings {\n        if longest_string.is_none() || longest_string.as_ref().unwrap().len()\
    \ < s.len() {\n            longest_string = Some(s);\n        }\n    }\n    longest_string",
  "    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n  \
    \          None => Some(s),\n            Some(l) => {\n                if s.len()\
    \ > l.len() {\n                    Some(s)\n                } else {\n       \
    \             Some(l)\n                }\n            }\n        }\n    })", " \
    \   let mut longest = \"\".to_string();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    if longest\
    \ == \"\" {\n        None\n    } else {\n        Some(longest)\n    }", "    let\
    \ mut longest_string: Option<String> = None;\n    for string in strings {\n  \
    \      if longest_string.is_none() || string.len() > longest_string.unwrap().len()\
    \ {\n            longest_string = Some(string);\n        }\n    }\n    longest_string",
  "    let mut result = None;\n    for s in strings {\n        match result {\n  \
    \          None => result = Some(s),\n            Some(ref r) => if s.len() >\
    \ r.len() {\n                result = Some(s);\n            }\n        }\n   \
    \ }\n    result", '    unimplemented!()', '    unimplemented!();', '    unimplemented!();',
  '    unimplemented!()']
stop_tokens:
- "\n}"
