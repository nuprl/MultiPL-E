name: HumanEval_120_maximum
language: rust
prompt: "/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example 2:\n///\
  \ Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n/// Input:\
  \ arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n/// 1. The\
  \ length of the array will be in the range of [1, 1000].\n/// 2. The elements in\
  \ the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\n\
  fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
  \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
  \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n \
  \   assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
  \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
  \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0,\
  \ 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n\
  \    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
  \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
  \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
  }\n"
completions: ['    arr.iter().take(k as usize).cloned().collect()', "    // T = O(nlogn),\
    \ S = O(n)\n    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).map(|&x| x).collect()", "    let mut heap = BinaryHeap::new();\n \
    \   let mut result = Vec::new();\n    for num in arr {\n        heap.push(num);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    while let Some(n) = heap.pop() {\n        result.push(n);\n    }\n \
    \   result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n \
    \   let mut result = Vec::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    for i in 0..k {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut pq = BinaryHeap::new();\n\
    \    for &x in arr.iter() {\n        pq.push(x);\n        if pq.len() > k as usize\
    \ {\n            pq.pop();\n        }\n    }\n    pq.into_sorted_vec()", "   \
    \ use std::collections::HashMap;\n    use std::collections::VecDeque;\n    let\
    \ mut freq: HashMap<isize, usize> = HashMap::new();\n    let mut heap: VecDeque<isize>\
    \ = VecDeque::new();\n    for &n in arr.iter() {\n        *freq.entry(n).or_insert(0)\
    \ += 1;\n        heap.push_back(n);\n    }\n    heap.sort_by(|a, b| {\n      \
    \  let cmp = freq[b].cmp(&freq[a]);\n        if cmp == std::cmp::Ordering::Equal\
    \ {\n            a.cmp(b)\n        } else {\n            cmp\n        }\n    });\n\
    \    let mut result = Vec::new();\n    while k > 0 {\n        let n = heap.pop_front().unwrap();\n\
    \        result.push(n);\n        k -= 1;\n    }\n    result", "    let mut res\
    \ = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for x in arr {\n \
    \       heap.push(x);\n        if heap.len() > k as usize {\n            heap.pop();\n\
    \        }\n    }\n    for _ in 0..k {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    // 1. Quick select with randomized\
    \ partition\n    let mut arr = arr;\n    let n = arr.len();\n    let k = k as\
    \ usize;\n    let mut quick_select = |l: usize, r: usize| {\n        let pivot\
    \ = arr[rand::thread_rng().gen_range(l, r)];\n        let mut i = l;\n       \
    \ let mut j = r;\n        while i <= j {\n            while arr[i] > pivot {\n\
    \                i += 1;\n            }\n            while arr[j] < pivot {\n\
    \                j -= 1;\n            }\n            if i <= j {\n           \
    \     arr.swap(i, j);\n                i += 1;\n                j -= 1;\n    \
    \        }\n        }\n        i\n    };\n    let mut l = 0;\n    let mut r =\
    \ n;\n    while l < r {\n        let m = quick_select(l, r);\n        if m < k\
    \ {\n            l = m + 1;\n        } else if m > k {\n            r = m;\n \
    \       } else {\n            break;\n        }\n    }\n    arr[..k].to_vec()",
  "    let mut res = vec![];\n    let mut min_heap = BinaryHeap::new();\n    let mut\
    \ index = 0;\n    while index < arr.len() {\n        let val = arr[index];\n \
    \       if min_heap.len() < k as usize {\n            min_heap.push(Min(val));\n\
    \        } else if let Some(Min(val2)) = min_heap.peek() {\n            if val\
    \ > *val2 {\n                min_heap.pop();\n                min_heap.push(Min(val));\n\
    \            }\n        }\n        index += 1;\n    }\n    while let Some(Min(val))\
    \ = min_heap.pop() {\n        res.push(val);\n    }\n    res.reverse();\n    res",
  "    let len = arr.len();\n    let k = k as usize;\n    let mut arr = arr;\n   \
    \ // The following is a classic quick select,\n    // which is similar to quick\
    \ sort.\n    let mut l = 0;\n    let mut r = len - 1;\n    while l < r {\n   \
    \     let p = partition(&mut arr, l, r);\n        if p == k {\n            break;\n\
    \        } else if p < k {\n            l = p + 1;\n        } else {\n       \
    \     r = p - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr =\
    \ arr;\n    arr.sort();\n    arr.reverse();\n    let mut res = Vec::new();\n \
    \   for i in 0..k {\n        res.push(arr[i as usize]);\n    }\n    res", "  \
    \  let mut max = arr.clone();\n    max.sort();\n    max.iter().rev().take(k as\
    \ usize).cloned().collect()", "    arr.iter().fold(BinaryHeap::new(), |mut heap,\
    \ &x| {\n        if heap.len() < k as usize {\n            heap.push(x);\n   \
    \     } else if heap.peek().unwrap() < &x {\n            heap.pop();\n       \
    \     heap.push(x);\n        }\n        heap\n    }).into_sorted_vec()", "   \
    \ let mut curr_queue = BinaryHeap::new();\n    for i in 0..k {\n        curr_queue.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if curr_queue.peek().unwrap()\
    \ < &arr[i as usize] {\n            curr_queue.pop();\n            curr_queue.push(arr[i\
    \ as usize]);\n        }\n    }\n    let mut out: Vec<isize> = vec![];\n    for\
    \ _ in 0..k {\n        out.push(curr_queue.pop().unwrap());\n    }\n    out.reverse();\n\
    \    out", "    let n = arr.len();\n    let mut max_heap = BinaryHeap::with_capacity(n);\n\
    \    for &num in arr.iter() {\n        max_heap.push(num);\n        if max_heap.len()\
    \ > k as usize {\n            max_heap.pop();\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let n = arr.len();\n    let mut heap = Vec::with_capacity(n);\n    for i in\
    \ 0..n {\n        if heap.len() == k as usize {\n            let min = heap[0];\n\
    \            if arr[i] <= min {\n                continue;\n            }\n  \
    \          heap[0] = arr[i];\n            let mut i = 0;\n            loop {\n\
    \                let left = (i + 1) * 2 - 1;\n                let right = (i +\
    \ 1) * 2;\n                if left >= heap.len() {\n                    break;\n\
    \                }\n                let mut j = if right < heap.len() && heap[right]\
    \ < heap[left] {\n                    right\n                } else {\n      \
    \              left\n                };\n                if heap[j] < heap[i]\
    \ {\n                    heap.swap(i, j);\n                    i = j;\n      \
    \          } else {\n                    break;\n                }\n         \
    \   }\n        } else {\n            heap.push(arr[i]);\n            let mut i\
    \ = heap.len() - 1;\n            while i > 0 {\n                let j = (i + 1)\
    \ / 2 - 1;\n                if heap[j] > heap[i] {\n                    heap.swap(i,\
    \ j);\n                    i = j;\n                } else {\n                \
    \    break;\n                }\n            }\n        }\n    }\n    heap", " \
    \   let mut a = arr;\n    a.sort();\n    a.iter().rev().take(k as usize).cloned().collect()",
  "    assert!(arr.len() >= k as usize);\n    let mut s = vec![];\n    for i in arr\
    \ {\n        s.push(i);\n        let idx = (s.len() - 1) as isize;\n        if\
    \ s.len() > k as usize {\n            s.remove(idx);\n        }\n        if s.len()\
    \ == k as usize {\n            s.sort();\n        }\n    }\n    s", "    let mut\
    \ max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    let mut res = vec![];\n\
    \    while !max_heap.is_empty() {\n        res.push(max_heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut a = arr;\n    let n = a.len();\n\
    \    let mut i = (n / 2) - 1;\n    while i >= 0 {\n        heapify(&mut a, i as\
    \ usize, n);\n        i -= 1;\n    }\n    let mut res = Vec::new();\n    for _\
    \ in 0..k {\n        res.push(a[0]);\n        a[0] = a[n - 1];\n        a.pop();\n\
    \        heapify(&mut a, 0, n - 1);\n    }\n    res", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    let n = arr.len();\n    for i in 0..k\
    \ {\n        let mut mi = i;\n        for j in i+1..n {\n            if arr[j]\
    \ > arr[mi] {\n                mi = j;\n            }\n        }\n        result.push(arr[mi]);\n\
    \        arr.swap(i as usize, mi);\n    }\n    result", "    let mut res = Vec::new();\n\
    \    for &e in arr.iter() {\n        if res.len() < k as usize {\n           \
    \ res.push(e);\n        } else {\n            let mut i = res.len() - 1;\n   \
    \         while i > 0 && res[i - 1] < e {\n                i -= 1;\n         \
    \   }\n            if i < res.len() {\n                res.remove(i);\n      \
    \          res.push(e);\n            }\n        }\n    }\n    res", "    let mut\
    \ arr = arr;\n    let mut result = Vec::new();\n    for _ in 0..k {\n        let\
    \ idx = arr.iter().enumerate().max_by_key(|&(_, &val)| val).unwrap().0;\n    \
    \    result.push(arr[idx]);\n        arr.remove(idx);\n    }\n    result", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    // Approach 1: Heap\n    // Using Min-Heap of size k to store the k largest\
    \ elements\n    // Time complexity: O(NlogK)\n    // Space complexity: O(k)\n\
    \    let mut heap = std::collections::BinaryHeap::with_capacity(k as usize);\n\
    \    for n in arr {\n        if heap.len() < k as usize {\n            heap.push(n);\n\
    \        } else if n > *heap.peek().unwrap() {\n            heap.pop();\n    \
    \        heap.push(n);\n        }\n    }\n    let mut res = vec![];\n    while\
    \ !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n\
    \    res", "    let mut max_nums = vec![0; k as usize];\n    let mut idx = 0;\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        if idx == 0 {\n      \
    \      max_nums[idx as usize] = arr[i];\n            idx += 1;\n        } else\
    \ {\n            let mut j = idx as usize - 1;\n            while j >= 0 && arr[i]\
    \ > max_nums[j] {\n                if j == idx as usize - 1 {\n              \
    \      max_nums[j + 1] = max_nums[j];\n                } else {\n            \
    \        max_nums[j + 1] = max_nums[j];\n                }\n                j\
    \ -= 1;\n            }\n            max_nums[j + 1] = arr[i];\n            if\
    \ idx < k {\n                idx += 1;\n            }\n        }\n        i +=\
    \ 1;\n    }\n    max_nums", "    let n = arr.len();\n    let mut pq = BinaryHeap::with_capacity(n);\n\
    \    for &x in &arr {\n        pq.push(x);\n        if pq.len() > k as usize {\n\
    \            pq.pop();\n        }\n    }\n    pq.into_sorted_vec()", "    // Use\
    \ a max heap with fixed size.\n    let mut heap = BinaryHeap::new();\n    let\
    \ heap_size = k as usize;\n    for (i, val) in arr.iter().enumerate() {\n    \
    \    if i < heap_size {\n            heap.push(*val);\n        } else {\n    \
    \        let min = heap.peek().unwrap();\n            if *min < *val {\n     \
    \           heap.pop();\n                heap.push(*val);\n            }\n   \
    \     }\n    }\n    let mut result = vec![];\n    while let Some(val) = heap.pop()\
    \ {\n        result.push(val);\n    }\n    result.reverse();\n    result", " \
    \   let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut heap = BinaryHeap::new();\n    for &n in arr.iter() {\n        heap.push(n);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let mut result = vec![];\n    let mut\
    \ v = arr;\n    v.sort();\n    v.iter().take(k as usize).for_each(|n| result.push(*n));\n\
    \    result", "    let n = arr.len();\n    let k = if k < n as isize { k } else\
    \ { n as isize };\n    let mut result = Vec::with_capacity(k as usize);\n    for\
    \ i in 0..k {\n        let mut tmp = i;\n        for j in i+1..n as isize {\n\
    \            if arr[j as usize] > arr[tmp as usize] {\n                tmp = j;\n\
    \            }\n        }\n        result.push(arr[tmp as usize]);\n        arr.swap(tmp\
    \ as usize, i as usize);\n    }\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for &n in arr.iter() {\n        heap.push(n);\n        if heap.len() > k\
    \ as usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut heap = BinaryHeap::<isize>::new();\n    for i in arr {\n        heap.push(i);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let mut set = arr.iter().collect::<BinaryHeap<_>>();\n\
    \    set.into_sorted_vec().into_iter().rev().take(k as usize).collect()", "  \
    \  if k == 0 {\n        return vec![];\n    }\n    let mut vec = vec![];\n   \
    \ for i in arr {\n        if vec.len() < k as usize {\n            let mut j =\
    \ 0;\n            for k in &vec {\n                if *k < i {\n             \
    \       break;\n                }\n                j += 1;\n            }\n  \
    \          vec.insert(j, i);\n        } else {\n            let mut j = 0;\n \
    \           for k in &vec {\n                if *k < i {\n                   \
    \ break;\n                }\n                j += 1;\n            }\n        \
    \    if j < vec.len() {\n                vec.remove(vec.len() - 1);\n        \
    \        vec.insert(j, i);\n            }\n        }\n    }\n    vec", "    let\
    \ mut heap = BinaryHeap::with_capacity(k as usize);\n    let mut vec = vec![];\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut vec: Vec<isize> = heap.iter().cloned().collect();\n    vec.sort();\n\
    \    vec.reverse();\n    vec", "    let mut min_heap = BinaryHeap::new();\n  \
    \  for v in arr {\n        if min_heap.len() < k as usize {\n            min_heap.push(v);\n\
    \        } else if v > *min_heap.peek().unwrap() {\n            min_heap.pop();\n\
    \            min_heap.push(v);\n        }\n    }\n    let mut rv = Vec::new();\n\
    \    while !min_heap.is_empty() {\n        rv.push(min_heap.pop().unwrap());\n\
    \    }\n    rv.reverse();\n    rv", "    let n = arr.len();\n    if n == k as\
    \ usize {\n        return arr;\n    }\n    let mut max = arr.clone();\n    if\
    \ k > n as isize {\n        let mut heap = BinaryHeap::new();\n        for x in\
    \ max.iter() {\n            heap.push(x.clone());\n        }\n        for _ in\
    \ 0..(k - n as isize) {\n            heap.pop();\n        }\n        max = heap.into_sorted_vec();\n\
    \    } else {\n        for i in (k as usize)..n {\n            let mut head =\
    \ 0;\n            for j in (1..k as usize).rev() {\n                if max[j]\
    \ < max[j - 1] {\n                    max.swap(j, j - 1);\n                  \
    \  head = j;\n                }\n            }\n            if head == 0 && max[0]\
    \ < arr[i] {\n                max[0] = arr[i];\n            }\n        }\n   \
    \ }\n    max", "    if k == 0 {\n        return vec![];\n    }\n    let mut max\
    \ = Vec::with_capacity(k as usize);\n    for i in 0..arr.len() {\n        if max.len()\
    \ < k as usize {\n            max.push(arr[i]);\n            continue;\n     \
    \   }\n        let mut index = 0;\n        for j in 0..max.len() {\n         \
    \   if max[j] > max[index] {\n                index = j;\n            }\n    \
    \    }\n        if arr[i] > max[index] {\n            max[index] = arr[i];\n \
    \       }\n    }\n    max.sort();\n    max", "    let mut result = Vec::new();\n\
    \    for num in arr {\n        if result.len() < k as usize {\n            result.push(num);\n\
    \            let idx = result.len() - 1;\n            let mut i = idx;\n     \
    \       while i > 0 && result[i] > result[i - 1] {\n                result.swap(i,\
    \ i - 1);\n                i -= 1;\n            }\n        } else if result[0]\
    \ < num {\n            result[0] = num;\n            let mut i = 1;\n        \
    \    while i < result.len() && result[i] > result[i - 1] {\n                result.swap(i,\
    \ i - 1);\n                i += 1;\n            }\n        }\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut heap = std::collections::BinaryHeap::new();\n    for &num in arr.iter()\
    \ {\n        heap.push(std::cmp::Reverse(num));\n        if heap.len() > k as\
    \ usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec().into_iter().map(|v|\
    \ v.0).collect()", "    if k == 0 {\n        return vec![];\n    }\n    let mut\
    \ result = Vec::with_capacity(k as usize);\n    for &n in arr.iter() {\n     \
    \   while result.len() > 0 && result[result.len() - 1] < n && result.len() as\
    \ isize > k - 1 {\n            result.pop();\n        }\n        if result.len()\
    \ < k as usize {\n            result.push(n);\n        }\n    }\n    result",
  "    let len = arr.len();\n    assert!(k as usize <= len);\n    let mut heap = BinaryHeap::new();\n\
    \    for &num in arr.iter() {\n        heap.push(num);\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()",
  "    let k = k as usize;\n    let mut queue = BinaryHeap::new();\n    for n in arr\
    \ {\n        queue.push(n);\n        if queue.len() > k {\n            queue.pop();\n\
    \        }\n    }\n    queue.into_sorted_vec()", "    let mut arr = arr;\n   \
    \ arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k as usize).collect()",
  "    let mut res = arr;\n    res.sort();\n    res.reverse();\n    res.truncate(k\
    \ as usize);\n    res", "    let len = arr.len();\n    if len == 0 {\n       \
    \ return Vec::new();\n    }\n\n    let mut result = Vec::with_capacity(k as usize);\n\
    \    for &x in arr.iter() {\n        while let Some(prev) = result.last() {\n\
    \            if x > *prev {\n                result.pop();\n            } else\
    \ {\n                break;\n            }\n        }\n        if result.len()\
    \ < k as usize {\n            result.push(x);\n        }\n    }\n    result",
  "    let mut heap = BinaryHeap::new();\n    for &a in arr.iter() {\n        heap.push(a);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        result.push(arr[i as usize]);\n   \
    \ }\n    result.sort();\n    for i in k..arr.len() as isize {\n        for j in\
    \ 0..k {\n            if arr[i as usize] > result[j as usize] {\n            \
    \    result.insert(j as usize, arr[i as usize]);\n                result.pop();\n\
    \                break;\n            }\n        }\n    }\n    result", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().take(k as\
    \ usize).cloned().collect()", "    use std::collections::BinaryHeap;\n    let\
    \ mut heap = BinaryHeap::new();\n    for num in arr {\n        heap.push(num);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec()", "    let mut indices = (0..arr.len()).collect::<Vec<usize>>();\n\
    \    indices.sort_by_key(|i| arr[*i]);\n    let mut res = Vec::new();\n    for\
    \ i in 0..k {\n        res.push(arr[indices[indices.len() - i as usize - 1]]);\n\
    \    }\n    res", "    let mut s = Vec::new();\n    for i in arr {\n        if\
    \ s.len() < k as usize {\n            s.push(i);\n        } else {\n         \
    \   s.sort();\n            let max = s[s.len() - 1];\n            if i > max {\n\
    \                s.pop();\n                s.push(i);\n            }\n       \
    \ }\n    }\n    s.sort();\n    s", "    let mut result = vec![];\n    if arr.len()\
    \ == 0 {\n        return result;\n    }\n    if k == 0 {\n        return result;\n\
    \    }\n    let mut iter = 0;\n    let mut n = arr.len();\n    let mut arr = arr;\n\
    \    while iter < k as usize {\n        let mut idx = 0;\n        let mut max\
    \ = -10000;\n        for i in 0..n {\n            if arr[i] > max {\n        \
    \        max = arr[i];\n                idx = i;\n            }\n        }\n \
    \       result.push(max);\n        iter += 1;\n        n = idx;\n    }\n    result",
  "    let k = k as usize;\n    let mut v = Vec::new();\n    for &i in arr.iter()\
    \ {\n        insert_max(&mut v, i, k);\n    }\n    v", "    use std::collections::VecDeque;\n\
    \    let k = k as usize;\n    let mut dq = VecDeque::new();\n    for num in arr\
    \ {\n        while let Some(last) = dq.back() {\n            if *last <= num {\n\
    \                dq.pop_back();\n            } else {\n                break;\n\
    \            }\n        }\n        dq.push_back(num);\n        if dq.len() > k\
    \ {\n            dq.pop_front();\n        }\n    }\n    dq.into_iter().collect()",
  "    let mut result = Vec::new();\n    if k == 0 {\n        return result;\n   \
    \ }\n    let len = arr.len();\n    if k >= len as isize {\n        return arr;\n\
    \    }\n    let mut left = 0;\n    let mut right = len;\n    while left < right\
    \ {\n        let index = partition(&arr, left, right);\n        if index as isize\
    \ == k {\n            break;\n        } else if index as isize < k {\n       \
    \     left = index + 1;\n        } else {\n            right = index;\n      \
    \  }\n    }\n    for i in 0..k as usize {\n        result.push(arr[i]);\n    }\n\
    \    result", "    // Use a max heap to always have the max k elements in O(n\
    \ log k) time.\n    let mut heap = BinaryHeap::with_capacity(k as usize);\n  \
    \  for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if heap.peek().unwrap() < &arr[i as usize] {\n         \
    \   heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n \
    \   let mut result = Vec::with_capacity(k as usize);\n    while let Some(x) =\
    \ heap.pop() {\n        result.push(x);\n    }\n    result.reverse();\n    result",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut heap = BinaryHeap::new();\n\
    \    for v in arr {\n        heap.push(v);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    while let Some(v) = heap.pop()\
    \ {\n        result.push(v);\n    }\n    result.reverse();\n    result", "   \
    \ let mut v = Vec::new();\n    for i in 0..k {\n        v.push(arr[i as usize]);\n\
    \    }\n    v.sort();\n    for i in k..arr.len() as isize {\n        if arr[i\
    \ as usize] > v[0] {\n            v.remove(0);\n            v.push(arr[i as usize]);\n\
    \            v.sort();\n        }\n    }\n    v", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut pq = BinaryHeap::new();\n    for e in arr {\n      \
    \  pq.push(Element { val: e, cnt: 1 });\n        let mut k_minus_1 = k;\n    \
    \    while let Some(Element { val, cnt }) = pq.peek() {\n            if *cnt ==\
    \ k_minus_1 {\n                result.push(*val);\n                k_minus_1 -=\
    \ 1;\n                pq.pop();\n            } else {\n                break;\n\
    \            }\n        }\n    }\n    result", "    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    sorted.into_iter().rev().take(k as usize).collect()",
  "    //Solution::maximum_0(arr, k)\n    Solution::maximum_1(arr, k)", "    // 1.\
    \ Quick select\n    let mut arr = arr;\n    let n = arr.len();\n    let k = k\
    \ as usize;\n    let mut l = 0;\n    let mut r = n - 1;\n    while l < r {\n \
    \       let m = partition(&mut arr, l, r);\n        if m == k {\n            break;\n\
    \        } else if m < k {\n            l = m + 1;\n        } else {\n       \
    \     r = m - 1;\n        }\n    }\n    let mut res = Vec::with_capacity(k);\n\
    \    for i in 0..k {\n        res.push(arr[i]);\n    }\n    res.sort();\n    res\n\
    \n    // 2. Heap, time: O(NlogK), space: O(K)\n    // let mut arr = arr;\n   \
    \ // let mut heap = BinaryHeap::with_capacity(k as usize);\n    // for i in 0..k\
    \ {\n    //     heap.push(arr[i]);\n    // }\n    // for i in k..arr.len() {\n\
    \    //     if arr[i] > *heap.peek().unwrap() {\n    //         heap.pop();\n\
    \    //         heap.push(arr[i]);\n    //     }\n    // }\n    // let mut res\
    \ = Vec::with_capacity(k as usize);\n    // while let Some(e) = heap.pop() {\n\
    \    //     res.push(e);\n    // }\n    // res.reverse();\n    // res", "    let\
    \ mut max_heap = BinaryHeap::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    let mut result = vec![];\n\
    \    while let Some(max) = max_heap.pop() {\n        result.push(max);\n    }\n\
    \    result.reverse();\n    result", "    let mut v = Vec::with_capacity(k as\
    \ usize);\n    for n in arr {\n        let i = v.binary_search(&n).unwrap_or_else(|i|\
    \ i);\n        if i < v.len() {\n            v.insert(i, n);\n        } else {\n\
    \            v.push(n);\n        }\n        if v.len() > k as usize {\n      \
    \      v.pop();\n        }\n    }\n    v", "    let mut res = vec![isize::min_value();\
    \ k as usize];\n    for &num in arr.iter() {\n        if num > res[0] {\n    \
    \        res[0] = num;\n            res.sort();\n        }\n    }\n    res", " \
    \   if k <= 0 {\n        return vec![];\n    }\n    let mut v = arr;\n    let\
    \ mut k = k as usize;\n    v.sort();\n    v.reverse();\n    v.into_iter().take(k).collect()",
  "    let mut heap = Heap::with_capacity(k as usize);\n    for &n in arr.iter() {\n\
    \        if heap.len() == k as usize {\n            if heap.peek().unwrap() <\
    \ &n {\n                heap.pop();\n                heap.push(n);\n         \
    \   }\n        } else {\n            heap.push(n);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let k = k as usize;\n    let mut a = arr;\n    a.sort();\n    a.iter().rev().take(k).cloned().collect()",
  "    use std::collections::BinaryHeap;\n    let mut heap = BinaryHeap::new();\n\
    \    for num in arr {\n        heap.push(num);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   let mut data = arr;\n    let mut k = k as usize;\n    let mut left = 0;\n\
    \    let mut right = data.len() - 1;\n    while k > 0 {\n        let pivot = partition(left,\
    \ right, &mut data);\n        if pivot == k - 1 {\n            break;\n      \
    \  } else if pivot < k - 1 {\n            left = pivot + 1;\n            k -=\
    \ pivot + 1;\n        } else {\n            right = pivot - 1;\n        }\n  \
    \  }\n    let mut res = Vec::with_capacity(k);\n    for i in 0..k {\n        res.push(data[i]);\n\
    \    }\n    res", "    let mut result = Vec::with_capacity(k as usize);\n    let\
    \ len = arr.len();\n    for i in 0..len {\n        while !result.is_empty() &&\
    \ arr[i] > result[result.len() - 1] {\n            result.pop();\n        }\n\
    \        if result.len() < k as usize {\n            result.push(arr[i]);\n  \
    \      }\n    }\n    result", "    let mut max: Vec<isize> = Vec::new();\n   \
    \ for i in 0..k {\n        let m = arr.iter().max().unwrap();\n        max.push(*m);\n\
    \    }\n    max", '    arr.iter().max_by_key(|&n| (k - n).abs()).map(|&n| n).collect()',
  "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut arr = arr;\n    let len = arr.len();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().take(k as usize).cloned().collect()", "    let mut queue = BinaryHeap::new();\n\
    \    for i in 0..k {\n        queue.push(std::cmp::Reverse(arr[i as usize]));\n\
    \    }\n    for i in k..arr.len() as isize {\n        let peek = queue.peek().unwrap();\n\
    \        if arr[i as usize] > peek.0 {\n            queue.pop();\n           \
    \ queue.push(std::cmp::Reverse(arr[i as usize]));\n        }\n    }\n    queue.into_sorted_vec().into_iter().map(|r|\
    \ r.0).collect()", "    if k <= 0 {\n        return vec![];\n    }\n    let mut\
    \ arr = arr;\n    arr.sort();\n    let mut result = vec![];\n    for i in (0..k).rev()\
    \ {\n        result.push(arr[i as usize]);\n    }\n    result", "    let mut res\
    \ = Vec::new();\n    for &n in arr.iter() {\n        let mut i = 0;\n        while\
    \ i < res.len() && n > res[i] {\n            i += 1;\n        }\n        if i\
    \ == k as usize {\n            continue;\n        }\n        res.insert(i, n);\n\
    \        if res.len() > k as usize {\n            res.pop();\n        }\n    }\n\
    \    res", "    let mut result = Vec::new();\n    let mut max_heap = std::collections::BinaryHeap::new();\n\
    \    for i in 0..arr.len() {\n        max_heap.push(arr[i]);\n        if max_heap.len()\
    \ > k as usize {\n            max_heap.pop();\n        }\n    }\n    while !max_heap.is_empty()\
    \ {\n        result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut res = Vec::new();\n    if k > arr.len() as isize {\
    \ return res; }\n    let mut s: BinaryHeap<isize> = BinaryHeap::new();\n    for\
    \ i in 0..k {\n        s.push(arr[i as usize]);\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > s.peek().unwrap() {\n            s.pop();\n\
    \            s.push(arr[i as usize]);\n        }\n    }\n    while !s.is_empty()\
    \ {\n        res.push(s.pop().unwrap());\n    }\n    res.reverse();\n    res",
  "    let mut res = vec![];\n    let mut tmp = arr.clone();\n    for _ in 0..k {\n\
    \        let max = tmp.iter().max().unwrap();\n        res.push(*max);\n     \
    \   tmp.remove_item(max);\n    }\n    res", "    let (mut p, mut q) = (0, arr.len()\
    \ - 1);\n    while q > p {\n        let mut i = p;\n        let mut j = q;\n \
    \       let x = arr[(p + q) / 2];\n        while i <= j {\n            while arr[i]\
    \ > x {\n                i += 1;\n            }\n            while arr[j] < x\
    \ {\n                j -= 1;\n            }\n            if i <= j {\n       \
    \         let t = arr[i];\n                arr[i] = arr[j];\n                arr[j]\
    \ = t;\n                i += 1;\n                j -= 1;\n            }\n    \
    \    }\n        if k - 1 <= j {\n            q = j;\n        }\n        if k -\
    \ 1 >= i {\n            p = i;\n        }\n    }\n    arr[..(k as usize)].to_vec()",
  "    let mut max_heap = BinaryHeap::with_capacity(k as usize);\n    for &elem in\
    \ arr.iter() {\n        max_heap.push(elem);\n        if max_heap.len() > k as\
    \ usize {\n            max_heap.pop();\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let mut min_heap = BinaryHeap::new();\n    for i in 0..arr.len() {\n      \
    \  if i < k as usize {\n            min_heap.push(arr[i]);\n        } else {\n\
    \            if arr[i] > *min_heap.peek().unwrap() {\n                min_heap.pop();\n\
    \                min_heap.push(arr[i]);\n            }\n        }\n    }\n   \
    \ min_heap.into_sorted_vec()", "    let mut k_max = vec![isize::min_value(); k\
    \ as usize];\n    for n in arr {\n        for i in 0..k {\n            if n >\
    \ k_max[i as usize] {\n                k_max.insert(i as usize, n);\n        \
    \        k_max.pop();\n                break;\n            }\n        }\n    }\n\
    \    k_max", "    let mut arr = arr;\n    let mut ans = Vec::new();\n    let len\
    \ = arr.len();\n    if k == 0 {\n        return ans;\n    }\n    if len <= k as\
    \ usize {\n        arr.sort();\n        return arr;\n    }\n    ans.resize(k as\
    \ usize, isize::min_value());\n    for i in 0..len {\n        let mut j = k as\
    \ usize - 1;\n        while j > 0 && arr[i] > ans[j - 1] {\n            ans[j]\
    \ = ans[j - 1];\n            j -= 1;\n        }\n        ans[j] = arr[i];\n  \
    \  }\n    ans", "    let mut arr = arr;\n    let mut ans = Vec::new();\n    arr.sort();\n\
    \    ans.extend_from_slice(&arr[arr.len() - k as usize..]);\n    ans", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().take(k as\
    \ usize).cloned().collect()", "    let mut heap = BinaryHeap::new();\n    for\
    \ num in arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "   \
    \ let mut max_heap = BinaryHeap::new();\n    for v in arr {\n        max_heap.push(v);\n\
    \        if max_heap.len() > k as usize {\n            max_heap.pop();\n     \
    \   }\n    }\n    max_heap.into_sorted_vec()", "    let mut res = vec![];\n  \
    \  for x in arr {\n        res.push(x);\n        res.sort();\n        if res.len()\
    \ > k as usize {\n            res.remove(0);\n        }\n    }\n    res", "  \
    \  use std::collections::BinaryHeap;\n    let mut heap = BinaryHeap::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n\
    \    for i in k..arr.len() as isize {\n        if arr[i as usize] > heap.peek().unwrap()\
    \ {\n            heap.pop();\n            heap.push(arr[i as usize]);\n      \
    \  }\n    }\n    heap.into_sorted_vec()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    if arr.len() < k as usize {\n        return result;\n    }\n\
    \    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    let mut i = 0;\n    while i < k {\n        result.push(sorted[i as usize]);\n\
    \        i += 1;\n    }\n    result", "    let mut nums = arr;\n    nums.sort();\n\
    \    nums.into_iter().rev().take(k as usize).collect()", "    let mut sorted =\
    \ arr.clone();\n    sorted.sort();\n    sorted.iter().rev().take(k as usize).map(|x|\
    \ *x).collect()", "    if k <= 0 {\n        return vec![];\n    }\n    let mut\
    \ result = arr[0..k as usize].to_vec();\n    result.sort();\n    for i in k as\
    \ usize..arr.len() {\n        let mut j = 0;\n        while j < k as usize &&\
    \ result[j] < arr[i] {\n            j += 1;\n        }\n        if j < k as usize\
    \ {\n            result.insert(j, arr[i]);\n            result.pop();\n      \
    \  }\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut res = vec![];\n    for i in 0..k\
    \ {\n        let mut max = 0;\n        for j in 1..arr.len() {\n            if\
    \ arr[j] > arr[max] {\n                max = j;\n            }\n        }\n  \
    \      res.push(arr[max]);\n        arr.remove(max);\n    }\n    res", "    let\
    \ mut k = k as usize;\n    let mut arr = arr;\n    let mut result = Vec::new();\n\
    \    while !arr.is_empty() && k > 0 {\n        let m = arr.iter().max().unwrap();\n\
    \        result.push(*m);\n        arr.retain(|&x| x != *m);\n        k -= 1;\n\
    \    }\n    result", "    let mut v = Vec::new();\n    for &x in arr.iter() {\n\
    \        if v.len() == k as usize {\n            let (mut i, mut j) = (0, v.len()\
    \ - 1);\n            while i < j {\n                let m = (i + j) / 2;\n   \
    \             if v[m] < x {\n                    i = m + 1;\n                }\
    \ else {\n                    j = m;\n                }\n            }\n     \
    \       if i != 0 && v[i - 1] < x {\n                v[i - 1] = x;\n         \
    \   }\n        } else {\n            let (mut i, mut j) = (0, v.len());\n    \
    \        while i < j {\n                let m = (i + j) / 2;\n               \
    \ if v[m] < x {\n                    i = m + 1;\n                } else {\n  \
    \                  j = m;\n                }\n            }\n            v.insert(i,\
    \ x);\n        }\n    }\n    v", "    let mut heap = Heap::new(false);\n    for\
    \ num in arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    heap.into_vec()", "    let mut\
    \ h = BinaryHeap::new();\n    for i in 0..k {\n        h.push(arr[i as usize]);\n\
    \    }\n    for i in k..arr.len() as isize {\n        if h.peek().unwrap() < &arr[i\
    \ as usize] {\n            h.pop();\n            h.push(arr[i as usize]);\n  \
    \      }\n    }\n    let mut v = vec![];\n    while let Some(x) = h.pop() {\n\
    \        v.push(x);\n    }\n    v.reverse();\n    v", "    let mut result = vec![];\n\
    \    let len = arr.len();\n    if k as usize > len {\n        return result;\n\
    \    }\n    if len == k as usize {\n        return arr;\n    }\n    let mut last\
    \ = 0;\n    while last < k {\n        let mut max = -10001;\n        let mut pos\
    \ = 0;\n        for i in 0..len {\n            if arr[i] > max && !result.contains(&i)\
    \ {\n                max = arr[i];\n                pos = i;\n            }\n\
    \        }\n        result.push(pos);\n        last += 1;\n    }\n    result.sort();\n\
    \    let mut res = vec![];\n    for i in result {\n        res.push(arr[i]);\n\
    \    }\n    res", "    if k < 1 {\n        return Vec::new();\n    }\n    let\
    \ mut q = BinaryHeap::new();\n    for i in 0..k {\n        q.push(arr[i as usize]);\n\
    \    }\n    for i in k..arr.len() as isize {\n        let x = q.peek().unwrap();\n\
    \        if arr[i as usize] > *x {\n            q.pop();\n            q.push(arr[i\
    \ as usize]);\n        }\n    }\n    q.into_sorted_vec()", "    let mut start\
    \ = 0;\n    let mut end = arr.len() as isize - k;\n    let mut max_indices = vec![];\n\
    \    let mut max_index = 0;\n    while start <= end {\n        let mut i = start;\n\
    \        let mut idx = i;\n        while i < start + k {\n            if arr[idx]\
    \ < arr[i as usize] {\n                idx = i;\n            }\n            i\
    \ += 1;\n        }\n        if idx == end {\n            max_indices.push(idx);\n\
    \            max_index = max_indices.len() - 1;\n        } else if max_indices.len()\
    \ > 0 && arr[max_indices[max_index]] < arr[idx] {\n            max_indices[max_index]\
    \ = idx;\n        }\n        start += 1;\n    }\n    let mut result = vec![];\n\
    \    for idx in max_indices {\n        result.push(arr[idx as usize]);\n    }\n\
    \    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    assert!(k > 0 && k <= arr.len() as isize);\n\
    \    let mut heap = BinaryHeap::with_capacity(k as usize);\n    for &e in arr.iter()\
    \ {\n        if heap.len() < k as usize {\n            heap.push(e);\n       \
    \ } else if heap.peek().unwrap() < &e {\n            heap.pop();\n           \
    \ heap.push(e);\n        }\n    }\n    heap.into_sorted_vec()", "    let mut vec\
    \ = arr;\n    vec.sort();\n    vec.reverse();\n    vec.into_iter().take(k as usize).collect()",
  "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.iter().take(k\
    \ as usize).map(|x| *x).collect()", "    let mut result = vec![];\n    if arr.len()\
    \ == 0 {\n        return result;\n    }\n    let mut heap = BinaryHeap::new();\n\
    \    for v in arr {\n        heap.push(v);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    for _ in 0..k {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut arr = arr;\n    let k\
    \ = k as usize;\n    arr.sort();\n    arr.iter().skip(arr.len() - k).cloned().collect()",
  "    if k as usize >= arr.len() {\n        return arr;\n    }\n    let mut arr =\
    \ arr;\n    arr.sort();\n    arr.reverse();\n    arr.truncate(k as usize);\n \
    \   arr", "    let mut arr = arr;\n    let len = arr.len();\n    if len == 0 {\n\
    \        return vec![];\n    }\n    heapify(&mut arr);\n    let mut result = Vec::with_capacity(k\
    \ as usize);\n    for _ in 0..k {\n        result.push(arr[0]);\n        arr[0]\
    \ = arr[len - 1];\n        arr.pop();\n        sift_down(&mut arr, 0);\n    }\n\
    \    result", "    let mut max = arr;\n    max.sort();\n    max.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut heap = BinaryHeap::new();\n    for &x in\
    \ arr.iter() {\n        heap.push(x);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "   \
    \ use std::collections::BinaryHeap;\n    let mut heap = BinaryHeap::new();\n \
    \   for i in arr {\n        heap.push(i);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   let mut window = arr[0..k as usize].to_vec();\n    window.sort();\n    for\
    \ i in k as usize..arr.len() {\n        let mut j = 0;\n        while j < k as\
    \ usize && arr[i] >= window[j] {\n            j += 1;\n        }\n        if j\
    \ == k as usize {\n            continue;\n        }\n        window.insert(j,\
    \ arr[i]);\n        window.remove(0);\n    }\n    window", "    let mut max_heap\
    \ = MaxHeap::new();\n    for &i in arr.iter() {\n        max_heap.insert(i);\n\
    \    }\n    max_heap.heap.into_iter().take(k as usize).collect()", "    let mut\
    \ res = Vec::new();\n    let l = arr.len();\n    for i in 0..k {\n        let\
    \ mut max = arr[i as usize];\n        let mut max_pos = i;\n        for j in (i\
    \ + 1)..l as isize {\n            if arr[j as usize] > max {\n               \
    \ max = arr[j as usize];\n                max_pos = j;\n            }\n      \
    \  }\n        let tmp = arr[i as usize];\n        arr[i as usize] = max;\n   \
    \     arr[max_pos as usize] = tmp;\n        res.push(max);\n    }\n    res", " \
    \   let mut arr = arr;\n    let mut res = Vec::new();\n    let mut i = 0;\n  \
    \  while i < k {\n        let mut index = i;\n        for j in i + 1..arr.len()\
    \ {\n            if arr[j] > arr[index] {\n                index = j;\n      \
    \      }\n        }\n        res.push(arr[index]);\n        arr.remove(index);\n\
    \        i += 1;\n    }\n    res", "    let mut max_nums = vec![0; k as usize];\n\
    \    let mut sorted_nums = arr.clone();\n    sorted_nums.sort();\n    for (i,\
    \ elem) in sorted_nums.iter().rev().enumerate() {\n        max_nums[i] = *elem;\n\
    \    }\n    max_nums", "    let n = arr.len();\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    let mut arr = arr;\n    for i in 0..k {\n        let\
    \ mut max_index = 0;\n        for j in 0..n {\n            if arr[j] > arr[max_index]\
    \ {\n                max_index = j;\n            }\n        }\n        arr[max_index]\
    \ = std::isize::MIN;\n    }\n    arr.into_iter().filter(|x| *x > std::isize::MIN).collect()",
  "    let mut vec = arr;\n    vec.sort();\n    vec.iter().rev().take(k as usize).map(|x|\
    \ *x).collect()", "    let mut arr = arr;\n    let mut res = Vec::new();\n   \
    \ for _ in 0..k {\n        res.push(arr.pop().unwrap());\n    }\n    res.sort();\n\
    \    for i in (0..arr.len()).rev() {\n        if arr[i] > res[res.len() - 1] {\n\
    \            let val = res.pop().unwrap();\n            res.push(arr[i]);\n  \
    \          res.push(val);\n            res.sort();\n        }\n    }\n    res",
  "    let k = k as usize;\n    let arr = arr.iter().cloned().collect::<BinaryHeap<_>>();\n\
    \    (0..k).map(|_| arr.pop().unwrap()).collect()", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ // If we have more than K numbers, sort the first K, then push each new number\
    \ onto the\n    // end of the array and remove the lowest number, repeating until\
    \ all numbers have been\n    // pushed onto the array.\n    // If we have fewer\
    \ than K numbers, sort the array and return it.\n    let mut vec = if arr.len()\
    \ > k as usize {\n        let mut vec = arr[0..k as usize].to_vec();\n       \
    \ vec.sort();\n        vec\n    } else {\n        arr.to_vec()\n    };\n    if\
    \ vec.len() == k as usize {\n        return vec;\n    }\n    vec.sort();\n   \
    \ vec", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().skip(arr.len()\
    \ - k as usize).cloned().collect()", "    if k == 0 {\n        return vec![];\n\
    \    }\n    let mut pq = BinaryHeap::new();\n    for x in arr {\n        pq.push(x);\n\
    \        if pq.len() > k as usize {\n            pq.pop();\n        }\n    }\n\
    \    let mut result = Vec::new();\n    while let Some(x) = pq.pop() {\n      \
    \  result.push(x);\n    }\n    result.reverse();\n    result", "    let mut arr\
    \ = arr;\n    arr.sort();\n    let mut max = Vec::new();\n    let len = arr.len();\n\
    \    for i in 0..k as usize {\n        max.push(arr[len - 1 - i]);\n    }\n  \
    \  max", "    let mut pr = PriorityQueue::new();\n    let k = k as usize;\n  \
    \  for i in 0..k {\n        pr.push(arr[i]);\n    }\n    for i in k..arr.len()\
    \ {\n        if let Some(v) = pr.peek() {\n            if arr[i] > *v {\n    \
    \            pr.pop();\n                pr.push(arr[i]);\n            }\n    \
    \    }\n    }\n    let mut ans = vec![];\n    while let Some(v) = pr.pop() {\n\
    \        ans.push(v);\n    }\n    ans.reverse();\n    ans", "    let mut heap\
    \ = BinaryHeap::with_capacity(k as usize);\n    for item in arr {\n        if\
    \ let Some(top) = heap.peek() {\n            if top > &item && heap.len() == k\
    \ as usize {\n                continue;\n            }\n        }\n        heap.push(item);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    let mut result = heap.into_sorted_vec();\n    if result.len() == k as\
    \ usize {\n        result\n    } else {\n        let mut reverse = result.drain(..).rev().collect::<Vec<_>>();\n\
    \        while reverse.len() != k as usize {\n            reverse.pop();\n   \
    \     }\n        reverse.into_iter().rev().collect()\n    }", "    let mut pq\
    \ = PriorityQueue::new();\n    for i in 0..k {\n        pq.push(arr[i as usize]);\n\
    \    }\n    for i in k..arr.len() as isize {\n        if arr[i as usize] > pq.peek().unwrap()\
    \ {\n            pq.pop();\n            pq.push(arr[i as usize]);\n        }\n\
    \    }\n    let mut res = vec![];\n    while !pq.is_empty() {\n        res.push(pq.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut res = Vec::new();\n    if k\
    \ == 0 {\n        return res;\n    }\n    let mut i = 0;\n    while i < k {\n\
    \        res.push(arr[i as usize]);\n        i += 1;\n    }\n    res.sort();\n\
    \    i = k;\n    while i < arr.len() as isize {\n        let mut j = k - 1;\n\
    \        while j >= 0 && arr[i as usize] > res[j as usize] {\n            j -=\
    \ 1;\n        }\n        if j >= 0 {\n            res.remove(j as usize);\n  \
    \          res.push(arr[i as usize]);\n            res.sort();\n        }\n  \
    \      i += 1;\n    }\n    res", "    let mut heap = BinaryHeap::new();\n    for\
    \ &n in arr.iter() {\n        heap.push(n);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   if k == arr.len() as isize {\n        return arr;\n    }\n    let mut min_heap\
    \ = MinHeap::new();\n    for v in arr {\n        min_heap.push(v);\n        if\
    \ min_heap.len() > k as usize {\n            min_heap.pop();\n        }\n    }\n\
    \    min_heap.into_sorted_vec()", "    use std::collections::BinaryHeap;\n   \
    \ let k = k as usize;\n    let mut heap = BinaryHeap::with_capacity(k);\n    for\
    \ a in arr {\n        if heap.len() < k {\n            heap.push(a);\n       \
    \ } else if a > *heap.peek().unwrap() {\n            heap.pop();\n           \
    \ heap.push(a);\n        }\n    }\n    heap.into_sorted_vec()", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    if k <= 0 {\n        return vec![];\n    }\n    let mut arr = arr;\n    let\
    \ mut result = Vec::with_capacity(k as usize);\n    arr.sort();\n    for i in\
    \ 0..k {\n        result.push(arr[arr.len() - 1 - i as usize]);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let n = arr.len();\n    if n == 0 {\n        return Vec::new();\n    }\n\n\
    \    let mut a = arr;\n    a.sort();\n    a.iter().rev().take(k as usize).map(|x|\
    \ *x).collect()", "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n\
    \        heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        let top = heap.peek().unwrap();\n        if arr[i as usize] > *top\
    \ {\n            heap.pop();\n            heap.push(arr[i as usize]);\n      \
    \  }\n    }\n    heap.into_sorted_vec()", "    // max heap\n    let mut heap =\
    \ BinaryHeap::new();\n    for num in arr {\n        heap.push(Reverse(num));\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec().into_iter().map(|x| x.0).collect()", "    let\
    \ n = arr.len();\n    let mut heap = BinaryHeap::new();\n    for i in 0..n {\n\
    \        if i < k as usize {\n            heap.push(arr[i]);\n        } else {\n\
    \            if let Some(min) = heap.peek() {\n                if arr[i] > *min\
    \ {\n                    heap.pop();\n                    heap.push(arr[i]);\n\
    \                }\n            }\n        }\n    }\n    let mut result = vec![];\n\
    \    for _ in 0..k {\n        if let Some(max) = heap.pop() {\n            result.push(max);\n\
    \        }\n    }\n    result.reverse();\n    result", "    let mut indices =\
    \ (0..arr.len()).collect::<Vec<usize>>();\n    indices.sort_by_key(|i| arr[*i]);\n\
    \    indices.iter().rev().take(k as usize).map(|i| arr[*i]).collect()", "    let\
    \ mut heap = BinaryHeap::with_capacity(k as usize);\n    for &e in arr.iter()\
    \ {\n        heap.push(e);\n        if heap.len() > k as usize {\n           \
    \ heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    let mut sorted_array\
    \ = arr.clone();\n    let mut k = k as usize;\n    if k >= sorted_array.len()\
    \ {\n        sorted_array.sort();\n        return sorted_array;\n    }\n    sorted_array.sort();\n\
    \    sorted_array.reverse();\n    sorted_array.drain(k..).collect()", "    let\
    \ mut result = Vec::with_capacity(k as usize);\n    for v in arr {\n        let\
    \ len = result.len();\n        if len == 0 {\n            result.push(v);\n  \
    \      } else if len < k as usize {\n            let mut i = len;\n          \
    \  while i > 0 && result[i - 1] < v {\n                result[i] = result[i -\
    \ 1];\n                i -= 1;\n            }\n            result[i] = v;\n  \
    \      } else if v > result[len - 1] {\n            let mut i = len - 1;\n   \
    \         while i > 0 && result[i - 1] < v {\n                result[i] = result[i\
    \ - 1];\n                i -= 1;\n            }\n            result[i] = v;\n\
    \        }\n    }\n    result", "    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.reverse();\n    sorted_arr.into_iter().take(k as usize).collect()",
  "    use std::collections::BinaryHeap;\n    let mut heap = BinaryHeap::with_capacity(k\
    \ as usize);\n    for item in arr {\n        if heap.len() < k as usize {\n  \
    \          heap.push(item);\n        } else if item > *heap.peek().unwrap() {\n\
    \            heap.pop();\n            heap.push(item);\n        }\n    }\n   \
    \ heap.into_sorted_vec()", "    let k = k as usize;\n    if k == 0 {\n       \
    \ return vec![];\n    }\n    if k == arr.len() {\n        return arr;\n    }\n\
    \    let mut max_heap = BinaryHeap::with_capacity(k);\n    for i in 0..k {\n \
    \       max_heap.push(arr[i]);\n    }\n    for i in k..arr.len() {\n        if\
    \ arr[i] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i]);\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let mut res = arr.clone();\n    res.sort();\n    res.iter().rev().take(k as\
    \ usize).cloned().collect()", "    let mut arr = arr;\n    arr.sort();\n    let\
    \ len = arr.len();\n    let mut res = Vec::with_capacity(k as usize);\n    for\
    \ i in 0..k {\n        res.push(arr[len - 1 - i as usize]);\n    }\n    res",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut heap = BinaryHeap::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(arr[i\
    \ as usize]);\n        }\n    }\n    heap.into_sorted_vec()", "    if k == 0 {\n\
    \        return vec![];\n    }\n    let mut res = Vec::with_capacity(k as usize);\n\
    \    for i in 0..arr.len() {\n        // if the last element is smaller than the\
    \ current, \n        // push it back to the end\n        while res.len() > 0 &&\
    \ res[res.len() - 1] < arr[i] {\n            res.pop();\n        }\n        if\
    \ res.len() < k as usize {\n            res.push(arr[i]);\n        }\n    }\n\
    \    res", "    let mut heap = BinaryHeap::new();\n    for v in arr {\n      \
    \  heap.push(Ordering::Greater(v));\n        if heap.len() > k as usize {\n  \
    \          heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    let\
    \ mut result = Vec::with_capacity(k as usize);\n    for _ in 0..k {\n        let\
    \ mut max = std::isize::MIN;\n        let mut max_index = 0;\n        for (i,\
    \ e) in arr.iter().enumerate() {\n            if *e > max {\n                max\
    \ = *e;\n                max_index = i;\n            }\n        }\n        result.push(max);\n\
    \        arr.remove(max_index);\n    }\n    result", "    if k as usize > arr.len()\
    \ {\n        return arr;\n    }\n    let mut arr = arr;\n    arr.sort();\n   \
    \ arr.drain(..(arr.len() - k as usize)).collect()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for num in arr {\n  \
    \      if heap.len() < k as usize {\n            heap.push(num);\n        } else\
    \ if let Some(max) = heap.peek() {\n            if num > *max {\n            \
    \    heap.pop();\n                heap.push(num);\n            }\n        }\n\
    \    }\n    while let Some(num) = heap.pop() {\n        result.push(num);\n  \
    \  }\n    result.reverse();\n    result", "    let mut res = arr.clone();\n  \
    \  res.sort();\n    res.reverse();\n    res.into_iter().take(k as usize).collect()",
  "    if k == 0 {\n        return vec![];\n    }\n    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        let current = arr[i as usize];\n        if\
    \ current > heap.peek().unwrap() {\n            heap.pop();\n            heap.push(current);\n\
    \        }\n    }\n    let mut result = vec![];\n    for _ in 0..k {\n       \
    \ result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n    result",
  "    let heap = arr.into_iter().take(k as usize).collect::<BinaryHeap<_>>();\n \
    \   for n in arr.into_iter().skip(k as usize) {\n        if n > *heap.peek().unwrap()\
    \ {\n            heap.pop();\n            heap.push(n);\n        }\n    }\n  \
    \  heap.into_sorted_vec()", "    let mut heap = BinaryHeap::new();\n    for &x\
    \ in arr.iter() {\n        heap.push(x);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "   \
    \ // FIXME\n    arr", "    let mut arr = arr;\n    arr.sort();\n    let l = arr.len();\n\
    \    let mut res = Vec::new();\n    for i in 0..k {\n        res.push(arr[l -\
    \ 1 - i as usize]);\n    }\n    res", "    let k = k as usize;\n    let len =\
    \ arr.len();\n    let mut nums = arr;\n    let mut lo = 0;\n    let mut hi = len\
    \ - 1;\n    let mut partition_pos = 0;\n    while lo < hi {\n        let partition_pos\
    \ = partition(&mut nums, lo, hi);\n        if partition_pos == k {\n         \
    \   break;\n        } else if partition_pos < k {\n            lo = partition_pos\
    \ + 1;\n        } else {\n            hi = partition_pos - 1;\n        }\n   \
    \ }\n    nums[..k].to_vec()", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut heap = BinaryHeap::new();\n    for num in\
    \ arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n     \
    \       heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    let mut\
    \ res = Vec::new();\n    let mut max = 0;\n    let mut head = 1;\n    let mut\
    \ tail = 0;\n    while res.len() < k as usize {\n        max = tail;\n       \
    \ for i in tail..head {\n            if arr[i as usize] > arr[max as usize] {\n\
    \                max = i;\n            }\n        }\n        if tail == max {\n\
    \            res.push(arr[tail as usize]);\n            tail += 1;\n        }\
    \ else {\n            head += 1;\n        }\n    }\n    res", "    let mut res\
    \ = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in arr {\n \
    \       heap.push(Reverse(i));\n        if heap.len() > k as usize {\n       \
    \     heap.pop();\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap().0);\n\
    \    }\n    res.reverse();\n    res", "    let mut res = arr.iter().cloned().take(k\
    \ as usize).collect::<Vec<isize>>();\n    res.sort();\n    for i in k as usize..arr.len()\
    \ {\n        for j in 0..res.len() {\n            if arr[i] > res[j] {\n     \
    \           res.remove(j);\n                res.push(arr[i]);\n              \
    \  res.sort();\n                break;\n            }\n        }\n    }\n    res",
  "    let k = k as usize;\n    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k).collect()",
  "    // Using a max heap to store the numbers, to get the k maximum numbers, we\
    \ \n    // need to retain the k numbers and discard the remaining.\n    // Since\
    \ the size of the heap is dynamic, we need to insert elements into \n    // the\
    \ heap first, then pop out the remaining numbers.\n    // Time complexity: O(nlogn)\n\
    \    // Space complexity: O(n)\n    let mut heap = BinaryHeap::<isize>::new();\n\
    \    for &x in arr.iter() {\n        heap.push(x);\n    }\n    for _ in 0..arr.len()\
    \ - k as usize {\n        heap.pop();\n    }\n    let mut res = vec![];\n    while\
    \ let Some(x) = heap.pop() {\n        res.push(x);\n    }\n    res.reverse();\n\
    \    res", "    let (mut a, mut b) = (arr.clone(), vec![]);\n    a.sort();\n \
    \   a.reverse();\n    while b.len() < k as usize {\n        b.push(a.pop().unwrap());\n\
    \    }\n    b", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    let mut minimums = Vec::with_capacity(k as usize);\n    for &n in arr.iter()\
    \ {\n        match result.len() {\n            0 => result.push(n),\n        \
    \    1 if result[0] < n => {\n                result.push(n);\n              \
    \  result.swap(0, 1);\n            },\n            1 => result.push(n),\n    \
    \        k if result[k - 1] > n => {\n                minimums.push(n);\n    \
    \            if minimums.len() < k as usize {\n                    continue;\n\
    \                }\n                minimums.sort();\n                minimums.swap(0,\
    \ k as usize - 1);\n                result.swap(k as usize - 1, k as usize);\n\
    \                result.pop();\n            },\n            _ => result.push(n),\n\
    \        }\n        result.sort();\n        if result.len() > k as usize {\n \
    \           result.swap(k as usize - 1, k as usize);\n            result.pop();\n\
    \        }\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n   \
    \ let mut ret = Vec::new();\n    for i in 0..k {\n        ret.push(arr[(arr.len()\
    \ - i - 1) as usize]);\n    }\n    ret", "    let mut heap = BinaryHeap::new();\n\
    \    let mut max_heap = Vec::new();\n    for &item in arr.iter() {\n        heap.push(item);\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    for _ in 0..k {\n        max_heap.push(heap.pop().unwrap());\n    }\n\
    \    max_heap.reverse();\n    max_heap", "    // Find maximum k items in arr.\n\
    \    let mut left = 0;\n    let mut right = arr.len() as isize - k;\n    while\
    \ left < right {\n        let mid = (left + right) / 2;\n        if arr[mid as\
    \ usize] < arr[(mid + k) as usize] {\n            left = mid + 1;\n        } else\
    \ {\n            right = mid;\n        }\n    }\n    arr[left as usize..left as\
    \ usize + k as usize].to_vec()", "    use std::collections::BinaryHeap;\n    let\
    \ k = k as usize;\n    let mut max_heap = BinaryHeap::with_capacity(k);\n    for\
    \ i in 0..arr.len() {\n        max_heap.push(arr[i]);\n        if max_heap.len()\
    \ > k {\n            max_heap.pop();\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let mut arr = arr;\n    let mut sol = vec![];\n    for _ in 0..k {\n      \
    \  let mut max = arr[0];\n        let mut max_idx = 0;\n        for (i, &x) in\
    \ arr.iter().enumerate() {\n            if x > max {\n                max = x;\n\
    \                max_idx = i;\n            }\n        }\n        sol.push(max);\n\
    \        arr.remove(max_idx);\n    }\n    sol", "    let mut pq = std::collections::BinaryHeap::new();\n\
    \    for x in arr {\n        if pq.len() < k as usize {\n            pq.push(x);\n\
    \        } else if let Some(top) = pq.peek() {\n            if *top < x {\n  \
    \              pq.pop();\n                pq.push(x);\n            }\n       \
    \ }\n    }\n    pq.into_sorted_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.iter().take(k as usize).map(|&n| n).collect()", " \
    \   let len = arr.len();\n    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).map(|&x| x).collect()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut pq = BinaryHeap::new();\n    for a in arr {\n      \
    \  if pq.len() < k as usize {\n            pq.push(a);\n        } else if let\
    \ Some(b) = pq.peek() {\n            if a > *b {\n                pq.pop();\n\
    \                pq.push(a);\n            }\n        }\n    }\n    for _ in 0..k\
    \ {\n        if let Some(v) = pq.pop() {\n            result.push(v);\n      \
    \  }\n    }\n    result", "    let mut result = vec![];\n    let mut heap = Heap::new(false);\n\
    \    for item in arr {\n        heap.push(item);\n        if heap.size() > k as\
    \ usize {\n            heap.pop();\n        }\n    }\n    for _ in 0..k {\n  \
    \      result.push(heap.pop().unwrap());\n    }\n    result", "    let size =\
    \ arr.len();\n    let arr = arr.into_iter().map(|x| x as usize).collect::<Vec<_>>();\n\
    \    if size == 0 {\n        return vec![];\n    }\n    let mut max_heap = BinaryHeap::new();\n\
    \    let k = k as usize;\n    if k >= size {\n        return arr.iter().cloned().map(|x|\
    \ x as isize).collect::<Vec<_>>();\n    }\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if idx < k {\n            max_heap.push(val);\n        } else {\n\
    \            if val > max_heap.peek().unwrap() {\n                max_heap.pop();\n\
    \                max_heap.push(val);\n            }\n        }\n    }\n    max_heap.into_sorted_vec().into_iter().map(|x|\
    \ x as isize).collect::<Vec<_>>()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", '    arr.iter().cloned().collect::<BinaryHeap<_>>().into_sorted_vec().into_iter().take(k
    as usize).collect()', "    let mut pq = BinaryHeap::new();\n    for n in arr {\n\
    \        pq.push(n);\n        if pq.len() > k as usize {\n            pq.pop();\n\
    \        }\n    }\n    pq.into_sorted_vec()", "    if k == 0 {\n        return\
    \ vec![];\n    }\n    let mut result = Vec::with_capacity(k as usize);\n    for\
    \ &elem in arr.iter() {\n        if result.len() < k as usize {\n            result.push(elem);\n\
    \        } else {\n            if elem > result[0] {\n                result[0]\
    \ = elem;\n            }\n        }\n        result.sort();\n    }\n    result",
  "    let mut heap = BinaryHeap::new();\n    for &i in arr.iter() {\n        heap.push(Reverse(i));\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec().into_iter().map(|Reverse(i)| i).collect()", " \
    \   // \u5BB9\u91CF\u4E3A k + 1 \u4E2A\uFF0C\u6700\u540E\u4E00\u4E2A\u5143\u7D20\
    \u7A7A\u7740\n    let mut buf = Vec::with_capacity(k as usize + 1);\n    for i\
    \ in 0..k {\n        let mut j = buf.len() - 1;\n        while j > 0 && buf[j\
    \ - 1] < arr[i as usize] {\n            j -= 1;\n        }\n        buf.insert(j,\
    \ arr[i as usize]);\n    }\n    buf.truncate(k as usize);\n    for &item in arr.iter().skip(k\
    \ as usize) {\n        if item <= buf[0] {\n            continue;\n        }\n\
    \        let mut j = k as usize - 1;\n        while j > 0 && buf[j - 1] < item\
    \ {\n            j -= 1;\n        }\n        buf.insert(j, item);\n        buf.remove(0);\n\
    \    }\n    buf", "    let len = arr.len();\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let mut heap = BinaryHeap::with_capacity(k\
    \ as usize);\n    for num in arr {\n        if heap.len() < k as usize {\n   \
    \         heap.push(num);\n        } else if let Some(max) = heap.peek() {\n \
    \           if num > *max {\n                heap.pop();\n                heap.push(num);\n\
    \            }\n        }\n    }\n    heap.into_sorted_vec()"]
stop_tokens:
- "\n}"
