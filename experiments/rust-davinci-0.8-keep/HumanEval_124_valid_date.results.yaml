name: HumanEval_124_valid_date
language: rust
results:
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpo02ors5f.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n  if date.len() != 10 {\n    return false;\n  }\n  let month = date[0..2].parse::<i32>().unwrap();\n\
    \  let day = date[3..5].parse::<i32>().unwrap();\n  let year = date[6..10].parse::<i32>().unwrap();\n\
    \  if !(month >= 1 && month <= 12) {\n    return false;\n  }\n  if !(year >= 1000\
    \ && year <= 9999) {\n    return false;\n  }\n  if (month == 1 || month == 3 ||\
    \ month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && !(day\
    \ >= 1 && day <= 31) {\n    return false;\n  }\n  if (month == 4 || month == 6\
    \ || month == 9 || month == 11) && !(day >= 1 && day <= 30) {\n    return false;\n\
    \  }\n  if (month == 2) && !(day >= 1 && day <= 29) {\n    return false;\n  }\n\
    \  if !date.contains(\"-\") {\n    return false;\n  }\n  true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpolncn1_p.rs:19:39\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2k4fb_f.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpua21a80y.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut rules = [rule1, rule2, rule3, rule4];\n    for rule in\
    \ rules.iter_mut() {\n        if !rule(date.clone()) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `rule1` in this scope\n  --> /tmp/tmp8ytoz05e.rs:15:22\n\
    \   |\n15 |     let mut rules = [rule1, rule2, rule3, rule4];\n   |          \
    \            ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `rule2` in this scope\n  --> /tmp/tmp8ytoz05e.rs:15:29\n   |\n15 |     let mut\
    \ rules = [rule1, rule2, rule3, rule4];\n   |                             ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `rule3` in this scope\n\
    \  --> /tmp/tmp8ytoz05e.rs:15:36\n   |\n15 |     let mut rules = [rule1, rule2,\
    \ rule3, rule4];\n   |                                    ^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `rule4` in this scope\n  --> /tmp/tmp8ytoz05e.rs:15:43\n\
    \   |\n15 |     let mut rules = [rule1, rule2, rule3, rule4];\n   |          \
    \                                 ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // TODO\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmeppdboq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let s = &date;\n    if s.len() == 0 {\n        return false;\n\
    \    }\n    if s.len() != 10 {\n        return false;\n    }\n    let a: Vec<&str>\
    \ = s.split(\"-\").collect();\n    if a.len() != 3 {\n        return false;\n\
    \    }\n    if a[0].len() != 2 || a[1].len() != 2 || a[2].len() != 4 {\n     \
    \   return false;\n    }\n    let month: i32 = a[0].parse().unwrap();\n    let\
    \ day: i32 = a[1].parse().unwrap();\n    let year: i32 = a[2].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if day <\
    \ 1 || day > 31 {\n        return false;\n    }\n    if (month == 4 || month ==\
    \ 6 || month == 9 || month == 11) && day > 30 {\n        return false;\n    }\n\
    \    if month == 2 && day > 29 {\n        return false;\n    }\n    if year <\
    \ 1000 || year > 9999 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let mut\
    \ days = 0;\n    let mdy: Vec<i32> = date.split(\"-\").map(|s| s.parse::<i32>().unwrap()).collect();\n\
    \    if mdy.len() != 3 {\n        return false;\n    }\n    if mdy[1] < 1 || mdy[1]\
    \ > 12 {\n        return false;\n    }\n    match mdy[1] {\n        1 | 3 | 5\
    \ | 7 | 8 | 10 | 12 => {\n            days = 31;\n        },\n        4 | 6 |\
    \ 9 | 11 => {\n            days = 30;\n        },\n        2 => {\n          \
    \  days = 29;\n        },\n        _ => {\n            return false;\n       \
    \ }\n    }\n    if mdy[2] < 1 || mdy[2] > days {\n        return false;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw49pe35c.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp80as73bj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n  // your code goes here\n  unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp82vlv9n0.rs:16:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpik1hl4_h.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkm586aco.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut valid = true;\n    let date_vector: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_vector.len() != 3 {\n        valid = false;\n   \
    \ } else {\n        let (month, day, year) = (date_vector[0].parse::<i64>().unwrap(),\n\
    \                                  date_vector[1].parse::<i64>().unwrap(),\n \
    \                                 date_vector[2].parse::<i64>().unwrap());\n \
    \       match month {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n        \
    \        if day < 1 || day > 31 {\n                    valid = false;\n      \
    \          }\n            }\n            4 | 6 | 9 | 11 => {\n               \
    \ if day < 1 || day > 30 {\n                    valid = false;\n             \
    \   }\n            }\n            2 => {\n                if day < 1 || day >\
    \ 29 {\n                    valid = false;\n                }\n            }\n\
    \            _ => {\n                valid = false;\n            }\n        }\n\
    \        if month < 1 || month > 12 {\n            valid = false;\n        }\n\
    \        if year < 1 {\n            valid = false;\n        }\n    }\n    valid\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_regex = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \    date_regex.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpwh3xouuh.rs:15:22\n   |\n15 |     let date_regex = Regex::new(r\"^\\\
    d{2}-\\d{2}-\\d{4}$\").unwrap();\n   |                      ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpabdvu0ip.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut valid_month = false;\n    let mut valid_day = false;\n\
    \    let mut valid_year = false;\n    let mut valid_format = false;\n    let mut\
    \ leap_year = false;\n    let mut date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    let mut year = date_vec[2].parse::<i32>().unwrap();\n    let month = date_vec[0].parse::<i32>().unwrap();\n\
    \    let day = date_vec[1].parse::<i32>().unwrap();\n    if date_vec.len() ==\
    \ 3 {\n        valid_format = true;\n    }\n    if month <= 12 && month >= 1 {\n\
    \        valid_month = true;\n    }\n    if year <= 2020 && year >= 1900 {\n \
    \       valid_year = true;\n    }\n    if month == 1 || month == 3 || month ==\
    \ 5 || month == 7 || month == 8 || month == 10 || month == 12 {\n        if day\
    \ >= 1 && day <= 31 {\n            valid_day = true;\n        }\n    }\n    if\
    \ month == 4 || month == 6 || month == 9 || month == 11 {\n        if day >= 1\
    \ && day <= 30 {\n            valid_day = true;\n        }\n    }\n    if month\
    \ == 2 {\n        if year % 4 == 0 {\n            leap_year = true;\n        }\n\
    \        if leap_year {\n            if day >= 1 && day <= 29 {\n            \
    \    valid_day = true;\n            }\n        } else {\n            if day >=\
    \ 1 && day <= 28 {\n                valid_day = true;\n            }\n       \
    \ }\n    }\n    if valid_day && valid_month && valid_year && valid_format {\n\
    \        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 2', /tmp/tmpnh4viy0m.rs:21:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp83wfxdt8.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\\d{4}$\").unwrap();\n    }\n    RE.is_match(&date)\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpncm_e8u5.rs:15:5\n\
    \   |\n15 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpncm_e8u5.rs:18:5\n   |\n18 |     RE.is_match(&date)\n\
    \   |     ^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() > 0 {\n        let v: Vec<&str> = date.split(\"\
    -\").collect();\n        if v.len() == 3 {\n            if v[0].len() == 2 &&\
    \ v[1].len() == 2 && v[2].len() == 4 {\n                let mut b = true;\n  \
    \              for i in v {\n                    if i.chars().any(|c| !c.is_digit(10))\
    \ {\n                        b = false;\n                    }\n             \
    \   }\n                if b {\n                    let m = v[0].parse::<i32>().unwrap();\n\
    \                    let d = v[1].parse::<i32>().unwrap();\n                 \
    \   let y = v[2].parse::<i32>().unwrap();\n                    if m > 0 && m <\
    \ 13 {\n                        if m == 1 || m == 3 || m == 5 || m == 7 || m ==\
    \ 8 || m == 10 || m == 12 {\n                            if d > 0 && d < 32 {\n\
    \                                return true;\n                            }\n\
    \                        } else if m == 4 || m == 6 || m == 9 || m == 11 {\n \
    \                           if d > 0 && d < 31 {\n                           \
    \     return true;\n                            }\n                        } else\
    \ if m == 2 {\n                            if d > 0 && d < 30 {\n            \
    \                    return true;\n                            }\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `y`\n  --> /tmp/tmpt9bbl1rb.rs:28:25\n   |\n\
    28 |                     let y = v[2].parse::<i32>().unwrap();\n   |         \
    \                ^ help: if this is intentional, prefix it with an underscore:\
    \ `_y`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `v`\n   --> /tmp/tmpt9bbl1rb.rs:26:29\n    |\n16  | \
    \        let v: Vec<&str> = date.split(\"-\").collect();\n    |             -\
    \ move occurs because `v` has type `Vec<&str>`, which does not implement the `Copy`\
    \ trait\n...\n20  |                 for i in v {\n    |                      \
    \    - `v` moved due to this implicit call to `.into_iter()`\n...\n26  |     \
    \                let m = v[0].parse::<i32>().unwrap();\n    |                \
    \             ^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `v`\nhelp: consider iterating\
    \ over a slice of the `Vec<&str>`'s content to avoid moving into the `for` loop\n\
    \    |\n20  |                 for i in &v {\n    |                          +\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfm7uoof2.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp90i4zwao.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // unimplemented!(\"Validate date = {:?}\", date);\n    false\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy6jpzl4s.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let days = [\"0\", \"31\", \"29\", \"31\", \"30\", \"31\", \"\
    30\", \"31\", \"31\", \"30\", \"31\", \"30\", \"31\"];\n    let date_data: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if date_data.len() != 3 {\n        return\
    \ false;\n    }\n    if date_data[0].parse::<i32>().unwrap() < 1 || date_data[0].parse::<i32>().unwrap()\
    \ > 12 {\n        return false;\n    }\n    if date_data[1].parse::<i32>().unwrap()\
    \ < 1 || date_data[1].parse::<i32>().unwrap() > days[date_data[0].parse::<i32>().unwrap()\
    \ as usize].parse::<i32>().unwrap() {\n        return false;\n    }\n    if date_data[2].parse::<i32>().unwrap()\
    \ < 0 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n  \
    \  let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut chars = date.chars();\n    let is_valid = |chars: &mut\
    \ std::str::Chars| {\n        let month: u32 = match chars.next() {\n        \
    \    Some(ch) => match ch.to_digit(10) {\n                Some(i) => i,\n    \
    \            None => return false,\n            },\n            None => return\
    \ false,\n        };\n        if month < 1 || month > 12 {\n            return\
    \ false;\n        }\n        if !chars.next().unwrap().eq(&'-') {\n          \
    \  return false;\n        }\n        let day: u32 = match chars.next() {\n   \
    \         Some(ch) => match ch.to_digit(10) {\n                Some(i) => i,\n\
    \                None => return false,\n            },\n            None => return\
    \ false,\n        };\n        let year: u32 = match chars.next() {\n         \
    \   Some(ch) => match ch.to_digit(10) {\n                Some(i) => i,\n     \
    \           None => return false,\n            },\n            None => return\
    \ false,\n        };\n        if day > 31 {\n            return false;\n     \
    \   }\n        if !chars.next().unwrap().eq(&'-') {\n            return false;\n\
    \        }\n        if day > 29 && month == 2 {\n            return false;\n \
    \       }\n        if month == 2 && day == 29 && year % 4 != 0 {\n           \
    \ return false;\n        }\n        if day > 30 && (month == 4 || month == 6 ||\
    \ month == 9 || month == 11) {\n            return false;\n        }\n       \
    \ true\n    };\n    is_valid(&mut chars)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_vr9g3no.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_regex = Regex::new(r\"^([0][1-9]|[1][0-2])-([0][1-9]|[1-2][0-9]|[3][0-1])-([0-9]{4})$\"\
    ).unwrap();\n    date_regex.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpckhtdedw.rs:15:22\n   |\n15 |     let date_regex = Regex::new(r\"^([0][1-9]|[1][0-2])-([0][1-9]|[1-2][0-9]|[3][0-1])-([0-9]{4})$\"\
    ).unwrap();\n   |                      ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // unimplemented!();\n    \n    // if date is empty, return false\n\
    \    if date.is_empty() { return false; }\n    \n    // store days and months\
    \ in variables\n    let days: String = date[..2].to_string();\n    let months:\
    \ String = date[3..5].to_string();\n    let years: String = date[6..].to_string();\n\
    \    \n    // convert days and months to integers\n    let days: i32 = days.parse().unwrap();\n\
    \    let months: i32 = months.parse().unwrap();\n    let years: i32 = years.parse().unwrap();\n\
    \    \n    // check if the date is valid, if the condition is false then return\
    \ false, if the condition is true then return true\n    if date.contains(\"-\"\
    ) && (days >= 1 && days <= 31) && (months >= 1 && months <= 12) && (years >= 2000\
    \ && years <= 2040) { return true; }\n    else { return false; }\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyeqkrj4h.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut total = 0;\n    for &c in date.as_bytes() {\n       \
    \ if !(c >= b'0' && c <= b'9') && c != b'-' {\n            return false;\n   \
    \     }\n        total += c;\n    }\n    let parts: Vec<&str> = date.split('-').collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    let month = match\
    \ parts[0].parse::<u32>() {\n        Ok(m) => m,\n        Err(_) => return false,\n\
    \    };\n    let day = match parts[1].parse::<u32>() {\n        Ok(d) => d,\n\
    \        Err(_) => return false,\n    };\n    let year = match parts[2].parse::<u32>()\
    \ {\n        Ok(y) => y,\n        Err(_) => return false,\n    };\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n    if day < 1 || day > 31\
    \ {\n        return false;\n    }\n    if (month == 4 || month == 6 || month ==\
    \ 9 || month == 11) && day > 30 {\n        return false;\n    }\n    if month\
    \ == 2 && day > 29 {\n        return false;\n    }\n    total == 0\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to add with overflow', /tmp/tmpzcv_gyg_.rs:20:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // You may use this function to create a list of tuples given\
    \ two lists:\n    //let zip = list_zip([1,2,3], ['a', 'b', 'c']);\n    // zip:\
    \ [(1, 'a'), (2, 'b'), (3, 'c')]\n    fn list_zip<T, U>(list1: Vec<T>, list2:\
    \ Vec<U>) -> Vec<(T, U)> {\n        let mut zipped: Vec<(T, U)> = Vec::new();\n\
    \        for item1 in list1 {\n            for item2 in list2.iter() {\n     \
    \           zipped.push((item1, *item2));\n            }\n        }\n        zipped\n\
    \    }\n\n    let date_splitted: Vec<&str> = date.split(\"-\").collect();\n  \
    \  let zip = list_zip(vec![0, 1, 2], vec![\"31\", \"12\", \"9999\"]);\n    let\
    \ mut is_valid = true;\n    let mut day_month_year: Vec<i32> = Vec::new();\n \
    \   if date_splitted.len() != 3 {\n        is_valid = false;\n    }\n    if is_valid\
    \ {\n        for (i, x) in date_splitted.iter().enumerate() {\n            let\
    \ y: i32 = x.parse().unwrap();\n            if y > zip[i].0 as i32 {\n       \
    \         is_valid = false;\n            }\n            day_month_year.push(y);\n\
    \        }\n    }\n    if is_valid {\n        if day_month_year[0] == 4 || day_month_year[0]\
    \ == 6 || day_month_year[0] == 9 || day_month_year[0] == 11 {\n            if\
    \ day_month_year[1] > 30 {\n                is_valid = false;\n            }\n\
    \        } else if day_month_year[0] == 2 {\n            if day_month_year[1]\
    \ > 29 {\n                is_valid = false;\n            }\n        }\n    }\n\
    \    is_valid\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `item1`\n  --> /tmp/tmpazo40my0.rs:22:30\n\
    \   |\n20 |         for item1 in list1 {\n   |             -----\n   |       \
    \      |\n   |             this reinitialization might get skipped\n   |     \
    \        move occurs because `item1` has type `T`, which does not implement the\
    \ `Copy` trait\n21 |             for item2 in list2.iter() {\n22 |           \
    \      zipped.push((item1, *item2));\n   |                              ^^^^^\
    \ value moved here, in previous iteration of loop\n   |\nhelp: consider restricting\
    \ type parameter `T`\n   |\n18 |     fn list_zip<T: Copy, U>(list1: Vec<T>, list2:\
    \ Vec<U>) -> Vec<(T, U)> {\n   |                  ++++++\n\nerror[E0507]: cannot\
    \ move out of `*item2` which is behind a shared reference\n  --> /tmp/tmpazo40my0.rs:22:37\n\
    \   |\n22 |                 zipped.push((item1, *item2));\n   |              \
    \                       ^^^^^^ move occurs because `*item2` has type `U`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpx4tctnt4.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // define a vector of valid months\n    let valid_months = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    // define a vector of valid days for\
    \ each month\n    let valid_days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30,\
    \ 31];\n    // define a vector of valid months with 30 days\n    let months_30_days\
    \ = [4, 6, 9, 11];\n    // define a vector of valid months with 31 days\n    let\
    \ months_31_days = [1, 3, 5, 7, 8, 10, 12];\n    // define a vector of leap years\
    \ to check if the year is valid\n    let leap_years = [1960, 1964, 1968, 1972,\
    \ 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024,\
    \ 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076,\
    \ 2080, 2084, 2088, 2092, 2096];\n    // split the provided date string on the\
    \ separator\n    let mut split_date = date.split(\"-\");\n    // set the day,\
    \ month and year of the date\n    let mut day = split_date.next().unwrap().parse::<i32>().unwrap();\n\
    \    let mut month = split_date.next().unwrap().parse::<i32>().unwrap();\n   \
    \ let mut year = split_date.next().unwrap().parse::<i32>().unwrap();\n    // we\
    \ initialise the date as valid\n    let mut valid = true;\n    // check if the\
    \ date is valid\n    if date.len() != 10 {\n        valid = false;\n    }\n  \
    \  if month > 12 || month < 1 {\n        valid = false;\n    }\n    if day > 31\
    \ || day < 1 {\n        valid = false;\n    }\n    if month == 2 && day > 29 {\n\
    \        valid = false;\n    }\n    if months_30_days.contains(&month) && day\
    \ > 30 {\n        valid = false;\n    }\n   \n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqmqez7vg.rs:46:52\n   |\n\
    46 |       if months_30_days.contains(&month) && day > 30 {\n   |  ____________________________________________________^\n\
    47 | |         valid = false;\n48 | |     }\n   | |_____^ expected `bool`, found\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Unimplemented!()\n    // validate length\n    if date.len()\
    \ != 10 {\n        return false;\n    }\n    // validate format\n    if !date.contains(\"\
    -\") {\n        return false;\n    }\n    // split the string\n    let mut dates\
    \ = date.split(\"-\");\n    let mut d = dates.nth(0).unwrap().parse::<i32>().unwrap();\n\
    \    let mut m = dates.nth(0).unwrap().parse::<i32>().unwrap();\n    let mut y\
    \ = dates.nth(0).unwrap().parse::<i32>().unwrap();\n    // return if invalid month\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    // return if invalid\
    \ year\n    if y < 1900 || y > 2100 {\n        return false;\n    }\n    // return\
    \ if invalid day\n    if m == 2 {\n        if y % 4 == 0 {\n            if d <\
    \ 1 || d > 29 {\n                return false;\n            }\n        } else\
    \ {\n            if d < 1 || d > 28 {\n                return false;\n       \
    \     }\n        }\n    } else if m == 1 || m == 3 || m == 5 || m == 7 || m ==\
    \ 8 || m == 10 || m == 12 {\n        if d < 1 || d > 31 {\n            return\
    \ false;\n        }\n    } else {\n        if d < 1 || d > 30 {\n            return\
    \ false;\n        }\n    }\n    // return true if everything is valid\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprhzhn7c5.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n    let days: i32 = v[1].parse().unwrap();\n\
    \    let months: i32 = v[0].parse().unwrap();\n    let years: i32 = v[2].parse().unwrap();\n\
    \    if months > 12 || months < 1 {\n        return false;\n    }\n    if days\
    \ > 31 || days < 1 {\n        return false;\n    }\n    if months == 2 {\n   \
    \     if days > 29 {\n            return false;\n        }\n    }\n    if months\
    \ == 4 || months == 6 || months == 9 || months == 11 {\n        if days > 30 {\n\
    \            return false;\n        }\n    }\n    if v[0].len() != 2 || v[1].len()\
    \ != 2 || v[2].len() != 4 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let mut\
    \ split = date.split('-');\n    let month: u32 = split.next().unwrap().parse().unwrap();\n\
    \    let day: u32 = split.next().unwrap().parse().unwrap();\n    let year: u32\
    \ = split.next().unwrap().parse().unwrap();\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n    if month == 2 {\n        if day < 1 || day\
    \ > 29 {\n            return false;\n        }\n    } else if day < 1 || day >\
    \ 31 {\n        return false;\n    }\n    if month == 4 || month == 6 || month\
    \ == 9 || month == 11 {\n        if day > 30 {\n            return false;\n  \
    \      }\n    }\n    if year < 1 {\n        return false;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp85k9wb_z.rs:20:33\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut it = date.split('-');\n    if let (Some(day), Some(month),\
    \ Some(year)) = (it.next(), it.next(), it.next()) {\n        if day.len() == 2\
    \ && month.len() == 2 && year.len() == 4 {\n            if let (Ok(day), Ok(month),\
    \ Ok(year)) = (day.parse::<u8>(), month.parse::<u8>(), year.parse::<u32>()) {\n\
    \                if day >= 1 && day <= 31 && month >= 1 && month <= 12 && year\
    \ >= 1800 && year <= 2100 {\n                    match month {\n             \
    \           1|3|5|7|8|10|12 => return true,\n                        4|6|9|11\
    \ => return day <= 30,\n                        2 => {\n                     \
    \       if year % 4 == 0 {\n                                return day <= 29;\n\
    \                            } else {\n                                return\
    \ day <= 28;\n                            }\n                        },\n    \
    \                    _ => return false\n                    }\n              \
    \  }\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7w1ixilz.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.len() > 0 && \n    date.chars().filter(|&c| c == '-').count()\
    \ == 2 &&\n    date.chars().filter(|&c| c == '/').count() == 0 &&\n    date.chars().filter(|&c|\
    \ c.is_digit(10)).count() == date.len() &&\n    date.chars().filter(|&c| c ==\
    \ '-').count() == 2 &&\n    date.chars().filter(|&c| c == '/').count() == 0 &&\n\
    \    date.chars().filter(|&c| c.is_digit(10)).count() == date.len() &&\n    match\
    \ (&date[..2], &date[3..5], &date[6..]) {\n        (m, d, y) => {\n          \
    \  let d = d.parse::<u8>().unwrap();\n            let m = m.parse::<u8>().unwrap();\n\
    \            match m {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => d <= 31,\n\
    \                4 | 6 | 9 | 11 => d <= 30,\n                2 => d <= 29,\n \
    \               _ => false\n            }\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpc6ip6qd7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut v: Vec<&str> = date.split('-').collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n    let month = v[0].parse::<i32>().unwrap();\n\
    \    let day = v[1].parse::<i32>().unwrap();\n    let year = v[2].parse::<i32>().unwrap();\n\
    \    if year < 1 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if day < 1 {\n        return false;\n\
    \    }\n    if (month == 1 || month == 3 || month == 5 || month == 7 || month\
    \ == 8 || month == 10 || month == 12) && day > 31 {\n        return false;\n \
    \   }\n    if (month == 4 || month == 6 || month == 9 || month == 11) && day >\
    \ 30 {\n        return false;\n    }\n    if month == 2 && day > 29 {\n      \
    \  return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\
    \    let (month, day, year) = match parse_date(date) {\n        Some(x) => x,\n\
    \        None => return false,\n    };\n    return year > 0 && year < 9999 &&\
    \ month > 0 && month < 13 &&\n           (day > 0 && day <= months[month - 1]\
    \ || month == 2 && day == 29 && is_leap_year(year));\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_date` in this scope\n  --> /tmp/tmp1svx6e52.rs:16:36\n\
    \   |\n16 |     let (month, day, year) = match parse_date(date) {\n   |      \
    \                              ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_leap_year` in this scope\n  --> /tmp/tmp1svx6e52.rs:21:79\n\
    \   |\n21 |            (day > 0 && day <= months[month - 1] || month == 2 && day\
    \ == 29 && is_leap_year(year));\n   |                                        \
    \                                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpik8sd_yc.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // your code goes here\n    let v: Vec<&str> = date.split(\"\
    -\").collect();\n    let mut valid = false;\n    let mut year = 0;\n    let mut\
    \ month = 0;\n    let mut day = 0;\n    if v.len() == 3 {\n        match v[0].parse::<u32>()\
    \ {\n            Ok(n) => {\n                month = n;\n                match\
    \ v[1].parse::<u32>() {\n                    Ok(n) => {\n                    \
    \    day = n;\n                        match v[2].parse::<u32>() {\n         \
    \                   Ok(n) => {\n                                year = n;\n  \
    \                              valid = true;\n                            },\n\
    \                            Err(_) => {},\n                        }\n      \
    \              },\n                    Err(_) => {},\n                }\n    \
    \        },\n            Err(_) => {},\n        }\n    }\n    if !valid {\n  \
    \      return false;\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n    if day < 1 || day > 31 {\n        return false;\n    }\n\
    \    if month == 2 {\n        if day > 29 {\n            return false;\n     \
    \   }\n    }\n    if month == 4 || month == 6 || month == 9 || month == 11 {\n\
    \        if day > 30 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplucp06v5.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut valid = false;\n    let re = Regex::new(r\"^(\\d{2})-(\\\
    d{2})-(\\d{4})$\").unwrap();\n    if let Some(caps) = re.captures(&date) {\n \
    \       if let Ok(m) = caps[1].parse::<i32>() {\n            if let Ok(d) = caps[2].parse::<i32>()\
    \ {\n                if let Ok(y) = caps[3].parse::<i32>() {\n               \
    \     if m >= 1 && m <= 12 {\n                        if m == 2 {\n          \
    \                  if d >= 1 && d <= 29 {\n                                valid\
    \ = true;\n                            }\n                        } else if m\
    \ == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n     \
    \                       if d >= 1 && d <= 31 {\n                             \
    \   valid = true;\n                            }\n                        } else\
    \ {\n                            if d >= 1 && d <= 30 {\n                    \
    \            valid = true;\n                            }\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \    }\n    valid\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmppslwxrl3.rs:16:14\n   |\n16 |     let re = Regex::new(r\"^(\\d{2})-(\\\
    d{2})-(\\d{4})$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \    let mut result = false;\n    if re.is_match(&date) {\n        let date_array:\
    \ Vec<i32> = date.split(\"-\").map(|x| x.parse::<i32>().unwrap()).collect();\n\
    \        if date_array[0] > 0 && date_array[0] < 13 {\n            if date_array[0]\
    \ == 2 {\n                if date_array[1] > 0 && date_array[1] < 30 {\n     \
    \               result = true;\n                }\n            } else if date_array[0]\
    \ == 1 || date_array[0] == 3 || date_array[0] == 5 || date_array[0] == 7 || date_array[0]\
    \ == 8 || date_array[0] == 10 || date_array[0] == 12 {\n                if date_array[1]\
    \ > 0 && date_array[1] < 32 {\n                    result = true;\n          \
    \      }\n            } else {\n                if date_array[1] > 0 && date_array[1]\
    \ < 31 {\n                    result = true;\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpwpf9plvh.rs:15:14\n   |\n15 |     let re = Regex::new(r\"^\\d{2}-\\\
    d{2}-\\d{4}$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // unimplemented!(\"date '{}' is {:?}\", date, ...);\n    let\
    \ vec: Vec<&str> = date.split(\"-\").collect();\n    if vec.len() != 3 {\n   \
    \     return false;\n    }\n    if vec[0].len() != 2 || vec[1].len() != 2 || vec[2].len()\
    \ != 4 {\n        return false;\n    }\n    let months: i32 = vec[0].parse().unwrap();\n\
    \    let days: i32 = vec[1].parse().unwrap();\n    let years: i32 = vec[2].parse().unwrap();\n\
    \    if months > 12 || months <= 0 {\n        return false;\n    }\n    if months\
    \ == 2 {\n        if (years % 4 == 0 && years % 100 != 0) || years % 400 == 0\
    \ {\n            if days > 29 || days <= 0 {\n                return false;\n\
    \            }\n        } else {\n            if days > 28 || days <= 0 {\n  \
    \              return false;\n            }\n        }\n    } else if months ==\
    \ 1 || months == 3 || months == 5 || months == 7 || months == 8 || months == 10\
    \ || months == 12 {\n        if days > 31 || days <= 0 {\n            return false;\n\
    \        }\n    } else {\n        if days > 30 || days <= 0 {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let parts: Vec<&str> = date.split(\"-\").collect();\n    if parts.len()\
    \ == 3 {\n        let mut parts: Vec<u32> = Vec::new();\n        for part in parts\
    \ {\n            let num = part.parse::<u32>();\n            match num {\n   \
    \             Ok(n) => parts.push(n),\n                Err(_) => return false,\n\
    \            }\n        }\n        let months: Vec<u32> = vec![1,3,5,7,8,10,12];\n\
    \        if parts[0] > 0 && parts[0] < 13 {\n            if parts[0] == 2 {\n\
    \                if parts[1] > 0 && parts[1] < 30 {\n                    return\
    \ true;\n                }\n            } else if months.contains(&parts[0]) {\n\
    \                if parts[1] > 0 && parts[1] < 32 {\n                    return\
    \ true;\n                }\n            } else {\n                if parts[1]\
    \ > 0 && parts[1] < 31 {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `parse` found for type `u32` in the current\
    \ scope\n  --> /tmp/tmpo8ffncbo.rs:19:28\n   |\n19 |             let num = part.parse::<u32>();\n\
    \   |                            ^^^^^ method not found in `u32`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \    if !re.is_match(&date) {\n        return false;\n    }\n    let date_vec:\
    \ Vec<_> = date.split(\"-\").collect();\n    let month: u32 = date_vec[0].parse().unwrap();\n\
    \    let day: u32 = date_vec[1].parse().unwrap();\n    if month > 12 || month\
    \ < 1 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 |\
    \ 7 | 8 | 10 | 12 => {\n            if day > 31 || day < 1 {\n               \
    \ return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n     \
    \       if day > 30 || day < 1 {\n                return false;\n            }\n\
    \        }\n        2 => {\n            if day > 29 || day < 1 {\n           \
    \     return false;\n            }\n        }\n        _ => {}\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpj5mb6_k6.rs:15:14\n   |\n15 |     let re = Regex::new(r\"^\\d{2}-\\\
    d{2}-\\d{4}$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8aq683i3.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.parse::<DateTime<Local>>().is_ok()\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `DateTime` in this scope\n  --> /tmp/tmpu7x6i9vq.rs:15:18\n\
    \   |\n15 |     date.parse::<DateTime<Local>>().is_ok()\n   |                \
    \  ^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Local`\
    \ in this scope\n  --> /tmp/tmpu7x6i9vq.rs:15:27\n   |\n14 | fn valid_date(date:\
    \ String) -> bool {\n   |              - help: you might be missing a type parameter:\
    \ `<Local>`\n15 |     date.parse::<DateTime<Local>>().is_ok()\n   |          \
    \                 ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if !date.contains('-') {\n        return false;\n    }\n    let\
    \ days = &date[0..2];\n    let months = &date[3..5];\n    let years = &date[6..10];\n\
    \    if days.parse::<u32>().unwrap() > 31 || months.parse::<u32>().unwrap() >\
    \ 12 {\n        return false;\n    }\n    if days.parse::<u32>().unwrap() > 30\
    \ &&\n        (months.parse::<u32>().unwrap() == 4 || months.parse::<u32>().unwrap()\
    \ == 6 ||\n         months.parse::<u32>().unwrap() == 9 || months.parse::<u32>().unwrap()\
    \ == 11) {\n        return false;\n    }\n    if days.parse::<u32>().unwrap()\
    \ > 29 && months.parse::<u32>().unwrap() == 2 {\n        return false;\n    }\n\
    \    if days.parse::<u32>().unwrap() > 28 && months.parse::<u32>().unwrap() ==\
    \ 2 &&\n        (years.parse::<u32>().unwrap() % 4) != 0 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppwbo9yjf.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n  \
    \  if date_split.len() != 3 {\n        return false;\n    }\n    for str in date_split\
    \ {\n        for char in str.chars() {\n            if !char.is_digit(10) {\n\
    \                return false;\n            }\n        }\n    }\n    let day:\
    \ i32 = date_split[1].parse().unwrap();\n    let month: i32 = date_split[0].parse().unwrap();\n\
    \    let year: i32 = date_split[2].parse().unwrap();\n    if day < 1 || month\
    \ < 1 || year < 1 {\n        return false;\n    }\n    match month {\n       \
    \ 1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <=\
    \ 30,\n        2 => {\n            if year % 400 == 0 || (year % 4 == 0 && year\
    \ % 100 != 0) {\n                day <= 29\n            } else {\n           \
    \     day <= 28\n            }\n        }\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `date_split`\n   --> /tmp/tmprmh6uiwn.rs:26:20\n\
    \    |\n15  |     let date_split: Vec<&str> = date.split(\"-\").collect();\n \
    \   |         ---------- move occurs because `date_split` has type `Vec<&str>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for str in date_split\
    \ {\n    |                ---------- `date_split` moved due to this implicit call\
    \ to `.into_iter()`\n...\n26  |     let day: i32 = date_split[1].parse().unwrap();\n\
    \    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `date_split`\n\
    help: consider iterating over a slice of the `Vec<&str>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for str in &date_split {\n    |      \
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5m7t46px.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let (day, month, year) = get_date(date);\n    if day == 0 ||\
    \ month == 0 || year == 0 {\n        return false;\n    }\n    let (max_day, leap_year)\
    \ = get_max_day(month, year);\n    if day > max_day {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_date` in this scope\n  --> /tmp/tmp9qthl064.rs:15:30\n\
    \   |\n15 |     let (day, month, year) = get_date(date);\n   |               \
    \               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `get_max_day` in this scope\n  --> /tmp/tmp9qthl064.rs:19:32\n   |\n\
    19 |     let (max_day, leap_year) = get_max_day(month, year);\n   |          \
    \                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let months = [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\"\
    , \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    let splitted: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if splitted.len() != 3 {\n        return\
    \ false;\n    }\n    let month = splitted[0];\n    let day = splitted[1];\n  \
    \  let year = splitted[2];\n    if !months.contains(&month) {\n        return\
    \ false;\n    }\n    if !month.chars().all(|x| x.is_digit(10)) || !day.chars().all(|x|\
    \ x.is_digit(10)) || !year.chars().all(|x| x.is_digit(10)) {\n        return false;\n\
    \    }\n    let day_ = day.parse::<i32>().unwrap();\n    let month_ = month.parse::<i32>().unwrap();\n\
    \    let year_ = year.parse::<i32>().unwrap();\n    if month_ > 12 || month_ <\
    \ 1 {\n        return false;\n    }\n    if year_ < 1 {\n        return false;\n\
    \    }\n    if (month_ % 2 == 1 && month_ < 8) || (month_ % 2 == 0 && month_ >\
    \ 7) {\n        if day_ > 31 || day_ < 1 {\n            return false;\n      \
    \  }\n    } else if month_ != 2 {\n        if day_ > 30 || day_ < 1 {\n      \
    \      return false;\n        }\n    } else {\n        if year_ % 4 == 0 {\n \
    \           if day_ > 29 || day_ < 1 {\n                return false;\n      \
    \      }\n        } else {\n            if day_ > 28 || day_ < 1 {\n         \
    \       return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date = date.trim().to_string();\n    let date_array: Vec<&str>\
    \ = date.split(\"-\").collect();\n    let length: usize = date_array.len();\n\
    \    // println!(\"date={}, date_array={:?}, length={}\", date, date_array, length);\n\
    \    if length != 3 {\n        return false;\n    }\n    let mut days: i32 = 0;\n\
    \    let mut month: i32 = 0;\n    let mut year: i32 = 0;\n    if let Ok(d) = date_array[1].parse::<i32>()\
    \ {\n        days = d;\n    } else {\n        return false;\n    }\n    if let\
    \ Ok(m) = date_array[0].parse::<i32>() {\n        month = m;\n    } else {\n \
    \       return false;\n    }\n    if let Ok(y) = date_array[2].parse::<i32>()\
    \ {\n        year = y;\n    } else {\n        return false;\n    }\n    // println!(\"\
    days={}, month={}, year={}\", days, month, year);\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    if month == 2 {\n        if days < 1\
    \ || days > 29 {\n            return false;\n        }\n    } else if month ==\
    \ 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 ||\
    \ month == 12 {\n        if days < 1 || days > 31 {\n            return false;\n\
    \        }\n    } else {\n        if days < 1 || days > 30 {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // TODO\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkqb746wk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let parts:\
    \ Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return\
    \ false;\n    }\n    if parts[0].len() != 2 || parts[1].len() != 2 || parts[2].len()\
    \ != 4 {\n        return false;\n    }\n    let day: i32 = parts[1].parse().unwrap();\n\
    \    let month: i32 = parts[0].parse().unwrap();\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    let days_of_month = [31, 29, 31, 30,\
    \ 31, 30, 31, 31, 30, 31, 30, 31];\n    if day < 1 || day > days_of_month[(month\
    \ - 1) as usize] {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut days = Vec::new();\n    let mut months = Vec::new();\n\
    \    let mut years = Vec::new();\n    for d in date.split(\"-\") {\n        match\
    \ d.parse::<u32>() {\n            Ok(i) => {\n                let b = i % 10;\n\
    \                let a = i / 10;\n                if b > 0 {\n               \
    \     months.push(a);\n                    days.push(b);\n                } else\
    \ {\n                    months.push(i);\n                }\n            }\n \
    \           Err(_) => {\n                for d in d.split(\"/\") {\n         \
    \           match d.parse::<u32>() {\n                        Ok(i) => {\n   \
    \                         years.push(i);\n                        }\n        \
    \                Err(_) => {\n                            return false;\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n    }\n    if days.len() < 1 || months.len() < 1 || years.len()\
    \ < 1 {\n        return false;\n    }\n    if days[0] == 0 || months[0] == 0 ||\
    \ years[0] == 0 {\n        return false;\n    }\n    if months[0] > 12 {\n   \
    \     return false;\n    }\n    if days[0] > 31 && months[0] == 1 || days[0] >\
    \ 31 && months[0] == 3 || days[0] > 31 && months[0] == 5 || days[0] > 31 && months[0]\
    \ == 7 || days[0] > 31 && months[0] == 8 || days[0] > 31 && months[0] == 10 ||\
    \ days[0] > 31 && months[0] == 12 {\n        return false;\n    }\n    if days[0]\
    \ > 30 && months[0] == 4 || days[0] > 30 && months[0] == 6 || days[0] > 30 &&\
    \ months[0] == 9 || days[0] > 30 && months[0] == 11 {\n        return false;\n\
    \    }\n    if days[0] > 29 && months[0] == 2 {\n        return false;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptyk62045.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Should be valid dates\n    assert_eq!(valid_date(\"03-11-2000\"\
    .to_string()), true);\n    assert_eq!(valid_date(\"06-04-2020\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"01-01-2000\".to_string()), true);\n    assert_eq!(valid_date(\"\
    30-12-2020\".to_string()), true);\n    assert_eq!(valid_date(\"29-02-2000\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"29-02-2004\".to_string()), true);\n    assert_eq!(valid_date(\"\
    28-02-2005\".to_string()), true);\n    assert_eq!(valid_date(\"28-02-1900\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"29-02-1900\".to_string()), false);\n   \
    \ assert_eq!(valid_date(\"29-02-2000\".to_string()), true);\n    assert_eq!(valid_date(\"\
    29-02-2012\".to_string()), true);\n    assert_eq!(valid_date(\"29-02-2016\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"29-02-2020\".to_string()), true);\n    assert_eq!(valid_date(\"\
    29-02-2024\".to_string()), true);\n    assert_eq!(valid_date(\"29-02-2028\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"29-02-2032\".to_string()), true);\n    assert_eq!(valid_date(\"\
    29-02-2036\".to_string()), true);\n    assert_eq!(valid_date(\"29-02-2040\".to_string()),\
    \ true);\n    assert_eq!(valid_date(\"29-02-2044\".to_string()), true);\n    assert_eq!(valid_date(\"\
    29-02-2048\".to_string()), true);\n    assert_eq!(valid_date(\"29-02-2052\".\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpdhk_ok20.rs:36:26\n\
    \   |\n14 | fn valid_date(date: String) -> bool {\n   |                      \
    \               - closing delimiter possibly meant for this\n...\n36 |     assert_eq!(valid_date(\"\
    29-02-2052\".\n   |                          ^ unclosed delimiter\n37 | }\n  \
    \ | ^ mismatched closing delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmpdhk_ok20.rs:37:1\n\
    \   |\n37 | }\n   | ^\n\nerror: unexpected end of macro invocation\n  --> /tmp/tmpdhk_ok20.rs:37:2\n\
    \   |\n37 | }\n   |  ^ missing tokens in macro arguments\n\nerror: aborting due\
    \ to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ximg_nn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() != 10 {\n        return false;\n    }\n    let\
    \ date_vec: Vec<&str> = date.split(\"-\").collect();\n    let day = date_vec[1].parse::<i32>().unwrap();\n\
    \    let month = date_vec[0].parse::<i32>().unwrap();\n    let year = date_vec[2].parse::<i32>().unwrap();\n\
    \    if month > 12 || month < 1 {\n        return false;\n    }\n    match month\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => if day > 31 || day < 1 {\n       \
    \     return false;\n        },\n        4 | 6 | 9 | 11 => if day > 30 || day\
    \ < 1 {\n            return false;\n        },\n        2 => if day > 29 || day\
    \ < 1 {\n            return false;\n        },\n        _ => return false,\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() == 0 {\n        return false;\n    }\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_split.len() != 3 {\n \
    \       return false;\n    }\n    let day: u32 = match date_split[1].parse() {\n\
    \        Ok(num) => num,\n        Err(_) => return false,\n    };\n    let month:\
    \ u32 = match date_split[0].parse() {\n        Ok(num) => num,\n        Err(_)\
    \ => return false,\n    };\n    let year: u32 = match date_split[2].parse() {\n\
    \        Ok(num) => num,\n        Err(_) => return false,\n    };\n    if day\
    \ < 1 || day > 31 || month < 1 || month > 12 {\n        return false;\n    }\n\
    \    let is_leap_year = |year: u32| -> bool {\n        if year % 4 == 0 {\n  \
    \          if year % 100 == 0 {\n                if year % 400 == 0 {\n      \
    \              return true;\n                }\n                return false;\n\
    \            }\n            return true;\n        }\n        return false;\n \
    \   };\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => true,\n    \
    \    4 | 6 | 9 | 11 => {\n            if day <= 30 {\n                return true;\n\
    \            }\n            return false;\n        }\n        2 => {\n       \
    \     if is_leap_year(year) {\n                if day <= 29 {\n              \
    \      return true;\n                }\n                return false;\n      \
    \      } else {\n                if day <= 28 {\n                    return true;\n\
    \                }\n                return false;\n            }\n        }\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let day_str = &date[..2];\n    let month_str = &date[3..5];\n\
    \    let year_str = &date[6..];\n    let day = day_str.parse::<i32>().unwrap();\n\
    \    let month = month_str.parse::<i32>().unwrap();\n    let year = year_str.parse::<i32>().unwrap();\n\
    \    if date.len() == 10 && day <= 31 && month <= 12 && day > 0 && month > 0 &&\
    \ year > 0 {\n        if day <= 30 && (month == 4 || month == 6 || month == 9\
    \ || month == 11) {\n            return true;\n        } else if day <= 29 &&\
    \ month == 2 {\n            return true;\n        } else if day <= 31 && (month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12) {\n            return true;\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp88v5ecir.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.matches(\"[0-9]{2}-[0-9]{2}-[0-9]{4}\").count() == 1\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6ax7y25l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9fev2e2p.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let parts: Vec<&str> = date.split(\"-\").collect();\n    if parts.len()\
    \ != 3 {\n        return false;\n    }\n    let year: i32 = parts[2].parse().unwrap();\n\
    \    let month: i32 = parts[0].parse().unwrap();\n    let day: i32 = parts[1].parse().unwrap();\n\
    \    match month {\n        2 => day < 1 || day > 29,\n        4 | 6 | 9 | 11\
    \ => day < 1 || day > 30,\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => day < 1 || day\
    \ > 31,\n        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzpk8cq9w.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkprrbvoi.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp531es0kt.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp8w4iv349.rs:15:14\n   |\n15 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut valid = true;\n    let mut year = String::new();\n  \
    \  let mut month = String::new();\n    let mut day = String::new();\n    if date.len()\
    \ != 10 {\n        valid = false;\n    } else {\n        let date_split: Vec<&str>\
    \ = date.split(\"-\").collect();\n        if date_split.len() != 3 {\n       \
    \     valid = false;\n        } else {\n            year = date_split[2].to_string();\n\
    \            month = date_split[0].to_string();\n            day = date_split[1].to_string();\n\
    \            let year_int: u32 = year.parse().unwrap();\n            let month_int:\
    \ u32 = month.parse().unwrap();\n            let day_int: u32 = day.parse().unwrap();\n\
    \            if month_int > 12 || month_int < 1 {\n                valid = false;\n\
    \            } else if month_int == 2 && (day_int > 29 || day_int < 1) {\n   \
    \             valid = false;\n            } else if (month_int == 4 || month_int\
    \ == 6 || month_int == 9 || month_int == 11) && (day_int > 30 || day_int < 1)\
    \ {\n                valid = false;\n            } else if (month_int == 1 ||\
    \ month_int == 3 || month_int == 5 || month_int == 7 || month_int == 8 || month_int\
    \ == 10 || month_int == 12) && (day_int > 31 || day_int < 1) {\n             \
    \   valid = false;\n            }\n        }\n    }\n    valid\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_format = date.as_bytes();\n    if date_format.len()\
    \ == 10 {\n        let month = date[0..2].parse::<i32>().unwrap();\n        let\
    \ day = date[3..5].parse::<i32>().unwrap();\n        let year = date[6..10].parse::<i32>().unwrap();\n\
    \        let is_month_valid = month >= 1 && month <= 12;\n        let is_day_valid\
    \ = match month {\n            2 => day >= 1 && day <= 29,\n            4 | 6\
    \ | 9 | 11 => day >= 1 && day <= 30,\n            _ => day >= 1 && day <= 31\n\
    \        };\n        is_month_valid && is_day_valid && year > 0\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpnk89t47r.rs:18:45\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl6ywqmi5.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(19[0-9]{2}|20[0-9]{2})$\").unwrap();\n\
    \    }\n    if RE.is_match(&date) {\n        let date: Vec<&str> = date.split(\"\
    -\").collect();\n        let day = date[1].parse::<u32>().unwrap();\n        let\
    \ month = date[0].parse::<u32>().unwrap();\n        if (1..32).contains(&day)\
    \ && (1..13).contains(&month) {\n            true\n        } else {\n        \
    \    false\n        }\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpjliokoni.rs:15:5\n\
    \   |\n15 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpjliokoni.rs:18:8\n   |\n18 |     if\
    \ RE.is_match(&date) {\n   |        ^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut value: Vec<u32> = Vec::new();\n    let d: String = String::from(\"\
    -\");\n    let mut part: Vec<&str> = date.split(d.as_str()).collect();\n    for\
    \ mut c in part.iter_mut() {\n        value.push(c.parse::<u32>().unwrap())\n\
    \    }\n    match value[0] {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n     \
    \       if value[1] > 31 {\n                return false;\n            }\n   \
    \     }\n        4 | 6 | 9 | 11 => {\n            if value[1] > 30 {\n       \
    \         return false;\n            }\n        }\n        2 => {\n          \
    \  if value[1] > 29 {\n                return false;\n            }\n        }\n\
    \        _ => {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphhi82kna.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let valid_separators = [\"-\", \"/\"];\n    for sep in valid_separators.iter()\
    \ {\n        let v: Vec<&str> = date.split(sep).collect();\n        if v.len()\
    \ == 3 {\n            let re = Regex::new(r\"(0[1-9]|1[0-2])\").unwrap();\n  \
    \          if re.is_match(v[0]) {\n                let v0: u32 = v[0].parse().unwrap();\n\
    \                if v0 >= 1 && v0 <= 12 {\n                    let re = Regex::new(r\"\
    (0[1-9]|[12][0-9]|3[01])\").unwrap();\n                    if re.is_match(v[1])\
    \ {\n                        let v1: u32 = v[1].parse().unwrap();\n          \
    \              if v1 >= 1 && v1 <= 31 {\n                            if (v0 ==\
    \ 1 || v0 == 3 || v0 == 5 || v0 == 7 || v0 == 8 || v0 == 10 || v0 == 12) && v1\
    \ > 31 {\n                                return false;\n                    \
    \        }\n                            if (v0 == 4 || v0 == 6 || v0 == 9 || v0\
    \ == 11) && v1 > 30 {\n                                return false;\n       \
    \                     }\n                            if v0 == 2 && v1 > 29 {\n\
    \                                return false;\n                            }\n\
    \                            let re = Regex::new(r\"(\\d{4})\").unwrap();\n  \
    \                          if re.is_match(v[2]) {\n                          \
    \      return true;\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpre6s8mbu.rs:19:22\n   |\n19 |             let re = Regex::new(r\"(0[1-9]|1[0-2])\"\
    ).unwrap();\n   |                      ^^^^^ use of undeclared type `Regex`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmpre6s8mbu.rs:23:30\n\
    \   |\n23 |                     let re = Regex::new(r\"(0[1-9]|[12][0-9]|3[01])\"\
    ).unwrap();\n   |                              ^^^^^ use of undeclared type `Regex`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmpre6s8mbu.rs:36:38\n\
    \   |\n36 | ...                   let re = Regex::new(r\"(\\d{4})\").unwrap();\n\
    \   |                                ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_pattern = Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\"\
    ).unwrap();\n    let month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\
    \ 31];\n    if !date_pattern.is_match(&date) {\n        return false;\n    }\n\
    \    let captures = date_pattern.captures(&date).unwrap();\n    let month = captures[1].parse::<u8>().unwrap();\n\
    \    let day = captures[2].parse::<u8>().unwrap();\n    let year = captures[3].parse::<u32>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if month\
    \ == 2 && day > 29 {\n        return false;\n    }\n    if (month == 4 || month\
    \ == 6 || month == 9 || month == 11) && day > 30 {\n        return false;\n  \
    \  }\n    if month == 2 && year % 4 == 0 && day > 28 {\n        return false;\n\
    \    }\n    if day > month_days[month as usize - 1] {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpc9wlazyt.rs:15:24\n   |\n15 |     let date_pattern = Regex::new(r\"\
    (\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n   |                        ^^^^^ use\
    \ of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_string: Vec<&str> = date.split(\"-\").collect();\n \
    \   if date_string.len() != 3 {\n        return false;\n    }\n    let month =\
    \ date_string[0].parse::<i8>().unwrap();\n    let day = date_string[1].parse::<i8>().unwrap();\n\
    \    let year = date_string[2].parse::<i16>().unwrap();\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n       \
    \ return false;\n    }\n    if month == 2 && (day < 1 || day > 29) {\n       \
    \ return false;\n    }\n    if (month == 4 || month == 6 || month == 9 || month\
    \ == 11) && (day < 1 || day > 30) {\n        return false;\n    }\n    if year\
    \ < 0 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n  \
    \  let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmpz_734gcy.rs:19:46\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // your code here\n    let mut day_arr = [31, 30, 29, 28];\n\
    \    let mut month_arr = [31, 12];\n    let mut date_arr: Vec<String> = date.split(\"\
    -\").map(|s| s.to_string()).collect();\n    if !date_arr.is_empty() {\n      \
    \  for i in 0..3 {\n            if !date_arr[i].parse::<i32>().is_ok() {\n   \
    \             return false;\n            }\n        }\n        if date_arr[0].parse::<i32>().unwrap()\
    \ > month_arr[0] || date_arr[0].parse::<i32>().unwrap() <= 0 {\n            return\
    \ false;\n        }\n        if date_arr[1].parse::<i32>().unwrap() > month_arr[1]\
    \ || date_arr[1].parse::<i32>().unwrap() <= 0 {\n            return false;\n \
    \       }\n        let day = date_arr[2].parse::<i32>().unwrap();\n        let\
    \ month = date_arr[0].parse::<i32>().unwrap();\n        if day > 0 && day <= day_arr[0]\
    \ && (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month\
    \ == 10 || month == 12) {\n            return true;\n        }\n        if day\
    \ > 0 && day <= day_arr[1] && (month == 4 || month == 6 || month == 9 || month\
    \ == 11) {\n            return true;\n        }\n        if day > 0 && day <=\
    \ day_arr[2] && month == 2 {\n            return true;\n        }\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpumald1pw.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptkc4f1hz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpywd5z98a.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let d = date.split(\"-\").collect::<Vec<&str>>();\n    let days\
    \ = [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"\
    10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\
    \ \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\"\
    , \"30\", \"31\"];\n    let mut count = 0;\n    let mut d_d = String::new();\n\
    \    let mut d_m = String::new();\n    let mut d_y = String::new();\n    if d.len()\
    \ != 3 {\n        return false;\n    }\n    for i in d.iter() {\n        if i.len()\
    \ != 2 {\n            return false;\n        }\n        if count == 0 {\n    \
    \        d_m = i.to_string();\n        }\n        if count == 1 {\n          \
    \  d_d = i.to_string();\n        }\n        if count == 2 {\n            d_y =\
    \ i.to_string();\n        }\n        count += 1;\n    }\n    for i in days.iter()\
    \ {\n        if d_d == i.to_string() {\n            return true;\n        }\n\
    \    }\n    return false;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp30f5hgjq.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmbun8fae.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut months = HashMap::new();\n    months.insert(1, 31);\n\
    \    months.insert(2, 28);\n    months.insert(3, 31);\n    months.insert(4, 30);\n\
    \    months.insert(5, 31);\n    months.insert(6, 30);\n    months.insert(7, 31);\n\
    \    months.insert(8, 31);\n    months.insert(9, 30);\n    months.insert(10, 31);\n\
    \    months.insert(11, 30);\n    months.insert(12, 31);\n\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_split.len() != 3 {\n \
    \       return false;\n    }\n    let mut date_int: Vec<u32> = Vec::new();\n \
    \   for num in date_split {\n        if let Ok(n) = num.parse::<u32>() {\n   \
    \         date_int.push(n);\n        } else {\n            return false;\n   \
    \     }\n    }\n    let month = date_int[0];\n    let day = date_int[1];\n   \
    \ let year = date_int[2];\n    if month == 0 || month > 12 {\n        return false;\n\
    \    }\n    if year < 1 {\n        return false;\n    }\n    if months.contains_key(&month)\
    \ {\n        if months[&month] < day {\n            return false;\n        }\n\
    \    } else {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk64ndxvo.rs:15:22\n   |\n15 |     let mut months = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.len() == 10 && \n    !date.contains(\"/\") && \n    !date.contains(\"\
    \ \") && \n    !date.contains(\"-00\") && \n    date.chars().filter(|c| *c ==\
    \ '-').count() == 2 && \n    date.split(\"-\").nth(0).unwrap().parse::<u8>().unwrap()\
    \ <= 12 && \n    date.split(\"-\").nth(1).unwrap().parse::<u8>().unwrap() <= 31\
    \ && \n    date.split(\"-\").nth(2).unwrap().parse::<u8>().unwrap() > 0\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmp49gvy45e.rs:22:51\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() < 10 {\n        return false;\n    }\n    let date_list:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let year = date_list[2].parse::<i32>().unwrap();\n\
    \    let month = date_list[0].parse::<i32>().unwrap();\n    let day = date_list[1].parse::<i32>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if day <\
    \ 1 || (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||\
    \ month == 10 || month == 12) && day > 31 || (month == 4 || month == 6 || month\
    \ == 9 || month == 11) && day > 30 || (month == 2 && day > 29) {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_vec: Vec<_> = date.split(\"-\").collect();\n    if date_vec.len()\
    \ != 3 {\n        return false;\n    }\n    let day: u32 = match date_vec[1].parse()\
    \ {\n        Ok(d) => d,\n        Err(_) => return false,\n    };\n    let month:\
    \ u32 = match date_vec[0].parse() {\n        Ok(m) => m,\n        Err(_) => return\
    \ false,\n    };\n    let year: u32 = match date_vec[2].parse() {\n        Ok(y)\
    \ => y,\n        Err(_) => return false,\n    };\n    if !(month >= 1 && month\
    \ <= 12) {\n        return false;\n    }\n    if !(day >= 1 && day <= 31) {\n\
    \        if !(day >= 1 && day <= 30) {\n            if !(day >= 1 && day <= 29)\
    \ {\n                if month != 2 {\n                    return false;\n    \
    \            }\n            }\n        }\n    }\n    if month == 2 && day == 29\
    \ {\n        return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg4h1dgxm.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprhy65m81.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    //your code here\n    let mut valid = true;\n    let mut days_valid\
    \ = true;\n    let mut month_valid = true;\n    let mut year_valid = true;\n \
    \   let mut format_valid = true;\n    let mut empty_valid = true;\n    let mut\
    \ arr: Vec<&str> = date.split(\"-\").collect();\n    let date_string: String =\
    \ date.to_string();\n    let mut i = 0;\n    let mut month: u32 = 0;\n    let\
    \ mut day: u32 = 0;\n    let mut year: u32 = 0;\n    let mut days: u32 = 0;\n\
    \    // println!(\"{:?}\", arr);\n    if arr.len() == 3 {\n        if arr[0].len()\
    \ > 0 && arr[1].len() > 0 && arr[2].len() > 0 {\n            empty_valid = true;\n\
    \        } else {\n            empty_valid = false;\n        }\n        // println!(\"\
    {:?}\", empty_valid);\n        for num in arr.iter() {\n            i = i + 1;\n\
    \            // println!(\"{:?}\", num);\n            match num.parse::<u32>()\
    \ {\n                Ok(v) => {\n                    if i == 1 {\n           \
    \             month = v;\n                    } else if i == 2 {\n           \
    \             day = v;\n                    } else if i == 3 {\n             \
    \           year = v;\n                    }\n                }\n            \
    \    Err(_) => {\n                    valid = false;\n                }\n    \
    \        }\n        }\n        // println!(\"{:?}\", month);\n        // println!(\"\
    {:?}\", day);\n        // println!(\"{:?}\", year);\n        if date_string.contains(\"\
    -\") {\n            format_valid = true;\n        } else {\n            format_valid\
    \ = false;\n        }\n        // println!(\"{:?}\", format_valid);\n        if\
    \ month > 0 && month < 13 {\n            month_valid = true;\n        } else {\n\
    \            month_valid = false;\n        }\n        // println!(\"{:?}\", month_valid);\n\
    \        if month ==\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpazaey82h.rs:91:3\n\
    \   |\n14 | fn valid_date(date: String) -> bool {\n   |                      \
    \               - unclosed delimiter\n...\n30 |     if arr.len() == 3 {\n   |\
    \                       - this delimiter might not be properly closed...\n...\n\
    71 | }\n   | - ...as it matches this but it has different indentation\n...\n91\
    \ | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpazaey82h.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpazaey82h.rs:14:32\n   |\n14 | fn valid_date(date: String) -> bool\
    \ {\n   |    ----------                  ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let rules = vec![(1,31), (2, 29), (3, 31), (4, 30), (5, 31),\
    \ (6, 30), (7, 31), (8, 31), (9, 30), (10, 31), (11, 30), (12, 31)];\n    let\
    \ d = date.split(\"-\").collect::<Vec<&str>>();\n    if d.len() != 3 { return\
    \ false }\n    let month = d[0].parse::<i32>().unwrap();\n    let day = d[1].parse::<i32>().unwrap();\n\
    \    let year = d[2].parse::<i32>().unwrap();\n    if month < 1 || month > 12\
    \ { return false }\n    if day < 1 || day > rules[(month - 1) as usize].1 { return\
    \ false }\n    if year < 1 { return false }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n\
    \    if !re.is_match(&date) {\n        return false;\n    }\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let date_array: [i32; 3] = [date_split[0].parse().unwrap(),\
    \ date_split[1].parse().unwrap(), date_split[2].parse().unwrap()];\n    if date_array[0]\
    \ < 1 || date_array[0] > 12 {\n        return false;\n    }\n    if date_array[0]\
    \ == 2 {\n        if date_array[2] % 4 == 0 {\n            if date_array[1] <\
    \ 1 || date_array[1] > 29 {\n                return false;\n            }\n  \
    \      } else {\n            if date_array[1] < 1 || date_array[1] > 28 {\n  \
    \              return false;\n            }\n        }\n    } else if date_array[0]\
    \ == 1 || date_array[0] == 3 || date_array[0] == 5 || date_array[0] == 7 || date_array[0]\
    \ == 8 || date_array[0] == 10 || date_array[0] == 12 {\n        if date_array[1]\
    \ < 1 || date_array[1] > 31 {\n            return false;\n        }\n    } else\
    \ {\n        if date_array[1] < 1 || date_array[1] > 30 {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmph0f94yw1.rs:15:14\n   |\n15 |     let re = Regex::new(r\"^(\\d{2})-(\\\
    d{2})-(\\d{4})$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    //unimplemented!(\"return true if the date is valid, false otherwise\"\
    );\n    if date.len()==0 {\n        return false;\n    }\n    let mut arr: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if arr.len()!=3 {\n        return false;\n\
    \    }\n    let mm = arr[0].parse::<u32>().unwrap();\n    let dd = arr[1].parse::<u32>().unwrap();\n\
    \    let yyyy = arr[2].parse::<u32>().unwrap();\n    if yyyy<0 {\n        return\
    \ false;\n    }\n    if mm<1 || mm>12 {\n        return false;\n    }\n    if\
    \ dd<1 || dd>31 {\n        return false;\n    }\n    if mm == 2 {\n        if\
    \ dd>29 {\n            return false;\n        }\n    } else if mm==4 || mm==6\
    \ || mm==9 || mm==11 {\n        if dd>30 {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut valid = false;\n    // Regex to extract all 3 numbers\
    \ into a vector\n    let re = Regex::new(r\"\\d+\").unwrap();\n    let vec: Vec<&str>\
    \ = re.find_iter(&date).map(|m| m.as_str()).collect();\n    if vec.len() == 3\
    \ {\n        // The 3 numbers are mm, dd, yyyy \n        let mm = vec[0].parse::<u8>().unwrap();\n\
    \        let dd = vec[1].parse::<u8>().unwrap();\n        let yyyy = vec[2].parse::<u16>().unwrap();\n\
    \        if mm > 0 && mm < 13 {\n            // check month\n            if mm\
    \ == 2 {\n                // check days\n                if dd > 0 && dd < 30\
    \ {\n                    valid = true;\n                }\n            } else\
    \ if mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10 || mm ==\
    \ 12 {\n                if dd > 0 && dd < 32 {\n                    valid = true;\n\
    \                }\n            } else {\n                if dd > 0 && dd < 31\
    \ {\n                    valid = true;\n                }\n            }\n   \
    \     }\n    }\n    valid\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpe7lrufj8.rs:17:14\n   |\n17 |     let re = Regex::new(r\"\\d+\").unwrap();\n\
    \   |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() != 10 {\n        return false;\n    }\n    let\
    \ v: Vec<&str> = date.split(\"-\").collect();\n    if v.len() != 3 {\n       \
    \ return false;\n    }\n    if let Ok(mut month) = v[0].parse::<i32>() {\n   \
    \     month -= 1;\n        if let Ok(day) = v[1].parse::<i32>() {\n          \
    \  if let Ok(year) = v[2].parse::<i32>() {\n                if let Some(d) = NaiveDate::from_ymd_opt(year,\
    \ month, day) {\n                    return true;\n                }\n       \
    \     }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `NaiveDate`\n \
    \ --> /tmp/tmp7fdu2iom.rs:26:34\n   |\n26 |                 if let Some(d) = NaiveDate::from_ymd_opt(year,\
    \ month, day) {\n   |                                  ^^^^^^^^^ use of undeclared\
    \ type `NaiveDate`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp692dffz4.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvx1udo0t.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    use std::str::FromStr;\n    let mut parts = date.split('-');\n\
    \    let month: u32 = u32::from_str(parts.next().unwrap()).unwrap();\n    let\
    \ day: u32 = u32::from_str(parts.next().unwrap()).unwrap();\n    let year: u32\
    \ = u32::from_str(parts.next().unwrap()).unwrap();\n    if month > 12 || month\
    \ < 1 { return false }\n    if year == 0 { return false }\n    if day > 31 ||\
    \ day < 1 { return false }\n    match month {\n        2 => {\n            if\
    \ day > 29 { return false }\n        },\n        4 | 6 | 9 | 11 => {\n       \
    \     if day > 30 { return false }\n        },\n        _ => {}\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: Empty }', /tmp/tmpxsvaaajc.rs:17:59\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() == 0 {\n        return false;\n    }\n    let date_vector:\
    \ Vec<_> = date.split(\"-\").collect();\n    if date_vector.len() != 3 {\n   \
    \     return false;\n    }\n    let month: i32 = date_vector[0].parse().unwrap();\n\
    \    let day: i32 = date_vector[1].parse().unwrap();\n    let year: i32 = date_vector[2].parse().unwrap();\n\
    \    if !(month > 0 && month < 13) {\n        return false;\n    }\n    if (month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12) && !(day > 0 && day < 32) {\n        return false;\n    }\n\
    \    if (month == 4 || month == 6 || month == 9 || month == 11) && !(day > 0 &&\
    \ day < 31) {\n        return false;\n    }\n    if month == 2 && !(day > 0 &&\
    \ day < 30) {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpoqzomw5_.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.split('-').collect::<Vec<&str>>().len() == 3 &&\n    date.split('-').collect::<Vec<&str>>().iter().all(|x|\
    \ x.chars().all(|c| c.is_digit(10))) &&\n    let [d, m, y] = date.split('-').collect::<Vec<&str>>().iter().map(|x|\
    \ x.parse::<u32>().unwrap()).collect::<Vec<u32>>();\n    y > 0 && y < 2100 &&\n\
    \    m > 0 && m < 13 &&\n    d > 0 && d < 32 &&\n    match m {\n        2 => d\
    \ <= 29,\n        4 | 6 | 9 | 11 => d <= 30,\n        _ => true\n    }\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found statement (`let`)\n  --> /tmp/tmpeuhcn620.rs:17:5\n\
    \   |\n17 |     let [d, m, y] = date.split('-').collect::<Vec<&str>>().iter().map(|x|\
    \ x.parse::<u32>().unwrap()).collect::<Vec<u32>>();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: variable declaration using `let` is a statement\n\nerror[E0658]:\
    \ `let` expressions in this position are unstable\n  --> /tmp/tmpeuhcn620.rs:17:5\n\
    \   |\n17 |     let [d, m, y] = date.split('-').collect::<Vec<&str>>().iter().map(|x|\
    \ x.parse::<u32>().unwrap()).collect::<Vec<u32>>();\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0529]: expected an array or slice, found `Vec<u32>`\n\
    \  --> /tmp/tmpeuhcn620.rs:17:9\n   |\n17 |     let [d, m, y] = date.split('-').collect::<Vec<&str>>().iter().map(|x|\
    \ x.parse::<u32>().unwrap()).collect::<Vec<u32>>();\n   |         ^^^^^^^^^  \
    \ ------------------------------------------------------------------------------------------------------\
    \ help: consider slicing here: `date.split('-').collect::<Vec<&str>>().iter().map(|x|\
    \ x.parse::<u32>().unwrap()).collect::<Vec<u32>>()[..]`\n   |         |\n   |\
    \         pattern cannot match with input type `Vec<u32>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0529, E0658.\n\
    For more information about an error, try `rustc --explain E0529`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    match Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ) {\n        Ok(re) => re.is_match(&date),\n        Err(_) => false,\n    }\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp1ienhdoa.rs:15:11\n   |\n15 |     match Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ) {\n   |           ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let pieces: Vec<&str> = date.split('-').collect();\n    if pieces.len()\
    \ != 3 {\n        return false;\n    }\n    if let Some(year) = pieces[2].parse::<u32>().ok()\
    \ {\n        if year < 1 {\n            return false;\n        }\n    } else {\n\
    \        return false;\n    }\n    if let Some(month) = pieces[0].parse::<u32>().ok()\
    \ {\n        if month > 12 || month < 1 {\n            return false;\n       \
    \ }\n    } else {\n        return false;\n    }\n    if let Some(day) = pieces[1].parse::<u32>().ok()\
    \ {\n        if day > 31 || day < 1 {\n            return false;\n        }\n\
    \        if month == 2 {\n            if day > 29 {\n                return false;\n\
    \            }\n        } else if month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n            if day > 30 {\n                return false;\n        \
    \    }\n        }\n    } else {\n        return false;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `month` in this scope\n  --> /tmp/tmpii5l09hi.rs:37:12\n\
    \   |\n37 |         if month == 2 {\n   |            ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `month` in this scope\n  --> /tmp/tmpii5l09hi.rs:41:19\n\
    \   |\n41 |         } else if month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n   |                   ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `month` in this scope\n  --> /tmp/tmpii5l09hi.rs:41:33\n \
    \  |\n41 |         } else if month == 4 || month == 6 || month == 9 || month ==\
    \ 11 {\n   |                                 ^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `month` in this scope\n  --> /tmp/tmpii5l09hi.rs:41:47\n\
    \   |\n41 |         } else if month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n   |                                               ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `month` in this scope\n  -->\
    \ /tmp/tmpii5l09hi.rs:41:61\n   |\n41 |         } else if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n   |                                  \
    \                           ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let (mut m, mut d, mut y) = (0, 0, 0);\n    let (mut i, mut j)\
    \ = (0, 0);\n    for (ii, c) in date.chars().enumerate() {\n        if ii == 2\
    \ || ii == 5 {\n            if c != '-' {\n                return false;\n   \
    \         }\n        } else {\n            if !c.is_digit(10) {\n            \
    \    return false;\n            }\n        }\n    }\n    for (ii, c) in date.chars().enumerate()\
    \ {\n        if ii == 0 || ii == 1 {\n            m = (m * 10) + c.to_digit(10).unwrap();\n\
    \        } else if ii == 3 || ii == 4 {\n            d = (d * 10) + c.to_digit(10).unwrap();\n\
    \        } else if ii == 6 || ii == 7 || ii == 8 || ii == 9 {\n            y =\
    \ (y * 10) + c.to_digit(10).unwrap();\n        }\n    }\n    if m < 1 || m > 12\
    \ {\n        return false;\n    }\n    if m == 1 || m == 3 || m == 5 || m == 7\
    \ || m == 8 || m == 10 || m == 12 {\n        if d < 1 || d > 31 {\n          \
    \  return false;\n        }\n    } else if m == 4 || m == 6 || m == 9 || m ==\
    \ 11 {\n        if d < 1 || d > 30 {\n            return false;\n        }\n \
    \   } else if m == 2 {\n        if y % 4 == 0 {\n            if d < 1 || d > 29\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    if d < 1 || d > 28 {\n                return false;\n            }\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n \
    \   assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let parts: Vec<_> = date.split('-').collect();\n    match parts.len()\
    \ {\n        3 => {\n            if let (Ok(m), Ok(d), Ok(y)) = (parts[0].parse::<u32>(),\
    \ parts[1].parse::<u32>(), parts[2].parse::<u32>()) {\n                if (1 <=\
    \ m && m <= 12) && (1 <= d && d <= 31) && (1 <= y && y <= 9999) {\n          \
    \          if (1 <= m && m <= 7 && m % 2 == 1) || (8 <= m && m <= 12 && m % 2\
    \ == 0) {\n                        return 1 <= d && d <= 31;\n               \
    \     } else if m == 2 {\n                        return 1 <= d && d <= 29;\n\
    \                    } else {\n                        return 1 <= d && d <= 30;\n\
    \                    }\n                }\n            }\n        },\n       \
    \ _ => {}\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpf900j9pv.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n    let mut days = 0;\n    let mut month\
    \ = 0;\n    let mut year = 0;\n    for i in v.iter() {\n        let num = i.parse::<i32>();\n\
    \        match num {\n            Ok(val) => {\n                if val <= 0 {\n\
    \                    return false;\n                }\n                if year\
    \ == 0 {\n                    year = val;\n                } else if month ==\
    \ 0 {\n                    month = val;\n                } else {\n          \
    \          days = val;\n                }\n            },\n            Err(_)\
    \ => return false,\n        }\n    }\n    if month > 12 || month == 0 {\n    \
    \    return false;\n    }\n    match month {\n        1|3|5|7|8|10|12 => {\n \
    \           if days > 31 || days == 0 {\n                return false;\n     \
    \       }\n        },\n        4|6|9|11 => {\n            if days > 30 || days\
    \ == 0 {\n                return false;\n            }\n        },\n        2\
    \ => {\n            if year % 4 == 0 {\n                if days > 29 || days ==\
    \ 0 {\n                    return false;\n                }\n            } else\
    \ {\n                if days > 28 || days == 0 {\n                    return false;\n\
    \                }\n            }\n        },\n        _ => return false,\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmtk6z2eg.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.split('-').count() == 3 && date.split('/').count() == 1\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph8udlq95.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let date_split:\
    \ Vec<_> = date.split('-').collect();\n    if date_split.len() != 3 {\n      \
    \  return false;\n    }\n    let month = date_split[0].parse::<u32>().unwrap();\n\
    \    let day = date_split[1].parse::<u32>().unwrap();\n    let year = date_split[2].parse::<u32>().unwrap();\n\
    \    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day\
    \ < 1 || day > 31 {\n                return false;\n            }\n        },\n\
    \        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n         \
    \       return false;\n            }\n        },\n        2 => {\n           \
    \ if day < 1 || day > 29 {\n                return false;\n            }\n   \
    \     },\n        _ => {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut result = false;\n    let date_vector: Vec<_> = date.split('-').collect();\n\
    \    if date_vector.len() == 3 {\n        match (date_vector[0].parse::<u8>(),\
    \ date_vector[1].parse::<u8>(), date_vector[2].parse::<u16>()) {\n           \
    \ (Ok(month), Ok(day), Ok(year)) => match month {\n                1 | 3 | 5 |\
    \ 7 | 8 | 10 | 12 => {\n                    if day >= 1 && day <= 31 {\n     \
    \                   result = true;\n                    }\n                },\n\
    \                4 | 6 | 9 | 11 => {\n                    if day >= 1 && day <=\
    \ 30 {\n                        result = true;\n                    }\n      \
    \          },\n                2 => {\n                    if day >= 1 && day\
    \ <= 29 {\n                        result = true;\n                    }\n   \
    \             },\n                _ => result = false,\n            },\n     \
    \       _ => result = false,\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() == 0 {\n        return false;\n    }\n    if date.find('-')\
    \ == None {\n        return false;\n    }\n    let mut dash_idx = 0;\n    let\
    \ mut day = String::new();\n    let mut month = String::new();\n    let mut year\
    \ = String::new();\n    for (i, c) in date.chars().enumerate() {\n        if c\
    \ == '-' {\n            if dash_idx == 0 {\n                month = date[0..i].to_string();\n\
    \            } else if dash_idx == 1 {\n                day = date[month.len()+1..i].to_string();\n\
    \            }\n            dash_idx += 1;\n        }\n    }\n    year = date[month.len()+day.len()+2..].to_string();\n\
    \    let d = day.parse::<u32>().unwrap();\n    let m = month.parse::<u32>().unwrap();\n\
    \    let y = year.parse::<u32>().unwrap();\n    if m == 0 || m > 12 {\n      \
    \  return false;\n    }\n    if m == 1 || m == 3 || m == 5 || m == 7 || m == 8\
    \ || m == 10 || m == 12 {\n        if d == 0 || d > 31 {\n            return false;\n\
    \        }\n    } else if m == 4 || m == 6 || m == 9 || m == 11 {\n        if\
    \ d == 0 || d > 30 {\n            return false;\n        }\n    } else if m ==\
    \ 2 {\n        if y % 4 == 0 {\n            if d == 0 || d > 29 {\n          \
    \      return false;\n            }\n        } else {\n            if d == 0 ||\
    \ d > 28 {\n                return false;\n            }\n        }\n    }\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: Empty }', /tmp/tmp4qs3i6lt.rs:36:32\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpq_u03l79.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // TODO\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4nq01rb_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let date_string\
    \ = date.split(\"-\").collect::<Vec<&str>>();\n    if date_string.len() != 3 {\n\
    \        return false;\n    }\n    let month = date_string[0].parse::<i32>().unwrap();\n\
    \    let day = date_string[1].parse::<i32>().unwrap();\n    let year = date_string[2].parse::<i32>().unwrap();\n\
    \    if !(1 <= month && month <= 12) {\n        return false;\n    }\n    if !(1\
    \ <= day && day <= 31) {\n        return false;\n    }\n    if !(1 <= year &&\
    \ year <= 9999) {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx7y0zm6_.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpskg7it_q.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzsmtrehv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpd3_2v878.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5skp9h_a.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if !date.contains('-') {\n        return false;\n    }\n    let\
    \ mut split = date.split('-');\n    if let Some(month) = split.next() {\n    \
    \    if month.len() != 2 {\n            return false;\n        }\n        if let\
    \ Some(day) = split.next() {\n            if day.len() != 2 {\n              \
    \  return false;\n            }\n            if let Some(year) = split.next()\
    \ {\n                if year.len() != 4 {\n                    return false;\n\
    \                }\n                if month == \"04\" || month == \"06\" || month\
    \ == \"09\" || month == \"11\" {\n                    if day.parse::<u32>().unwrap()\
    \ > 30 {\n                        return false;\n                    }\n     \
    \           } else if month == \"02\" {\n                    if day.parse::<u32>().unwrap()\
    \ > 29 {\n                        return false;\n                    }\n     \
    \           } else if day.parse::<u32>().unwrap() > 31 {\n                   \
    \ return false;\n                }\n                if month.parse::<u32>().unwrap()\
    \ > 12 {\n                    return false;\n                }\n             \
    \   return true;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // return true if date is valid\n    let mut is_valid = true;\n\
    \    let mut test_date: Vec<&str> = date.split(\"-\").collect();\n    let mut\
    \ test_month: u32 = 0;\n    let mut test_day: u32 = 0;\n    let mut test_year:\
    \ u32 = 0;\n    if test_date.len() != 3 {\n        return false;\n    }\n    else\
    \ {\n        if test_date[0].len() == 2 && test_date[1].len() == 2 && test_date[2].len()\
    \ == 4 {\n            test_month = test_date[0].parse::<u32>().unwrap();\n   \
    \         test_day = test_date[1].parse::<u32>().unwrap();\n            test_year\
    \ = test_date[2].parse::<u32>().unwrap();\n        }\n        else {\n       \
    \     return false;\n        }\n    }\n    if (test_month == 1 || test_month ==\
    \ 3 || test_month == 5 || test_month == 7 || test_month == 8 || test_month ==\
    \ 10 || test_month == 12) && test_day > 31 {\n        is_valid = false;\n    }\n\
    \    else if (test_month == 4 || test_month == 6 || test_month == 9 || test_month\
    \ == 11) && test_day > 30 {\n        is_valid = false;\n    }\n    else if test_month\
    \ == 2 && test_day > 29 {\n        is_valid = false;\n    }\n    else if test_month\
    \ > 12 {\n        is_valid = false;\n    }\n    else if test_day < 1 {\n     \
    \   is_valid = false;\n    }\n    is_valid\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let pattern = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-((19[0-9][0-9])|(20[0-1][0-9]))$\"\
    ).unwrap();\n    let date = date.as_str();\n    pattern.is_match(date)\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpgdty70_k.rs:15:19\n   |\n15 |     let pattern = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-((19[0-9][0-9])|(20[0-1][0-9]))$\"\
    ).unwrap();\n   |                   ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let (d, m, y) = split_date(&date);\n    let day = d.parse::<u8>().unwrap();\n\
    \    let mon = m.parse::<u8>().unwrap();\n    let year = y.parse::<u32>().unwrap();\n\
    \    let is_day_valid = day <= 31 &&\n                       day >= 1 &&\n   \
    \                    (mon == 1 || mon == 3 || mon == 5 || mon == 7 || mon == 8\
    \ || mon == 10 || mon == 12 ||\n                        (mon == 4 || mon == 6\
    \ || mon == 9 || mon == 11) && day <= 30 ||\n                        (mon == 2\
    \ && day <= 29));\n    let is_mon_valid = mon <= 12 && mon >= 1;\n    is_day_valid\
    \ && is_mon_valid && year >= 0\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split_date` in this scope\n  --> /tmp/tmpomhvqzvu.rs:15:21\n\
    \   |\n15 |     let (d, m, y) = split_date(&date);\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.len() != 0\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3kj__g02.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    if re.is_match(&date) {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpqp60x5hw.rs:15:14\n   |\n15 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptw7xj6l3.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    fn is_leap_year(year: usize) -> bool {\n        if year % 4 ==\
    \ 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n\
    \                    return true;\n                }\n                return false;\n\
    \            }\n            return true;\n        }\n        return false;\n \
    \   }\n\n    if date.len() == 0 {\n        return false;\n    }\n\n    let date_vec:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_vec.len() != 3 {\n   \
    \     return false;\n    }\n\n    let mut month: usize = 0;\n    let mut day:\
    \ usize = 0;\n    let mut year: usize = 0;\n\n    for num in date_vec {\n    \
    \    if num.parse::<usize>().is_err() {\n            return false;\n        }\n\
    \    }\n\n    month = date_vec[0].parse::<usize>().unwrap();\n    day = date_vec[1].parse::<usize>().unwrap();\n\
    \    year = date_vec[2].parse::<usize>().unwrap();\n\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n\n    if month == 2 {\n        if is_leap_year(year)\
    \ {\n            if day < 1 || day > 29 {\n                return false;\n   \
    \         }\n        } else {\n            if day < 1 || day > 28 {\n        \
    \        return false;\n            }\n        }\n    } else if month == 1 ||\
    \ month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month\
    \ == 12 {\n        if day < 1 || day > 31 {\n            return false;\n     \
    \   }\n    } else {\n        if day < 1 || day > 30 {\n            return false;\n\
    \        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `month` is never read\n  --> /tmp/tmp19wg899e.rs:37:13\n\
    \   |\n37 |     let mut month: usize = 0;\n   |             ^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `day` is never read\n  -->\
    \ /tmp/tmp19wg899e.rs:38:13\n   |\n38 |     let mut day: usize = 0;\n   |    \
    \         ^^^\n   |\n   = help: maybe it is overwritten before being read?\n\n\
    warning: value assigned to `year` is never read\n  --> /tmp/tmp19wg899e.rs:39:13\n\
    \   |\n39 |     let mut year: usize = 0;\n   |             ^^^^\n   |\n   = help:\
    \ maybe it is overwritten before being read?\n\nerror[E0382]: borrow of moved\
    \ value: `date_vec`\n   --> /tmp/tmp19wg899e.rs:47:13\n    |\n32  |     let date_vec:\
    \ Vec<&str> = date.split(\"-\").collect();\n    |         -------- move occurs\
    \ because `date_vec` has type `Vec<&str>`, which does not implement the `Copy`\
    \ trait\n...\n41  |     for num in date_vec {\n    |                -------- `date_vec`\
    \ moved due to this implicit call to `.into_iter()`\n...\n47  |     month = date_vec[0].parse::<usize>().unwrap();\n\
    \    |             ^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `date_vec`\nhelp:\
    \ consider iterating over a slice of the `Vec<&str>`'s content to avoid moving\
    \ into the `for` loop\n    |\n41  |     for num in &date_vec {\n    |        \
    \        +\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date = date.split('-').collect::<Vec<&str>>();\n    let months:\
    \ [i32; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    if date.len() != 3\
    \ {\n        return false;\n    }\n    let mut check = false;\n    for m in months.iter()\
    \ {\n        if m.to_string() == date[0] {\n            check = true;\n      \
    \  }\n    }\n    if !check {\n        return false;\n    }\n    let d = date[1].parse::<i32>().unwrap();\n\
    \    let m = date[0].parse::<i32>().unwrap();\n    let y = date[2].parse::<i32>().unwrap();\n\
    \    let max_days: [i32; 12] = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\
    \    let max_days_leap: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\
    \ 31];\n    if m < 1 || m > 12 {\n        return false;\n    }\n    if d < 1 ||\
    \ d > max_days[m as usize - 1] {\n        return false;\n    }\n    if y % 4 ==\
    \ 0 && m == 2 && d > max_days_leap[m as usize - 1] {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcwti7c8f.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let split: Vec<&str> = date.split(\"-\").collect();\n    if split.len()\
    \ == 3 {\n        let month: u32 = split[0].parse().unwrap();\n        let day:\
    \ u32 = split[1].parse().unwrap();\n        let year: u32 = split[2].parse().unwrap();\n\
    \        if (month > 0 && month < 13) && (day > 0 && day < 32) && (year > 0) {\n\
    \            if (month == 1 || month == 3 || month == 5 || month == 7 || month\
    \ == 8 || month == 10 || month == 12) && (day < 32) {\n                return\
    \ true;\n            } else if (month == 4 || month == 6 || month == 9 || month\
    \ == 11) && (day < 31) {\n                return true;\n            } else if\
    \ (month == 2) && (day < 30) {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpghkc_zmz.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut split = date.split(\"-\");\n    let mut month = split.next().unwrap().parse::<u32>().unwrap();\n\
    \    let mut day = split.next().unwrap().parse::<u32>().unwrap();\n    let mut\
    \ year = split.next().unwrap().parse::<u32>().unwrap();\n    // println!(\"{}\
    \ {} {}\", month, day, year);\n    if month > 12 || month < 1 || day > 31 || day\
    \ < 1 || year < 1 {\n        return false;\n    }\n    if (month == 4 || month\
    \ == 6 || month == 9 || month == 11) && day > 30 {\n        return false;\n  \
    \  }\n    if month == 2 && day > 29 {\n        return false;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: Empty }', /tmp/tmp0j1fl04y.rs:16:58\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date = date.trim();\n    if date.len() != 10 {\n        return\
    \ false;\n    }\n    if date.contains('/') {\n        return false;\n    }\n \
    \   let mut iter = date.split('-');\n    let month: u32 = iter.next().unwrap().parse().unwrap();\n\
    \    let day: u32 = iter.next().unwrap().parse().unwrap();\n    let year: u32\
    \ = iter.next().unwrap().parse().unwrap();\n    match month {\n        1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => (day > 0 && day < 32),\n        4 | 6 | 9 | 11 => (day\
    \ > 0 && day < 31),\n        2 => (day > 0 && day < 30),\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Unimplemented!()\n    let mut valid = true;\n    let d = date.split(\"\
    -\").collect::<Vec<&str>>();\n    if d.len() != 3 { return false; }\n    let m:\
    \ i32 = match d[0].parse() {\n        Ok(v) => v,\n        Err(_) => {\n     \
    \       valid = false;\n            0\n        }\n    };\n    let d: i32 = match\
    \ d[1].parse() {\n        Ok(v) => v,\n        Err(_) => {\n            valid\
    \ = false;\n            0\n        }\n    };\n    let y: i32 = match d[2].parse()\
    \ {\n        Ok(v) => v,\n        Err(_) => {\n            valid = false;\n  \
    \          0\n        }\n    };\n    if !valid { return false; }\n    if y < 1582\
    \ { return false; }\n    if !(m > 0 && m < 13) { return false; }\n    if !(d >\
    \ 0 && d < 32) { return false; }\n    let leap = if y % 4 == 0 { true } else {\
    \ false };\n    if (m == 2 && d > 29) || ((m == 2 && d > 28) && !leap) { return\
    \ false; }\n    if ((m == 4 || m == 6 || m == 9 || m == 11) && d > 30) { return\
    \ false; }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphoa0gedi.rs:46:8\n\
    \   |\n46 |     if ((m == 4 || m == 6 || m == 9 || m == 11) && d > 30) { return\
    \ false; }\n   |        ^                                                 ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n46 -     if ((m == 4 || m == 6 || m == 9 || m == 11) && d > 30) { return\
    \ false; }\n46 +     if (m == 4 || m == 6 || m == 9 || m == 11) && d > 30 { return\
    \ false; }\n   | \n\nerror[E0608]: cannot index into a value of type `i32`\n \
    \ --> /tmp/tmphoa0gedi.rs:33:24\n   |\n33 |     let y: i32 = match d[2].parse()\
    \ {\n   |                        ^^^^\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdxr3fzfh.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3_dlacej.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re_date = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n\
    \    let date = date.trim();\n    if date.is_empty() {\n        return false;\n\
    \    }\n    if let Some(caps) = re_date.captures(date) {\n        if let Some(m)\
    \ = caps.get(1) {\n            let month = m.as_str().parse::<u32>().unwrap();\n\
    \            if month < 1 || month > 12 {\n                return false;\n   \
    \         }\n        }\n        if let Some(d) = caps.get(2) {\n            let\
    \ day = d.as_str().parse::<u32>().unwrap();\n            if day < 1 || day > 31\
    \ {\n                return false;\n            }\n            match month {\n\
    \                1|3|5|7|8|10|12 => {\n                    if day > 31 {\n   \
    \                     return false;\n                    }\n                },\n\
    \                4|6|9|11 => {\n                    if day > 30 {\n          \
    \              return false;\n                    }\n                },\n    \
    \            2 => {\n                    if day > 29 {\n                     \
    \   return false;\n                    }\n                },\n               \
    \ _ => {}\n            }\n        }\n        if let Some(y) = caps.get(3) {\n\
    \            let year = y.as_str().parse::<u32>().unwrap();\n            if year\
    \ < 1 {\n                return false;\n            }\n        }\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpwkctebfx.rs:15:19\n   |\n15 |     let re_date = Regex::new(r\"^(\\d{2})-(\\\
    d{2})-(\\d{4})$\").unwrap();\n   |                   ^^^^^ use of undeclared type\
    \ `Regex`\n\nerror[E0425]: cannot find value `month` in this scope\n  --> /tmp/tmpwkctebfx.rs:32:19\n\
    \   |\n32 |             match month {\n   |                   ^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let date_items:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_items.len() != 3 {\n \
    \       return false;\n    }\n    let months: Vec<i32> = vec![31, 29, 31, 30,\
    \ 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut m = date_items[0].parse::<i32>().unwrap();\n\
    \    let mut d = date_items[1].parse::<i32>().unwrap();\n    let mut y = date_items[2].parse::<i32>().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if y < 0 {\n    \
    \    return false;\n    }\n    if y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)\
    \ {\n        // It's a leap year\n        if d < 1 || d > months[m as usize -\
    \ 1] {\n            return false;\n        }\n    } else {\n        if d < 1 ||\
    \ d > months[m as usize - 1] {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let separator\
    \ = get_separator(&date);\n    if separator == ' ' {\n        return false;\n\
    \    }\n    let fields: Vec<&str> = date.split(separator).collect();\n    if fields.len()\
    \ != 3 {\n        return false;\n    }\n    if !is_date_in_correct_format(&fields)\
    \ {\n        return false;\n    }\n    if !is_valid_date(&fields) {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_separator` in this scope\n  -->\
    \ /tmp/tmpidvlrgsu.rs:18:21\n   |\n18 |     let separator = get_separator(&date);\n\
    \   |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_date_in_correct_format` in this scope\n  --> /tmp/tmpidvlrgsu.rs:26:9\n\
    \   |\n26 |     if !is_date_in_correct_format(&fields) {\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_valid_date`\
    \ in this scope\n  --> /tmp/tmpidvlrgsu.rs:29:9\n   |\n29 |     if !is_valid_date(&fields)\
    \ {\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut res = true;\n    let mut r = Regex::new(r\"^(?P<day>\\\
    d{2})-(?P<month>\\d{2})-(?P<year>\\d{4})$\").unwrap();\n    if let Some(captures)\
    \ = r.captures(&date) {\n        let d = captures.name(\"day\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \        let m = captures.name(\"month\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \        let y = captures.name(\"year\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \        if d > 31 || d < 1 || m > 12 || m < 1 || y < 1000 || y > 9999 {\n   \
    \         res = false;\n        } else if m == 2 && d > 29 {\n            res\
    \ = false;\n        } else if m == 2 && d == 29 && !is_leap_year(y) {\n      \
    \      res = false;\n        } else if m % 2 == 0 && m <= 7 && d > 30 {\n    \
    \        res = false;\n        } else if m % 2 == 0 && m > 7 && d > 31 {\n   \
    \         res = false;\n        } else if m % 2 != 0 && m > 7 && d > 30 {\n  \
    \          res = false;\n        }\n    } else {\n        res = false;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp9pni68s6.rs:16:17\n   |\n16 |     let mut r = Regex::new(r\"^(?P<day>\\\
    d{2})-(?P<month>\\d{2})-(?P<year>\\d{4})$\").unwrap();\n   |                 ^^^^^\
    \ use of undeclared type `Regex`\n\nerror[E0425]: cannot find function `is_leap_year`\
    \ in this scope\n  --> /tmp/tmp9pni68s6.rs:25:41\n   |\n25 |         } else if\
    \ m == 2 && d == 29 && !is_leap_year(y) {\n   |                              \
    \           ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() == 0 {\n        return false;\n    }\n    let mut\
    \ split_date = date.split(\"-\");\n    let mut months: Vec<_> = split_date.collect();\n\
    \    if months.len() != 3 {\n        return false;\n    }\n    if months[0].len()\
    \ != 2 || months[1].len() != 2 || months[2].len() != 4 {\n        return false;\n\
    \    }\n    if months[0].starts_with(\"0\") {\n        return false;\n    }\n\
    \    if months[1].starts_with(\"0\") {\n        return false;\n    }\n    let\
    \ mut day = u32::from_str(months[1]).unwrap();\n    let mut month = u32::from_str(months[0]).unwrap();\n\
    \    let mut year = u32::from_str(months[2]).unwrap();\n    if month == 2 {\n\
    \        if day > 29 {\n            return false;\n        }\n    }\n    if month\
    \ == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\
    \ || month == 12 {\n        if day > 31 {\n            return false;\n       \
    \ }\n    }\n    if month == 4 || month == 6 || month == 9 || month == 11 {\n \
    \       if day > 30 {\n            return false;\n        }\n    }\n    if month\
    \ > 12 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ type `u32` in the current scope\n  --> /tmp/tmpus_wrdu9.rs:32:24\n   |\n32 |\
    \     let mut day = u32::from_str(months[1]).unwrap();\n   |                 \
    \       ^^^^^^^^ function or associated item not found in `u32`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\nhelp: there is an associated function with\
    \ a similar name\n   |\n32 |     let mut day = u32::from_str_radix(months[1]).unwrap();\n\
    \   |                        ~~~~~~~~~~~~~~\n\nerror[E0599]: no function or associated\
    \ item named `from_str` found for type `u32` in the current scope\n  --> /tmp/tmpus_wrdu9.rs:33:26\n\
    \   |\n33 |     let mut month = u32::from_str(months[0]).unwrap();\n   |     \
    \                     ^^^^^^^^ function or associated item not found in `u32`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n33 |     let mut month = u32::from_str_radix(months[0]).unwrap();\n\
    \   |                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no function or\
    \ associated item named `from_str` found for type `u32` in the current scope\n\
    \  --> /tmp/tmpus_wrdu9.rs:34:25\n   |\n34 |     let mut year = u32::from_str(months[2]).unwrap();\n\
    \   |                         ^^^^^^^^ function or associated item not found in\
    \ `u32`\n   |\n   = help: items from traits can only be used if the trait is in\
    \ scope\nhelp: the following trait is implemented but not in scope; perhaps add\
    \ a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\nhelp: there is an\
    \ associated function with a similar name\n   |\n34 |     let mut year = u32::from_str_radix(months[2]).unwrap();\n\
    \   |                         ~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about th"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n    match v[0].parse::<i32>() {\n    \
    \    Ok(n) => {\n            if n < 1 || n > 12 {\n                return false;\n\
    \            }\n        },\n        Err(_) => return false,\n    }\n    match\
    \ v[1].parse::<i32>() {\n        Ok(n) => {\n            match v[0].parse::<i32>()\
    \ {\n                Ok(n2) => {\n                    if n2 == 2 {\n         \
    \               if n < 1 || n > 29 {\n                            return false;\n\
    \                        }\n                    } else if n2 == 1 || n2 == 3 ||\
    \ n2 == 5 || n2 == 7 || n2 == 8 || n2 == 10 || n2 == 12 {\n                  \
    \      if n < 1 || n > 31 {\n                            return false;\n     \
    \                   }\n                    } else {\n                        if\
    \ n < 1 || n > 30 {\n                            return false;\n             \
    \           }\n                    }\n                },\n                Err(_)\
    \ => return false,\n            }\n        },\n        Err(_) => return false,\n\
    \    }\n    match v[2].parse::<i32>() {\n        Ok(n) => {\n            if n\
    \ < 1 {\n                return false;\n            }\n        },\n        Err(_)\
    \ => return false,\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpssiml2ue.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let valid_months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n\
    \    let valid_days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\
    \ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut month\
    \ = 0;\n    let mut day = 0;\n    let mut year = 0;\n    let mut date_str = date.clone();\n\
    \    let mut val = true;\n    let mut is_valid = false;\n    // empty string should\
    \ return false.\n    if date.len() == 0 {\n        return false;\n    }\n    //\
    \ date string should have format mm-dd-yyyy\n    if date.find(\"-\").is_none()\
    \ {\n        return false;\n    }\n    // find the month, if it does not exist\
    \ return false.\n    let mut result = date_str.find(\"-\");\n    if result.is_none()\
    \ {\n        return false;\n    }\n    let result = result.unwrap();\n    month\
    \ = date_str[0..result].parse::<i32>().unwrap();\n    date_str = date_str[result\
    \ + 1..].to_string();\n    // check if the month is valid.\n    for i in valid_months.iter()\
    \ {\n        if *i == month {\n            is_valid = true;\n            break;\n\
    \        }\n    }\n    if !is_valid {\n        return false;\n    }\n    // check\
    \ if the days are valid.\n    result = date_str.find(\"-\");\n    if result.is_none()\
    \ {\n        return false;\n    }\n    let result = result.unwrap();\n    day\
    \ = date_str[0..result].parse::<i32>().unwrap();\n    date_str = date_str[result\
    \ + 1..].to_string();\n    is_valid = false;\n    for i in valid_days.iter() {\n\
    \        if *i == day {\n            is_valid = true;\n            break;\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg9jxury9.rs:82:3\n\
    \   |\n14 | fn valid_date(date: String) -> bool {\n   |                      \
    \               - unclosed delimiter\n...\n58 |     for i in valid_days.iter()\
    \ {\n   |                                - unclosed delimiter\n59 |         if\
    \ *i == day {\n   |                      - this delimiter might not be properly\
    \ closed...\n...\n62 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n82 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9jxury9.rs:50:14\n\
    \   |\n36 |     let result = result.unwrap();\n   |                  ---------------\
    \ expected due to this value\n...\n50 |     result = date_str.find(\"-\");\n \
    \  |              ^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n \
    \  |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0599]: no method named `is_none` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpg9jxury9.rs:51:15\n   |\n51 |     if result.is_none() {\n\
    \   |               ^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpg9jxury9.rs:54:25\n\
    \   |\n54 |     let result = result.unwrap();\n   |                         ^^^^^^\
    \ method not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9jxury9.rs:58:5\n\
    \   |\n14 |   fn valid_date(date: String) -> bool {\n   |                    \
    \              ---- expected `bool` because of return type\n...\n58 | /     for\
    \ i in valid_days.iter() {\n59 | |         if *i == day {\n60 | |            \
    \ is_valid = true;\n61 | |             break;\n...  |\n81 | |     assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n82 | | }\n   | |__^ expected `bool`, found `()`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() != 10 {\n        return false;\n    }\n    let\
    \ date_data: Vec<&str> = date.split(\"-\").collect();\n    if date_data.len()\
    \ != 3 {\n        return false;\n    }\n    let month: usize = date_data[0].parse().unwrap();\n\
    \    let day: usize = date_data[1].parse().unwrap();\n    let year: usize = date_data[2].parse().unwrap();\n\
    \    if year < 1000 || year > 9999 {\n        return false;\n    }\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n    if day < 1 || day > 31\
    \ {\n        return false;\n    }\n    if month == 2 {\n        if day > 29 {\n\
    \            return false;\n        }\n    }\n    if day > 30 {\n        if month\
    \ == 4 || month == 6 || month == 9 || month == 11 {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_ref = date.as_ref();\n    if date_ref.len() != 10 {\n\
    \        return false;\n    }\n    let day_str = &date_ref[3..5];\n    let day\
    \ = match day_str.parse::<i32>() {\n        Ok(num) => num,\n        Err(_) =>\
    \ return false,\n    };\n    let month_str = &date_ref[0..2];\n    let month =\
    \ match month_str.parse::<i32>() {\n        Ok(num) => num,\n        Err(_) =>\
    \ return false,\n    };\n    let year_str = &date_ref[6..10];\n    let year =\
    \ match year_str.parse::<i32>() {\n        Ok(num) => num,\n        Err(_) =>\
    \ return false,\n    };\n    if month < 1 || month > 12 {\n        return false;\n\
    \    }\n    if year <= 0 {\n        return false;\n    }\n    if month == 2 {\n\
    \        let is_leap_year = (year % 4 == 0 && year % 100 != 0) || year % 400 ==\
    \ 0;\n        if is_leap_year {\n            if day < 1 || day > 29 {\n      \
    \          return false;\n            }\n        } else {\n            if day\
    \ < 1 || day > 28 {\n                return false;\n            }\n        }\n\
    \    } else if month == 1 || month == 3 || month == 5 || month == 7 || month ==\
    \ 8 || month == 10 || month == 12 {\n        if day < 1 || day > 31 {\n      \
    \      return false;\n        }\n    } else {\n        if day < 1 || day > 30\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpuzcxqz39.rs:15:25\n\
    \   |\n15 |     let date_ref = date.as_ref();\n   |         --------        ^^^^^^\
    \ cannot infer type for type parameter `T` declared on the trait `AsRef`\n   |\
    \         |\n   |         consider giving `date_ref` the explicit type `&T`, where\
    \ the type parameter `T` is specified\n   |\n   = note: type must be known at\
    \ this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.contains(\"-\") && !date.contains(\"/\") {\n        let\
    \ split_date: Vec<_> = date.split(\"-\").collect();\n        if split_date.len()\
    \ == 3 {\n            let date = split_date;\n            let mut date_num = vec![];\n\
    \            for i in date {\n                match i.parse::<i32>() {\n     \
    \               Ok(x) => date_num.push(x),\n                    Err(_) => return\
    \ false,\n                }\n            }\n            if date_num[0] < 1 ||\
    \ date_num[0] > 12 {\n                return false;\n            }\n         \
    \   if date_num[0] == 2 {\n                if date_num[1] < 1 || date_num[1] >\
    \ 29 {\n                    return false;\n                }\n            } else\
    \ if date_num[0] == 1 || date_num[0] == 3 || date_num[0] == 5 || date_num[0] ==\
    \ 7 || date_num[0] == 8 || date_num[0] == 10 || date_num[0] == 12 {\n        \
    \        if date_num[1] < 1 || date_num[1] > 31 {\n                    return\
    \ false;\n                }\n            } else {\n                if date_num[1]\
    \ < 1 || date_num[1] > 30 {\n                    return false;\n             \
    \   }\n            }\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpl7q_d0h3.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut result = true;\n    let temp = date.split('-').collect::<Vec<&str>>();\n\
    \    if temp.len() != 3 {\n        result = false;\n    }\n    let mut days =\
    \ temp[1].parse::<i64>().unwrap();\n    let mut months = temp[0].parse::<i64>().unwrap();\n\
    \    let years = temp[2].parse::<i64>().unwrap();\n    if days < 1 || days > 31\
    \ {\n        result = false;\n    }\n    if months < 1 || months > 12 {\n    \
    \    result = false;\n    }\n    if months == 2 && days > 29 {\n        result\
    \ = false;\n    }\n    if months == 4 || months == 6 || months == 9 || months\
    \ == 11 {\n        if days > 30 {\n            result = false;\n        }\n  \
    \  }\n    if years % 4 == 0 {\n        if months == 2 && days == 29 {\n      \
    \      result = true;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpjw52jwod.rs:20:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_regex = regex::Regex::new(r\"^(0[1-9]|1[0-2])\\-(0[1-9]|[1-2][0-9]|3[0-1])\\\
    -(\\d{4})$\").unwrap();\n    let mut result = false;\n    if date_regex.is_match(&date)\
    \ {\n        let d: Vec<&str> = date.split(\"-\").collect();\n        if d[0].parse::<i32>().unwrap()\
    \ > 0 && d[0].parse::<i32>().unwrap() < 13 &&\n            d[1].parse::<i32>().unwrap()\
    \ > 0 && d[1].parse::<i32>().unwrap() < 32 &&\n            d[2].parse::<i32>().unwrap()\
    \ > 0 {\n            result = true;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmp227mz0rm.rs:15:22\n   |\n15 |     let date_regex = regex::Regex::new(r\"\
    ^(0[1-9]|1[0-2])\\-(0[1-9]|[1-2][0-9]|3[0-1])\\-(\\d{4})$\").unwrap();\n   | \
    \                     ^^^^^ use of undeclared crate or module `regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpo4ttk3oy.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxegs1h27.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let mut\
    \ split = date.split('-');\n    if split.clone().count() != 3 {\n        return\
    \ false;\n    }\n    let day: i32 = split.next().unwrap().parse().unwrap();\n\
    \    let month: i32 = split.next().unwrap().parse().unwrap();\n    let year: i32\
    \ = split.next().unwrap().parse().unwrap();\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n    if month == 2 {\n        if day < 1 || day\
    \ > 29 {\n            return false;\n        }\n    } else if month == 1 || month\
    \ == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12\
    \ {\n        if day < 1 || day > 31 {\n            return false;\n        }\n\
    \    } else {\n        if day < 1 || day > 30 {\n            return false;\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwjlefn1i.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut m_d_y = date.split(\"-\");\n    let m = m_d_y.next().unwrap().parse::<i32>().unwrap();\n\
    \    let d = m_d_y.next().unwrap().parse::<i32>().unwrap();\n    let y = m_d_y.next().unwrap().parse::<i32>().unwrap();\n\
    \    if m > 12 || m < 1 || y < 0 || d < 1 {\n        return false;\n    }\n  \
    \  let is_leap = (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n    match m {\n\
    \        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            d <= 31\n        },\n \
    \       4 | 6 | 9 | 11 => {\n            d <= 30\n        },\n        2 => {\n\
    \            d <= if is_leap { 29 } else { 28 }\n        },\n        _ => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: Empty }', /tmp/tmpoe5d2qmp.rs:16:50\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut it = date.split('-');\n    let v: Vec<&str> = it.collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let dd = v[1].parse::<u32>().unwrap();\n\
    \    let mm = v[0].parse::<u32>().unwrap();\n    let yyyy = v[2].parse::<u32>().unwrap();\n\
    \    if dd < 1 || dd > 31 || mm < 1 || mm > 12 || yyyy < 1000 || yyyy > 3000 {\n\
    \        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqfujwt1f.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // unimplemented!()\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    if re.is_match(&date) {\n        let date_vec: Vec<&str> = date.split(\"\
    -\").collect();\n        let month: u32 = date_vec[0].parse().unwrap();\n    \
    \    let day: u32 = date_vec[1].parse().unwrap();\n        let year: u32 = date_vec[2].parse().unwrap();\n\
    \        if year % 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n          \
    \  if month == 2 && day < 30 {\n                return true;\n            }\n\
    \        }\n        if month == 1 || month == 3 || month == 5 || month == 7 ||\
    \ month == 8 || month == 10 || month == 12 {\n            if day < 32 {\n    \
    \            return true;\n            }\n        }\n        if month == 4 ||\
    \ month == 6 || month == 9 || month == 11 {\n            if day < 31 {\n     \
    \           return true;\n            }\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp7xhe7n6v.rs:16:14\n   |\n16 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let s = date.split(\"-\").collect::<Vec<&str>>();\n    if s.len()\
    \ != 3 {\n        return false;\n    }\n    let mut s2 = s.clone();\n    s2.sort();\n\
    \    if s2[0] != \"01\" || s2[1] != \"01\" || s2[2] != \"2020\" {\n        return\
    \ false;\n    }\n    let m = s[0].parse::<u32>().unwrap();\n    let d = s[1].parse::<u32>().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if m == 2 {\n   \
    \     if d < 1 || d > 29 {\n            return false;\n        }\n    } else if\
    \ m < 8 {\n        if m % 2 == 0 {\n            if d < 1 || d > 30 {\n       \
    \         return false;\n            }\n        } else {\n            if d < 1\
    \ || d > 31 {\n                return false;\n            }\n        }\n    }\
    \ else {\n        if m % 2 == 0 {\n            if d < 1 || d > 31 {\n        \
    \        return false;\n            }\n        } else {\n            if d < 1\
    \ || d > 30 {\n                return false;\n            }\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7k6my__0.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp174qxcyl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date = date.trim();\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let mut date_split = date.split(\"-\");\n    let months =\
    \ date_split.next().unwrap();\n    let days = date_split.next().unwrap();\n  \
    \  let years = date_split.next().unwrap();\n    if years.len() != 4 {\n      \
    \  return false;\n    }\n    let months: u32 = match months.parse() {\n      \
    \  Ok(i) => i,\n        Err(_) => return false,\n    };\n    let days: u32 = match\
    \ days.parse() {\n        Ok(i) => i,\n        Err(_) => return false,\n    };\n\
    \    let years: u32 = match years.parse() {\n        Ok(i) => i,\n        Err(_)\
    \ => return false,\n    };\n    if months > 12 || months < 1 {\n        return\
    \ false;\n    }\n    if (months == 2 && days > 29) || (months == 2 && days < 1)\
    \ {\n        return false;\n    }\n    if (months == 4 || months == 6 || months\
    \ == 9 || months == 11) && (days > 30 || days < 1) {\n        return false;\n\
    \    }\n    if (months == 1 || months == 3 || months == 5 || months == 7 || months\
    \ == 8 || months == 10 || months == 12) && (days > 31 || days < 1) {\n       \
    \ return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmptg95iml9.rs:21:34\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if !date.is_empty() {\n        if let Some(i) = date.find('-')\
    \ {\n            if let Some(j) = date.find('-', i + 1) {\n                let\
    \ (mm, dd, yyyy) = (&date[..i], &date[i + 1..j], &date[j + 1..]);\n          \
    \      match mm.parse::<u32>() {\n                    Ok(m) => {\n           \
    \             match dd.parse::<u32>() {\n                            Ok(d) =>\
    \ {\n                                if 1 <= m && m <= 12 {\n                \
    \                    match m {\n                                        1 | 3\
    \ | 5 | 7 | 8 | 10 | 12 => {\n                                            if 1\
    \ <= d && d <= 31 {\n                                                match yyyy.parse::<u32>()\
    \ {\n                                                    Ok(_) => true,\n    \
    \                                                Err(_) => false,\n          \
    \                                      }\n                                   \
    \         } else {\n                                                false\n  \
    \                                          }\n                               \
    \         }\n                                        4 | 6 | 9 | 11 => {\n   \
    \                                         if 1 <= d && d <= 30 {\n           \
    \                                     match yyyy.parse::<u32>() {\n          \
    \                                          Ok(_) => true,\n                  \
    \                                  Err(_) => false,\n                        \
    \                        }\n                                            } else\
    \ {\n                                                false\n                 \
    \                           }\n                                        }\n   \
    \                                     2 => {\n                               \
    \             if 1 <= d && d <= 29 {\n                                       \
    \         match yyyy.parse::<u32>() {\n                                      \
    \              Ok(_) => true,\n                                              \
    \      Err(_) => false,\n                                                }\n \
    \                                           } else {\n                       \
    \                         false\n                                            }\n\
    \                                        }\n                                 \
    \       _ => false,\n                                    }\n                 \
    \               } else {\n                                    false\n        \
    \                        }\n                            }\n                  \
    \          Err(_) => false,\n                        }\n                    }\n\
    \                    Err(_) => false,\n                }\n            } else {\n\
    \                false\n            }\n        } else {\n            false\n \
    \       }\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp4rqf76wa.rs:17:35\n     |\n17   |             if let Some(j)\
    \ = date.find('-', i + 1) {\n     |                                   ^^^^ ---\
    \  ----- supplied 2 arguments\n     |                                   |\n  \
    \   |                                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let d\
    \ = date.split('-').collect::<Vec<&str>>();\n    if d.len() != 3 {\n        return\
    \ false;\n    }\n    let d1 = d[0].parse::<u8>().unwrap();\n    let d2 = d[1].parse::<u8>().unwrap();\n\
    \    let d3 = d[2].parse::<u32>().unwrap();\n    if d1 < 1 || d1 > 12 {\n    \
    \    return false;\n    }\n    match d1 {\n        1 | 3 | 5 | 7 | 8 | 10 | 12\
    \ => {\n            if d2 < 1 || d2 > 31 {\n                return false;\n  \
    \          }\n        }\n        4 | 6 | 9 | 11 => {\n            if d2 < 1 ||\
    \ d2 > 30 {\n                return false;\n            }\n        }\n       \
    \ 2 => {\n            if d2 < 1 || d2 > 29 {\n                return false;\n\
    \            }\n        }\n        _ => {}\n    }\n    if d3 > 9999 {\n      \
    \  return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmpeph9ogj3.rs:22:33\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxuhisppo.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let parts: Vec<_> = date.split('-').collect();\n    if parts.len()\
    \ != 3 {\n        return false;\n    }\n    let mut days: [usize; 13] = [0, 31,\
    \ 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut number_of_days: usize\
    \ = 0;\n    for (index, part) in parts.iter().enumerate() {\n        if index\
    \ == 0 {\n            if let Ok(num) = part.parse::<usize>() {\n             \
    \   if num == 0 || num > 12 {\n                    return false;\n           \
    \     }\n            } else {\n                return false;\n            }\n\
    \        } else if index == 1 {\n            if let Ok(num) = part.parse::<usize>()\
    \ {\n                if num == 0 {\n                    return false;\n      \
    \          }\n                number_of_days = num;\n            } else {\n  \
    \              return false;\n            }\n        } else if index == 2 {\n\
    \            if let Ok(num) = part.parse::<usize>() {\n                if num\
    \ == 0 {\n                    return false;\n                }\n             \
    \   if num % 4 == 0 {\n                    days[2] = 29;\n                }\n\
    \            } else {\n                return false;\n            }\n        }\n\
    \    }\n    if number_of_days > days[parts[0].parse::<usize>().unwrap()] {\n \
    \       return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsphe6xci.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n  match date.matches(r\"(\\d{2})-(\\d{2})-(\\d{4})\").count() {\n\
    \    0 => false,\n    1 => {\n      let (_, (month, day, year)) = date.matches(r\"\
    (\\d{2})-(\\d{2})-(\\d{4})\").zip(date.matches(r\"(\\d{2})-(\\d{2})-(\\d{4})\"\
    ).map(|f| {\n        let (_, _, year) = f.split_at(6);\n        let (month, _,\
    \ day) = f.split_at(3);\n        (month, day, year)\n      })).next().unwrap();\n\
    \      match month.parse::<i32>().unwrap() {\n        1 | 3 | 5 | 7 | 8 | 10 |\
    \ 12 => {\n          match day.parse::<i32>().unwrap() {\n            0...31 =>\
    \ true,\n            _ => false\n          }\n        },\n        4 | 6 | 9 |\
    \ 11 => {\n          match day.parse::<i32>().unwrap() {\n            0...30 =>\
    \ true,\n            _ => false\n          }\n        },\n        2 => {\n   \
    \       match day.parse::<i32>().unwrap() {\n            0...29 => true,\n   \
    \         _ => false\n          }\n        },\n        _ => false\n      }\n \
    \   },\n    _ => false\n  }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpf5_umz8f.rs:26:14\n\
    \   |\n26 |             0...31 => true,\n   |              ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpf5_umz8f.rs:32:14\n\
    \   |\n32 |             0...30 => true,\n   |              ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpf5_umz8f.rs:38:14\n\
    \   |\n38 |             0...29 => true,\n   |              ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf5_umz8f.rs:19:13\n   |\n19 |\
    \         let (_, _, year) = f.split_at(6);\n   |             ^^^^^^^^^^^^   -------------\
    \ this expression has type `(&str, &str)`\n   |             |\n   |          \
    \   expected a tuple with 2 elements, found one with 3 elements\n   |\n   = note:\
    \ expected tuple `(&str, &str)`\n              found tuple `(_, _, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf5_umz8f.rs:20:13\n   |\n20 |         let (month,\
    \ _, day) = f.split_at(3);\n   |             ^^^^^^^^^^^^^^^   ------------- this\
    \ expression has type `(&str, &str)`\n   |             |\n   |             expected\
    \ a tuple with 2 elements, found one with 3 elements\n   |\n   = note: expected\
    \ tuple `(&str, &str)`\n              "
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Write your code here\n    if date.is_empty() {\n        return\
    \ false;\n    }\n    let words: Vec<&str> = date.split('-').collect();\n    let\
    \ mut months: Vec<i32> = vec![1,3,5,7,8,10,12];\n    if words.len() != 3 {\n \
    \       return false;\n    }\n    let year: i32 = words[2].parse().unwrap();\n\
    \    let month: i32 = words[0].parse().unwrap();\n    let day: i32 = words[1].parse().unwrap();\n\
    \    if day > 31 || month > 12 || month < 1 || day < 1 {\n        return false;\n\
    \    }\n    if month == 2 {\n        if day > 29 {\n            return false;\n\
    \        }\n        if day == 29 {\n            if year % 4 != 0 {\n         \
    \       return false;\n            }\n            if year % 100 == 0 && year %\
    \ 400 != 0 {\n                return false;\n            }\n        }\n    }\n\
    \    if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day\
    \ > 30 {\n            return false;\n        }\n    }\n    if !months.contains(&month)\
    \ {\n        if day > 30 {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprsxfjomx.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp09qrds9l.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // if the string is empty we consider it invalid\n    if date.is_empty()\
    \ {\n        return false;\n    }\n\n    // split the string into month, day and\
    \ year\n    let split_date: Vec<i32> = date.split('-').map(|x| x.parse::<i32>().unwrap()).collect();\n\
    \n    // if the split date has more than 3 elements (month, day and year)\n  \
    \  // or if any of the elements is negative, it is considered invalid\n    if\
    \ split_date.len() != 3 || split_date.iter().any(|x| *x < 0) {\n        return\
    \ false;\n    }\n\n    // make sure that the month is in the range [1, 12]\n \
    \   if split_date[0] < 1 || split_date[0] > 12 {\n        return false;\n    }\n\
    \n    // make sure that the day is in the correct range for that month\n    match\
    \ split_date[0] {\n        2 => {\n            if split_date[1] < 1 || split_date[1]\
    \ > 29 {\n                return false;\n            }\n        },\n        1\
    \ | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if split_date[1] < 1 || split_date[1]\
    \ > 31 {\n                return false;\n            }\n        },\n        4\
    \ | 6 | 9 | 11 => {\n            if split_date[1] < 1 || split_date[1] > 30 {\n\
    \                return false;\n            }\n        },\n        _ => (),\n\
    \    }\n\n    // if we reached here then the date is valid\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut is_valid = true;\n    let mut days_of_month: Vec<i32>\
    \ = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut month_index\
    \ = 0;\n    let mut day_index = 0;\n    let mut year_index = 0;\n    let mut month_digit\
    \ = 0;\n    let mut day_digit = 0;\n    let mut year_digit = 0;\n    let mut date_value:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_value.len() == 3 {\n \
    \       // The date should be in the format: mm-dd-yyyy\n        month_index =\
    \ 0;\n        day_index = 1;\n        year_index = 2;\n    } else {\n        return\
    \ false;\n    }\n    // 1. The date string is not empty.\n    if date.is_empty()\
    \ {\n        return false;\n    }\n    // Parse the month.\n    if let Ok(month)\
    \ = date_value[month_index].parse::<i32>() {\n        month_digit = month;\n \
    \   } else {\n        return false;\n    }\n    // Parse the day.\n    if let\
    \ Ok(day) = date_value[day_index].parse::<i32>() {\n        day_digit = day;\n\
    \    } else {\n        return false;\n    }\n    // Parse the year.\n    if let\
    \ Ok(year) = date_value[year_index].parse::<i32>() {\n        year_digit = year;\n\
    \    } else {\n        return false;\n    }\n    // Calculate the leap year days.\n\
    \    if year_digit % 4 == 0 && year_digit % 100 != 0 || year_digit % 400 == 0\
    \ {\n        days_of_month[1] = 29;\n    }\n    // 2. The number of days is not\
    \ less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\n    // And the\
    \ number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\n\
    \    //\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzbbr2o6.rs:55:78\n   |\n\
    55 |       if year_digit % 4 == 0 && year_digit % 100 != 0 || year_digit % 400\
    \ == 0 {\n   |  ______________________________________________________________________________^\n\
    56 | |         days_of_month[1] = 29;\n57 | |     }\n   | |_____^ expected `bool`,\
    \ found `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_time: Option<chrono::NaiveDate> = NaiveDate::parse_from_str(&date,\
    \ \"%m-%d-%Y\").ok();\n    match date_time {\n        Some(_) => true,\n     \
    \   None => false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chrono`\n\
    \  --> /tmp/tmpcm7g6lwg.rs:15:27\n   |\n15 |     let date_time: Option<chrono::NaiveDate>\
    \ = NaiveDate::parse_from_str(&date, \"%m-%d-%Y\").ok();\n   |               \
    \            ^^^^^^ use of undeclared crate or module `chrono`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `NaiveDate`\n  --> /tmp/tmpcm7g6lwg.rs:15:48\n\
    \   |\n15 |     let date_time: Option<chrono::NaiveDate> = NaiveDate::parse_from_str(&date,\
    \ \"%m-%d-%Y\").ok();\n   |                                                ^^^^^^^^^\
    \ use of undeclared type `NaiveDate`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date = date.replace(\"/\", \"-\");\n    if date.len() !=\
    \ 10 {\n        return false;\n    }\n    let c: Vec<&str> = date.split(\"-\"\
    ).collect();\n    if c.len() != 3 {\n        return false;\n    }\n    let mut\
    \ m = String::from(c[0]);\n    let mut d = String::from(c[1]);\n    let mut y\
    \ = String::from(c[2]);\n    if m.len() == 1 {\n        m = String::from(\"0\"\
    ) + &m;\n    }\n    if d.len() == 1 {\n        d = String::from(\"0\") + &d;\n\
    \    }\n    if y.len() == 1 {\n        y = String::from(\"0\") + &y;\n    }\n\
    \    let newdate = m + \"-\" + &d + \"-\" + &y;\n    if newdate != date {\n  \
    \      return false;\n    }\n    if !m.parse::<i32>().is_ok() || !d.parse::<i32>().is_ok()\
    \ || !y.parse::<i32>().is_ok() {\n        return false;\n    }\n    let m = m.parse::<i32>().unwrap();\n\
    \    let d = d.parse::<i32>().unwrap();\n    let y = y.parse::<i32>().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if m == 2 {\n   \
    \     if y % 4 == 0 {\n            if d < 1 || d > 29 {\n                return\
    \ false;\n            }\n        } else {\n            if d < 1 || d > 28 {\n\
    \                return false;\n            }\n        }\n    } else if m == 1\
    \ || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 {\n        if\
    \ d < 1 || d > 31 {\n            return false;\n        }\n    } else {\n    \
    \    if d < 1 || d > 30 {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `m`\n  --> /tmp/tmp8t1d6de9.rs:39:9\n\
    \   |\n23 |     let mut m = String::from(c[0]);\n   |         ----- move occurs\
    \ because `m` has type `String`, which does not implement the `Copy` trait\n...\n\
    35 |     let newdate = m + \"-\" + &d + \"-\" + &y;\n   |                   -------\
    \ `m` moved due to usage in operator\n...\n39 |     if !m.parse::<i32>().is_ok()\
    \ || !d.parse::<i32>().is_ok() || !y.parse::<i32>().is_ok() {\n   |         ^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n   |\nnote: calling this operator moves the\
    \ left-hand side\n  --> /tmp/tmp8t1d6de9.rs:35:19\n   |\n35 |     let newdate\
    \ = m + \"-\" + &d + \"-\" + &y;\n   |                   ^^^^^^^\n   = note: borrow\
    \ occurs due to deref coercion to `str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5z6avd5j.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let pattern = Regex::new(r\"^([0-1]?[0-9])-([0-3]?[0-9])-([0-9]{4})$\"\
    ).unwrap();\n    let mut result = false;\n    let g:Vec<&str> = pattern.captures(date.as_str()).unwrap().iter().map(|x|\
    \ x.unwrap().as_str()).collect();\n    let mm: i32 = g[1].parse().unwrap();\n\
    \    let dd: i32 = g[2].parse().unwrap();\n    let yyyy: i32 = g[3].parse().unwrap();\n\
    \    if mm < 1 || mm > 12 {\n        result = false;\n    }\n    else if mm ==\
    \ 2 {\n        if dd < 1 || dd > 29 {\n            result = false;\n        }\n\
    \        else {\n            result = true;\n        }\n    }\n    else if mm\
    \ == 4 || mm == 6 || mm == 9 || mm == 11 {\n        if dd < 1 || dd > 30 {\n \
    \           result = false;\n        }\n        else {\n            result = true;\n\
    \        }\n    }\n    else {\n        if dd < 1 || dd > 31 {\n            result\
    \ = false;\n        }\n        else {\n            result = true;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp64gqk6pc.rs:15:19\n   |\n15 |     let pattern = Regex::new(r\"^([0-1]?[0-9])-([0-3]?[0-9])-([0-9]{4})$\"\
    ).unwrap();\n   |                   ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let v:\
    \ Vec<&str> = date.split('-').collect();\n    let mon: i32 = v[0].parse().unwrap();\n\
    \    let day: i32 = v[1].parse().unwrap();\n    let year: i32 = v[2].parse().unwrap();\n\
    \    if mon > 12 || mon < 1 {\n        return false;\n    }\n    if year < 0 {\n\
    \        return false;\n    }\n    if vec![1, 3, 5, 7, 8, 10, 12].contains(&mon)\
    \ {\n        if day < 1 || day > 31 {\n            return false;\n        }\n\
    \    } else if vec![4, 6, 9, 11].contains(&mon) {\n        if day < 1 || day >\
    \ 30 {\n            return false;\n        }\n    } else if mon == 2 {\n     \
    \   if (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 {\n            if\
    \ day < 1 || day > 29 {\n                return false;\n            }\n      \
    \  } else {\n            if day < 1 || day > 28 {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpaleo1epb.rs:20:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpgay1ktz7.rs:15:14\n   |\n15 |     let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let mut v: Vec<&str> = date.split(\"-\").collect();\n    let\
    \ valid = match v.len() {\n        3 => {\n            let month = v[0].parse::<i32>().unwrap();\n\
    \            let day = v[1].parse::<i32>().unwrap();\n            let year = v[2].parse::<i32>().unwrap();\n\
    \            match month {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => day\
    \ >= 1 && day <= 31,\n                4 | 6 | 9 | 11 => day >= 1 && day <= 30,\n\
    \                2 => day >= 1 && day <= 29,\n                _ => false\n   \
    \         } && month >= 1 && month <= 12 && year >= 1\n        },\n        _ =>\
    \ false\n    };\n    valid\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppiogukux.rs:21:13\n   |\n\
    21 | /             match month {\n22 | |                 1 | 3 | 5 | 7 | 8 | 10\
    \ | 12 => day >= 1 && day <= 31,\n23 | |                 4 | 6 | 9 | 11 => day\
    \ >= 1 && day <= 30,\n24 | |                 2 => day >= 1 && day <= 29,\n25 |\
    \ |                 _ => false\n26 | |             } && month >= 1 && month <=\
    \ 12 && year >= 1\n   | |             ^- help: consider using a semicolon here\n\
    \   | |_____________|\n   |               expected `()`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppiogukux.rs:26:27\n   |\n26 |             }\
    \ && month >= 1 && month <= 12 && year >= 1\n   |                           ^\
    \ expected `&&i32`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    match date.find('-') {\n        None => return false,\n     \
    \   Some(idx) => {\n            let month_day = date[..idx].to_string();\n   \
    \         let year = date[idx + 1..].to_string();\n            let month_day_tuple\
    \ = match month_day.find('-') {\n                None => return false,\n     \
    \           Some(idx) => (month_day[..idx].to_string(), month_day[idx + 1..].to_string()),\n\
    \            };\n            let days = match month_day_tuple.1.parse::<i32>()\
    \ {\n                Ok(val) => val,\n                Err(_) => return false,\n\
    \            };\n            let month = match month_day_tuple.0.parse::<i32>()\
    \ {\n                Ok(val) => val,\n                Err(_) => return false,\n\
    \            };\n            let is_leap_year = match year.parse::<i32>() {\n\
    \                Ok(val) => {\n                    if val % 4 == 0 {\n       \
    \                 if val % 100 == 0 {\n                            if val % 400\
    \ == 0 {\n                                true\n                            }\
    \ else {\n                                false\n                            }\n\
    \                        } else {\n                            true\n        \
    \                }\n                    } else {\n                        false\n\
    \                    }\n                }\n                Err(_) => return false,\n\
    \            };\n            let days_allowed = if is_leap_year {\n          \
    \      [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n            } else {\n\
    \                [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n          \
    \  };\n            if month < 1 || month > 12 {\n                return false;\n\
    \            }\n            if days < 1 || days > days_allowed[(month - 1) as\
    \ usize] {\n                return false;\n            }\n        }\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkhsoslyw.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let fields: Vec<&str> = date.split(\"-\").collect();\n    if\
    \ fields.len() != 3 {\n        return false;\n    }\n    let d = fields[0].parse::<i32>().unwrap();\n\
    \    let m = fields[1].parse::<i32>().unwrap();\n    let y = fields[2].parse::<i32>().unwrap();\n\
    \    if d < 1 || d > 31 || m < 1 || m > 12 || y < 1 {\n        return false;\n\
    \    }\n    if m == 2 {\n        if y % 4 == 0 {\n            return d <= 29;\n\
    \        } else {\n            return d <= 28;\n        }\n    }\n    if m ==\
    \ 4 || m == 6 || m == 9 || m == 11 {\n        return d <= 30;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1m7se4it.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.is_empty() {\n        return false;\n    }\n    let day:\
    \ u32;\n    let month: u32;\n    let year: u32;\n    let parts: Vec<&str> = date.split('-').collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    if let Ok(d) = parts[0].parse::<u32>()\
    \ {\n        day = d;\n    } else {\n        return false;\n    }\n    if let\
    \ Ok(m) = parts[1].parse::<u32>() {\n        month = m;\n    } else {\n      \
    \  return false;\n    }\n    if let Ok(y) = parts[2].parse::<u32>() {\n      \
    \  year = y;\n    } else {\n        return false;\n    }\n    if !(1 <= day &&\
    \ day <= 31) {\n        return false;\n    }\n    if !(1 <= month && month <=\
    \ 12) {\n        return false;\n    }\n    if !(2020 <= year && year <= 2040)\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7oqce3ga.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphckpsyc0.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-(19|20)\\d\\d$\").unwrap();\n    }\n\
    \    let m = RE.captures(&date).unwrap();\n    let month = m[1].parse::<i32>().unwrap();\n\
    \    let day = m[2].parse::<i32>().unwrap();\n    let year = m[3].parse::<i32>().unwrap();\n\
    \    println!(\"{}-{}-{}\", month, day, year);\n    match month {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day > 31 || day < 1 {\n       \
    \         return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n\
    \            if day > 30 || day < 1 {\n                return false;\n       \
    \     }\n        }\n        2 => {\n            if (year % 4 == 0 && year % 100\
    \ != 0) || year % 400 == 0 {\n                if day > 29 || day < 1 {\n     \
    \               return false;\n                }\n            } else {\n     \
    \           if day > 28 || day < 1 {\n                    return false;\n    \
    \            }\n            }\n        }\n        _ => return false,\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmp_r700g2o.rs:15:5\n\
    \   |\n15 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmp_r700g2o.rs:18:13\n   |\n18 |     let\
    \ m = RE.captures(&date).unwrap();\n   |             ^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    //coderbyte\n    let days = vec![31,28,31,30,31,30,31,31,30,31,30,31];\n\
    \    if !date.contains(\"-\") || date.len() != 10 {\n        return false;\n \
    \   }\n    let data: Vec<&str> = date.split(\"-\").collect();\n    let month:\
    \ u8 = data[0].parse().unwrap();\n    let day: u8 = data[1].parse().unwrap();\n\
    \    let year: u8 = data[2].parse().unwrap();\n    if month < 1 || month > 12\
    \ || day < 1 || day > 31 || year < 0 || year > 99 {\n        return false;\n \
    \   }\n    if month == 2 && day > 29 {\n        return false;\n    }\n    if month\
    \ != 2 && day > days[month as usize - 1] {\n        return false;\n    }\n   \
    \ return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmpif9mjkij.rs:23:36\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len()\
    \ != 3 {\n        return false;\n    }\n    let year = parts[2].parse::<u16>().unwrap();\n\
    \    let month = parts[0].parse::<u8>().unwrap();\n    let day = parts[1].parse::<u8>().unwrap();\n\
    \    if year == 0 || month == 0 || day == 0 {\n        return false;\n    }\n\
    \    if year < 1582 || year > 9999 {\n        return false;\n    }\n    if month\
    \ > 12 {\n        return false;\n    }\n    if day > 31 {\n        return false;\n\
    \    }\n    match month {\n        1|3|5|7|8|10|12 => {},\n        4|6|9|11 =>\
    \ {\n            if day > 30 {\n                return false;\n            }\n\
    \        },\n        2 => {\n            if day > 29 {\n                return\
    \ false;\n            }\n        },\n        _ => unreachable!()\n    }\n    if\
    \ day == 29 && month == 2 {\n        if year % 4 != 0 {\n            return false;\n\
    \        }\n        if year % 100 == 0 && year % 400 != 0 {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmpuqffujqd.rs:20:40\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    if date.len() != 10 {\n        return false;\n    }\n    let\
    \ (month, day, year) = (date[0..2].parse::<u8>().unwrap(),\n                 \
    \             date[3..5].parse::<u8>().unwrap(),\n                           \
    \   date[6..10].parse::<u16>().unwrap());\n    if year % 4 == 0 && year % 100\
    \ != 0 || year % 400 == 0 {\n        if month == 2 && day > 29 {\n           \
    \ return false;\n        }\n    } else {\n        if month == 2 && day > 28 {\n\
    \            return false;\n        }\n    }\n    if month == 4 || month == 6\
    \ || month == 9 || month == 11 {\n        if day > 30 {\n            return false;\n\
    \        }\n    }\n    if month == 1 || month == 3 || month == 5 || month == 7\
    \ || month == 8 || month == 10 || month == 12 {\n        if day > 31 {\n     \
    \       return false;\n        }\n    }\n    if month > 12 {\n        return false;\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp55f5_921.rs:19:56\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // YOUR CODE HERE\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq0as8d4r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpifny743r.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvsfcn4_u.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpc3hqvveu.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let components: Vec<&str> = date.split(\"-\").collect();\n  \
    \  if components.len() != 3 {\n        return false;\n    }\n    let year = components[2].parse::<i32>().unwrap();\n\
    \    let month = components[0].parse::<i32>().unwrap();\n    let day = components[1].parse::<i32>().unwrap();\n\
    \    if year < 0 || month < 1 || month > 12 || day < 1 {\n        return false;\n\
    \    }\n    if is_leap_year(year) {\n        match month {\n            1 | 3\
    \ | 5 | 7 | 8 | 10 | 12 => return day < 32,\n            4 | 6 | 9 | 11 => return\
    \ day < 31,\n            2 => return day < 30,\n            _ => return false,\n\
    \        }\n    } else {\n        match month {\n            1 | 3 | 5 | 7 | 8\
    \ | 10 | 12 => return day < 32,\n            4 | 6 | 9 | 11 => return day < 31,\n\
    \            2 => return day < 29,\n            _ => return false,\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_leap_year` in this scope\n  -->\
    \ /tmp/tmp5z9rydz5.rs:25:8\n   |\n25 |     if is_leap_year(year) {\n   |     \
    \   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Unimplemented!()\n    let date_re = Regex::new(r\"(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n    date_re.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpjgvuom3p.rs:16:19\n   |\n16 |     let date_re = Regex::new(r\"(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n   |                   ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpe975ex_a.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxyanzuwt.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    use std::collections::HashMap;\n    let month_map: HashMap<_,\
    \ _> = [\n        (1, 31),\n        (2, 29),\n        (3, 31),\n        (4, 30),\n\
    \        (5, 31),\n        (6, 30),\n        (7, 31),\n        (8, 31),\n    \
    \    (9, 30),\n        (10, 31),\n        (11, 30),\n        (12, 31),\n    ].iter().cloned().collect();\n\
    \    let splitted: Vec<_> = date.split(\"-\").collect();\n    if splitted.len()\
    \ != 3 {\n        return false;\n    }\n    let year = match splitted[2].parse::<i32>()\
    \ {\n        Ok(x) => x,\n        Err(_) => return false,\n    };\n    let month\
    \ = match splitted[0].parse::<i32>() {\n        Ok(x) => x,\n        Err(_) =>\
    \ return false,\n    };\n    let day = match splitted[1].parse::<i32>() {\n  \
    \      Ok(x) => x,\n        Err(_) => return false,\n    };\n    if month < 1\
    \ || month > 12 {\n        return false;\n    }\n    let expected_max_day = match\
    \ month_map.get(&month) {\n        Some(x) => *x,\n        None => return false,\n\
    \    };\n    if day < 1 || day > expected_max_day {\n        return false;\n \
    \   }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n \
    \   assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcsz74xx_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    date.parse::<DateTime<Local>>().is_ok()\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `DateTime` in this scope\n  --> /tmp/tmpkkyb5hpm.rs:15:18\n\
    \   |\n15 |     date.parse::<DateTime<Local>>().is_ok()\n   |                \
    \  ^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Local`\
    \ in this scope\n  --> /tmp/tmpkkyb5hpm.rs:15:27\n   |\n14 | fn valid_date(date:\
    \ String) -> bool {\n   |              - help: you might be missing a type parameter:\
    \ `<Local>`\n15 |     date.parse::<DateTime<Local>>().is_ok()\n   |          \
    \                 ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    // Unimplemented!()\n    let split_date = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    let days = split_date[1].parse::<i32>().unwrap();\n    let months = split_date[0].parse::<i32>().unwrap();\n\
    \    let years = split_date[2].parse::<i32>().unwrap();\n    if split_date.len()\
    \ == 3 {\n        if days <= 31 && days >= 1 && months <= 12 && months >= 1 &&\
    \ years > 0 {\n            if months == 1 || months == 3 || months == 5 || months\
    \ == 7 || months == 8 || months == 10 || months == 12 {\n                return\
    \ true;\n            } else if months == 4 || months == 6 || months == 9 || months\
    \ == 11 {\n                if days <= 30 {\n                    return true;\n\
    \                }\n            } else if months == 2 {\n                if days\
    \ <= 29 {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpp2sl1nhx.rs:17:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptppmmtas.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_array: Vec<&str> = date.split(\"-\").collect();\n  \
    \  if date_array.len() != 3 {\n        return false;\n    }\n    let month: u32\
    \ = match date_array[0].parse() {\n        Ok(num) => num,\n        Err(_) =>\
    \ return false,\n    };\n    let day: u32 = match date_array[1].parse() {\n  \
    \      Ok(num) => num,\n        Err(_) => return false,\n    };\n    let year:\
    \ u32 = match date_array[2].parse() {\n        Ok(num) => num,\n        Err(_)\
    \ => return false,\n    };\n    if (1..=12).contains(&month) && (1..=31).contains(&day)\
    \ && (1..=9999).contains(&year) {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0t4plpy3.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n  if date.len() < 10 { return false; }\n  let date_parts: Vec<&str>\
    \ = date.split('-').collect();\n  if date_parts.len() != 3 { return false; }\n\
    \  let m = date_parts[0].parse::<u32>().unwrap();\n  let d = date_parts[1].parse::<u32>().unwrap();\n\
    \  let y = date_parts[2].parse::<u32>().unwrap();\n  if m < 1 || m > 12 { return\
    \ false; }\n  if m == 2 {\n    if d < 1 || d > 29 { return false; }\n  } else\
    \ if m == 4 || m == 6 || m == 9 || m == 11 {\n    if d < 1 || d > 30 { return\
    \ false; }\n  } else {\n    if d < 1 || d > 31 { return false; }\n  }\n  return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n    if\
    \ date_vec.len() != 3 {\n        return false;\n    }\n    let month: i32 = date_vec[0].parse().unwrap();\n\
    \    let day: i32 = date_vec[1].parse().unwrap();\n    let year: i32 = date_vec[2].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if day <\
    \ 1 || day > 31 {\n        return false;\n    }\n    if (month == 4 || month ==\
    \ 6 || month == 9 || month == 11) && day > 30 {\n        return false;\n    }\n\
    \    if month == 2 && day > 29 {\n        return false;\n    }\n    if year <\
    \ 0 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let split: Vec<&str> = date.split('-').collect();\n    let mut\
    \ mm = split[0].parse::<i32>().unwrap();\n    let mut dd = split[1].parse::<i32>().unwrap();\n\
    \    let mut yyyy = split[2].parse::<i32>().unwrap();\n    if mm < 1 || mm > 12\
    \ {\n        return false;\n    }\n    if yyyy < 0 {\n        return false;\n\
    \    }\n    if dd < 1 {\n        return false;\n    }\n    if yyyy == 0 {\n  \
    \      if mm == 2 && dd > 29 {\n            return false;\n        }\n       \
    \ if (mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10 || mm ==\
    \ 12) && dd > 31 {\n            return false;\n        }\n        if (mm == 4\
    \ || mm == 6 || mm == 9 || mm == 11) && dd > 30 {\n            return false;\n\
    \        }\n    } else {\n        if mm == 2 && dd > 28 {\n            return\
    \ false;\n        }\n        if (mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm\
    \ == 8 || mm == 10 || mm == 12) && dd > 31 {\n            return false;\n    \
    \    }\n        if (mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd > 30 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: Empty }', /tmp/tmpvfmu07lk.rs:16:42\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let m: Vec<&str> = date.split(\"-\").collect();\n    match m.len()\
    \ {\n        3 => {\n            if (m[0].len() == 2) && (m[1].len() == 2) &&\
    \ (m[2].len() == 4) {\n                match (m[0].parse::<i32>(), m[1].parse::<i32>(),\
    \ m[2].parse::<i32>()) {\n                    (Ok(mut month), Ok(mut day), Ok(year))\
    \ => {\n                        month = month - 1;\n                        day\
    \ = day - 1;\n                        match month {\n                        \
    \    0 => {\n                                if day >= 0 && day <= 30 {\n    \
    \                                return true;\n                              \
    \  }\n                            },\n                            1 | 3 | 5 |\
    \ 7 | 8 | 10 => {\n                                if day >= 0 && day <= 30 {\n\
    \                                    return true;\n                          \
    \      }\n                            },\n                            2 => {\n\
    \                                if day >= 0 && day <= 29 {\n                \
    \                    return true;\n                                }\n       \
    \                     },\n                            4 | 6 | 9 | 11 => {\n  \
    \                              if day >= 0 && day <= 29 {\n                  \
    \                  return true;\n                                }\n         \
    \                   },\n                            _ => { return false; }\n \
    \                       }\n                    },\n                    _ => {\
    \ return false; }\n                }\n            }\n        },\n        _ =>\
    \ { return false; }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptcnww05e.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n  if date.is_empty() {\n    return false;\n  }\n  let arr: Vec<_>\
    \ = date.split(\"-\").collect();\n  let month: u8 = arr[0].parse().unwrap();\n\
    \  let day: u8 = arr[1].parse().unwrap();\n  let year: u8 = arr[2].parse().unwrap();\n\
    \  match month {\n    1|3|5|7|8|10|12 => {\n      if day < 1 || day > 31 {\n \
    \       return false;\n      }\n    },\n    4|6|9|11 => {\n      if day < 1 ||\
    \ day > 30 {\n        return false;\n      }\n    },\n    2 => {\n      if year\
    \ % 4 == 0 {\n        if day < 1 || day > 29 {\n          return false;\n    \
    \    }\n      } else {\n        if day < 1 || day > 28 {\n          return false;\n\
    \        }\n      }\n    },\n    _ => {\n      return false;\n    }\n  }\n  return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmpv4od7p0m.rs:21:33\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    let (year, month, day) = (\n        date[6..].parse::<u16>().unwrap(),\n\
    \        date[3..5].parse::<u8>().unwrap(),\n        date[..2].parse::<u8>().unwrap(),\n\
    \    );\n    if year < 2020 {\n        return false;\n    }\n    if month > 12\
    \ || month < 1 {\n        return false;\n    }\n    if day > 31 || day < 1 {\n\
    \        return false;\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\
    \ && day > 30 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuvulkdyd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// for example: \n/// valid_date('03-11-2000') => True\n/// valid_date('15-01-2012')\
    \ => False\n/// valid_date('04-0-2040') => False\n/// valid_date('06-04-2020')\
    \ => True\n/// valid_date('06/04/2020') => False\nfn valid_date(date: String)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpm1818yzu.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
