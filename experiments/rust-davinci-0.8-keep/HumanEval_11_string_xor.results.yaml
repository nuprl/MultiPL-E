name: HumanEval_11_string_xor
language: rust
results:
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = u8::from_str_radix(&a, 2).unwrap();\n    let b = u8::from_str_radix(&b,\
    \ 2).unwrap();\n    format!(\"{:b}\", a ^ b)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmpqju0f3z9.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = Vec::new();\n    for i in 0..a.len() {\n        let x = a.chars().nth(i).unwrap();\n\
    \        let y = b.chars().nth(i).unwrap();\n        let z = if x == y {\n   \
    \         '0'\n        } else {\n            '1'\n        };\n        result.push(z);\n\
    \    }\n    String::from_iter(result)\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpf8l49bsf.rs:17:13\n   |\n\
    17 |     String::from_iter(result)\n   |             ^^^^^^^^^ function or associated\
    \ item not found in `String`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\nhelp: there is an associated function with a similar name\n   |\n17 | \
    \    String::from_utf8(result)\n   |             ~~~~~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    while let (Some(a_val), Some(b_val)) = (a_iter.next(), b_iter.next())\
    \ {\n        result.push_str(&format!(\"{}\", a_val.to_digit(10).unwrap() ^ b_val.to_digit(10).unwrap()));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut output = String::new();\n    let mut s1 = a.chars();\n    let mut s2 = b.chars();\n\
    \    loop {\n        let c1 = s1.next();\n        let c2 = s2.next();\n      \
    \  if c1 == None || c2 == None {\n            break;\n        }\n        if c1.unwrap()\
    \ == c2.unwrap() {\n            output.push('0');\n        } else {\n        \
    \    output.push('1');\n        }\n    }\n    output\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out = String::new();\n    let mut chars_a = a.chars();\n    let mut chars_b\
    \ = b.chars();\n    while let (Some(char_a), Some(char_b)) = (chars_a.next(),\
    \ chars_b.next()) {\n        out.push(match (char_a, char_b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Unexpected character.\"\
    ),\n        });\n    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"string_xor: strings must be the same length\"\
    );\n    }\n    let mut ret: String = String::new();\n    for i in 0..a.len() {\n\
    \        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n       \
    \     ret.push('0');\n        } else {\n            ret.push('1');\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    while let (Some(ai), Some(bi)) = (a.next(), b.next()) {\n        result.push(char::from(ai.to_digit(10).unwrap()\
    \ ^ bi.to_digit(10).unwrap() + 48));\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `char: From<u32>` is not satisfied\n  -->\
    \ /tmp/tmphm0mgijl.rs:10:21\n   |\n10 |         result.push(char::from(ai.to_digit(10).unwrap()\
    \ ^ bi.to_digit(10).unwrap() + 48));\n   |                     ^^^^^^^^^^ the\
    \ trait `From<u32>` is not implemented for `char`\n   |\n   = help: the trait\
    \ `From<u8>` is implemented for `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor = String::new();\n    for i in 0..std::cmp::min(a.len(), b.len()) {\n\
    \        let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        xor.push(if a_char == b_char { '0' } else { '1' });\n    }\n    xor\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a_bits = BitVec::from_bytes(&a.into_bytes());\n    let mut b_bits = BitVec::from_bytes(&b.into_bytes());\n\
    \    let mut result = BitVec::new();\n    for _ in 0..a_bits.len() {\n       \
    \ result.push(a_bits.pop().unwrap() ^ b_bits.pop().unwrap());\n    }\n    result.into_bytes().into_iter().map(|byte|\
    \ char::from(byte)).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BitVec`\n -->\
    \ /tmp/tmpp2dgjp1y.rs:6:22\n  |\n6 |     let mut a_bits = BitVec::from_bytes(&a.into_bytes());\n\
    \  |                      ^^^^^^ use of undeclared type `BitVec`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `BitVec`\n --> /tmp/tmpp2dgjp1y.rs:7:22\n\
    \  |\n7 |     let mut b_bits = BitVec::from_bytes(&b.into_bytes());\n  |     \
    \                 ^^^^^^ use of undeclared type `BitVec`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BitVec`\n --> /tmp/tmpp2dgjp1y.rs:8:22\n\
    \  |\n8 |     let mut result = BitVec::new();\n  |                      ^^^^^^\
    \ use of undeclared type `BitVec`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // replace\
    \ all characters with '1'\n    a.chars().zip(b.chars()).map(|(c1, c2)| {\n   \
    \     match (c1, c2) {\n            ('0', '0') => '0',\n            ('1', '1')\
    \ => '0',\n            _ => '1',\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(\n\
    \        a.into_bytes()\n            .into_iter()\n            .zip(b.into_bytes().into_iter())\n\
    \            .map(|(a, b)| a ^ b)\n            .collect::<Vec<u8>>(),\n    )\n\
    \    .unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpci0hwgo5.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let bit_a =\
    \ a.as_bytes()[i] - 48;\n        let bit_b = b.as_bytes()[i] - 48;\n        let\
    \ bit_xor = bit_a ^ bit_b;\n        result.push_str(&bit_xor.to_string());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ bytes_a = a.as_bytes();\n    let bytes_b = b.as_bytes();\n    let max_bytes\
    \ = cmp::max(bytes_a.len(), bytes_b.len());\n    let mut res = Vec::with_capacity(max_bytes);\n\
    \    for i in 0..max_bytes {\n        let mut b = 0u8;\n        if i < bytes_a.len()\
    \ {\n            b = b | bytes_a[i];\n        }\n        if i < bytes_b.len()\
    \ {\n            b = b ^ bytes_b[i];\n        }\n        res.push(b);\n    }\n\
    \    String::from_utf8(res).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmp2pxlny8o.rs:8:21\n  |\n8 |     let max_bytes = cmp::max(bytes_a.len(),\
    \ bytes_b.len());\n  |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ret = String::new();\n    for ((i, j), _k) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        let c = i32::from_str_radix(&a[i..i + 1], 2).unwrap()\n         \
    \   ^ i32::from_str_radix(&b[j..j + 1], 2).unwrap();\n        ret.push_str(&c.to_string());\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbreewwvk.rs:7:10\n  |\n7 |\
    \     for ((i, j), _k) in a.chars().zip(b.chars()).enumerate() {\n  |        \
    \  ^^^^^^         ------------------------------------ this expression has type\
    \ `Option<(usize, (char, char))>`\n  |          |\n  |          expected `usize`,\
    \ found tuple\n  |\n  = note: expected type `usize`\n            found tuple `(_,\
    \ _)`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Strings are not of the same length.\");\n   \
    \ }\n    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push(if\
    \ a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n            '0'\n\
    \        } else {\n            '1'\n        });\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n   \
    \     if i == j {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n    let\
    \ mut result = String::new();\n    let mut buf = [0u8; 1];\n    for i in 0..a.len()\
    \ {\n        buf[0] = a[i] ^ b[i];\n        result.push_str(&String::from_utf8(buf.to_vec()).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpmxednov9.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out: String = String::new();\n    let mut carry = 0;\n    let mut count\
    \ = 0;\n    if a.len() > b.len() {\n        for _ in 0..(a.len() - b.len()) {\n\
    \            b.insert(0, '0');\n        }\n    } else if a.len() < b.len() {\n\
    \        for _ in 0..(b.len() - a.len()) {\n            a.insert(0, '0');\n  \
    \      }\n    }\n    println!(\"{:?} {:?}\", a, b);\n    for (i, a_) in a.chars().rev().enumerate()\
    \ {\n        for (j, b_) in b.chars().rev().enumerate() {\n            if j ==\
    \ i {\n                if a_ == '1' && b_ == '1' {\n                    if carry\
    \ == 0 {\n                        out.insert(0, '0');\n                      \
    \  carry = 1;\n                    } else {\n                        out.insert(0,\
    \ '1');\n                        carry = 1;\n                    }\n         \
    \       } else if a_ == '0' && b_ == '0' {\n                    if carry == 0\
    \ {\n                        out.insert(0, '0');\n                        carry\
    \ = 0;\n                    } else {\n                        out.insert(0, '1');\n\
    \                        carry = 0;\n                    }\n                }\
    \ else {\n                    if carry == 0 {\n                        out.insert(0,\
    \ '1');\n                        carry = 0;\n                    } else {\n  \
    \                      out.insert(0, '0');\n                        carry = 1;\n\
    \                    }\n                }\n            }\n        }\n        count\
    \ += 1;\n    }\n    if carry == 1 {\n        out.insert(0, '1');\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "warning: variable `count` is assigned to, but never used\n --> /tmp/tmpig0oc2d1.rs:8:13\n\
    \  |\n8 |     let mut count = 0;\n  |             ^^^^^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_count` instead\n\nerror[E0596]: cannot\
    \ borrow `b` as mutable, as it is not declared as mutable\n  --> /tmp/tmpig0oc2d1.rs:11:13\n\
    \   |\n5  | fn string_xor(a: String, b: String) -> String {\n   |            \
    \              - help: consider changing this to be mutable: `mut b`\n...\n11\
    \ |             b.insert(0, '0');\n   |             ^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0596]: cannot borrow `a` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpig0oc2d1.rs:15:13\n   |\n5  | fn string_xor(a: String,\
    \ b: String) -> String {\n   |               - help: consider changing this to\
    \ be mutable: `mut a`\n...\n15 |             a.insert(0, '0');\n   |         \
    \    ^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.chars();\n    let b = b.chars();\n    a.zip(b)\n        .map(|(a, b)|\
    \ if a == b { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for i in 0..std::cmp::min(a.len(), b.len()) {\n\
    \        res.push(if a.chars().nth(i) == b.chars().nth(i) {\n            '0'\n\
    \        } else {\n            '1'\n        });\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut res = String::new();\n    for i in 0..a.len() {\n   \
    \     let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        assert!(a_char == '0' || a_char == '1');\n        assert!(b_char == '0'\
    \ || b_char == '1');\n        let res_char = if a_char == b_char { '0' } else\
    \ { '1' };\n        res.push(res_char);\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (0..a.len())\n\
    \        .map(|i| if a.chars().nth(i) == b.chars().nth(i) {\n            '0'\n\
    \        } else {\n            '1'\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n    let\
    \ mut res = Vec::new();\n    for i in 0..a.len() {\n        if a[i] == b[i] {\n\
    \            res.push(48);\n        } else {\n            res.push(49);\n    \
    \    }\n    }\n    unsafe { std::str::from_utf8_unchecked(&res).to_string() }\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpc707uvna.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| {\n            format!(\n    \
    \            \"{}\",\n                if a == b {\n                    0\n   \
    \             } else {\n                    1\n                }\n           \
    \ )\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut out = String::new();\n    for (&i, &j) in a.as_bytes().iter().zip(b.as_bytes().iter())\
    \ {\n        let i = (i - b'0') as i8;\n        let j = (j - b'0') as i8;\n  \
    \      let c = i ^ j;\n        out.push(c.to_string().as_str());\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpttcejwwv.rs:12:18\n   |\n\
    12 |         out.push(c.to_string().as_str());\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.parse::<u32>().unwrap();\n    let b = b.parse::<u32>().unwrap();\n   \
    \ let c = a ^ b;\n    format!(\"{:b}\", c)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"11101100001010\"`,\n right: `\"010010\"`', /tmp/tmpai3k6d_5.rs:14:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut result = Vec::with_capacity(a_bytes.len());\n    for i in 0..a_bytes.len()\
    \ {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp5wybc_k1.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = \"\".to_string();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor = String::new();\n    let mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n\
    \    a.reverse();\n    b.reverse();\n    for (ai, bi) in a.iter().zip(b.iter())\
    \ {\n        xor.push(match (ai, bi) {\n            (b'0', b'0') => '0',\n   \
    \         (b'1', b'1') => '0',\n            _ => '1',\n        });\n    }\n  \
    \  xor.reverse();\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp582nxdps.rs:18:9\n   |\n18 |     xor.reverse();\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut c = String::new();\n    for i in 0..a.len() {\n        c.push(if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(ch1, ch2)| match (ch1, ch2) {\n     \
    \       ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"unexpected\
    \ input\"),\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ xors: Vec<_> = a.chars().zip(b.chars()).map(|(x, y)| x.eq(&y)).collect();\n\
    \    xors.iter().map(|x| match x {\n        true => \"0\",\n        false => \"\
    1\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    String::from_utf8(a.into_bytes().iter().zip(b.into_bytes().iter()).map(|(&x,\
    \ &y)| x ^ y).collect()).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpe86jlacu.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = parse_binary_string(&a);\n    let b = parse_binary_string(&b);\n    let\
    \ xor_result = xor(&a, &b);\n    xor_result.iter().map(|val| val.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_binary_string` in this scope\n\
    \ --> /tmp/tmp85fgrkwq.rs:6:13\n  |\n6 |     let a = parse_binary_string(&a);\n\
    \  |             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `parse_binary_string` in this scope\n --> /tmp/tmp85fgrkwq.rs:7:13\n\
    \  |\n7 |     let b = parse_binary_string(&b);\n  |             ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `xor` in this\
    \ scope\n --> /tmp/tmp85fgrkwq.rs:8:22\n  |\n8 |     let xor_result = xor(&a,\
    \ &b);\n  |                      ^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n   \
    \     res.push(if x == y { '0' } else { '1' });\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor_string = String::new();\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    for i in 0..std::cmp::min(a_bytes.len(), b_bytes.len())\
    \ {\n        xor_string.push((a_bytes[i] ^ b_bytes[i]) as char);\n    }\n    xor_string\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpykjaxqe8.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    let mut last_bit = false;\n    for (a_bit, b_bit)\
    \ in a.chars().zip(b.chars()) {\n        if a_bit == '1' && b_bit == '1' {\n \
    \           res.push(if last_bit { '1' } else { '0' });\n            last_bit\
    \ = true;\n        } else if a_bit == '1' || b_bit == '1' {\n            res.push(if\
    \ last_bit { '0' } else { '1' });\n            last_bit = false;\n        } else\
    \ {\n            res.push(if last_bit { '1' } else { '0' });\n            last_bit\
    \ = false;\n        }\n    }\n    if last_bit {\n        res.push('1');\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000110\"`,\n right: `\"010010\"`', /tmp/tmpjz3l6oe4.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor = String::new();\n    for i in 0..a.len() {\n        let x = a.as_bytes()[i]\
    \ ^ b.as_bytes()[i];\n        xor.push_str(&format!(\"{:x}\", x));\n    }\n  \
    \  xor\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // \
    \   let mut result: String = \"\".to_string();\n    //    if a.len() == b.len()\
    \ {\n    //        for i in 0..a.len() {\n    //            result.push(char::from(u8::from(a.chars().nth(i).unwrap())\
    \ ^ u8::from(b.chars().nth(i).unwrap())));\n    //        }\n    //    }\n   \
    \ //    result\n    let mut result: String = \"\".to_string();\n    if a.len()\
    \ == b.len() {\n        for (ca, cb) in a.chars().zip(b.chars()) {\n         \
    \   result.push(char::from(u8::from(ca) ^ u8::from(cb)));\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `u8: From<char>` is not satisfied\n  -->\
    \ /tmp/tmpjxq8t81v.rs:16:36\n   |\n16 |             result.push(char::from(u8::from(ca)\
    \ ^ u8::from(cb)));\n   |                                    ^^^^^^^^ the trait\
    \ `From<char>` is not implemented for `u8`\n   |\n   = help: the following other\
    \ types implement trait `From<T>`:\n             <f32 as From<i16>>\n        \
    \     <f32 as From<i8>>\n             <f32 as From<u16>>\n             <f32 as\
    \ From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n\nerror[E0277]: the trait bound `u8: From<char>` is not satisfied\n\
    \  --> /tmp/tmpjxq8t81v.rs:16:51\n   |\n16 |             result.push(char::from(u8::from(ca)\
    \ ^ u8::from(cb)));\n   |                                                   ^^^^^^^^\
    \ the trait `From<char>` is not implemented for `u8`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <f32 as From<i16>>\n  \
    \           <f32 as From<i8>>\n             <f32 as From<u16>>\n             <f32\
    \ as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Your\
    \ code here.\n    // And maybe add some tests in lib.rs\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuz7d_neh.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut result = String::new();\n    for i in 0..a.len() {\n\
    \        result.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| a.to_digit(2).unwrap() ^ b.to_digit(2).unwrap())\n\
    \        .map(|n| n.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Make\
    \ strings same length by adding leading zeros.\n    let mut a_len = a.len();\n\
    \    let mut b_len = b.len();\n    let mut a = a;\n    let mut b = b;\n    if\
    \ a_len < b_len {\n        a = a.repeat(b_len / a_len + 1).chars().take(b_len).collect();\n\
    \        a_len = a.len();\n    } else if b_len < a_len {\n        b = b.repeat(a_len\
    \ / b_len + 1).chars().take(a_len).collect();\n        b_len = b.len();\n    }\n\
    \n    let mut result = String::new();\n    for i in 0..a_len {\n        result.push(\n\
    \            match (a.chars().nth(i).unwrap(), b.chars().nth(i).unwrap()) {\n\
    \                ('0', '0') => '0',\n                ('0', '1') => '1',\n    \
    \            ('1', '0') => '1',\n                ('1', '1') => '0',\n        \
    \        _ => unreachable!(),\n            }\n        );\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| match (x, y) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"unexpected\"),\n  \
    \      })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_int = usize::from_str_radix(&a, 2).unwrap();\n    let b_int = usize::from_str_radix(&b,\
    \ 2).unwrap();\n    format!(\"{:b}\", a_int ^ b_int)\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmp58ps8iku.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = Vec::new();\n    let length = cmp::max(a.len(), b.len());\n    for\
    \ i in 0..length {\n        let char_a = a.chars().nth(i).unwrap_or('0');\n  \
    \      let char_b = b.chars().nth(i).unwrap_or('0');\n        if char_a == char_b\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res.iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmp0huopzde.rs:7:18\n  |\n7 |     let length = cmp::max(a.len(), b.len());\n\
    \  |                  ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| x == y)\n        .map(|x| if x\
    \ { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut i = 0;\n    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        result.push_str(&(c1.to_digit(10).unwrap() ^ c2.to_digit(10).unwrap()).to_string());\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut asplit = a.chars();\n    let mut bsplit = b.chars();\n    let mut res =\
    \ String::new();\n    loop {\n        match (asplit.next(), bsplit.next()) {\n\
    \            (Some(x), Some(y)) => {\n                if x == y {\n          \
    \          res.push('0');\n                } else {\n                    res.push('1');\n\
    \                }\n            }\n            _ => break,\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ string_a = a.as_bytes();\n    let string_b = b.as_bytes();\n    let mut result:\
    \ Vec<u8> = Vec::new();\n    for (a, b) in string_a.iter().zip(string_b.iter())\
    \ {\n        result.push(a ^ b);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpnrn1akap.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n   \
    \     out.push(if a == b { '0' } else { '1' });\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::with_capacity(a.len());\n    for pair in a.chars().zip(b.chars())\
    \ {\n        res.push(match pair {\n            (c1, c2) if c1 == c2 => '0',\n\
    \            _ => '1',\n        });\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ as_bytes = a.as_bytes();\n    let bs_bytes = b.as_bytes();\n    if as_bytes.len()\
    \ != bs_bytes.len() {\n        panic!(\"Unequal input string lengths.\");\n  \
    \  }\n    let mut res = Vec::new();\n    for i in 0..as_bytes.len() {\n      \
    \  let one = as_bytes[i] - 48;\n        let two = bs_bytes[i] - 48;\n        res.push((one\
    \ ^ two) + 48);\n    }\n    String::from_utf8(res).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| xor(x, y))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpc06n04r3.rs:8:23\n\
    \  |\n8 |         .map(|(x, y)| xor(x, y))\n  |                       ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ v1: Vec<u8> = a.as_bytes().to_vec();\n    let v2: Vec<u8> = b.as_bytes().to_vec();\n\
    \    v1.iter().zip(v2.iter()).map(|(x, y)| if x == y { '0' as u8 } else { '1'\
    \ as u8 }).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmprd0qdt3i.rs:8:87\n     |\n8    |\
    \     v1.iter().zip(v2.iter()).map(|(x, y)| if x == y { '0' as u8 } else { '1'\
    \ as u8 }).collect()\n     |                                                 \
    \                                      ^^^^^^^ value of type `String` cannot be\
    \ built from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a_bit_iter = a.chars().rev();\n    let mut b_bit_iter = b.chars().rev();\n\
    \    let mut result = String::new();\n\n    while let (Some(a_bit), Some(b_bit))\
    \ = (a_bit_iter.next(), b_bit_iter.next()) {\n        if a_bit == b_bit {\n  \
    \          result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n\n    result.chars().rev().collect()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(aa, bb)| aa == bb)\n        .map(|e|\
    \ if e { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO\
    \ 1.0\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmpq6r031m8.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut out =\
    \ String::new();\n    let mut carry = '0';\n    for (i, j) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        if *i == j {\n            out.push(carry);\n            carry = '0';\n\
    \        } else {\n            if carry == '0' {\n                out.push('1');\n\
    \            } else {\n                out.push('0');\n            }\n       \
    \ }\n    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumschiok.rs:11:18\n   |\n\
    11 |         if *i == j {\n   |                  ^ expected `u8`, found `&u8`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n11 |         if *i == *j\
    \ {\n   |                  +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        match (a_chars.next(), b_chars.next()) {\n\
    \            (Some(a_char), Some(b_char)) => {\n                let char_result\
    \ = match (a_char, b_char) {\n                    ('0', '0') => '0',\n       \
    \             ('0', '1') => '1',\n                    ('1', '0') => '1',\n   \
    \                 ('1', '1') => '0',\n                    _ => panic!(\"String\
    \ XOR contains invalid characters\"),\n                };\n                result.push(char_result);\n\
    \            }\n            (None, None) => break,\n            _ => panic!(\"\
    String XOR inputs are not of equal length\"),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ (a, b) = xor_preconditions(a, b);\n    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor_preconditions` in this scope\n\
    \ --> /tmp/tmp_mxhooeb.rs:6:18\n  |\n6 |     let (a, b) = xor_preconditions(a,\
    \ b);\n  |                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut c = String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(e), Some(f))\
    \ => {\n                c.push_str(&match (e, f) {\n                    ('0',\
    \ '0') => \"0\",\n                    ('0', '1') => \"1\",\n                 \
    \   ('1', '0') => \"1\",\n                    ('1', '1') => \"0\",\n         \
    \           _ => panic!(\"invalid string\"),\n                });\n          \
    \  }\n            (None, None) => break,\n            _ => panic!(\"strings must\
    \ be equal length\"),\n        }\n    }\n    c\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut v: Vec<_> = a.chars().zip(b.chars()).collect();\n    for (c, d) in v.iter_mut()\
    \ {\n        if *c == '1' ^ *d == '1' {\n            *c = '1';\n        } else\
    \ {\n            *c = '0';\n        }\n    }\n    v.into_iter().collect()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n --> /tmp/tmp1ua9_i_r.rs:8:15\n\
    \  |\n8 |         if *c == '1' ^ *d == '1' {\n  |               ^^          ^^\n\
    \  |\nhelp: split the comparison into two\n  |\n8 |         if *c == '1' ^ *d\
    \ && '1' ^ *d == '1' {\n  |                           +++++++++++\n\nerror[E0369]:\
    \ no implementation for `char ^ char`\n --> /tmp/tmp1ua9_i_r.rs:8:22\n  |\n8 |\
    \         if *c == '1' ^ *d == '1' {\n  |                  --- ^ -- char\n  |\
    \                  |\n  |                  char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp1ua9_i_r.rs:8:30\n  |\n8 |         if *c == '1' ^ *d == '1' {\n\
    \  |                              ^^^ expected `bool`, found `char`\n\nerror[E0277]:\
    \ a value of type `String` cannot be built from an iterator over elements of type\
    \ `(char, char)`\n    --> /tmp/tmp1ua9_i_r.rs:14:19\n     |\n14   |     v.into_iter().collect()\n\
    \     |                   ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=(char, char)>`\n     |\n     = help: the trait `FromIterator<(char,\
    \ char)>` is not implemented for `String`\n     = help: the following other types\
    \ implement trait `FromIterator<A>`:\n               <String as FromIterator<&'a\
    \ char>>\n               <String as FromIterator<&'a str>>\n               <String\
    \ as FromIterator<Box<str>>>\n               <String as FromIterator<Cow<'a, str>>>\n\
    \               <String as FromIterator<String>>\n               <String as FromIterator<char>>\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    for (ch_a, ch_b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if ch_a == ch_b { '0' } else { '1' });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    //ascii\
    \ 48 is 0, 49 is 1\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| {\n            (if a == '0' { 48 } else { 49 }) ^ (if b == '0' { 48 } else\
    \ { 49 })\n        })\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ ret: String = a\n        .chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| if x == y { '0' } else { '1' })\n        .collect();\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let mut output\
    \ = vec![];\n    for i in 0..a_bytes.len() {\n        let dec = (a_bytes[i] -\
    \ 48) ^ (b_bytes[i] - 48);\n        output.push(dec + 48);\n    }\n    String::from_utf8(output).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| if x == y { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ans = String::new();\n    for (c, d) in a.chars().zip(b.chars()) {\n   \
    \     let val = (c == '1') ^ (d == '1');\n        if val {\n            ans.push('1');\n\
    \        } else {\n            ans.push('0');\n        }\n    }\n    ans\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_next = a_iter.next();\n        let b_next\
    \ = b_iter.next();\n        if a_next.is_none() || b_next.is_none() {\n      \
    \      break;\n        }\n        let a_val = a_next.unwrap();\n        let b_val\
    \ = b_next.unwrap();\n        if a_val == b_val {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        let a = a == '1';\n        let b = b == '1';\n        let c = a ^ b;\n\
    \        result.push(if c { '1' } else { '0' });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ret = String::new();\n    for (i, (x, y)) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        if x == y {\n            ret.push('0');\n        } else {\n     \
    \       ret.push('1');\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(c, d)| {\n            if c == d {\n \
    \               \"0\"\n            } else {\n                \"1\"\n         \
    \   }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    ///\
    \ Credit: https://rosettacode.org/wiki/Bitwise_operations#Rust\n    fn char_to_binary(c:\
    \ char) -> u8 {\n        match c {\n            '0' => 0,\n            '1' =>\
    \ 1,\n            _ => panic!(\"Invalid input: {}\", c),\n        }\n    }\n\n\
    \    /// Credit: https://rosettacode.org/wiki/Bitwise_operations#Rust\n    fn\
    \ binary_to_char(x: u8) -> char {\n        match x {\n            0 => '0',\n\
    \            1 => '1',\n            _ => panic!(\"Invalid input: {}\", x),\n \
    \       }\n    }\n\n    let a_binary = a.chars().map(char_to_binary).collect::<Vec<u8>>();\n\
    \    let b_binary = b.chars().map(char_to_binary).collect::<Vec<u8>>();\n\n  \
    \  let xored = xor_vectors(&a_binary, &b_binary);\n\n    xored.iter().map(binary_to_char).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor_vectors` in this scope\n  --> /tmp/tmpidv5synw.rs:27:17\n\
    \   |\n27 |     let xored = xor_vectors(&a_binary, &b_binary);\n   |         \
    \        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n \
    \   let b: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n\
    \    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<Vec<u8>>().iter().map(|c|\
    \ c.to_string()).collect::<Vec<String>>().join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let a_bits\
    \ = bits_from_bytes(&a_bytes);\n    let b_bits = bits_from_bytes(&b_bytes);\n\
    \    let result_bits = xor(&a_bits, &b_bits);\n    let result_bytes = bytes_from_bits(&result_bits);\n\
    \    // Convert bytes to a string\n    result_bytes.iter().map(|b| char::from(*b)).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bits_from_bytes` in this scope\n -->\
    \ /tmp/tmplju3rfau.rs:8:18\n  |\n8 |     let a_bits = bits_from_bytes(&a_bytes);\n\
    \  |                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `bits_from_bytes` in this scope\n --> /tmp/tmplju3rfau.rs:9:18\n\
    \  |\n9 |     let b_bits = bits_from_bytes(&b_bytes);\n  |                  ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `xor` in this\
    \ scope\n  --> /tmp/tmplju3rfau.rs:10:23\n   |\n10 |     let result_bits = xor(&a_bits,\
    \ &b_bits);\n   |                       ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `bytes_from_bits` in this scope\n  --> /tmp/tmplju3rfau.rs:11:24\n\
    \   |\n11 |     let result_bytes = bytes_from_bits(&result_bits);\n   |      \
    \                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = \"\".to_string();\n    let mut a_bytes = a.into_bytes();\n    let\
    \ mut b_bytes = b.into_bytes();\n    a_bytes.reverse();\n    b_bytes.reverse();\n\
    \    for (i, _) in a_bytes.iter().enumerate() {\n        let n = match (a_bytes[i],\
    \ b_bytes[i]) {\n            (48, 48) => '0',\n            (48, 49) => '1',\n\
    \            (49, 48) => '1',\n            (49, 49) => '0',\n            _ =>\
    \ panic!(\"Unexpected value\"),\n        };\n        result.push(n);\n    }\n\
    \    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO\n\
    \    String::new()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmpkyrw0yh1.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    let a_chars = a.chars();\n\
    \    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        let a_bit = a_char.to_digit(10).unwrap();\n        let b_bit = b_char.to_digit(10).unwrap();\n\
    \        let xor_bit = a_bit ^ b_bit;\n        result.push_str(&xor_bit.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let len = a.len();\n    for i in 0..len {\n\
    \        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n       \
    \     result.push('0');\n        } else {\n            result.push('1');\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        if a == b {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut out: Vec<char> = Vec::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        out.push(char_xor(i, j));\n    }\n    out.iter().collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n --> /tmp/tmp3tb2m1ki.rs:9:18\n\
    \  |\n9 |         out.push(char_xor(i, j));\n  |                  ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    let mut buffer\
    \ = String::new();\n    loop {\n        let a_char = a_iter.next();\n        let\
    \ b_char = b_iter.next();\n        match (a_char, b_char) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                if a_char == b_char {\n                \
    \    buffer.push('0');\n                } else {\n                    buffer.push('1');\n\
    \                }\n            }\n            _ => {\n                break;\n\
    \            }\n        }\n    }\n    buffer\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_vals: Vec<char> = a.chars().collect();\n    let b_vals: Vec<char> = b.chars().collect();\n\
    \    if a_vals.len() != b_vals.len() {\n        panic!(\"Strings are of different\
    \ length\");\n    }\n    let mut results: Vec<char> = Vec::new();\n    for i in\
    \ 0..a_vals.len() {\n        if a_vals[i] == b_vals[i] {\n            results.push('0');\n\
    \        } else {\n            results.push('1');\n        }\n    }\n    results.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        let a_char = a_chars.next();\n        let\
    \ b_char = b_chars.next();\n        match (a_char, b_char) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                result.push(if a_char == b_char { '0' }\
    \ else { '1' });\n            }\n            _ => break,\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = Vec::with_capacity(a.len());\n    for (&a, &b) in a.bytes().zip(b.bytes())\
    \ {\n        res.push(a ^ b);\n    }\n    String::from_utf8(res).unwrap()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp15q20cvs.rs:7:10\n  |\n7 |\
    \     for (&a, &b) in a.bytes().zip(b.bytes()) {\n  |          ^^         ------------------------\
    \ this expression has type `Option<(u8, u8)>`\n  |          |\n  |          expected\
    \ `u8`, found reference\n  |          help: you can probably remove the explicit\
    \ borrow: `a`\n  |\n  = note:   expected type `u8`\n          found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp15q20cvs.rs:7:14\n  |\n\
    7 |     for (&a, &b) in a.bytes().zip(b.bytes()) {\n  |              ^^     ------------------------\
    \ this expression has type `Option<(u8, u8)>`\n  |              |\n  |       \
    \       expected `u8`, found reference\n  |              help: you can probably\
    \ remove the explicit borrow: `b`\n  |\n  = note:   expected type `u8`\n     \
    \     found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out = String::new();\n    for i in 0..std::cmp::min(a.len(), b.len()) {\n\
    \        let a_num = a.chars().nth(i).unwrap();\n        let b_num = b.chars().nth(i).unwrap();\n\
    \        let a_bit = match a_num {\n            '0' => false,\n            '1'\
    \ => true,\n            _ => panic!(\"Unexpected character {}\", a_num),\n   \
    \     };\n        let b_bit = match b_num {\n            '0' => false,\n     \
    \       '1' => true,\n            _ => panic!(\"Unexpected character {}\", b_num),\n\
    \        };\n        let bit = a_bit ^ b_bit;\n        out.push(if bit { '1' }\
    \ else { '0' });\n    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xor_str = String::new();\n    if a.len() == b.len() {\n        for i in\
    \ 0..a.len() {\n            xor_str.push(match (a.chars().nth(i), b.chars().nth(i))\
    \ {\n                (Some('0'), Some('0')) => '0',\n                (Some('0'),\
    \ Some('1')) => '1',\n                (Some('1'), Some('0')) => '1',\n       \
    \         (Some('1'), Some('1')) => '0',\n                _ => panic!(\"Non binary\
    \ character in input\"),\n            });\n        }\n    } else {\n        panic!(\"\
    The lengths of the two inputs are not equal\");\n    }\n    xor_str\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(if\
    \ a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n            '0'\n\
    \        } else {\n            '1'\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, (a_char, b_char)) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        result.push(match (a_char, b_char) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Unexpected input at index {}\", i),\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    for i in 0..a.len() {\n  \
    \      let ax = a.chars().nth(i).unwrap();\n        let bx = b.chars().nth(i).unwrap();\n\
    \        if ax == bx {\n            result.push('0');\n        } else {\n    \
    \        result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(x, y)| x ^ y)\n        .map(|x| x.to_string())\n\
    \        .collect::<Vec<String>>()\n        .join(\"\")\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<bool> = a.chars().map(|x| x == '1').collect();\n    let b: Vec<bool>\
    \ = b.chars().map(|x| x == '1').collect();\n    let len = cmp::max(a.len(), b.len());\n\
    \    let mut a: Vec<bool> = a.into_iter().cycle().take(len).collect();\n    let\
    \ mut b: Vec<bool> = b.into_iter().cycle().take(len).collect();\n    a.iter_mut().zip(b.iter_mut()).for_each(|(x,\
    \ y)| *x ^= *y);\n    a.into_iter().map(|x| if x { '1' } else { '0' }).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpzd8v_tgr.rs:8:15\n  |\n8 |     let len = cmp::max(a.len(), b.len());\n\
    \  |               ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    loop {\n        let a_next = a_iter.next();\n        let b_next\
    \ = b_iter.next();\n        match (a_next, b_next) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                result.push_str(&(a_int\
    \ ^ b_int).to_string());\n            }\n            (Some(_), None) => {\n  \
    \              result.push_str(\"0\");\n            }\n            (None, Some(_))\
    \ => {\n                result.push_str(\"0\");\n            }\n            (None,\
    \ None) => {\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut out = String::with_capacity(a.len());\n    for i in 0..a.len()\
    \ {\n        let x = a.as_bytes()[i] ^ b.as_bytes()[i];\n        out.push(char::from(x));\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp7i205mfh.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a_char_iter = a.chars();\n    let mut\
    \ b_char_iter = b.chars();\n    while let (Some(a_char), Some(b_char)) = (a_char_iter.next(),\
    \ b_char_iter.next()) {\n        let (a_bit, b_bit) = (a_char.to_digit(10).unwrap(),\
    \ b_char.to_digit(10).unwrap());\n        result.push_str(&(a_bit ^ b_bit).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    xor(\n\
    \        a.as_bytes().to_vec(),\n        b.as_bytes().to_vec(),\n    ).iter()\n\
    \    .map(|x| format!(\"{:x}\", x))\n    .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpuhsad5er.rs:6:5\n\
    \  |\n6 |     xor(\n  |     ^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {:b}\", u32::from_str_radix(&a, 2).unwrap() ^ u32::from_str_radix(&b, 2).unwrap())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmplhy0vwng.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (idx, val) in a.chars().enumerate() {\n\
    \        let xor = val != b.chars().nth(idx).unwrap();\n        result.push(if\
    \ xor { '1' } else { '0' });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n   \
    \     if x == y {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // string\
    \ -> byte vector\n    let mut a = a.as_bytes().to_vec();\n    let mut b = b.as_bytes().to_vec();\n\
    \n    let mut result = String::new();\n\n    // pad the shorter string with zeros\n\
    \    if a.len() < b.len() {\n        a.extend(std::iter::repeat(b'0').take(b.len()\
    \ - a.len()));\n    } else if a.len() > b.len() {\n        b.extend(std::iter::repeat(b'0').take(a.len()\
    \ - b.len()));\n    }\n\n    // xor the bytes\n    for i in 0..a.len() {\n   \
    \     match a[i] ^ b[i] {\n            48 => result.push('0'),\n            49\
    \ => result.push('1'),\n            _ => println!(\"err\"),\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: "err\nerr\nerr\nerr\nerr\nerr\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmpra2xegfi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ chars_a: Vec<_> = a.chars().collect();\n    let chars_b: Vec<_> = b.chars().collect();\n\
    \    let mut results: Vec<char> = Vec::new();\n\n    for i in 0..a.len() {\n \
    \       let num_a = char_to_num(chars_a[i]);\n        let num_b = char_to_num(chars_b[i]);\n\
    \        let result = num_a ^ num_b;\n        results.push(num_to_char(result));\n\
    \    }\n\n    results.iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_to_num` in this scope\n  --> /tmp/tmpwr9bhbhf.rs:11:21\n\
    \   |\n11 |         let num_a = char_to_num(chars_a[i]);\n   |               \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `char_to_num` in this scope\n  --> /tmp/tmpwr9bhbhf.rs:12:21\n   |\n12 |   \
    \      let num_b = char_to_num(chars_b[i]);\n   |                     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `num_to_char`\
    \ in this scope\n  --> /tmp/tmpwr9bhbhf.rs:14:22\n   |\n14 |         results.push(num_to_char(result));\n\
    \   |                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    (a.parse::<u8>().unwrap()\
    \ ^ b.parse::<u8>().unwrap()).to_string()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmprcg6ydxs.rs:6:22\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    for i in 0..a.len() {\n  \
    \      result.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n\
    \            '0'\n        } else {\n            '1'\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ length = if a.len() > b.len() { a.len() } else { b.len() };\n    let mut result\
    \ = String::new();\n    for i in 0..length {\n        let bit_a = if i < a.len()\
    \ { a.chars().nth(i).unwrap() } else { '0' };\n        let bit_b = if i < b.len()\
    \ { b.chars().nth(i).unwrap() } else { '0' };\n        result.push(char_xor(bit_a,\
    \ bit_b));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n  --> /tmp/tmpxwomthyp.rs:11:21\n\
    \   |\n11 |         result.push(char_xor(bit_a, bit_b));\n   |               \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut xor_chars = a.chars().zip(b.chars());\n\
    \    while let Some((first, second)) = xor_chars.next() {\n        let xor = first.to_digit(2).unwrap()\
    \ ^ second.to_digit(2).unwrap();\n        result.push_str(&xor.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut c = String::new();\n\
    \    while let (Some(aa), Some(bb)) = (a.next(), b.next()) {\n        c.push(if\
    \ aa == bb {\n            '0'\n        } else {\n            '1'\n        });\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n    let\
    \ c = a.iter().zip(b.iter()).map(|(x, y)| {\n        assert!(*x == b'0' || *x\
    \ == b'1');\n        assert!(*y == b'0' || *y == b'1');\n        if *x == *y {\n\
    \            b'0'\n        } else {\n            b'1'\n        }\n    });\n  \
    \  String::from_utf8(c.collect()).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut ret = String::new();\n    let a = a.as_bytes();\n    let b = b.as_bytes();\n\
    \    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        let a =\
    \ a[i] - b'0';\n        let b = b[i] - b'0';\n        let x = (a + b) % 2;\n \
    \       ret.push(x as char);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpzizwqkdt.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| if x == y { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut bytes\
    \ = Vec::new();\n    assert_eq!(a_bytes.len(), b_bytes.len());\n    for i in 0..a_bytes.len()\
    \ {\n        let a_byte = a_bytes[i];\n        let b_byte = b_bytes[i];\n    \
    \    assert!(a_byte == b'0' || a_byte == b'1');\n        assert!(b_byte == b'0'\
    \ || b_byte == b'1');\n        if a_byte == b_byte {\n            bytes.push(b'0');\n\
    \        } else {\n            bytes.push(b'1');\n        }\n    }\n    String::from_utf8(bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<char> = a.chars().collect();\n    let b: Vec<char> = b.chars().collect();\n\
    \    let c: Vec<char> = xor(a, b);\n    c.iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmp8nd7ypdk.rs:8:24\n\
    \  |\n8 |     let c: Vec<char> = xor(a, b);\n  |                        ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(a.xor(b));\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `xor` found for type `char` in the current\
    \ scope\n --> /tmp/tmpwwozqijs.rs:8:23\n  |\n8 |         result.push(a.xor(b));\n\
    \  |                       ^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut result = String::new();\n\
    \    while let (Some(a), Some(b)) = (a.next(), b.next()) {\n        result.push(if\
    \ a == b { '0' } else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    for _ in 0..a.count() {\n        match (a.next(), b.next()) {\n         \
    \   (Some('0'), Some('0')) => result.push('0'),\n            (Some('1'), Some('1'))\
    \ => result.push('0'),\n            (Some('0'), Some('1')) => result.push('1'),\n\
    \            (Some('1'), Some('0')) => result.push('1'),\n            _ => panic!(\"\
    Invalid input\"),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `a`\n   --> /tmp/tmpu5a_8bgj.rs:10:16\n\
    \    |\n7   |     let mut a = a.chars();\n    |         ----- move occurs because\
    \ `a` has type `Chars<'_>`, which does not implement the `Copy` trait\n8   | \
    \    let mut b = b.chars();\n9   |     for _ in 0..a.count() {\n    |        \
    \           ------- `a` moved due to this method call\n10  |         match (a.next(),\
    \ b.next()) {\n    |                ^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `a`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    assert_eq!(a_bytes.len(),\
    \ b_bytes.len());\n    let mut result = Vec::with_capacity(a_bytes.len());\n \
    \   for i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n        let\
    \ b_byte = b_bytes[i];\n        assert!(a_byte == b'0' || a_byte == b'1');\n \
    \       assert!(b_byte == b'0' || b_byte == b'1');\n        result.push(\n   \
    \         match (a_byte, b_byte) {\n                (b'0', b'0') => b'0',\n  \
    \              (b'1', b'1') => b'0',\n                (b'0', b'1') => b'1',\n\
    \                (b'1', b'0') => b'1',\n                _ => unreachable!(),\n\
    \            }\n        );\n    }\n    String::from_utf8(result).unwrap()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(c, d)| c.to_digit(2).unwrap() ^ d.to_digit(2).unwrap())\n\
    \        .map(|e| e.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.chars().rev().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n\
    \    let b = b.chars().rev().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n\
    \    let mut result = vec![];\n    for (i, x) in a.iter().enumerate() {\n    \
    \    result.push(if let Some(y) = b.get(i) { x ^ y } else { *x });\n    }\n  \
    \  for (i, x) in b.iter().enumerate() {\n        if a.get(i).is_none() {\n   \
    \         result.push(*x);\n        }\n    }\n    result.iter().rev().map(|&x|\
    \ std::char::from_digit(x, 10).unwrap()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| match (a, b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"),\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ x = String::from(\"0\")\n        .chars()\n        .zip(a.chars())\n       \
    \ .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect::<String>();\n\
    \    let y = String::from(\"0\")\n        .chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect::<String>();\n\
    \    let z = x\n        .chars()\n        .zip(y.chars())\n        .map(|(a, b)|\
    \ if a == b { '0' } else { '1' })\n        .collect::<String>();\n    z\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"010010\"`', /tmp/tmptba68_iw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // The\
    \ unwrap here is safe because we know that a.len() == b.len()\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result = Vec::with_capacity(a_bytes.len());\n\
    \    for i in 0..a_bytes.len() {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n\
    \    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp8zlb290o.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Transform\
    \ the strings into an array of bytes\n    let a_bytes = a.as_bytes();\n    let\
    \ b_bytes = b.as_bytes();\n\n    // As we expect the strings to have equal length,\
    \ we take the\n    // length of the first string.\n    let len = a_bytes.len();\n\
    \n    // Initialize the result string to empty.\n    let mut result = String::new();\n\
    \n    // Iterate over each byte in the arrays.\n    for i in 0..len {\n      \
    \  // XOR each byte of the strings and add the result to the result string.\n\
    \        result.push_str(&format!(\"{}\", a_bytes[i] ^ b_bytes[i]));\n    }\n\n\
    \    // Return the result string.\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.chars().map(|x| x == '1').collect::<Vec<bool>>();\n    let b = b.chars().map(|x|\
    \ x == '1').collect::<Vec<bool>>();\n    let x = repeat_xor(a, b);\n    x.iter().map(|x|\
    \ if *x { '1' } else { '0' }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `repeat_xor` in this scope\n --> /tmp/tmp1ybw7n95.rs:8:13\n\
    \  |\n8 |     let x = repeat_xor(a, b);\n  |             ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let result\
    \ = a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n        .map(|(x,\
    \ y)| x ^ y)\n        .collect::<Vec<u8>>();\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp0plg98eg.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n    let\
    \ mut out = Vec::with_capacity(a.len());\n    for (a, b) in a.into_iter().zip(b.into_iter())\
    \ {\n        out.push(a ^ b);\n    }\n    String::from_utf8(out).unwrap()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp0dwdye6n.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut result = String::new();\n\
    \    while let (Some(x), Some(y)) = (a.next(), b.next()) {\n        let x = x.to_digit(10).unwrap();\n\
    \        let y = y.to_digit(10).unwrap();\n        let z = x ^ y;\n        result.push_str(&z.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    xor(a.as_bytes(),\
    \ b.as_bytes()).iter().map(|&b| b as char).collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpi7g92us0.rs:6:5\n\
    \  |\n6 |     xor(a.as_bytes(), b.as_bytes()).iter().map(|&b| b as char).collect()\n\
    \  |     ^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut output = String::new();\n    for i in 0..a.len() {\n        let mut c =\
    \ 0;\n        match a.chars().nth(i) {\n            Some('0') => {},\n       \
    \     Some('1') => { c += 1; },\n            Some(_) => panic!(\"not a valid character\
    \ in string a\"),\n            None => panic!(\"no such character in string a\"\
    ),\n        }\n        match b.chars().nth(i) {\n            Some('0') => {},\n\
    \            Some('1') => { c += 1; },\n            Some(_) => panic!(\"not a\
    \ valid character in string b\"),\n            None => panic!(\"no such character\
    \ in string b\"),\n        }\n        match c {\n            0 => output.push('0'),\n\
    \            1 => output.push('1'),\n            2 => output.push('0'),\n    \
    \        _ => panic!(\"something went wrong with the XOR\"),\n        }\n    }\n\
    \    output\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::with_capacity(a.len());\n    let bytes_a = a.as_bytes();\n\
    \    let bytes_b = b.as_bytes();\n    for i in 0..a.len() {\n        result.push(match\
    \ (bytes_a[i], bytes_b[i]) {\n            (48, 48) => '0',\n            (48, 49)\
    \ => '1',\n            (49, 48) => '1',\n            (49, 49) => '0',\n      \
    \      _ => unreachable!(),\n        });\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    // a and b are\
    \ guaranteed to be the same length.\n    let result_bytes = a_bytes.iter().zip(b_bytes.iter()).map(|(a,\
    \ b)| a ^ b);\n    // Convert `Vec<u8>` to `String`.\n    let result_string =\
    \ std::str::from_utf8(result_bytes.collect::<Vec<u8>>().as_slice()).unwrap();\n\
    \    result_string.to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpwiawsr_b.rs:11:45\n\
    \   |\n11 |     let result_string = std::str::from_utf8(result_bytes.collect::<Vec<u8>>().as_slice()).unwrap();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \                     - temporary value is freed at the end of this statement\n\
    \   |                                             |\n   |                    \
    \                         creates a temporary which is freed while still in use\n\
    12 |     result_string.to_string()\n   |     ------------------------- borrow\
    \ later used here\n   |\n   = note: consider using a `let` binding to create a\
    \ longer lived value\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(aa), Some(bb))\
    \ => {\n                if aa == bb {\n                    result.push('0');\n\
    \                } else {\n                    result.push('1');\n           \
    \     }\n            }\n            _ => break,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Convert\
    \ strings to bytes\n    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\
    \n    // Make sure the lengths are the same\n    if a_bytes.len() != b_bytes.len()\
    \ {\n        panic!(\"string_xor called with strings of different lengths\");\n\
    \    }\n\n    // Iterate over each byte, producing xor\n    let mut res_bytes\
    \ = Vec::new();\n    for (a_byte, b_byte) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        res_bytes.push(a_byte ^ b_byte);\n    }\n\n    // Return the result\
    \ as a string\n    String::from_utf8(res_bytes).unwrap()\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp7vl1t4io.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| xor(a, b))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpy3t5q7o3.rs:8:23\n\
    \  |\n8 |         .map(|(a, b)| xor(a, b))\n  |                       ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        result.push(match\
    \ a.chars().nth(i).unwrap() {\n            '0' => match b.chars().nth(i).unwrap()\
    \ {\n                '0' => '0',\n                '1' => '1',\n              \
    \  _ => '',\n            },\n            '1' => match b.chars().nth(i).unwrap()\
    \ {\n                '0' => '1',\n                '1' => '0',\n              \
    \  _ => '',\n            },\n            _ => '',\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpoce_s0j2.rs:12:23\n   |\n\
    12 |                 _ => '',\n   |                       ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmpoce_s0j2.rs:17:23\n   |\n17 |\
    \                 _ => '',\n   |                       ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmpoce_s0j2.rs:19:19\n   |\n19 |\
    \             _ => '',\n   |                   ^ empty character literal\n\nerror:\
    \ aborting due to 3 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n    let mut result\
    \ = Vec::new();\n    while a.len() > 0 || b.len() > 0 {\n        let c1 = a.pop().unwrap_or(48);\n\
    \        let c2 = b.pop().unwrap_or(48);\n        if c1 == c2 {\n            result.push(48);\n\
    \        } else {\n            result.push(49);\n        }\n    }\n    result.reverse();\n\
    \    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // create\
    \ Vec of u8 from each string,\n    // and XOR elements of each Vec at the same\
    \ position.\n    // An element of the resulting Vec is cast back to a char\n \
    \   // and appended to a String.\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(ac, bc)| ac.to_digit(2).unwrap() ^ bc.to_digit(2).unwrap())\n   \
    \     .map(|x| char::from(x as u8 + 48))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpj5v2gwih.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut v = vec![];\n    for (x, y) in a.chars().zip(b.chars()) {\n        v.push(if\
    \ x == y { '0' } else { '1' });\n    }\n    v.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let a: Vec<char> = a.chars().collect();\n    let b: Vec<char>\
    \ = b.chars().collect();\n    let mut xor: Vec<char> = Vec::new();\n    for (idx,\
    \ _) in a.iter().enumerate() {\n        xor.push(if a[idx] == b[idx] {\n     \
    \       '0'\n        } else {\n            '1'\n        });\n    }\n    xor.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ xor_bytes = xor(a.as_bytes(), b.as_bytes());\n    String::from_utf8(xor_bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmptis74rwb.rs:6:21\n\
    \  |\n6 |     let xor_bytes = xor(a.as_bytes(), b.as_bytes());\n  |          \
    \           ^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"a and b should have the same length.\");\n  \
    \  }\n    let mut result = String::new();\n    for i in 0..a.len() {\n       \
    \ let mut c = &a[i..i+1];\n        let mut d = &b[i..i+1];\n        result.push_str(&string_xor_char(c,\
    \ d).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `string_xor_char` in this scope\n  -->\
    \ /tmp/tmp8wn9cel6.rs:13:26\n   |\n13 |         result.push_str(&string_xor_char(c,\
    \ d).to_string());\n   |                          ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        let res = match (a, b) {\n            ('0', '0') => '0',\n          \
    \  ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Unexpected input\"),\n        };\n      \
    \  result.push(res);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_as_int = a.parse::<u8>().unwrap();\n    let b_as_int = b.parse::<u8>().unwrap();\n\
    \    let xor_as_int = a_as_int ^ b_as_int;\n    return format!(\"{:b}\", xor_as_int);\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: PosOverflow }', /tmp/tmp3740z5jm.rs:6:36\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| match (a, b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Invalid input.\"),\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_chars: Vec<char> = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\
    \    let mut result = String::new();\n    for i in 0..a_chars.len() {\n      \
    \  let a_val = a_chars[i];\n        let b_val = b_chars[i];\n        if a_val\
    \ == b_val {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| x == y && '0' || '1')\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx9dr5zs2.rs:8:33\n  |\n8 |\
    \         .map(|(x, y)| x == y && '0' || '1')\n  |                           \
    \      ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpx9dr5zs2.rs:8:40\n  |\n8 |         .map(|(x, y)| x == y && '0' || '1')\n\
    \  |                                        ^^^ expected `bool`, found `char`\n\
    \nerror[E0277]: a value of type `String` cannot be built from an iterator over\
    \ elements of type `bool`\n    --> /tmp/tmpx9dr5zs2.rs:9:10\n     |\n9    |  \
    \       .collect()\n     |          ^^^^^^^ value of type `String` cannot be built\
    \ from `std::iter::Iterator<Item=bool>`\n     |\n     = help: the trait `FromIterator<bool>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    return\
    \ a.chars().zip(b.chars()).map(|(c1, c2)| if c1 == c2 { '0' } else { '1' }).collect();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut output = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    while let (Some(a_char), Some(b_char)) = (a_chars.next(),\
    \ b_chars.next()) {\n        if a_char == b_char {\n            output.push('0');\n\
    \        } else {\n            output.push('1');\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ (a, b) = (a.into_bytes(), b.into_bytes());\n    let z = a.iter().zip(b);\n \
    \   let res = z.map(|(c, d)| *c ^ *d).collect::<Vec<u8>>();\n    String::from_utf8(res).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n --> /tmp/tmpghny2w3a.rs:8:35\n\
    \  |\n8 |     let res = z.map(|(c, d)| *c ^ *d).collect::<Vec<u8>>();\n  |   \
    \                                ^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n   \
    \     res.push(if a == b {\n            '0'\n        } else {\n            '1'\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Strings don't have the same length!\");\n   \
    \ }\n\n    let mut result = String::new();\n    for (i, c) in a.chars().enumerate()\
    \ {\n        let c1 = b.chars().nth(i).unwrap();\n        if c == c1 {\n     \
    \       result.push('0');\n        } else {\n            result.push('1');\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut ret = String::new();\n\
    \    loop {\n        let ac = a.next();\n        let bc = b.next();\n        if\
    \ ac.is_none() && bc.is_none() {\n            break;\n        }\n        if ac.is_none()\
    \ || bc.is_none() {\n            panic!(\"a and b must be of the same length\"\
    );\n        }\n        let ac = ac.unwrap();\n        let bc = bc.unwrap();\n\
    \        if ac == '0' && bc == '0' {\n            ret.push('0');\n        } else\
    \ if ac == '1' && bc == '1' {\n            ret.push('0');\n        } else {\n\
    \            ret.push('1');\n        }\n    }\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_arr: Vec<char> = a.chars().collect();\n    let b_arr: Vec<char> = b.chars().collect();\n\
    \    let mut xor_arr: Vec<char> = vec![];\n    for i in 0..a_arr.len() {\n   \
    \     xor_arr.push(if a_arr[i] == b_arr[i] {\n            '0'\n        } else\
    \ {\n            '1'\n        });\n    }\n    xor_arr.iter().collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.into_bytes();\n    let b = b.into_bytes();\n    assert_eq!(a.len(), b.len());\n\
    \    a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmpo9lr4gyp.rs:9:48\n     |\n9    |\
    \     a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()\n     |           \
    \                                     ^^^^^^^ value of type `String` cannot be\
    \ built from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut string = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    loop {\n        let xor = match (a_chars.next(), b_chars.next())\
    \ {\n            (Some(x), Some(y)) => x ^ y,\n            _ => break,\n     \
    \   };\n        string.push(xor);\n    }\n    string\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char ^ char`\n  --> /tmp/tmp_mfmpure.rs:11:37\n\
    \   |\n11 |             (Some(x), Some(y)) => x ^ y,\n   |                   \
    \                - ^ - char\n   |                                   |\n   |  \
    \                                 char\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result\
    \ = String::new();\n    for i in 0..a_bytes.len() {\n        let char_a = a_bytes[i];\n\
    \        let char_b = b_bytes[i];\n        let char_xor = char_a ^ char_b;\n \
    \       result.push(char_xor as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmphblj5906.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut xored = String::new();\n    for (ai, bi) in a.chars().zip(b.chars()) {\n\
    \        xored.push(match (ai, bi) {\n            ('0', '0') => '0',\n       \
    \     ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"unexpected character: {} {}\", ai, bi),\n\
    \        });\n    }\n    xored\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a: Vec<_> = a.chars().collect();\n    let mut b: Vec<_> = b.chars().collect();\n\
    \    let mut len = a.len();\n    if b.len() > len {\n        len = b.len();\n\
    \    }\n    for _ in 0..len {\n        a.insert(0, '0');\n        b.insert(0,\
    \ '0');\n    }\n    let mut result = Vec::new();\n    for i in 0..len {\n    \
    \    if a[i] == b[i] {\n            result.push('0');\n        } else {\n    \
    \        result.push('1');\n        }\n    }\n    result.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000000\"`,\n right: `\"010010\"`', /tmp/tmpqn_l5fky.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(x, y)| (x ^ y) as char)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmptdb4m1_4.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO\n\
    \    \"\".to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n   \
    \ assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmpedoqsqjb.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3k3zsv2k.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Convert\
    \ strings to vecs of integers.\n    let mut a_vec: Vec<char> = a.chars().collect();\n\
    \    let mut b_vec: Vec<char> = b.chars().collect();\n\n    // Ensure that both\
    \ vecs are the same length.\n    if a_vec.len() > b_vec.len() {\n        let mut\
    \ delta = a_vec.len() - b_vec.len();\n        while delta > 0 {\n            b_vec.insert(0,\
    \ '0');\n            delta -= 1;\n        }\n    } else if b_vec.len() > a_vec.len()\
    \ {\n        let mut delta = b_vec.len() - a_vec.len();\n        while delta >\
    \ 0 {\n            a_vec.insert(0, '0');\n            delta -= 1;\n        }\n\
    \    }\n\n    // Perform the XOR operation.\n    let c_vec: Vec<char> = a_vec\n\
    \        .iter()\n        .zip(b_vec.iter())\n        .map(|(x, y)| if x == y\
    \ { '0' } else { '1' })\n        .collect();\n\n    // Convert the result to a\
    \ string.\n    return c_vec.iter().collect();\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO:\
    \ implement me!\n    a.chars().zip(b.chars()).map(|(a, b)| match (a, b) {\n  \
    \      ('0', '0') => '0',\n        ('0', '1') => '1',\n        ('1', '0') => '1',\n\
    \        ('1', '1') => '0',\n        _ => '0',\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {:0>1$b}\", u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b, 2), a.len())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `Result<u8, ParseIntError> ^ Result<u8,\
    \ ParseIntError>`\n --> /tmp/tmpybxq3f4j.rs:6:51\n  |\n6 |     format!(\"{:0>1$b}\"\
    , u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b, 2), a.len())\n  |       \
    \                  ------------------------- ^ ------------------------- Result<u8,\
    \ ParseIntError>\n  |                         |\n  |                         Result<u8,\
    \ ParseIntError>\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n\
    \        if c1 == c2 {\n            result.push('0');\n        } else {\n    \
    \        result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let x = a.chars().nth(i).unwrap();\n\
    \        let y = b.chars().nth(i).unwrap();\n        if x == y {\n           \
    \ result.push('0');\n        } else {\n            result.push('1');\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO!\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0z_w9rt5.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(c1, c2)| (c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap()).to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.as_bytes();\n    let b = b.as_bytes();\n    (0..a.len()).map(|i| a[i]\
    \ ^ b[i]).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmp7t60pub8.rs:8:39\n     |\n8    |\
    \     (0..a.len()).map(|i| a[i] ^ b[i]).collect()\n     |                    \
    \                   ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=u8>`\n\
    \     |\n     = help: the trait `FromIterator<u8>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.into_bytes();\n    let b = b.into_bytes();\n    let mut out = String::new();\n\
    \    for (&c, &d) in a.iter().zip(b.iter()) {\n        out.push(char::from(c ^\
    \ d));\n    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpm4c585tp.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(aa, bb)| aa ^ bb)\n        .map(|bb|\
    \ bb.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\")\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for pair in a.chars().zip(b.chars()) {\n  \
    \      result.push(match pair {\n            (a, b) if a == b => '0',\n      \
    \      _ => '1',\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.as_bytes();\n    let b = b.as_bytes();\n    let mut out = vec![0; a.len()];\n\
    \    for i in 0..a.len() {\n        let a = a[i] == b'1';\n        let b = b[i]\
    \ == b'1';\n        let c = if a ^ b { b'1' } else { b'0' };\n        out[i] =\
    \ c;\n    }\n    std::str::from_utf8(&out).unwrap().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut bytes = Vec::new();\n    for i in 0..a.len() {\n        let c1 = a.as_bytes()[i];\n\
    \        let c2 = b.as_bytes()[i];\n        bytes.push(c1 ^ c2);\n    }\n    unsafe\
    \ { String::from_utf8_unchecked(bytes) }\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmprpzxo0pz.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    let a = a.chars().collect::<Vec<char>>();\n  \
    \  let b = b.chars().collect::<Vec<char>>();\n    for (i, ch) in a.iter().enumerate()\
    \ {\n        res.push(match ch {\n            '0' => match b[i] {\n          \
    \      '0' => '0',\n                '1' => '1',\n                _ => panic!(\"\
    impossible\"),\n            },\n            '1' => match b[i] {\n            \
    \    '0' => '1',\n                '1' => '0',\n                _ => panic!(\"\
    impossible\"),\n            },\n            _ => panic!(\"impossible\"),\n   \
    \     });\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut v: Vec<u8> = Vec::new();\n    let mut s: String = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            v.push(0);\n\
    \        } else {\n            v.push(1);\n        }\n    }\n    for i in v {\n\
    \        s.push_str(&i.to_string());\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a = a.chars().collect::<Vec<char>>();\n    let b = b.chars().collect::<Vec<char>>();\n\
    \    let mut xor = String::new();\n    for i in 0..a.len() {\n        if a[i]\
    \ == b[i] {\n            xor.push('0');\n        } else {\n            xor.push('1');\n\
    \        }\n    }\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| match (a, b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"unexpected character\"\
    ),\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(\n            if i == j {\n                '0'\n        \
    \    } else {\n                '1'\n            }\n        );\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| if x == y { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(a, b)| (a.to_digit(2).unwrap() ^ b.to_digit(2).unwrap()).to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    if a.len()\
    \ != b.len() {\n        panic!(\"Invalid inputs: {} {}\", a, b);\n    }\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(ca, cb)| if ca == cb { '0' } else { '1'\
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut output = String::new();\n    let mut ia = a.chars();\n    let mut ib = b.chars();\n\
    \    loop {\n        let ca = ia.next();\n        let cb = ib.next();\n      \
    \  match (ca, cb) {\n            (Some(a), Some(b)) => {\n                output.push(char_xor(a,\
    \ b));\n            }\n            (Some(_), None) => {\n                panic!(\"\
    Input error: input string b shorter than input string a\");\n            }\n \
    \           (None, Some(_)) => {\n                panic!(\"Input error: input\
    \ string a shorter than input string b\");\n            }\n            (None,\
    \ None) => {\n                break;\n            }\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n  --> /tmp/tmpel58ol9r.rs:14:29\n\
    \   |\n14 |                 output.push(char_xor(a, b));\n   |               \
    \              ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut s = String::new();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(c1), Some(c2))\
    \ => s.push(xor(c1, c2)),\n            _ => break,\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmphnhylset.rs:11:44\n\
    \   |\n11 |             (Some(c1), Some(c2)) => s.push(xor(c1, c2)),\n   |   \
    \                                         ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1rewrahk.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ zipped = a.chars().zip(b.chars());\n    zipped.map(|(x, y)| if x == y { '0'\
    \ } else { '1' }).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {:?}\", a.into_bytes().iter().zip(b.into_bytes().iter()).map(|(x, y)| x ^ y).collect::<Vec<u8>>())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"[0, 1, 0, 0, 1, 0]\"`,\n right: `\"010010\"`', /tmp/tmp_m61jwip.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut res = String::new();\n    for (char_a, char_b) in a.chars().zip(b.chars())\
    \ {\n        if char_a == char_b {\n            res.push('0');\n        } else\
    \ {\n            res.push('1');\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(x, y)| if x == y { '0' } else { '1' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut c = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n     \
    \   c.push(if i == j { '0' } else { '1' });\n    }\n    c\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    let mut output = String::new();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(ai), Some(bi))\
    \ => output.push(xor(ai, bi)),\n            _ => break,\n        }\n    }\n  \
    \  output\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmpzcxoe7u1.rs:11:49\n\
    \   |\n11 |             (Some(ai), Some(bi)) => output.push(xor(ai, bi)),\n  \
    \ |                                                 ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    format!(\"\
    {:b}\", u32::from_str_radix(&a, 2).unwrap() ^ u32::from_str_radix(&b, 2).unwrap())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmp1tt6o8v6.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let mut results\
    \ = Vec::new();\n    for (index, a_byte) in a_bytes.iter().enumerate() {\n   \
    \     let b_byte = b_bytes[index];\n        let result = a_byte ^ b_byte;\n  \
    \      results.push(result);\n    }\n    let result = String::from_utf8(results).unwrap();\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpinbaz6p1.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
