name: HumanEval_123_get_odd_collatz
language: rust
results:
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   unimplemented!()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpryiadxl5.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   vec![1, n]\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 14]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpwwdumcv7.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut i = n;\n    while i > 1 {\n    \
    \    if i & 1 == 1 {\n            result.push(i);\n        }\n        i = if i\
    \ & 1 == 1 { 3 * i + 1 } else { i / 2 };\n    }\n    result.push(1);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpjcg8xi6o.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut num = n;\n    let mut set = HashSet::new();\n    set.insert(n);\n\
    \    while num != 1 {\n        if num % 2 == 0 {\n            num /= 2;\n    \
    \    } else {\n            num = num * 3 + 1;\n        }\n        set.insert(num);\n\
    \    }\n    set.iter().filter(|&&x| x % 2 == 1).map(|&x| x).collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpc6g8zs8j.rs:14:19\n   |\n14 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   assert!(n > 0);\n    let mut result = vec![n];\n    let mut m = n;\n    while\
    \ m != 1 {\n        if m % 2 == 0 {\n            m /= 2;\n        } else {\n \
    \           m = 3 * m + 1;\n        }\n        if m % 2 != 0 {\n            result.push(m);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp4fw8yyrh.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n\n    let mut odds = vec![n];\n\
    \    let mut current = n;\n    loop {\n        if current % 2 == 0 {\n       \
    \     current /= 2;\n        } else {\n            current = 3 * current + 1;\n\
    \        }\n        if current % 2 == 1 {\n            odds.push(current);\n \
    \       }\n        if current == 1 {\n            break;\n        }\n    }\n \
    \   odds\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzp1bq8va.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut current_n = n;\n    while current_n\
    \ != 1 {\n        if current_n % 2 == 1 {\n            result.push(current_n);\n\
    \        }\n        current_n = if current_n % 2 == 0 {\n            current_n\
    \ / 2\n        } else {\n            3 * current_n + 1\n        };\n    }\n  \
    \  result.push(1);\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpdc0o0kvc.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut set = HashSet::new();\n    let mut res = Vec::new();\n    let mut\
    \ start = n;\n    loop {\n        if start == 1 {\n            break;\n      \
    \  }\n        if start % 2 == 1 {\n            set.insert(start);\n        }\n\
    \        start = if start % 2 == 0 {\n            start / 2\n        } else {\n\
    \            start * 3 + 1\n        };\n    }\n    for i in set {\n        res.push(i);\n\
    \    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp79123igk.rs:13:19\n   |\n13 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    while collatz.last().unwrap() != &1 {\n  \
    \      if collatz.last().unwrap() % 2 == 0 {\n            collatz.push(collatz.last().unwrap()\
    \ / 2);\n        } else {\n            collatz.push(collatz.last().unwrap() *\
    \ 3 + 1);\n        }\n    }\n    collatz.into_iter().filter(|&x| x % 2 != 0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxa6e_22u.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![];\n    let mut current = n;\n    res.push(current);\n\
    \    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ /= 2;\n        } else {\n            current = current * 3 + 1;\n        }\n\
    \        if current % 2 != 0 {\n            res.push(current);\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpggkrzihm.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    let mut last = n;\n    loop {\n\
    \        if last == 1 {\n            break;\n        }\n        let next = if\
    \ last % 2 == 0 {\n            last / 2\n        } else {\n            last *\
    \ 3 + 1\n        };\n        collatz.push(next);\n        last = next;\n    }\n\
    \    collatz.into_iter().filter(|x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_m2p8hzu.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    if n <= 0 {\n        return v;\n\
    \    }\n    v.push(n);\n    while n != 1 {\n        if n % 2 == 0 {\n        \
    \    n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n      \
    \  if n % 2 != 0 {\n            v.push(n);\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpm4t3r_lh.rs:20:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n20 |       \
    \      n /= 2;\n   |             ^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpm4t3r_lh.rs:22:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n22 |       \
    \      n = 3 * n + 1;\n   |             ^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   //implementation here\n    let mut v = Vec::new();\n    let mut c = n;\n \
    \   loop {\n        if c == 1 {\n            v.push(c);\n            break;\n\
    \        }\n        v.push(c);\n        if c%2 == 0 {\n            c /= 2;\n \
    \       } else {\n            c = 3*c + 1;\n        }\n    }\n    let mut result\
    \ = Vec::new();\n    for i in v {\n        if i%2 != 0 {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpvd3wrg23.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut curr = n;\n    result.push(curr);\n\
    \    while curr != 1 {\n        if curr % 2 == 0 {\n            curr /= 2;\n \
    \       } else {\n            curr = curr * 3 + 1;\n            result.push(curr);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 40, 16]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp5jcfyvi_.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    while collatz.last().unwrap() != &1 {\n  \
    \      let last = collatz.last().unwrap();\n        if last % 2 == 0 {\n     \
    \       collatz.push(last / 2);\n        } else {\n            collatz.push(last\
    \ * 3 + 1);\n        }\n    }\n    collatz.iter().filter(|&x| x % 2 != 0).map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpyjkvnjr3.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut result = vec![];\n\
    \    let mut value = n;\n    while value != 1 {\n        if value % 2 == 1 {\n\
    \            result.push(value);\n        }\n        value = if value % 2 == 0\
    \ {\n            value / 2\n        } else {\n            3 * value + 1\n    \
    \    };\n    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpvc6c1coe.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut num = n;\n    let mut res = vec![n];\n    while num != 1 {\n     \
    \   if num % 2 == 0 {\n            num /= 2;\n        } else {\n            num\
    \ = 3 * num + 1;\n        }\n        res.push(num);\n    }\n    let mut res: Vec<isize>\
    \ = res.into_iter().filter(|&x| x % 2 != 0).collect();\n    res.sort();\n    res\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut l = Vec::new();\n    let mut m = n;\n    l.push(m);\n    while m !=\
    \ 1 {\n        if m % 2 == 0 {\n            m = m / 2;\n        } else {\n   \
    \         m = 3 * m + 1;\n        }\n        l.push(m);\n    }\n    return l.into_iter().filter(|&x|\
    \ x % 2 != 0).collect();\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp3gvrnq9u.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![];\n    let mut curr = n;\n    while curr != 1 {\n    \
    \    if curr % 2 == 1 {\n            res.push(curr);\n        }\n        curr\
    \ = if curr % 2 == 0 {\n            curr / 2\n        } else {\n            3\
    \ * curr + 1\n        };\n    }\n    res.push(1);\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxk3o50fj.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![];\n    let mut i = n;\n    while i !=\
    \ 1 {\n        collatz.push(i);\n        if i % 2 == 0 {\n            i /= 2;\n\
    \        } else {\n            i = 3 * i + 1;\n        }\n    }\n    collatz.push(1);\n\
    \    collatz.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpbeq5v3h5.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 { return vec![1]; }\n    let mut nums = vec![n];\n    let mut last\
    \ = n;\n    loop {\n        let new = match last % 2 {\n            0 => last\
    \ / 2,\n            _ => last * 3 + 1,\n        };\n        if new == 1 {\n  \
    \          nums.push(1);\n            break;\n        }\n        nums.push(new);\n\
    \        last = new;\n    }\n    nums.iter().filter(|&x| x % 2 != 0).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp0jvvytyb.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut n = n;\n    while n != 1 {\n   \
    \     if n % 2 == 1 {\n            result.push(n);\n        }\n        n = match\
    \ n % 2 {\n            0 => n / 2,\n            _ => 3 * n + 1,\n        };\n\
    \    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpi9ygenxy.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    if n == 1 {\n        v.push(1);\n\
    \        return v;\n    }\n    v.push(n);\n    let mut t = n;\n    while t !=\
    \ 1 {\n        if t % 2 == 0 {\n            t = t / 2;\n        } else {\n   \
    \         t = 3 * t + 1;\n        }\n        if t != 1 && t % 2 != 0 {\n     \
    \       v.push(t);\n        }\n    }\n    v.sort();\n    v\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 7, 11, 13, 14, 17]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx1csmxbj.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut result = vec![n];\n\
    \    let mut curr = n;\n    while curr != 1 {\n        curr = if curr % 2 == 0\
    \ { curr / 2 } else { 3 * curr + 1 };\n        if curr % 2 != 0 {\n          \
    \  result.push(curr);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11,\
    \ 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpyxdwvetf.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![];\n    if n == 1 {\n        v.push(1);\n        return v;\n\
    \    }\n\n    let mut res = collatz(n);\n    // println!(\"{:?}\", res);\n   \
    \ for i in 0..res.len() {\n        if res[i] % 2 != 0 {\n            v.push(res[i]);\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collatz` in this scope\n  --> /tmp/tmpn_zx8vf2.rs:19:19\n\
    \   |\n19 |     let mut res = collatz(n);\n   |                   ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut v: Vec<isize> = Vec::new();\n\
    \    v.push(n);\n    while n != 1 {\n        if n % 2 == 0 {\n            n =\
    \ n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        if\
    \ n % 2 != 0 {\n            v.push(n);\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpiq2lnxn9.rs:20:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n20 |       \
    \      n = n / 2;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpiq2lnxn9.rs:22:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n22 |       \
    \      n = 3 * n + 1;\n   |             ^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut num = n;\n    while num != 1 {\n\
    \        if num % 2 != 0 {\n            result.push(num);\n        }\n       \
    \ num = if num % 2 == 0 { num / 2 } else { 3 * num + 1 };\n    }\n    result.push(1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpt4ra8nye.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut cur = n;\n    let\
    \ mut res = vec![n];\n    while cur != 1 {\n        if cur % 2 == 0 {\n      \
    \      cur /= 2;\n        } else {\n            cur = cur * 3 + 1;\n        }\n\
    \        if cur % 2 == 1 {\n            res.push(cur);\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpijev_5ui.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![];\n    let mut current = n;\n    res.push(n);\n    while\
    \ current != 1 {\n        if current % 2 == 0 {\n            current /= 2;\n \
    \       } else {\n            current = current * 3 + 1;\n            res.push(current);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 40, 16]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpwp8vcl99.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO: implement.\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpk_q3qsug.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut collatz_odd = Vec::new();\n    while n != 1 {\n\
    \        collatz_odd.push(n);\n        n = n & 1 == 0 ? n >> 1 : n * 3 + 1;\n\
    \    }\n    collatz_odd.push(1);\n    collatz_odd\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `n`\n\
    \  --> /tmp/tmpevsoiq6u.rs:17:26\n   |\n17 |         n = n & 1 == 0 ? n >> 1 :\
    \ n * 3 + 1;\n   |                          ^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut odd_collatz = Vec::new();\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    loop {\n        count = collatz[i];\n\
    \        if count % 2 == 0 {\n            odd_collatz.push(count);\n        }\
    \ else {\n            odd_collatz.push(count);\n        }\n        collatz.push(count\
    \ / 2);\n        collatz.push(count * 3 + 1);\n        i += 1;\n        if count\
    \ == 1 {\n            break;\n        }\n    }\n    odd_collatz\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 43, 3, 22, 21, 130, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpnph7ucca.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut res = vec![n];\n    loop {\n        if n == 1\
    \ {\n            break;\n        }\n        let next_n = if n % 2 == 0 { n / 2\
    \ } else { n * 3 + 1 };\n        if next_n % 2 == 1 {\n            res.push(next_n);\n\
    \        }\n        n = next_n;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp88xy4znh.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut result = vec![];\n    while n != 1 {\n       \
    \ if n % 2 == 1 {\n            result.push(n);\n        }\n        n = if n %\
    \ 2 == 0 { n / 2 } else { 3 * n + 1 };\n    }\n    result.push(1);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpybus0w9p.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_collatz: Vec<isize> = Vec::new();\n    if n <= 0 {\n        return\
    \ odd_collatz;\n    }\n\n    let mut curr_odd = n;\n    odd_collatz.push(curr_odd);\n\
    \    loop {\n        let next_num = if curr_odd % 2 == 0 {\n            curr_odd\
    \ / 2\n        } else {\n            3 * curr_odd + 1\n        };\n        if\
    \ next_num % 2 == 1 {\n            odd_collatz.push(next_num);\n        }\n  \
    \      if next_num == 1 {\n            break;\n        }\n        curr_odd = next_num;\n\
    \    }\n    odd_collatz\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpe91yccc7.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    let mut n = n;\n    while n != 1 {\n        if\
    \ n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n +\
    \ 1;\n        }\n        if n % 2 != 0 {\n            res.push(n);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpkrr3s_ol.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odds = Vec::new();\n    let mut current = n;\n    while current !=\
    \ 1 {\n        if current % 2 != 0 {\n            odds.push(current);\n      \
    \  }\n        current = if current % 2 == 0 {\n            current / 2\n     \
    \   } else {\n            3 * current + 1\n        };\n    }\n    odds.push(1);\n\
    \    odds\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmphwlgnovq.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut output: Vec<isize> = Vec::new();\n    let mut i = n;\n    while i\
    \ > 1 {\n        output.push(i);\n        i = (i / 2) + (i % 2);\n    }\n    output.push(1);\n\
    \    output\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 4, 2, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpz1vk33g4.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n\t\
    let mut res = Vec::new();\n\tif n < 1 { return res; }\n\tres.push(n);\n\twhile\
    \ n != 1 {\n\t\tn = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n\t\tif n % 2\
    \ != 0 { res.push(n); }\n\t}\n\tres\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp238poy3o.rs:17:3\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n17 |       \
    \  n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    let mut i = n;\n    while i != 1 {\n        i\
    \ = if i % 2 == 0 { i / 2 } else { 3 * i + 1 };\n        if i % 2 != 0 {\n   \
    \         res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpmg_13zfi.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    let mut n = n;\n    while n != 1 {\n        if\
    \ n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n +\
    \ 1;\n        }\n        if n % 2 != 0 {\n            res.push(n);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpfjb_8e_4.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![n];\n    let mut i = v[0];\n    loop {\n        if i == 1\
    \ {\n            break;\n        } else if i % 2 == 0 {\n            i = i / 2;\n\
    \            v.push(i);\n        } else {\n            i = 3 * i + 1;\n      \
    \      v.push(i);\n        }\n    }\n    v.into_iter().filter(|&x| x % 2 != 0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpfj95logy.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    if n == 1 {\n        return res;\n    }\n    let\
    \ mut cur = n;\n    while cur != 1 {\n        if cur % 2 == 0 {\n            cur\
    \ /= 2;\n        } else {\n            cur = cur * 3 + 1;\n        }\n       \
    \ if cur % 2 != 0 {\n            res.push(cur);\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpgakikrlr.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut num = n;\n    let mut odds = Vec::new();\n    while num != 1 {\n \
    \       if num % 2 != 0 {\n            odds.push(num);\n        }\n        num\
    \ = if num % 2 == 0 {\n            num / 2\n        } else {\n            3 *\
    \ num + 1\n        };\n    }\n    odds.push(1);\n    odds\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpw06tlwb4.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![];\n    let mut odd_collatz: Vec<isize>\
    \ = vec![];\n    let mut current_num = n;\n    collatz.push(current_num);\n  \
    \  while current_num != 1 {\n        if current_num % 2 == 0 {\n            current_num\
    \ = current_num / 2;\n        } else {\n            current_num = current_num\
    \ * 3 + 1;\n        }\n        collatz.push(current_num);\n    }\n    for num\
    \ in collatz {\n        if num % 2 != 0 {\n            odd_collatz.push(num);\n\
    \        }\n    }\n    odd_collatz\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpy94p0_zw.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n\t\
    let mut sequence = vec![];\n\tlet mut number = n;\n\twhile number != 1 {\n\t\t\
    sequence.push(number);\n\t\tif number % 2 == 0 {\n\t\t\tnumber /= 2;\n\t\t} else\
    \ {\n\t\t\tnumber = number * 3 + 1;\n\t\t}\n\t}\n\tsequence.push(1);\n\tsequence.iter().filter(|x|\
    \ **x % 2 != 0).map(|x| *x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp8fv8l5mc.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut n = n;\n    while n != 1 {\n   \
    \     if n % 2 == 1 {\n            result.push(n);\n        }\n        n = if\
    \ n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n    }\n    result.push(1);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp0tp1lymx.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut rn = n;\n    loop {\n        if rn\
    \ == 1 {\n            break;\n        } else if rn % 2 == 0 {\n            rn\
    \ = rn / 2;\n        } else {\n            rn = rn * 3 + 1;\n        }\n     \
    \   collatz.push(rn);\n    }\n    collatz.into_iter().filter(|i| *i % 2 != 0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxfq5v_ve.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut results = Vec::new();\n    let mut x = n;\n    results.push(x);\n\
    \    while x != 1 {\n        x = if x % 2 == 0 { x / 2 } else { 3 * x + 1 };\n\
    \        if x % 2 != 0 {\n            results.push(x);\n        }\n    }\n   \
    \ results\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpp4jejz6y.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![n];\n    let mut odd = vec![];\n    while v.last().unwrap()\
    \ != &1 {\n        if v.last().unwrap() % 2 == 0 {\n            let x = v.last().unwrap()\
    \ / 2;\n            v.push(x);\n        } else {\n            let x = v.last().unwrap()\
    \ * 3 + 1;\n            v.push(x);\n        }\n    }\n    for x in v {\n     \
    \   if x % 2 != 0 {\n            odd.push(x);\n        }\n    }\n    odd\n}\n\n\
    fn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmps3f_en8l.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO: Implement your solution here\n    let mut result = vec![];\n    let\
    \ mut num = n;\n    result.push(num);\n    while num != 1 {\n        num = if\
    \ num % 2 == 0 {\n            num / 2\n        } else {\n            3 * num +\
    \ 1\n        };\n        if num % 2 != 0 {\n            result.push(num);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx6627r8o.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    if n == 1 {\n        result.push(1);\n \
    \       return result;\n    }\n    let mut num = n;\n    while num != 1 {\n  \
    \      if num % 2 == 1 {\n            result.push(num);\n        }\n        num\
    \ = if num % 2 == 0 { num / 2 } else { num * 3 + 1 };\n    }\n    result.push(1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1hk1069v.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut m = n;\n    while m != 1 {\n   \
    \     if m % 2 == 1 {\n            result.push(m);\n        }\n        m = if\
    \ m % 2 == 0 { m / 2 } else { 3 * m + 1 };\n    }\n    result.push(1);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp9zlzj9e4.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    if n == 1 {\n        result.push(1);\n \
    \       return result;\n    }\n    let mut odd_num: isize = if n % 2 == 0 {1}\
    \ else {n};\n    result.push(odd_num);\n    let mut is_even = false;\n    while\
    \ odd_num != 1 {\n        odd_num = if is_even { odd_num/2 } else { 3*odd_num\
    \ + 1 };\n        if odd_num % 2 != 0 {\n            result.push(odd_num);\n \
    \       }\n        is_even = !is_even;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1rz75w0g.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    let mut num = n;\n    while num != 1 {\n     \
    \   num = if num % 2 == 0 { num / 2 } else { num * 3 + 1 };\n        if num %\
    \ 2 != 0 {\n            res.push(num);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpdj_3s77t.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut nums = Vec::new();\n    nums.push(n);\n    let mut i = n;\n    loop\
    \ {\n        if i == 1 {\n            break;\n        }\n        if i % 2 == 0\
    \ {\n            i = i / 2;\n        } else {\n            i = i * 3 + 1;\n  \
    \      }\n        nums.push(i);\n    }\n    let mut result = Vec::new();\n   \
    \ for num in nums {\n        if num % 2 == 1 {\n            result.push(num);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpyokv_lkh.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO implement me!\n    let mut v: Vec<isize> = Vec::new();\n    let mut\
    \ m = n;\n    loop {\n        if m == 1 {\n            v.push(m);\n          \
    \  break;\n        }\n        if m % 2 == 1 {\n            v.push(m);\n      \
    \  }\n        if m % 2 == 0 {\n            m = m / 2;\n        } else {\n    \
    \        m = m * 3 + 1;\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp2ihdz5uj.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut list = vec![n];\n    let mut i = 0;\n    while list[i] != 1 {\n  \
    \      if list[i] % 2 == 0 {\n            list.push(list[i] / 2);\n        } else\
    \ {\n            list.push(list[i] * 3 + 1);\n        }\n        i += 1;\n   \
    \ }\n    list.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzh9sdhfa.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut s: Vec<isize> = Vec::new();\n    let mut r = n;\n    loop {\n    \
    \    if r == 1 {\n            s.push(r);\n            break;\n        } else {\n\
    \            s.push(r);\n            if r % 2 == 0 {\n                r = r /\
    \ 2;\n            } else {\n                r = 3 * r + 1;\n            }\n  \
    \      }\n    }\n    s.iter().filter(|&n| n % 2 != 0).cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpev8b1o6y.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut collatz_sequence = vec![n];\n    while n != 1\
    \ {\n        n = if n % 2 == 0 {\n            n / 2\n        } else {\n      \
    \      3 * n + 1\n        };\n        collatz_sequence.push(n);\n    }\n    collatz_sequence.into_iter().filter(|x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpvzq_ubhu.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // initialize to n and 1, since n should be returned as part of the sequence.\n\
    \    let mut sequence = vec![n, 1];\n    let mut next = n;\n    while next !=\
    \ 1 {\n        next = if next % 2 == 0 {\n            next / 2\n        } else\
    \ {\n            3 * next + 1\n        };\n        if next % 2 != 0 {\n      \
    \      sequence.push(next);\n        }\n    }\n    sequence\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 1, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp25gyeahp.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut c: isize = n;\n    while\
    \ c != 1 {\n        if c % 2 != 0 {\n            v.push(c);\n        }\n     \
    \   c = if c % 2 == 0 {\n            c / 2\n        } else {\n            3 *\
    \ c + 1\n        };\n    }\n    v.push(1);\n    v\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpszvqehej.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut cache = HashMap::new();\n    let mut result = Vec::new();\n    let\
    \ mut c = n;\n    loop {\n        if c & 1 == 1 {\n            result.push(c);\n\
    \        }\n        if c == 1 {\n            break;\n        } else if let Some(next)\
    \ = cache.get(&c) {\n            c = *next;\n        } else {\n            c =\
    \ match c % 2 {\n                0 => c / 2,\n                _ => 3 * c + 1,\n\
    \            };\n            cache.insert(c, c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpw67jxfda.rs:13:21\n   |\n13 |     let mut cache = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO: implement here\n    unimplemented!();\n}\n\nfn main() {\n    let\
    \ candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11,\
    \ 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2eicen51.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut i = n;\n    v.push(i);\n\
    \    while i != 1 {\n        if i % 2 == 0 {\n            i = i / 2;\n       \
    \ } else {\n            i = 3 * i + 1;\n        }\n        v.push(i);\n    }\n\
    \    v.iter().filter(|&x| *x % 2 != 0).map(|&x| x).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpnk16zxtw.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut out = Vec::new();\n    let mut n = n;\n    while n > 1 {\n       \
    \ out.push(n);\n        n = match n % 2 {\n            0 => n / 2,\n         \
    \   _ => 3 * n + 1,\n        };\n    }\n    out.push(1);\n    out\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmp6_m6nkzz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut result = vec![n];\n\
    \    let mut cur = n;\n    loop {\n        if cur == 1 {\n            break;\n\
    \        }\n        if cur % 2 == 0 {\n            cur /= 2;\n        } else {\n\
    \            cur = cur * 3 + 1;\n            result.push(cur);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n   \
    \ assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 40, 16]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzzhpmrw2.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 { return vec![]; }\n    let mut v = vec![];\n    let mut m = n;\n\
    \    while m != 1 {\n        if m % 2 == 1 {\n            v.push(m);\n       \
    \ }\n        m = if m % 2 == 0 { m / 2 } else { 3 * m + 1 };\n    }\n    v.push(1);\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpol39uxi3.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![];\n    if n <= 0 {\n        return collatz;\n\
    \    }\n    let mut num = n;\n    while num != 1 {\n        collatz.push(num);\n\
    \        if num % 2 == 0 {\n            num /= 2;\n        } else {\n        \
    \    num = num * 3 + 1;\n        }\n    }\n    collatz.push(1);\n    let mut odd_collatz:\
    \ Vec<isize> = vec![];\n    for odd in collatz {\n        if odd % 2 != 0 {\n\
    \            odd_collatz.push(odd);\n        }\n    }\n    odd_collatz\n}\n\n\
    fn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpgzmdb_tf.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut next = n;\n    loop {\n        next\
    \ = match next {\n            x if x % 2 == 0 => x / 2,\n            x => 3 *\
    \ x + 1,\n        };\n        if next == 1 {\n            break;\n        }\n\
    \        collatz.push(next);\n    }\n    collatz.into_iter().filter(|&x| x % 2\
    \ != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n  \
    \  assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpnfq296wl.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![n];\n    while v.last().unwrap() != &1 {\n        let x =\
    \ v.last().unwrap();\n        if x % 2 == 0 {\n            v.push(x / 2);\n  \
    \      } else {\n            v.push(3 * x + 1);\n        }\n    }\n    v.into_iter().filter(|x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_t5d5_6b.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = Vec::new();\n    let mut i = n;\n    while i > 1 {\n   \
    \     collatz.push(i);\n        i = if i % 2 == 0 {\n            i / 2\n     \
    \   } else {\n            3 * i + 1\n        };\n    }\n    collatz.push(1);\n\
    \    let collatz: Vec<isize> = collatz.into_iter().filter(|&x| x % 2 != 0).collect();\n\
    \    collatz\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptbso7nc_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut current = n;\n    while current\
    \ != 1 {\n        result.push(current);\n        current = match current % 2 {\n\
    \            0 => current / 2,\n            _ => current * 3 + 1,\n        };\n\
    \    }\n    result.push(1);\n    result.iter().filter(|i| **i % 2 != 0).map(|i|\
    \ *i).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzxqh379b.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut num = n;\n    let mut odd_collatz: Vec<isize> = Vec::new();\n    while\
    \ num != 1 {\n        if num % 2 == 1 {\n            odd_collatz.push(num);\n\
    \        }\n        num = if num % 2 == 0 {\n            num / 2\n        } else\
    \ {\n            3 * num + 1\n        };\n    }\n    odd_collatz.push(1);\n  \
    \  odd_collatz\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpbrm168kh.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut i = n;\n    while i != 1 {\n   \
    \     if i % 2 != 0 {\n            result.push(i);\n        }\n        i = if\
    \ i % 2 == 0 {\n            i / 2\n        } else {\n            i * 3 + 1\n \
    \       };\n    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11,\
    \ 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp7xbx923g.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut num = n;\n    while num != 1 {\n\
    \        if num % 2 != 0 {\n            result.push(num);\n        }\n       \
    \ num = if num % 2 == 0 {\n            num / 2\n        } else {\n           \
    \ 3 * num + 1\n        };\n    }\n    result.push(1);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp3sungqtp.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut result = vec![];\n    while n > 1 {\n        if\
    \ n % 2 == 1 {\n            result.push(n);\n        }\n        n = if n % 2 ==\
    \ 0 { n / 2 } else { 3 * n + 1 };\n    }\n    result.push(1);\n    result\n}\n\
    \nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp9ywdh5w9.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut cur = n;\n    let\
    \ mut v = vec![cur];\n    while cur != 1 {\n        if cur % 2 == 0 {\n      \
    \      cur /= 2;\n        } else {\n            cur = cur * 3 + 1;\n        }\n\
    \        v.push(cur);\n    }\n    v.into_iter().filter(|&i| i % 2 == 1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp7zvb4dv2.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // 1. implement the Collatz sequence code here\n    // 2. from the Collatz\
    \ sequence, get the odd numbers\n    // 3. return a vector of odd numbers\n  \
    \  let mut collatz = vec![n];\n    let mut current = n;\n    while current !=\
    \ 1 {\n        if current % 2 == 0 {\n            current = current / 2;\n   \
    \     } else {\n            current = current * 3 + 1;\n        }\n        collatz.push(current);\n\
    \    }\n    return collatz.into_iter().filter(|&num| num % 2 != 0).collect();\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp4xmtud7l.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut collatz = vec![];\n\
    \    let mut curr_num = n;\n    while curr_num != 1 {\n        collatz.push(curr_num);\n\
    \        if curr_num % 2 == 0 {\n            curr_num /= 2;\n        } else {\n\
    \            curr_num = curr_num * 3 + 1;\n        }\n    }\n    collatz.push(1);\n\
    \    collatz.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmps2hfphs7.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_collatz = Vec::new();\n    let mut current = n;\n    odd_collatz.push(current);\n\
    \    loop {\n        current = if current % 2 == 0 { current / 2 } else { current\
    \ * 3 + 1 };\n        if current == 1 { break; }\n        if current % 2 != 0\
    \ { odd_collatz.push(current); }\n    }\n    odd_collatz\n}\n\nfn main() {\n \
    \   let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxn0iec5w.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut ret = Vec::new();\n    if n <= 0 {\n        return ret;\n    }\n \
    \   ret.push(n);\n    while n != 1 {\n        n = if n & 1 == 0 {\n          \
    \  n / 2\n        } else {\n            3 * n + 1\n        };\n        if n &\
    \ 1 == 1 {\n            ret.push(n);\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp9_egute6.rs:19:9\n\
    \   |\n12 |   fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |             \
    \         - help: consider making this binding mutable: `mut n`\n...\n19 | / \
    \        n = if n & 1 == 0 {\n20 | |             n / 2\n21 | |         } else\
    \ {\n22 | |             3 * n + 1\n23 | |         };\n   | |_________^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   unimplemented!();\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplabohzmt.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![];\n    if n <= 0 {\n        return res;\n    }\n    if\
    \ n == 1 {\n        res.push(1);\n        return res;\n    }\n    res.push(1);\n\
    \    if n % 2 == 1 {\n        res.push(n);\n    }\n    let mut curr = n;\n   \
    \ while curr != 1 {\n        if curr % 2 == 0 {\n            curr /= 2;\n    \
    \    } else {\n            curr = curr * 3 + 1;\n        }\n        if curr %\
    \ 2 == 1 {\n            res.push(curr);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpinv0bre4.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![];\n    if n > 0 {\n        if n % 2 == 1 {\n           \
    \ v.push(n);\n        }\n        let mut x = n;\n        while x > 1 {\n     \
    \       x = if x % 2 == 0 {\n                x / 2\n            } else {\n   \
    \             3 * x + 1\n            };\n            if x % 2 == 1 {\n       \
    \         v.push(x);\n            }\n        }\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp89zlytfs.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut m = n;\n    loop {\n        if m\
    \ == 1 {\n            result.push(m);\n            break;\n        }\n       \
    \ result.push(m);\n        if m % 2 == 0 {\n            m = m / 2;\n        }\
    \ else {\n            m = 3 * m + 1;\n        }\n    }\n    result.retain(|x|\
    \ x % 2 != 0);\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_ags6muw.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n\t\
    unimplemented!()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n   \
    \ assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4prl5yqk.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odds: Vec<isize> = Vec::new();\n    let mut current = n;\n    loop\
    \ {\n        if current % 2 == 1 {\n            odds.push(current);\n        }\n\
    \        if current == 1 {\n            break;\n        }\n        if current\
    \ % 2 == 0 {\n            current = current / 2;\n        } else {\n         \
    \   current = current * 3 + 1;\n        }\n    }\n    odds\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzfjdzg72.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut next = n;\n    while next != 1 {\n\
    \        next = match next % 2 {\n            0 => next / 2,\n            _ =>\
    \ 3 * next + 1,\n        };\n        collatz.push(next);\n    }\n    collatz.into_iter().filter(|&n|\
    \ n % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpel9ojraz.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut current = n;\n    let mut result = vec![];\n    while current != 1\
    \ {\n        result.push(current);\n        if current % 2 == 0 {\n          \
    \  current /= 2;\n        } else {\n            current = current * 3 + 1;\n \
    \       }\n    }\n    result.push(1);\n    result.iter().filter(|x| x.clone()\
    \ % 2 != 0).map(|x| x.clone()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmphgyl8rek.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut collatz = vec![n];\n    while n != 1 {\n     \
    \   if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3\
    \ * n + 1;\n        }\n        collatz.push(n);\n    }\n    collatz.iter().filter(|&x|\
    \ x % 2 != 0).map(|&x| x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpym9k2qof.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut curr = n;\n    let\
    \ mut collatz: Vec<isize> = Vec::new();\n    while curr != 1 {\n        collatz.push(curr);\n\
    \        if curr % 2 == 0 {\n            curr /= 2;\n        } else {\n      \
    \      curr = curr * 3 + 1;\n        }\n    }\n    collatz.push(1);\n    collatz.into_iter().filter(|x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp3k_uzkwz.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![];\n    let mut n = n;\n    while n > 1 {\n       \
    \ collatz.push(n);\n        n = if n % 2 == 0 {\n            n / 2\n        }\
    \ else {\n            3 * n + 1\n        };\n    }\n    collatz.push(1);\n   \
    \ let mut result = collatz.iter().filter(|x| x % 2 != 0).map(|x| *x).collect::<Vec<isize>>();\n\
    \    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpb20_ui_h.rs:24:50\n\
    \   |\n24 |     let mut result = collatz.iter().filter(|x| x % 2 != 0).map(|x|\
    \ *x).collect::<Vec<isize>>();\n   |                                         \
    \       - ^ - {integer}\n   |                                                |\n\
    \   |                                                &&isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `x`\n   |\n24 |     let mut result\
    \ = collatz.iter().filter(|x| *x % 2 != 0).map(|x| *x).collect::<Vec<isize>>();\n\
    \   |                                                +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut result = Vec::new();\n\
    \    let mut current = n;\n    while current != 1 {\n        if current % 2 ==\
    \ 1 {\n            result.push(current);\n        }\n        current = match current\
    \ % 2 {\n            0 => current / 2,\n            _ => current * 3 + 1,\n  \
    \      };\n    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp5c0z3ycl.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut number = n;\n    let mut odds = Vec::new();\n    loop {\n        if\
    \ number == 1 {\n            odds.push(number);\n            break;\n        }\n\
    \        if number % 2 == 1 {\n            odds.push(number);\n        }\n   \
    \     if number % 2 == 0 {\n            number = number / 2;\n        } else {\n\
    \            number = 3 * number + 1;\n        }\n    }\n    odds\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpz1p_n0ow.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut odd_nums = Vec::new();\n\
    \    let mut num = n;\n    while num != 1 {\n        if num % 2 == 1 {\n     \
    \       odd_nums.push(num);\n        }\n        num = if num % 2 == 0 {\n    \
    \        num / 2\n        } else {\n            num * 3 + 1\n        };\n    }\n\
    \    odd_nums.push(1);\n    odd_nums\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpo0zmy23j.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut list = vec![n];\n    let mut num = n;\n    while num != 1 {\n    \
    \    num = if num % 2 == 0 { num / 2 } else { num * 3 + 1 };\n        if num %\
    \ 2 != 0 {\n            list.push(num);\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpv6d0gyaj.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![n];\n    let mut num = n;\n    loop {\n        num = if\
    \ num % 2 == 0 {\n            num / 2\n        } else {\n            3 * num +\
    \ 1\n        };\n        if num == 1 {\n            break;\n        }\n      \
    \  res.push(num);\n    }\n    res.into_iter().filter(|n| n % 2 != 0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmps2_d4ahz.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut num = n;\n    while num != 1 {\n \
    \       num = if num % 2 == 0 { num / 2 } else { 3 * num + 1 };\n        collatz.push(num);\n\
    \    }\n    collatz.into_iter().filter(|i| i % 2 != 0).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx412nqby.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_seq = Vec::new();\n    let mut num = n;\n    while num != 1 {\n\
    \        odd_seq.push(num);\n        if num % 2 == 0 {\n            num /= 2;\n\
    \        } else {\n            num = 3 * num + 1;\n        }\n    }\n    odd_seq.push(1);\n\
    \    odd_seq\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmp0983999z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptz5lsqnx.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![n];\n    let mut is_odd = n % 2 == 1;\n    let mut f = |x|\
    \ { if is_odd { 3 * x + 1 } else { x / 2 } };\n    while n != 1 {\n        n =\
    \ f(n);\n        v.push(n);\n        is_odd = n % 2 == 1;\n    }\n    v.iter().filter(|&x|\
    \ x % 2 == 1).map(|&x| x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `is_odd` is never read\n  --> /tmp/tmpkt3y3bn0.rs:19:9\n\
    \   |\n19 |         is_odd = n % 2 == 1;\n   |         ^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpkt3y3bn0.rs:15:9\n\
    \   |\n15 |     let mut f = |x| { if is_odd { 3 * x + 1 } else { x / 2 } };\n\
    \   |         ----^\n   |         |\n   |         help: remove this `mut`\n  \
    \ |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign\
    \ to immutable argument `n`\n  --> /tmp/tmpkt3y3bn0.rs:17:9\n   |\n12 | fn get_odd_collatz(n:\
    \ isize) -> Vec<isize> {\n   |                    - help: consider making this\
    \ binding mutable: `mut n`\n...\n17 |         n = f(n);\n   |         ^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0506]: cannot assign to `is_odd`\
    \ because it is borrowed\n  --> /tmp/tmpkt3y3bn0.rs:19:9\n   |\n15 |     let mut\
    \ f = |x| { if is_odd { 3 * x + 1 } else { x / 2 } };\n   |                 ---\
    \      ------ borrow occurs due to use in closure\n   |                 |\n  \
    \ |                 borrow of `is_odd` occurs here\n16 |     while n != 1 {\n\
    17 |         n = f(n);\n   |             - borrow later used here\n18 |      \
    \   v.push(n);\n19 |         is_odd = n % 2 == 1;\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ assignment to borrowed `is_odd` occurs here\n\nerror: aborting due to 2 previous\
    \ errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0384,\
    \ E0506.\nFor more information about an error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut ret = Vec::new();\n    let mut m = n;\n    while m > 1 {\n       \
    \ if m % 2 == 1 {\n            ret.push(m);\n        }\n        m = match m %\
    \ 2 {\n            0 => m / 2,\n            _ => 3 * m + 1,\n        };\n    }\n\
    \    ret.push(1);\n    ret\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmppi9ldzbi.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut res = vec![];\n    let mut m = n;\n    res.push(m);\n    while m !=\
    \ 1 {\n        m = collatz(m);\n        if m % 2 == 1 {\n            res.push(m);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collatz` in this scope\n  --> /tmp/tmp5ivvqomw.rs:17:13\n\
    \   |\n17 |         m = collatz(m);\n   |             ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    while collatz.last().unwrap() != &1 {\n  \
    \      let last = collatz.last().unwrap();\n        if last % 2 == 0 {\n     \
    \       collatz.push(last / 2);\n        } else {\n            collatz.push(last\
    \ * 3 + 1);\n        }\n    }\n    collatz.iter().filter(|x| **x % 2 != 0).map(|x|\
    \ *x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpmfd5dq82.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    let mut next = collatz_next(n);\n\
    \    while next != 1 {\n        collatz.push(next);\n        next = collatz_next(next);\n\
    \    }\n    collatz.push(1);\n    let mut odd_collatz: Vec<isize> = vec![];\n\
    \    for i in collatz {\n        if i % 2 != 0 {\n            odd_collatz.push(i);\n\
    \        }\n    }\n    odd_collatz\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collatz_next` in this scope\n  -->\
    \ /tmp/tmpvuhoukd0.rs:14:20\n   |\n14 |     let mut next = collatz_next(n);\n\
    \   |                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `collatz_next` in this scope\n  --> /tmp/tmpvuhoukd0.rs:17:16\n\
    \   |\n17 |         next = collatz_next(next);\n   |                ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut cur = n;\n    let mut collatz = vec![cur];\n    while cur != 1 {\n\
    \        if cur % 2 == 0 {\n            cur /= 2;\n        } else {\n        \
    \    cur = cur * 3 + 1;\n        }\n        collatz.push(cur);\n    }\n    collatz.into_iter().filter(|&x|\
    \ x % 2 == 1).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx2n02ocq.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    let mut m = n;\n    result.push(m);\n    while m != 1 {\n        if m % 2\
    \ == 0 {\n            m /= 2;\n        } else {\n            m = 3 * m + 1;\n\
    \        }\n        if m % 2 != 0 {\n            result.push(m);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n \
    \   assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp0ixjjq5k.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odds: Vec<isize> = Vec::new();\n    let mut curr = n;\n    while curr\
    \ != 1 {\n        odds.push(curr);\n        curr = if curr % 2 == 0 { curr / 2\
    \ } else { 3 * curr + 1 };\n    }\n    odds.push(1);\n    odds\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmpu80snxd6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut result = vec![];\n    loop {\n   \
    \     let temp = collatz.last().unwrap();\n        if temp % 2 == 0 {\n      \
    \      collatz.push(temp / 2);\n        } else {\n            collatz.push(3 *\
    \ temp + 1);\n            result.push(*temp);\n        }\n        if *collatz.last().unwrap()\
    \ == 1 {\n            result.push(1);\n            break;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `collatz` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpd59wyz0d.rs:20:13\n   |\n16 |         let temp =\
    \ collatz.last().unwrap();\n   |                    -------------- immutable borrow\
    \ occurs here\n...\n20 |             collatz.push(3 * temp + 1);\n   |       \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n21 |           \
    \  result.push(*temp);\n   |                         ----- immutable borrow later\
    \ used here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut ret: Vec<isize> = Vec::new();\n    let mut i = n;\n    while i > 1\
    \ {\n        ret.push(i);\n        i = if i % 2 == 0 { i / 2 } else { i * 3 +\
    \ 1 };\n    }\n    ret.push(1);\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmpoiytah53.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![];\n    let mut n = n;\n    while n != 1 {\n        if n\
    \ % 2 != 0 {\n            v.push(n);\n        }\n        n = match n % 2 {\n \
    \           0 => n / 2,\n            _ => n * 3 + 1,\n        };\n    }\n    v.push(1);\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmps7nuyxur.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut cur = n;\n    while cur != 1 {\n\
    \        if cur % 2 == 1 {\n            result.push(cur);\n        }\n       \
    \ cur = if cur % 2 == 0 {\n            cur / 2\n        } else {\n           \
    \ cur * 3 + 1\n        };\n    }\n    result.push(1);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxwd8axga.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut answer = Vec::new();\n    let mut val = n;\n    while val != 1 {\n\
    \        if val % 2 == 1 {\n            answer.push(val);\n        }\n       \
    \ val = if val % 2 == 0 { val / 2 } else { 3 * val + 1 };\n    }\n    answer.push(1);\n\
    \    answer\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptcdnfz5k.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut x = n;\n    let mut res = vec![n];\n    loop {\n        if x == 1\
    \ {\n            break;\n        } else if x % 2 == 0 {\n            x /= 2;\n\
    \        } else {\n            x = 3 * x + 1;\n            res.push(x);\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 40, 16]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp89ewpkkb.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        panic!(\"parameter 'n' should be positive!\");\n    }\n\
    \n    let mut collatz = vec![n];\n    let mut i = n;\n    while i != 1 {\n   \
    \     if i % 2 == 0 {\n            i /= 2;\n        } else {\n            i =\
    \ 3 * i + 1;\n        }\n        collatz.push(i);\n    }\n\n    collatz.into_iter().filter(|&x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxi5bg_1a.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // I hate math\n    let mut num = n;\n    let mut list = vec![n];\n    loop\
    \ {\n        if num % 2 == 0 {\n            num /= 2;\n        } else {\n    \
    \        num = num * 3 + 1;\n        }\n        if num == 1 {\n            break;\n\
    \        }\n        list.push(num);\n    }\n    list.into_iter().filter(|&x| x\
    \ % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpc4t3kfcm.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut current = n;\n    while current !=\
    \ 1 {\n        if current % 2 == 0 {\n            current /= 2;\n        } else\
    \ {\n            current = current * 3 + 1;\n        }\n        collatz.push(current);\n\
    \    }\n    collatz.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx2acljom.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut s = n;\n    while s != 1 {\n   \
    \     result.push(s);\n        s = if s % 2 == 0 { s / 2 } else { s * 3 + 1 };\n\
    \    }\n    result.push(1);\n    result.into_iter().filter(|&x| x % 2 == 1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpulxoe6jv.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut next = n;\n    let mut res = vec![1];\n    while next != 1 {\n   \
    \     res.push(next);\n        next = if next % 2 == 0 { next / 2 } else { 3 *\
    \ next + 1 };\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_byf4mur.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut l = vec![n];\n    let mut m = n;\n    while m != 1 {\n        if m\
    \ % 2 == 0 {\n            m /= 2;\n        } else {\n            m = m * 3 + 1;\n\
    \        }\n        if m % 2 != 0 {\n            l.push(m);\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpuzafmg6p.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO - implement this function\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpeangj94z.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpbzf8cqp5.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   assert!(n > 0);\n    let mut result = vec![n];\n    let mut m = n;\n    loop\
    \ {\n        if m % 2 == 0 {\n            m /= 2;\n        } else {\n        \
    \    m = 3 * m + 1;\n        }\n        if m == 1 {\n            result.push(m);\n\
    \            break;\n        }\n        result.push(m);\n    }\n    result.into_iter().filter(|&i|\
    \ i % 2 == 1).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp5xcytuh2.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut i = n;\n    while i > 1 {\n    \
    \    result.push(i);\n        i = if i % 2 == 0 {\n            i / 2\n       \
    \ } else {\n            3 * i + 1\n        };\n    }\n    result.push(1);\n  \
    \  result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmpb8k6qag4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut seq = Vec::new();\n    if n <= 0 {\n        return seq;\n    }\n \
    \   seq.push(n);\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        seq.push(n);\n\
    \    }\n    let mut res = Vec::new();\n    for i in seq {\n        if i % 2 ==\
    \ 1 {\n            res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpx7u1z5yn.rs:20:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n20 |       \
    \      n /= 2;\n   |             ^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpx7u1z5yn.rs:22:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n22 |       \
    \      n = 3 * n + 1;\n   |             ^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut numbers = vec![n];\n    let mut n = n;\n    while n != 1 {\n     \
    \   n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n        numbers.push(n);\n\
    \    }\n    numbers.retain(|&n| n % 2 != 0);\n    numbers\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptqiljdle.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    for i in 1..n + 1 {\n        let mut number\
    \ = i;\n        let mut odd = false;\n        while number != 1 {\n          \
    \  if number % 2 == 1 {\n                odd = true;\n            }\n        \
    \    number = if number % 2 == 0 {\n                number / 2\n            }\
    \ else {\n                3 * number + 1\n            };\n        }\n        if\
    \ odd {\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, 6, 7, 9, 10, 11, 12, 13, 14]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpd3r0t8py.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut num = n;\n    let mut res = vec![];\n    while num != 1 {\n      \
    \  if num % 2 == 1 {\n            res.push(num);\n        }\n        num = if\
    \ num % 2 == 0 {\n            num / 2\n        } else {\n            3 * num +\
    \ 1\n        };\n    }\n    res.push(1);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp6pq02wvj.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    if n <= 0 {\n        return v;\n\
    \    }\n    let mut m = n;\n    v.push(m);\n    while m != 1 {\n        if m %\
    \ 2 == 0 {\n            m = m / 2;\n        } else {\n            m = 3 * m +\
    \ 1;\n        }\n        if m % 2 != 0 {\n            v.push(m);\n        }\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_6592wfq.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut seq = vec![n];\n    while seq.last().unwrap() != &1 {\n        if\
    \ seq.last().unwrap() % 2 == 0 {\n            seq.push(seq.last().unwrap() / 2);\n\
    \        } else {\n            seq.push(seq.last().unwrap() * 3 + 1);\n      \
    \  }\n    }\n    let mut odd = vec![];\n    for i in seq {\n        if i % 2 !=\
    \ 0 {\n            odd.push(i);\n        }\n    }\n    odd\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpv9cj5_av.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut result = vec![n];\n\
    \    let mut n = n;\n    while n != 1 {\n        if n % 2 == 0 {\n           \
    \ n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        if\
    \ n != 1 && n % 2 != 0 {\n            result.push(n);\n        }\n    }\n    result.push(1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpyq9cyi95.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    while collatz.last().unwrap()\
    \ != &1 {\n        if collatz.last().unwrap() % 2 == 0 {\n            collatz.push(collatz.last().unwrap()\
    \ / 2);\n        } else {\n            collatz.push(collatz.last().unwrap() *\
    \ 3 + 1);\n        }\n    }\n    collatz.retain(|&x| x % 2 != 0);\n    collatz\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpcth8vgdj.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut m = n;\n    while m > 1 {\n\
    \        if m % 2 == 1 {\n            v.push(m);\n        }\n        m = if m\
    \ % 2 == 0 { m / 2 } else { m * 3 + 1 };\n    }\n    v.push(1);\n    v\n}\n\n\
    fn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpcmfmrt72.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut cur = n;\n    let\
    \ mut res = vec![n];\n    while cur != 1 {\n        if cur % 2 == 0 {\n      \
    \      cur /= 2;\n        } else {\n            cur = cur * 3 + 1;\n         \
    \   res.push(cur);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 40, 16]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmps2xu_lv9.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    let mut cur = n;\n    loop {\n        cur\
    \ = if cur % 2 == 0 { cur / 2 } else { cur * 3 + 1 };\n        if cur == 1 { break;\
    \ }\n        if cur % 2 != 0 { collatz.push(cur); }\n    }\n    collatz\n}\n\n\
    fn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpks_jyim0.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    if n <= 0 {\n        return result;\n  \
    \  }\n    result.push(n);\n    while n != 1 {\n        if n % 2 == 0 {\n     \
    \       n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n   \
    \     if n % 2 != 0 {\n            result.push(n);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpvlkoggu5.rs:20:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n20 |       \
    \      n /= 2;\n   |             ^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpvlkoggu5.rs:22:13\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n22 |       \
    \      n = 3 * n + 1;\n   |             ^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut seq = vec![n];\n    while seq.last().unwrap() != &1 {\n        if\
    \ seq.last().unwrap() % 2 == 0 {\n            seq.push(seq.last().unwrap() / 2);\n\
    \        } else {\n            seq.push(seq.last().unwrap() * 3 + 1);\n      \
    \  }\n    }\n    seq.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptmtyy_d4.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut n = n;\n    let mut result = vec![n];\n    while n != 1 {\n      \
    \  n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n        if n % 2 != 0 {\n\
    \            result.push(n);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpfl6943c6.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // TODO\n    let mut output = Vec::new();\n    let mut m = n;\n    while m\
    \ != 1 {\n        if m % 2 == 1 {\n            output.push(m);\n        }\n  \
    \      m = if m % 2 == 0 {\n            m / 2\n        } else {\n            3\
    \ * m + 1\n        };\n    }\n    output.push(1);\n    output\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1tn3130r.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    let mut curr = n;\n    loop {\n\
    \        curr = collatz_step(curr);\n        collatz.push(curr);\n        if curr\
    \ == 1 {\n            break;\n        }\n    }\n    collatz.sort();\n    let mut\
    \ odd_collatz: Vec<isize> = vec![];\n    for i in collatz {\n        if i % 2\
    \ != 0 {\n            odd_collatz.push(i);\n        }\n    }\n    odd_collatz\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collatz_step` in this scope\n  -->\
    \ /tmp/tmp8f1rbotx.rs:16:16\n   |\n16 |         curr = collatz_step(curr);\n \
    \  |                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_numbers: Vec<isize> = Vec::new();\n    let mut n = n;\n    while\
    \ n != 1 {\n        odd_numbers.push(n);\n        n = match n % 2 {\n        \
    \    0 => n / 2,\n            _ => 3 * n + 1,\n        };\n    }\n    odd_numbers.push(1);\n\
    \    odd_numbers\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n   \
    \ assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmpdomea0j6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut sequence = vec![n];\n\
    \    let mut cur = n;\n    loop {\n        if cur == 1 {\n            break;\n\
    \        }\n        if cur % 2 == 0 {\n            cur /= 2;\n        } else {\n\
    \            cur = cur * 3 + 1;\n        }\n        sequence.push(cur);\n    }\n\
    \    sequence.into_iter().filter(|&x| x % 2 == 1).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpjd9rguch.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = Vec::new();\n    let mut x = n;\n    while x != 1 {\n  \
    \      collatz.push(x);\n        if x % 2 == 0 {\n            x /= 2;\n      \
    \  } else {\n            x = x * 3 + 1;\n        }\n    }\n    collatz.push(1);\n\
    \    collatz.into_iter().filter(|x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpz14o28t1.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   assert!(n > 0);\n    let mut m = n;\n    let mut odd_collatz = Vec::new();\n\
    \    while m != 1 {\n        if m % 2 == 1 {\n            odd_collatz.push(m);\n\
    \        }\n        m = if m % 2 == 0 { m / 2 } else { 3 * m + 1 };\n    }\n \
    \   odd_collatz.push(1);\n    odd_collatz\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1mp0_kd2.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![n];\n    let mut i = n;\n    while i != 1 {\n        i =\
    \ if i % 2 == 0 { i / 2 } else { 3 * i + 1 };\n        if i % 2 != 0 {\n     \
    \       v.push(i);\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp9efeyp1q.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut i = n;\n    while i > 1 {\n    \
    \    if i & 1 == 1 {\n            result.push(i);\n        }\n        i = if i\
    \ & 1 == 1 { 3 * i + 1 } else { i / 2 };\n    }\n    result.push(1);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpwo7txurp.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n\t\
    let mut ret = Vec::new();\n\tlet mut k = n;\n\twhile k > 1 {\n\t\tif k % 2 ==\
    \ 1 {\n\t\t\tret.push(k);\n\t\t}\n\t\tk = if k % 2 == 0 {\n\t\t\tk / 2\n\t\t}\
    \ else {\n\t\t\t3 * k + 1\n\t\t}\n\t}\n\tret.push(1);\n\tret\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpeokeim4w.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut arr: Vec<isize> = Vec::new();\n    let mut x = n;\n    while x !=\
    \ 1 {\n        if x % 2 != 0 {\n            arr.push(x);\n        }\n        x\
    \ = if x % 2 == 0 { x / 2 } else { 3 * x + 1 };\n    }\n    arr.push(1);\n   \
    \ arr\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpldgdmuue.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n\n    let mut collatz: Vec<isize>\
    \ = vec![n];\n    let mut num = n;\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2;\n        } else {\n            num = 3 * num + 1;\n\
    \        }\n        collatz.push(num);\n    }\n\n    collatz.iter().filter(|&x|\
    \ x % 2 != 0).map(|&x| x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpb1uws_wv.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut i = n;\n    while i != 1\
    \ {\n        v.push(i);\n        if i % 2 == 0 {\n            i /= 2;\n      \
    \  } else {\n            i = 3 * i + 1;\n        }\n    }\n    v.push(1);\n  \
    \  v.into_iter().filter(|x| x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1f_afmdn.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut nums = Vec::new();\n\
    \    let mut num = n;\n    while num != 1 {\n        nums.push(num);\n       \
    \ if num % 2 == 0 {\n            num /= 2;\n        } else {\n            num\
    \ = num * 3 + 1;\n        }\n    }\n    nums.push(1);\n    nums.iter().filter(|&x|\
    \ x % 2 != 0).map(|&x| x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp4xl3ixr9.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = vec![n];\n    while collatz.last().unwrap() != &1 {\n  \
    \      let next = if collatz.last().unwrap() % 2 == 0 {\n            collatz.last().unwrap()\
    \ / 2\n        } else {\n            3 * collatz.last().unwrap() + 1\n       \
    \ };\n        collatz.push(next);\n    }\n    collatz.iter().cloned().filter(|&x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpxjhom2k4.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   assert!(n > 0);\n    let mut v: Vec<isize> = Vec::new();\n    let mut cur\
    \ = n;\n    v.push(cur);\n    while cur != 1 {\n        if cur % 2 == 0 {\n  \
    \          cur /= 2;\n        } else {\n            cur = cur * 3 + 1;\n     \
    \   }\n        if cur % 2 == 1 {\n            v.push(cur);\n        }\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp8xoqhmeg.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   vec![1]\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpuon2azsr.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut prev = n;\n    let\
    \ mut res = vec![n];\n    while prev != 1 {\n        if prev % 2 == 0 {\n    \
    \        prev /= 2;\n        } else {\n            prev = prev * 3 + 1;\n    \
    \    }\n        if prev % 2 != 0 {\n            res.push(prev);\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp35tuofl0.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_numbers: Vec<isize> = Vec::new();\n    let mut temp_num = n;\n\
    \    odd_numbers.push(temp_num);\n    while temp_num != 1 {\n        if temp_num\
    \ % 2 == 0 {\n            temp_num = temp_num / 2;\n        } else {\n       \
    \     temp_num = temp_num * 3 + 1;\n        }\n        if temp_num % 2 != 0 {\n\
    \            odd_numbers.push(temp_num);\n        }\n    }\n    odd_numbers\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp66gbcjka.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut results = Vec::new();\n    let mut m = n;\n    while m > 1 {\n   \
    \     if m % 2 == 1 {\n            results.push(m);\n        }\n        m = if\
    \ m % 2 == 0 {\n            m / 2\n        } else {\n            3 * m + 1\n \
    \       };\n    }\n    results.push(1);\n    results\n}\n\nfn main() {\n    let\
    \ candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11,\
    \ 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpjp8233xu.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    let mut temp = n;\n    while temp != 1 {\n        if temp % 2 == 1 {\n  \
    \          result.push(temp);\n        }\n        temp = if temp % 2 == 0 {\n\
    \            temp / 2\n        } else {\n            temp * 3 + 1\n        };\n\
    \    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_ri05aje.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n\t\
    if n == 1 {\n\t\treturn vec![1];\n\t}\n\tlet mut a = n;\n\tlet mut result = vec![n];\n\
    \twhile a != 1 {\n\t\tif a % 2 == 0 {\n\t\t\ta = a / 2;\n\t\t} else {\n\t\t\t\
    a = 3 * a + 1;\n\t\t}\n\t\tresult.push(a);\n\t}\n\tresult.into_iter().filter(|&x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpet2xqnpu.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut result = vec![];\n\
    \    let mut current = n;\n    while current != 1 {\n        if current % 2 ==\
    \ 1 {\n            result.push(current);\n        }\n        current = if current\
    \ % 2 == 0 {\n            current / 2\n        } else {\n            3 * current\
    \ + 1\n        };\n    }\n    result.push(1);\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp3n20m98v.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   assert!(n > 0);\n    let mut nums = Vec::new();\n    nums.push(n);\n    let\
    \ mut current = n;\n    loop {\n        current = match current % 2 {\n      \
    \      0 => current / 2,\n            _ => 3 * current + 1,\n        };\n    \
    \    if current == 1 {\n            break;\n        }\n        nums.push(current);\n\
    \    }\n    nums.sort();\n    return nums;\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 20, 22, 26, 34, 40, 52]`,\n right:\
    \ `[1, 5, 7, 11, 13, 17]`', /tmp/tmpk8y3eapv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   fn helper(n: isize, acc: &mut Vec<isize>) {\n        acc.push(n);\n      \
    \  match n {\n            1 => (),\n            _ => helper(if n % 2 == 0 { n\
    \ / 2 } else { 3 * n + 1 }, acc),\n        }\n    }\n    let mut v = Vec::new();\n\
    \    helper(n, &mut v);\n    v.into_iter().filter(|&n| n % 2 == 1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpd4c4zt2q.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odds: Vec<isize> = Vec::new();\n    let mut i = n;\n    while i !=\
    \ 1 {\n        if i % 2 != 0 {\n            odds.push(i);\n        }\n       \
    \ i = if i % 2 == 0 { i / 2 } else { 3 * i + 1 };\n    }\n    odds.push(1);\n\
    \    odds\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpx35jw_ys.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut i = n;\n    let mut result = vec![];\n    while i != 1 {\n       \
    \ if i % 2 != 0 {\n            result.push(i);\n        }\n        i = i / 2;\n\
    \    }\n    result.push(1);\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 3, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmph3ivqm8o.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![];\n    let mut next = n;\n    while next != 1 {\n      \
    \  if next % 2 == 1 {\n            v.push(next);\n        }\n        next = if\
    \ next % 2 == 0 { next / 2 } else { next * 3 + 1 };\n    }\n    v.push(1);\n \
    \   v\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpt49g8jed.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut num = n;\n    loop {\n        if\
    \ num % 2 == 1 {\n            result.push(num);\n        }\n        if num ==\
    \ 1 {\n            break;\n        }\n        if num % 2 == 0 {\n            num\
    \ /= 2;\n        } else {\n            num = num * 3 + 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpv8nq_xn6.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![];\n    let mut next = n;\n    while next\
    \ != 1 {\n        collatz.push(next);\n        next = match next % 2 {\n     \
    \       0 => next / 2,\n            _ => next * 3 + 1,\n        };\n    }\n  \
    \  collatz.push(1);\n    collatz.iter().filter(|x| *x % 2 != 0).map(|x| *x).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptskhb1zg.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut ret = Vec::new();\n    let mut odd = Vec::new();\n    let mut tmp\
    \ = n;\n    while tmp != 1 {\n        if tmp % 2 == 1 {\n            odd.push(tmp);\n\
    \        }\n        tmp = match tmp % 2 {\n            0 => tmp / 2,\n       \
    \     _ => tmp * 3 + 1,\n        };\n    }\n    odd.reverse();\n    for i in odd\
    \ {\n        ret.push(i);\n    }\n    ret.push(1);\n    ret\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 13, 17, 11, 7, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpcx72n0dq.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n\n    let mut collatz: Vec<isize>\
    \ = vec![];\n    collatz.push(n);\n    let mut i = collatz.len() - 1;\n    while\
    \ collatz[i] != 1 {\n        if collatz[i] % 2 == 0 {\n            collatz.push(collatz[i]\
    \ / 2);\n        } else {\n            collatz.push(collatz[i] * 3 + 1);\n   \
    \     }\n        i += 1;\n    }\n    collatz.retain(|&x| x % 2 != 0);\n    collatz\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpk86cyq7m.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n\n    let mut n: isize = n;\n\
    \    let mut collatz: Vec<isize> = vec![];\n    while n != 1 {\n        collatz.push(n);\n\
    \        if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n\
    \ = 3 * n + 1;\n        }\n    }\n    collatz.push(1);\n    collatz.iter().filter(|&x|\
    \ x % 2 != 0).cloned().collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmplppe8ttu.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut i = n;\n    let mut res = vec![n];\n    while i != 1 {\n        i\
    \ = if i % 2 == 0 { i / 2 } else { i * 3 + 1 };\n        if i % 2 != 0 {\n   \
    \         res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpo1oz1993.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_sequence: Vec<isize> = Vec::new();\n    let mut number = n;\n\
    \    while number != 1 {\n        if number % 2 != 0 {\n            odd_sequence.push(number);\n\
    \        }\n        number = if number % 2 == 0 {\n            number / 2\n  \
    \      } else {\n            3 * number + 1\n        };\n    }\n    odd_sequence.push(1);\n\
    \    odd_sequence\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n  \
    \  assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpjb0vjt6f.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut i = n;\n    let mut values = vec![i];\n    while i != 1 {\n      \
    \  if i % 2 == 0 {\n            i = i / 2;\n        } else {\n            i =\
    \ i * 3 + 1;\n        }\n        values.push(i);\n    }\n    values.into_iter().filter(|x|\
    \ x % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpkk5hih3y.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut current = n;\n    let mut sequence = vec![current];\n    while current\
    \ != 1 {\n        if current % 2 == 0 {\n            current /= 2;\n        }\
    \ else {\n            current = 3 * current + 1;\n        }\n        sequence.push(current);\n\
    \    }\n    sequence.retain(|&x| x % 2 != 0);\n    sequence\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpkf4zgu8q.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut num = n;\n    while num != 1 {\n\
    \        if num % 2 != 0 {\n            result.push(num);\n        }\n       \
    \ num = if num % 2 == 0 { num / 2 } else { num * 3 + 1 };\n    }\n    result.push(1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpkcv_g9bb.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    while *collatz.last().unwrap()\
    \ != 1 {\n        let last = *collatz.last().unwrap();\n        collatz.push(if\
    \ last % 2 == 0 {\n            last / 2\n        } else {\n            3 * last\
    \ + 1\n        });\n    }\n    collatz.into_iter().filter(|v| v % 2 != 0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp5ktylb6v.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n\n    let mut collatz = vec![n];\n\
    \    let mut num = n;\n    while num != 1 {\n        if num % 2 == 0 {\n     \
    \       num /= 2;\n        } else {\n            num = num * 3 + 1;\n        }\n\
    \        collatz.push(num);\n    }\n\n    collatz.iter().filter(|x| x % 2 != 0).map(|x|\
    \ *x).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmplbosmnfr.rs:28:33\n\
    \   |\n28 |     collatz.iter().filter(|x| x % 2 != 0).map(|x| *x).collect()\n\
    \   |                               - ^ - {integer}\n   |                    \
    \           |\n   |                               &&isize\n   |\nhelp: `%` can\
    \ be used on `isize`, you can dereference `x`\n   |\n28 |     collatz.iter().filter(|x|\
    \ *x % 2 != 0).map(|x| *x).collect()\n   |                               +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    let mut num = n;\n    while num != 1 {\n\
    \        result.push(num);\n        if num % 2 == 0 {\n            num /= 2;\n\
    \        } else {\n            num = 3 * num + 1;\n        }\n    }\n    result.push(1);\n\
    \    result.into_iter().filter(|&x| x % 2 != 0).collect()\n}\n\nfn main() {\n\
    \    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5,\
    \ 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpw2u3nqy4.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = Vec::new();\n    collatz_generator(n, &mut result);\n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `collatz_generator` in this scope\n\
    \  --> /tmp/tmpw88s4f2j.rs:14:5\n   |\n14 |     collatz_generator(n, &mut result);\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut ret = vec![n];\n\
    \    let mut nn = n;\n    while nn != 1 {\n        nn = if nn % 2 == 0 {\n   \
    \         nn / 2\n        } else {\n            nn * 3 + 1\n        };\n     \
    \   if nn % 2 != 0 {\n            ret.push(nn);\n        }\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp8smtwmyk.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n == 1 {\n        return vec![1];\n    }\n    let mut collatz = vec![n];\n\
    \    let mut num = n;\n    loop {\n        if num == 1 {\n            break;\n\
    \        }\n        if num % 2 == 0 {\n            num /= 2;\n        } else {\n\
    \            num = num * 3 + 1;\n        }\n        collatz.push(num);\n    }\n\
    \    let mut set = HashSet::new();\n    for i in collatz {\n        if i % 2 ==\
    \ 1 {\n            set.insert(i);\n        }\n    }\n    set.into_iter().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpycjri9rq.rs:29:19\n   |\n29 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v = vec![];\n    let mut x = n;\n    loop {\n        if x == 1 { v.push(x);\
    \ break; }\n        v.push(x);\n        if x % 2 == 0 { x /= 2; }\n        else\
    \ { x = 3 * x + 1; }\n    }\n    v.iter().filter(|&x| x % 2 != 0).map(|&x| x).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpfrmzwyxc.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut list = vec![n];\n    let mut odd_list = vec![];\n    let mut num =\
    \ n;\n    loop {\n        if num == 1 {\n            break;\n        }\n     \
    \   num = match num % 2 {\n            0 => num / 2,\n            _ => num * 3\
    \ + 1,\n        };\n        list.push(num);\n    }\n    odd_list.push(list[0]);\n\
    \    for i in 1..list.len() {\n        if list[i] % 2 != 0 {\n            odd_list.push(list[i]);\n\
    \        }\n    }\n    odd_list\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpz7dwgd02.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut sequence = vec![n];\n    let mut number = n;\n    while number !=\
    \ 1 {\n        if number % 2 == 0 {\n            number /= 2;\n        } else\
    \ {\n            number = number * 3 + 1;\n        }\n        if number % 2 !=\
    \ 0 {\n            sequence.push(number);\n        }\n    }\n    sequence\n}\n\
    \nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp1yxvn7cm.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = vec![];\n    let mut num = n;\n    result.push(num);\n  \
    \  while num != 1 {\n        if num % 2 == 0 {\n            num /= 2;\n      \
    \  } else {\n            num = num * 3 + 1;\n        }\n        if num % 2 !=\
    \ 0 {\n            result.push(num);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpc_ycawvd.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // Implementing collatz\n    fn collatz(n: isize) -> Vec<isize> {\n      \
    \  let mut current = n;\n        let mut result = vec![current];\n        while\
    \ current != 1 {\n            if current % 2 == 0 {\n                current =\
    \ current / 2;\n            } else {\n                current = current * 3 +\
    \ 1;\n            }\n            result.push(current);\n        }\n        result\n\
    \    }\n\n    let mut seq = collatz(n);\n    seq.retain(|&x| x % 2 != 0);\n  \
    \  seq\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpox7qibvs.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut list: Vec<isize> = Vec::new();\n    let mut num = n;\n    while num\
    \ != 1 {\n        if num % 2 != 0 {\n            list.push(num);\n        }\n\
    \        num = if num % 2 == 0 {\n            num / 2\n        } else {\n    \
    \        3 * num + 1\n        };\n    }\n    list.push(1);\n    list\n}\n\nfn\
    \ main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp_4ulrk53.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = vec![n];\n    let mut number = n;\n    while number != 1\
    \ {\n        if number % 2 == 0 {\n            number /= 2;\n        } else {\n\
    \            number = 3 * number + 1;\n        }\n        if number % 2 != 0 {\n\
    \            result.push(number);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp9o04z_8u.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut tmp: isize = n;\n    v.push(tmp);\n\
    \    while tmp != 1 {\n        if tmp % 2 == 0 {\n            tmp = tmp / 2;\n\
    \        } else {\n            tmp = 3 * tmp + 1;\n        }\n        if tmp %\
    \ 2 != 0 {\n            v.push(tmp);\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1,\
    \ 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12),\
    \ vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpy3yepx5c.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = vec![n];\n    while n != 1 {\n        n = if n % 2 == 0 {\
    \ n / 2 } else { 3 * n + 1 };\n        if n % 2 != 0 {\n            result.push(n);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0bcgt2fb.rs:15:9\n\
    \   |\n12 | fn get_odd_collatz(n: isize) -> Vec<isize> {\n   |               \
    \     - help: consider making this binding mutable: `mut n`\n...\n15 |       \
    \  n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut s = Vec::new();\n    if n == 1 {\n        s.push(1);\n        return\
    \ s;\n    }\n\n    let mut is_odd = true;\n    let mut num = n;\n    while num\
    \ != 1 {\n        if is_odd {\n            s.push(num);\n        }\n        if\
    \ num % 2 == 0 {\n            num /= 2;\n        } else {\n            num = num\
    \ * 3 + 1;\n        }\n        is_odd = !is_odd;\n    }\n    s.push(1);\n    s\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 22, 34, 52, 13, 20, 5, 8, 2, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpzuvs9i4i.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   // Use a hashmap to store the result.\n    let mut result = HashMap::new();\n\
    \    result.insert(1, true);\n\n    let is_odd = |&number: &isize| -> bool {\n\
    \        let mut next = number;\n        while next > 1 {\n            if next\
    \ % 2 == 0 {\n                next /= 2;\n            } else {\n             \
    \   next = 3 * next + 1;\n            }\n            if result.contains_key(&next)\
    \ {\n                return *result.get(&next).unwrap();\n            }\n    \
    \    }\n        false\n    };\n\n    for i in 2..n + 1 {\n        result.insert(i,\
    \ is_odd(&i));\n    }\n\n    let mut vec: Vec<isize> = Vec::new();\n    for (k,\
    \ v) in result {\n        if k <= n && v {\n            vec.push(k);\n       \
    \ }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqjt83d59.rs:14:22\n   |\n14 |     let mut result = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut odd_values = Vec::new();\n    let mut current_n = n;\n    odd_values.push(current_n);\n\
    \    while current_n != 1 {\n        current_n = if current_n % 2 == 0 {\n   \
    \         current_n / 2\n        } else {\n            3 * current_n + 1\n   \
    \     };\n        if current_n % 2 != 0 {\n            odd_values.push(current_n);\n\
    \        }\n    }\n    odd_values\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpuuvkwkxm.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut v: Vec<isize> = Vec::new();\n    let mut u: Vec<isize> = Vec::new();\n\
    \    let mut r: isize = n;\n    v.push(n);\n    loop {\n        if r == 1 {\n\
    \            v.append(&mut u);\n            v.sort();\n            return v;\n\
    \        }\n        if r % 2 == 0 {\n            r = r / 2;\n        } else {\n\
    \            u.push(r);\n            r = r * 3 + 1;\n        }\n        v.push(r);\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 4, 5, 5, 7, 7, 8, 10, 11, 11, 13, 13, 14, 16, 17, 17, 20, 22, 26, 34,\
    \ 40, 52]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpksx_xbcg.rs:35:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz = n;\n    let mut ans = vec![];\n    ans.push(n);\n    while\
    \ collatz != 1 {\n        if collatz % 2 == 0 {\n            collatz /= 2;\n \
    \       } else {\n            collatz = collatz * 3 + 1;\n        }\n        if\
    \ collatz % 2 != 0 {\n            ans.push(collatz);\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[14, 7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpys3puhei.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut x: isize = n;\n    let mut output: Vec<isize> = Vec::new();\n    while\
    \ x != 1 {\n        output.push(x);\n        if x % 2 == 0 {\n            x =\
    \ x / 2;\n        } else {\n            x = 3 * x + 1;\n        }\n    }\n   \
    \ output.push(1);\n    output.iter().filter(|&x| x % 2 != 0).map(|&x| x).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmp0ki5_laf.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut collatz: Vec<isize> = vec![n];\n    let mut k = n;\n    while k !=\
    \ 1 {\n        if k % 2 == 0 {\n            k = k / 2;\n        } else {\n   \
    \         k = 3 * k + 1;\n        }\n        collatz.push(k);\n    }\n    collatz.into_iter().filter(|k|\
    \ k % 2 != 0).collect()\n}\n\nfn main() {\n    let candidate = get_odd_collatz;\n\
    \    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5),\
    \ vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1),\
    \ vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmptqgwgxzb.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   if n <= 0 {\n        return vec![];\n    }\n\n    let mut n = n;\n    let\
    \ mut odds = vec![];\n    while n != 1 {\n        if n % 2 != 0 {\n          \
    \  odds.push(n);\n        }\n        n = if n % 2 == 0 { n / 2 } else { 3 * n\
    \ + 1 };\n    }\n    odds.push(1);\n    odds\n}\n\nfn main() {\n    let candidate\
    \ = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n\
    \    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1,\
    \ 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpnwp2efrq.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n \
    \   let mut result = vec![n];\n    let mut next = n;\n    loop {\n        let\
    \ next_ = if next % 2 == 0 {\n            next / 2\n        } else {\n       \
    \     next * 3 + 1\n        };\n        if next_ == 1 {\n            result.push(next_);\n\
    \            break;\n        }\n        result.push(next_);\n        next = next_;\n\
    \    }\n    result.iter().filter(|&num| num % 2 != 0).map(|num| *num).collect()\n\
    }\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14),\
    \ vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n   \
    \ assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 11, 17, 13, 5, 1]`,\n right: `[1, 5, 7, 11, 13, 17]`', /tmp/tmpsh4vk61d.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
