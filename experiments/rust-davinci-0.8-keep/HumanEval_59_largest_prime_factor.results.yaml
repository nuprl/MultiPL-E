name: HumanEval_59_largest_prime_factor
language: rust
results:
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut k = 2;\n    while k * k <= n {\n        if n % k == 0 {\n            n /=\
    \ k;\n        } else {\n            k += 1;\n        }\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    return 0;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmphs3ky125.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest_factor = i;\n            n /= i;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    return if n > largest_factor { n } else\
    \ { largest_factor };\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpb427l6ua.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 2;\n    while n > 1 {\n        if n % largest_factor ==\
    \ 0 {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let factors = prime_factors(n);\n    *factors.iter().max().unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpau6qazx6.rs:8:19\n  |\n8 |     let factors = prime_factors(n);\n  |\
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev()\
    \ {\n        if is_prime(i) && n % i == 0 {\n            return i;\n        }\n\
    \    }\n    panic!(\"Something went wrong.\");\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp7eu9i6g9.rs:8:12\n\
    \  |\n8 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 2;\n\
    \    let mut input = n;\n    while input > 1 {\n        if is_prime(input) {\n\
    \            result = input;\n            break;\n        }\n        for i in\
    \ 2..input + 1 {\n            if is_prime(i) && input % i == 0 {\n           \
    \     result = i;\n                input = input / i;\n                break;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbwl5rgmt.rs:10:12\n\
    \   |\n10 |         if is_prime(input) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpbwl5rgmt.rs:15:16\n   |\n15 |             if is_prime(i) && input\
    \ % i == 0 {\n   |                ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    for i in 2..n {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n / i);\n        }\n    }\n    panic!(\"largest_prime_factor\
    \ precondition failed\");\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpdbsjfx78.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut prime_factors = vec![];\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            prime_factors.push(i);\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    if n > 1 {\n        prime_factors.push(n);\n\
    \    }\n    prime_factors.pop().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpvq136wo9.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 2;\n\
    \    let mut k = n;\n    let sqr_k = (k as f64).sqrt().ceil() as isize;\n    while\
    \ prime <= sqr_k {\n        if k % prime == 0 {\n            k /= prime;\n   \
    \     } else {\n            prime += 1;\n        }\n    }\n    k\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpsnmfk4ue.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut v = Vec::new();\n\
    \    let mut remainder = n;\n    let mut i = 2;\n    while remainder != 1 {\n\
    \        while remainder % i == 0 {\n            v.push(i);\n            remainder\
    \ /= i;\n        }\n        i += 1;\n    }\n    v.iter().max().unwrap().clone()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n       \
    \     result = d;\n            n /= d;\n        } else {\n            d += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpp3w67fc9.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= d;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = prime_factors(n);\n\
    \    factors.sort();\n    factors.last().unwrap().clone()\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpi59_xb0r.rs:7:23\n  |\n7 |     let mut factors = prime_factors(n);\n\
    \  |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut result = n;\n    while i <= result {\n        if result % i == 0 {\n   \
    \         result /= i;\n        } else {\n            i += 1;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmppdji9aaa.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut c = n;\n    let\
    \ mut i = 2;\n    while i <= c {\n        if c % i == 0 {\n            c /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    for i in 2..n {\n        if n % i == 0 && is_prime(i) {\n            largest\
    \ = i;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpz_0q6yul.rs:9:26\n\
    \  |\n9 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor: isize\
    \ = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n\
    \            n /= factor;\n        } else {\n            factor += 1;\n      \
    \  }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i < n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 2;\n    let mut current = n;\n    while current > 1 {\n        if current\
    \ % largest_prime == 0 {\n            current /= largest_prime;\n        } else\
    \ {\n            largest_prime += 1;\n        }\n    }\n    largest_prime\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut remainder = n;\n\
    \    let mut factor = 2;\n    while remainder > 1 {\n        if remainder % factor\
    \ == 0 {\n            remainder /= factor;\n        } else {\n            factor\
    \ += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut m = n;\n    while m % 2 == 0 {\n        result = 2;\n        m /=\
    \ 2;\n    }\n    let mut p = 3;\n    while m > 1 {\n        while m % p == 0 {\n\
    \            result = p;\n            m /= p;\n        }\n        p += 2;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (1..n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    return 0;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp0wrik44r.rs:8:26\n\
    \  |\n8 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = 1;\n    let mut i = 2;\n    while i <= n {\n        if n\
    \ % i == 0 {\n            n /= i;\n            largest_prime = i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    largest_prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    if n % 2 == 0 {\n        return largest_prime_factor(n\
    \ / 2);\n    }\n    let mut f = 3;\n    while n % f != 0 {\n        f += 2;\n\
    \    }\n    return largest_prime_factor(n / f);\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp1tx3hmpp.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = n;\n\
    \    let mut d = 2;\n    while d * d <= result {\n        if result % d == 0 {\n\
    \            result /= d;\n        } else {\n            d += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut last_factor =\
    \ 1;\n    let mut number = n;\n    // While the factor is less than the number,\
    \ try dividing it.\n    for i in 2..number {\n        if number % i == 0 {\n \
    \           last_factor = i;\n            number /= i;\n            while number\
    \ % i == 0 {\n                number /= i;\n            }\n        }\n    }\n\
    \    if number == 1 {\n        last_factor\n    } else {\n        number\n   \
    \ }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n / 2;\n\
    \    let mut y = n;\n    let mut last_y = y;\n    let mut prime_factors = Vec::new();\n\
    \    let mut prime_factor = 2;\n    while y > x {\n        if y % x == 0 {\n \
    \           if prime_factor == x {\n                prime_factors.push(x);\n \
    \               prime_factor = 2;\n            }\n            last_y = y;\n  \
    \          y = y / x;\n        } else {\n            prime_factor = x;\n     \
    \       x -= 1;\n        }\n    }\n    if prime_factor == y {\n        prime_factors.push(y);\n\
    \    } else {\n        prime_factors.push(last_y);\n    }\n    prime_factors.pop().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp09_mrei6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n\
    \    let mut divisor = 2;\n    let mut remainder = n;\n    while remainder > 1\
    \ {\n        while remainder % divisor == 0 {\n            largest = divisor;\n\
    \            remainder /= divisor;\n        }\n        divisor += 1;\n    }\n\
    \    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Start with 2 and repeatedly\
    \ divide out factors of 2, then try 3, 5, 7,\n    // etc.\n    let mut f = 2;\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % f == 0 {\n            n\
    \ /= f;\n        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut n = n;\n    while n % f == 0 {\n        n /= f;\n    }\n    for f in (3..).step_by(2)\
    \ {\n        while n % f == 0 {\n            n /= f;\n        }\n        if n\
    \ == 1 {\n            return f;\n        }\n    }\n    unreachable!()\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    for\
    \ i in 2..(n as f64).sqrt() as isize + 1 {\n        while n % i == 0 {\n     \
    \       n /= i;\n        }\n    }\n    if n > 1 {\n        n\n    } else {\n \
    \       n / 2\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpthxhe4_j.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 2;\n    let mut current = n;\n    while current % 2 == 0 {\n        current\
    \ /= 2;\n    }\n    for i in (3..).step_by(2) {\n        while current % i ==\
    \ 0 {\n            largest_prime = i;\n            current /= i;\n        }\n\
    \    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     return n / 2;\n    }\n\n    let mut n = n;\n    let mut i = 3;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n\
    \            i += 2;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `165`,\n right: `11`', /tmp/tmp6_b46305.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut n = n;\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n > 1 {\n        if n % p == 0 {\n            n /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i <= m {\n        if m % i == 0 {\n            m /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 2;\n    let mut number = n;\n    while prime_factor * prime_factor <= number\
    \ {\n        while number % prime_factor == 0 {\n            number /= prime_factor;\n\
    \        }\n        prime_factor += 1;\n    }\n    number\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpvq4bnmit.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n > 1 {\n        if n % p == 0 {\n            n /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = 2;\n\
    \    let mut n = n;\n    while n > max_prime {\n        if n % max_prime == 0\
    \ {\n            n /= max_prime;\n        } else {\n            max_prime += 1;\n\
    \        }\n    }\n    max_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\
    \    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\
    \    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let limit = isqrt(n);\n\
    \    let mut result = 1;\n    for i in 2..=limit {\n        if n % i == 0 {\n\
    \            let mut j = n / i;\n            while j % i == 0 {\n            \
    \    j /= i;\n            }\n            if j == 1 {\n                result =\
    \ i;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `isqrt` in this scope\n --> /tmp/tmp_z3q4yoh.rs:7:17\n\
    \  |\n7 |     let limit = isqrt(n);\n  |                 ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![2,\
    \ 3];\n    let mut m = n;\n    let mut p = 0;\n    while m != 1 {\n        p =\
    \ next_prime(&mut primes);\n        while m % p == 0 {\n            m /= p;\n\
    \        }\n    }\n    p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `next_prime` in this scope\n  --> /tmp/tmp7b0kil1v.rs:11:13\n\
    \   |\n11 |         p = next_prime(&mut primes);\n   |             ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max = 0;\n  \
    \  let mut current = n;\n    while current % 2 == 0 {\n        max = 2;\n    \
    \    current /= 2;\n    }\n    let mut f = 3;\n    while f * f <= current {\n\
    \        if current % f == 0 {\n            max = f;\n            current /= f;\n\
    \        } else {\n            f += 2;\n        }\n    }\n    if current > 2 {\n\
    \        current\n    } else {\n        max\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let n = n as usize;\n\
    \    let half = n / 2;\n    let (mut p, mut factor) = (2, n);\n    while p <=\
    \ half {\n        if n % p == 0 {\n            factor = p;\n            while\
    \ n % p == 0 {\n                n /= p;\n            }\n        }\n        p +=\
    \ 1;\n    }\n    factor as isize\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpvkguhn8f.rs:14:17\n\
    \   |\n7  |     let n = n as usize;\n   |         -\n   |         |\n   |    \
    \     first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n...\n14 |                 n /= p;\n   |                 ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n\
    \            largest_factor = i;\n            n /= i;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    if n > 1 {\n        largest_factor = n;\n\
    \    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_bui4v1o.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 1;\n  \
    \  let mut j = 2;\n    let mut i = n;\n    while i > 1 {\n        while i % j\
    \ == 0 {\n            res = j;\n            i /= j;\n        }\n        j += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n / 2).rev()\
    \ {\n        if is_prime(i) && n % i == 0 {\n            return i;\n        }\n\
    \    }\n    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp_juv15w8.rs:8:12\n\
    \  |\n8 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_prime = n;\n    while n % 2 == 0 {\n        n /= 2;\n    }\n   \
    \ let mut i = 3;\n    while i <= n {\n        if n % i == 0 {\n            n /=\
    \ i;\n            largest_prime = i;\n        } else {\n            i += 2;\n\
    \        }\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut prime, mut last)\
    \ = (2, 0);\n    while n != 1 {\n        if n % prime == 0 {\n            last\
    \ = prime;\n            n /= prime;\n        } else {\n            prime += 1;\n\
    \        }\n    }\n    last\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3v24ihud.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= prime;\n   |             ^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p: isize = n;\n\
    \    let mut result: isize = 1;\n    let mut factor: isize = 2;\n    while p !=\
    \ 1 {\n        if p % factor == 0 {\n            result = factor;\n          \
    \  p /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for p in (2..n).rev()\
    \ {\n        if n % p == 0 && is_prime(p) {\n            return p;\n        }\n\
    \    }\n    unreachable!()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp27iaamfu.rs:8:26\n\
    \  |\n8 |         if n % p == 0 && is_prime(p) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = prime_factors(n);\n\
    \    let mut max = 0;\n    while let Some(x) = factors.pop() {\n        if x >\
    \ max {\n            max = x;\n        }\n    }\n    max\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpoptfzb10.rs:7:23\n  |\n7 |     let mut factors = prime_factors(n);\n\
    \  |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let n = n as usize;\n\
    \    let limit = n / 2;\n    for i in 2..limit {\n        if n % i == 0 {\n  \
    \          return largest_prime_factor(n / i)\n        }\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgwbz4l2.rs:11:41\n   |\n\
    11 |             return largest_prime_factor(n / i)\n   |                    \
    \                     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n11 |             return largest_prime_factor((n / i).try_into().unwrap())\n\
    \   |                                         +     +++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcgwbz4l2.rs:14:5\n   |\n6  | fn\
    \ largest_prime_factor(n: isize) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n14 |     n\n  \
    \ |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n14 |     n.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut m = n;\n    while m % p == 0 {\n        m /= p;\n    }\n    p += 1;\n  \
    \  while m != 1 {\n        if m % p == 0 {\n            m /= p;\n        } else\
    \ {\n            p += 2;\n        }\n    }\n    p\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut x = n;\n    while x % p == 0 {\n        x /= p;\n    }\n    let mut q =\
    \ p + 1;\n    while q * q <= x {\n        if x % q == 0 {\n            p = q;\n\
    \            while x % p == 0 {\n                x /= p;\n            }\n    \
    \    }\n        q += 1;\n    }\n    if x > 1 {\n        p = x;\n    }\n    p\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut x = 2;\n    while x * x <= n {\n        if n % x == 0 {\n            n /=\
    \ x;\n        } else {\n            x += 1;\n        }\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 2;\n    let mut remaining = n;\n    while remaining > largest_prime_factor\
    \ {\n        if remaining % largest_prime_factor == 0 {\n            remaining\
    \ /= largest_prime_factor;\n        } else {\n            largest_prime_factor\
    \ += 1;\n        }\n    }\n    return largest_prime_factor;\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // It is guaranteed that\
    \ n > 1 and is not a prime.\n    assert!(n > 1);\n    let mut fact = 1;\n    let\
    \ mut x = n;\n    // We start from 2 and increment the number until we find the\
    \ largest prime factor.\n    let mut i = 2;\n    // The largest factor can't be\
    \ greater than sqrt(n).\n    while i * i <= x {\n        // If x is divisible\
    \ by i, then the loop will continue until x is no longer divisible by i.\n   \
    \     while x % i == 0 {\n            x /= i;\n            fact = i;\n       \
    \ }\n        i += 1;\n    }\n    // If the remainder is not 1, then the remainder\
    \ is a prime number.\n    if x > 1 {\n        fact = x;\n    }\n    fact\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n\
    \    n /= factor;\n    if n == 1 {\n        factor\n    } else {\n        largest_prime_factor(n)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 0;\n    let mut temp = n;\n    let mut factor = 2;\n    while temp > 1 {\n\
    \        if temp % factor == 0 {\n            largest_factor = factor;\n     \
    \       temp /= factor;\n            while temp % factor == 0 {\n            \
    \    temp /= factor;\n            }\n        }\n        factor += 1;\n    }\n\
    \    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut curr = n;\n \
    \   let mut largest = 0;\n    while curr % 2 == 0 {\n        largest = 2;\n  \
    \      curr /= 2;\n    }\n    let mut i = 3;\n    while i <= (curr as f64).sqrt()\
    \ as isize {\n        while curr % i == 0 {\n            largest = i;\n      \
    \      curr /= i;\n        }\n        i += 2;\n    }\n    if curr > largest {\n\
    \        curr\n    } else {\n        largest\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Find smallest factor\n\
    \    let mut factor = 3;\n    while n % factor != 0 {\n        factor += 2;\n\
    \    }\n    // Divide out factor as long as it's a factor\n    let mut n = n /\
    \ factor;\n    while n % factor == 0 {\n        n = n / factor;\n    }\n    //\
    \ There are no more factorizations to find, so the largest prime factor of n is\
    \ either\n    // factor or n itself.\n    if n == 1 {\n        factor\n    } else\
    \ {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `110`,\n right: `11`', /tmp/tmplxvqepki.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n / 2).rev()\
    \ {\n        if is_prime(i) && n % i == 0 {\n            return i;\n        }\n\
    \    }\n    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp3ns0oz7s.rs:8:12\n\
    \  |\n8 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n\n    let smallest_factor = smallest_factor(n);\n   \
    \ largest_prime_factor(n / smallest_factor)\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp6bmyoxlo.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `smallest_factor` in this scope\n  --> /tmp/tmp6bmyoxlo.rs:11:27\n\
    \   |\n11 |     let smallest_factor = smallest_factor(n);\n   |              \
    \             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let primes = sieve(n);\n\
    \    let mut remaining = n;\n    let mut i = primes.len() - 1;\n    while i >=\
    \ 0 {\n        if remaining % primes[i] == 0 {\n            remaining /= primes[i];\n\
    \        }\n        i -= 1;\n    }\n    n / remaining\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sieve` in this scope\n --> /tmp/tmpjfwtzo7p.rs:7:18\n\
    \  |\n7 |     let primes = sieve(n);\n  |                  ^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % f == 0 {\n            n /= f;\n\
    \        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..).find(|i| n % i\
    \ == 0 && is_prime(*i)).unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp_u8651av.rs:7:34\n\
    \  |\n7 |     (2..).find(|i| n % i == 0 && is_prime(*i)).unwrap()\n  |       \
    \                           ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 1;\n  \
    \  let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            res\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfpfy1bmo.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = 2;\n    let\
    \ mut max_prime = 0;\n    while x * x <= n {\n        if n % x == 0 {\n      \
    \      max_prime = x;\n            n /= x;\n        } else {\n            x +=\
    \ 1;\n        }\n    }\n    max_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1c8a0jzl.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= x;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 2;\n    let mut remaining = n;\n    while remaining % largest_factor == 0\
    \ {\n        remaining /= largest_factor;\n    }\n    largest_factor += 1;\n \
    \   while remaining > 1 {\n        while remaining % largest_factor == 0 {\n \
    \           remaining /= largest_factor;\n        }\n        largest_factor +=\
    \ 2;\n    }\n    largest_factor - 2\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut max_p = p;\n    while p * p <= n {\n        if n % p == 0 {\n          \
    \  max_p = p;\n            n /= p;\n        } else {\n            p += 1;\n  \
    \      }\n    }\n    if n > max_p {\n        max_p = n;\n    }\n    max_p\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgphtixvm.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= p;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n           \
    \ n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmp196x_64r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut max = p;\n    while p <= n {\n        while n % p == 0 {\n            max\
    \ = p;\n            n /= p;\n        }\n        p += 1;\n    }\n    max\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdnmbf4os.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= p;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 2;\n    let mut divisor = 2;\n    while n > 1 {\n     \
    \   if n % divisor == 0 {\n            n /= divisor;\n            largest_factor\
    \ = divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n\
    \    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    for i in 2..n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \        }\n    }\n    let mut biggest = 0;\n    for i in factors {\n        if\
    \ is_prime(i) {\n            if i > biggest {\n                biggest = i;\n\
    \            }\n        }\n    }\n    return biggest;\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpnw602bos.rs:15:12\n\
    \   |\n15 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut n = n;\n    while n != 1 {\n        if n % factor == 0 {\n      \
    \      n /= factor;\n        } else {\n            factor += 1;\n        }\n \
    \   }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut num = n;\n    while num % 2 == 0 {\n        factors.push(2);\n  \
    \      num /= 2;\n    }\n    let mut factor = 3;\n    while num > 1 {\n      \
    \  while num % factor == 0 {\n            factors.push(factor);\n            num\
    \ /= factor;\n        }\n        factor += 2;\n    }\n    *factors.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut val = n;\n  \
    \  let mut factor = 2;\n    while val != 1 {\n        if val % factor == 0 {\n\
    \            val /= factor;\n        } else {\n            factor += 1;\n    \
    \    }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (p, _) = prime_factorization(n);\n\
    \    p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \ --> /tmp/tmpg_5216yr.rs:7:18\n  |\n7 |     let (p, _) = prime_factorization(n);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     return largest_prime_factor(n / 2);\n    }\n    for i in (3..(n as f64).sqrt()\
    \ as isize).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp1c4_f68e.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_prime = 1;\n    while i <= n {\n        if n % i == 0 {\n      \
    \      let mut j = 2;\n            let mut is_prime = true;\n            while\
    \ j <= i / 2 {\n                if i % j == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n                j +=\
    \ 1;\n            }\n            if is_prime {\n                largest_prime\
    \ = i;\n            }\n        }\n        i += 1;\n    }\n    largest_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = n;\n\
    \    let mut i = 2;\n    while i <= (factor as f64).sqrt() as isize {\n      \
    \  if factor % i == 0 {\n            factor /= i;\n        } else {\n        \
    \    i += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 1;\n    let\
    \ mut n = n;\n    while n > 1 {\n        p += 1;\n        while n % p == 0 {\n\
    \            n /= p;\n        }\n    }\n    p\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut curr = n;\n    let mut result = 0;\n    while f <= curr {\n        if curr\
    \ % f == 0 {\n            if is_prime(f) {\n                result = f;\n    \
    \        }\n            curr /= f;\n        } else {\n            f += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpihac699m.rs:12:16\n\
    \   |\n12 |             if is_prime(f) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut i = 2;\n    while i <= x {\n        if x % i == 0 {\n            x /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n\
    \    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ largest = i;\n            n /= i;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfn8nxa84.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    let mut factor = 2;\n    while factor <= n {\n  \
    \      if n % factor == 0 {\n            return largest_prime_factor(n / factor);\n\
    \        }\n        factor += 1;\n    }\n    1\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp4rx6846m.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest = 1;\n    let mut cur = n;\n    while i * i <= cur {\n        if\
    \ cur % i == 0 {\n            largest = i;\n            cur /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    return std::cmp::max(largest,\
    \ cur);\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = Primes::new();\n\
    \    let mut largest_prime = 1;\n    let mut i = 2;\n    while i <= n {\n    \
    \    let prime = primes.next().unwrap();\n        if n % prime == 0 {\n      \
    \      largest_prime = prime;\n            n /= prime;\n        }\n        i +=\
    \ 1;\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Primes`\n -->\
    \ /tmp/tmpr9z4ire0.rs:7:22\n  |\n7 |     let mut primes = Primes::new();\n  |\
    \                      ^^^^^^ use of undeclared type `Primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![2];\n\
    \    let mut value = n;\n    let mut factor = 3;\n    while value > 1 {\n    \
    \    while value % factor == 0 {\n            value /= factor;\n            primes.push(factor);\n\
    \        }\n        factor += 2;\n    }\n    primes.pop().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut i = 2;\n    while i * i <= m {\n        if m % i == 0 {\n            m /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    m\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ panic!(\"n must be > 1!\");\n    }\n    let mut result = 2;\n    let mut num\
    \ = n;\n    for i in 3..((n as f64).sqrt() as isize) {\n        if is_prime(i)\
    \ && num % i == 0 {\n            result = i;\n            num /= i;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp3n273im1.rs:13:12\n\
    \   |\n13 |         if is_prime(i) && num % i == 0 {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let m = n / 2;\n    for\
    \ i in m..1 {\n        if n % i == 0 && is_prime(i) {\n            return i;\n\
    \        }\n    }\n    0\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmppo20p2zf.rs:9:26\n\
    \  |\n9 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut largest_factor = 0;\n    while factor <= n {\n        if n % factor\
    \ == 0 {\n            largest_factor = factor;\n            n /= factor;\n   \
    \     } else {\n            factor += 1;\n        }\n    }\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp335fh8dt.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut divisor = 2;\n    let mut largest_prime = 1;\n    while divisor <= n {\n\
    \        if n % divisor == 0 {\n            f = n / divisor;\n            if f\
    \ % divisor == 0 {\n                f = f / divisor;\n            }\n        \
    \    if largest_prime < f {\n                largest_prime = f;\n            }\n\
    \        }\n        divisor += 1;\n    }\n    largest_prime\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `7`', /tmp/tmpws6pwqze.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 2;\n    loop {\n        if n == largest_factor {\n    \
    \        return largest_factor;\n        }\n        if n % largest_factor == 0\
    \ {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut m = n;\n    while m != 1 {\n        while m % p == 0 {\n            m /=\
    \ p;\n        }\n        p += 1;\n    }\n    p - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n  \
    \      return n;\n    }\n    // The highest prime factor of n will not be greater\
    \ than its square root\n    for factor in 2..((n as f64).sqrt() as isize + 1)\
    \ {\n        if n % factor == 0 && is_prime(factor) {\n            return factor;\n\
    \        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpwp8k0q7t.rs:7:8\n\
    \  |\n7 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwp8k0q7t.rs:12:31\n\
    \   |\n12 |         if n % factor == 0 && is_prime(factor) {\n   |           \
    \                    ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..n).rev().find(|i|\
    \ n % i == 0 && is_prime(*i)).unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp26p47s4l.rs:7:41\n\
    \  |\n7 |     (2..n).rev().find(|i| n % i == 0 && is_prime(*i)).unwrap()\n  |\
    \                                         ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut max_f = 1;\n    while f * f <= n {\n        if n % f == 0 {\n          \
    \  max_f = f;\n            n /= f;\n        } else {\n            f += 1;\n  \
    \      }\n    }\n    if n > 1 {\n        max_f = n;\n    }\n    max_f\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqlv1koac.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= f;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i <= (n / i) {\n        while n % i == 0 {\n         \
    \   n = n / i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmp13ac4k7l.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 2;\n\
    \    let mut x = n;\n    while x > largest {\n        if x % largest == 0 {\n\
    \            x /= largest;\n        } else {\n            largest += 1;\n    \
    \    }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut largest_factor = 1;\n    while n > 1 {\n        while n % divisor\
    \ == 0 {\n            largest_factor = divisor;\n            n /= divisor;\n \
    \       }\n        divisor += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_vrzukgl.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= divisor;\n   |             ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut n, mut factor)\
    \ = (n, 2);\n    while n > 1 {\n        if n % factor == 0 {\n            n /=\
    \ factor;\n        } else {\n            factor += 1;\n        }\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (p, r) = divide_out_prime_factors(n,\
    \ 2);\n    if r == 1 {\n        p\n    } else {\n        largest_prime_factor(r)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `divide_out_prime_factors` in this scope\n\
    \ --> /tmp/tmpm33b6879.rs:7:18\n  |\n7 |     let (p, r) = divide_out_prime_factors(n,\
    \ 2);\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut max_prime = 2;\n    while n > max_prime {\n        if n % max_prime == 0\
    \ {\n            n /= max_prime;\n        } else {\n            max_prime += 1;\n\
    \        }\n    }\n    max_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p: isize = 2;\n\
    \    let mut m: isize = n;\n    while m != 1 {\n        if m % p == 0 {\n    \
    \        m /= p;\n        } else {\n            p += 1;\n        }\n    }\n  \
    \  p\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut f = 2;\n    while f <= n {\n        if n % f == 0 {\n    \
    \        largest_factor = f;\n            n /= f;\n        } else {\n        \
    \    f += 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpothqpjto.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= f;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let (mut n, mut f) =\
    \ (n, 2);\n    while n > 1 {\n        while n % f == 0 {\n            n /= f;\n\
    \        }\n        f += 1;\n    }\n    f - 1\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut q = n;\n    while q > p {\n        if q % p == 0 {\n            q /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    q\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n % p == 0 {\n        n /= p;\n    }\n    p += 1;\n  \
    \  while n > 1 {\n        while n % p == 0 {\n            n /= p;\n        }\n\
    \        p += 2;\n    }\n    p -= 2\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8umhyvuh.rs:19:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n19 |    \
    \ p -= 2\n   |     ^^^^^^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    let mut tmp = n;\n    // The factor is less than sqrt(n)\n    let\
    \ sqrt = (n as f64).sqrt() as isize;\n    for i in 2..sqrt {\n        if tmp %\
    \ i == 0 {\n            largest_prime_factor = i;\n            tmp /= i;\n   \
    \     }\n    }\n    // n is a prime or there is only one prime factor greater\
    \ than sqrt(n)\n    largest_prime_factor = max(largest_prime_factor, tmp);\n \
    \   largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpw1w_z0hv.rs:18:28\n\
    \   |\n18 |     largest_prime_factor = max(largest_prime_factor, tmp);\n   | \
    \                           ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    let mut ans = 0;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            ans = i;\n            while n % i == 0 {\n                n\
    \ /= i;\n            }\n        }\n        i += 1;\n    }\n    if n > 1 {\n  \
    \      ans = n;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = 2;\n\
    \    let mut target = n;\n    while target > max_prime {\n        if target %\
    \ max_prime == 0 {\n            target /= max_prime;\n        } else {\n     \
    \       max_prime += 1;\n        }\n    }\n    max_prime\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut last_factor = 1;\n    let mut largest_factor = 1;\n    while n >\
    \ 1 {\n        while n % factor == 0 {\n            largest_factor = factor;\n\
    \            n /= factor;\n        }\n        last_factor = factor;\n        factor\
    \ += 1;\n        if factor * factor > n {\n            if n > 1 {\n          \
    \      largest_factor = n;\n            }\n            break;\n        }\n   \
    \ }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "warning: variable `last_factor` is assigned to, but never used\n --> /tmp/tmpwuiahyh3.rs:8:13\n\
    \  |\n8 |     let mut last_factor = 1;\n  |             ^^^^^^^^^^^\n  |\n  =\
    \ note: `#[warn(unused_variables)]` on by default\n  = note: consider using `_last_factor`\
    \ instead\n\nwarning: value assigned to `last_factor` is never read\n  --> /tmp/tmpwuiahyh3.rs:15:9\n\
    \   |\n15 |         last_factor = factor;\n   |         ^^^^^^^^^^^\n   |\n  \
    \ = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `n`\n  --> /tmp/tmpwuiahyh3.rs:13:13\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                         - help: consider making this\
    \ binding mutable: `mut n`\n...\n13 |             n /= factor;\n   |         \
    \    ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp31dy2l9g.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n       \
    \     result = d;\n            while n % d == 0 {\n                n /= d;\n \
    \           }\n        }\n        d += 1;\n    }\n    if n > 1 {\n        result\
    \ = n;\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0501_xgd.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= d;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut new_n = n;\n\
    \    let mut factor = 2;\n    while new_n != 1 {\n        while new_n % factor\
    \ == 0 {\n            new_n /= factor;\n        }\n        factor += 1;\n    }\n\
    \    factor - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n\
    \    let mut r = n;\n    let mut d = 2;\n    while r > 1 {\n        if r % d ==\
    \ 0 {\n            largest = d;\n            r /= d;\n        } else {\n     \
    \       d += 1;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in 2..n {\n   \
    \     if n % i == 0 {\n            return largest_prime_factor(n / i);\n     \
    \   }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n != 1 {\n        while n % p == 0 {\n            n /=\
    \ p;\n        }\n        p += 1;\n    }\n    p - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut factor = 2;\n    while x > 1 {\n        if x % factor == 0 {\n         \
    \   x /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\
    \    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 0;\n\
    \    for x in 2..n {\n        if n % x == 0 {\n            result = largest_prime_factor(n\
    \ / x);\n            break;\n        }\n    }\n    if result == 0 {\n        result\
    \ = n;\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n       \
    \     n /= factor;\n        } else {\n            factor += 1;\n        }\n  \
    \  }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let\
    \ mut prime_factors = Vec::new();\n    let mut div = 2;\n    while x > 1 {\n \
    \       while x % div == 0 {\n            prime_factors.push(div);\n         \
    \   x /= div;\n        }\n        div += 1;\n    }\n    *prime_factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    2..n\n        .iter()\n\
    \        .filter(|x| n % x == 0)\n        .filter(|x| is_prime(*x))\n        .max()\n\
    \        .unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwnhjggp2.rs:10:21\n\
    \   |\n10 |         .filter(|x| is_prime(*x))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `iter` found for type\
    \ `isize` in the current scope\n --> /tmp/tmpwnhjggp2.rs:8:10\n  |\n8 |      \
    \   .iter()\n  |          ^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwnhjggp2.rs:7:5\n   |\n6  |   fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                        ----- expected\
    \ `isize` because of return type\n7  | /     2..n\n8  | |         .iter()\n9 \
    \ | |         .filter(|x| n % x == 0)\n10 | |         .filter(|x| is_prime(*x))\n\
    11 | |         .max()\n12 | |         .unwrap()\n   | |_________________^ expected\
    \ `isize`, found struct `std::ops::Range`\n   |\n   = note: expected type `isize`\n\
    \            found struct `std::ops::Range<{integer}>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factors = Vec::new();\n    let mut prime = 3;\n    let mut max_factor =\
    \ 1;\n    while n % 2 == 0 {\n        factors.push(2);\n        n /= 2;\n    }\n\
    \    while n > 1 {\n        while n % prime == 0 {\n            max_factor = prime;\n\
    \            factors.push(prime);\n            n /= prime;\n        }\n      \
    \  prime += 2;\n    }\n    return max_factor;\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO: implement\n\
    \    -1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `5`', /tmp/tmpcb9nrvv5.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut v = vec![];\n\
    \    let mut i = 2;\n    while i < n {\n        if n % i == 0 {\n            v.push(i);\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    v.push(n);\n    v.pop().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpz0pfa1ba.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = 2;\n\
    \    let mut current = n;\n    while current > 1 {\n        max_prime = largest_prime_factor_helper(current,\
    \ max_prime);\n        current /= max_prime;\n    }\n    max_prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_helper` in this\
    \ scope\n  --> /tmp/tmpmgr3wrqq.rs:10:21\n   |\n10 |         max_prime = largest_prime_factor_helper(current,\
    \ max_prime);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n    let mut test_factor = 2;\n    let mut remainder = n;\n    while remainder\
    \ > 1 {\n        while remainder % test_factor == 0 {\n            largest_prime_factor\
    \ = test_factor;\n            remainder /= test_factor;\n        }\n        test_factor\
    \ += 1;\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   while n % factor == 0 {\n                n /= factor;\n            }\n   \
    \     }\n        factor += 1;\n    }\n    factor - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = Primes::default();\n\
    \    let mut factor = 1;\n    let mut remain = n;\n    while remain > 1 {\n  \
    \      let p = primes.next();\n        while remain % p == 0 {\n            factor\
    \ = p;\n            remain /= p;\n        }\n    }\n    factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Primes`\n -->\
    \ /tmp/tmpj6szkt2m.rs:7:22\n  |\n7 |     let mut primes = Primes::default();\n\
    \  |                      ^^^^^^ use of undeclared type `Primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 2;\n    while n % largest_prime == 0 {\n        n /= largest_prime;\n    }\n\
    \    let mut i = 3;\n    while i * i <= n {\n        while n % i == 0 {\n    \
    \        n /= i;\n            largest_prime = i;\n        }\n        i += 2;\n\
    \    }\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmptwbwsqoc.rs:9:9\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \   n /= largest_prime;\n  |         ^^^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptwbwsqoc.rs:14:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n14 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev()\
    \ {\n        if is_prime(i) && n % i == 0 {\n            return i;\n        }\n\
    \    }\n    1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpjzg0evb7.rs:8:12\n\
    \  |\n8 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut n = n;\n    let mut largest_prime_factor = 1;\n    while n > 1 {\n\
    \        while n % divisor == 0 {\n            n /= divisor;\n            largest_prime_factor\
    \ = divisor;\n        }\n        divisor += 1;\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    let mut last_factor = 1;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            last_factor = i;\n            n /= i;\n          \
    \  while n % i == 0 {\n                n /= i;\n            }\n        }\n   \
    \     i += 1;\n    }\n    if n == 1 {\n        last_factor\n    } else {\n   \
    \     n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut remaining = n;\n    while factor <= remaining {\n        if remaining\
    \ % factor == 0 {\n            remaining /= factor;\n        } else {\n      \
    \      factor += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n    let max_factor = n;\n    let mut i = 2;\n    while i < max_factor\
    \ {\n        if n % i == 0 {\n            if is_prime(i) {\n                largest_prime_factor\
    \ = i;\n            }\n        }\n        i += 1;\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_k0qqwkg.rs:12:16\n\
    \   |\n12 |             if is_prime(i) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n\
    \    let mut largest_prime_factor = 0;\n    while n > 1 {\n        while n % divisor\
    \ == 0 {\n            largest_prime_factor = divisor;\n            n /= divisor;\n\
    \        }\n        divisor += 1;\n    }\n    largest_prime_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkd5gfmeb.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= divisor;\n   |             ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime\
    \ = 2;\n    let mut next_prime = 3;\n    let mut limit = n;\n    while limit !=\
    \ 1 {\n        while limit % next_prime == 0 {\n            largest_prime = next_prime;\n\
    \            limit /= next_prime;\n        }\n        next_prime += 2;\n    }\n\
    \    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn trial_division(n:\
    \ isize) -> Option<isize> {\n        if n % 2 == 0 {\n            return Some(2);\n\
    \        }\n        for i in (3..).step_by(2) {\n            if n % i == 0 {\n\
    \                return Some(i);\n            }\n        }\n        None\n   \
    \ }\n\n    let mut remainder = n;\n    let mut factor = trial_division(remainder);\n\
    \    while let Some(factor) = factor {\n        remainder /= factor;\n       \
    \ factor = trial_division(remainder);\n    }\n    remainder\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7wuf95y9.rs:23:18\n   |\n\
    21 |     while let Some(factor) = factor {\n   |                    ------ expected\
    \ due to the type of this binding\n22 |         remainder /= factor;\n23 |   \
    \      factor = trial_division(remainder);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut facs = vec![];\n\
    \    let mut i = 2;\n    let mut n = n;\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            facs.push(i);\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    if n > 1 {\n        facs.push(n);\n\
    \    }\n    *facs.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut max_factor = 1;\n    while factor * factor <= n {\n        if n %\
    \ factor == 0 {\n            max_factor = factor;\n            n /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    if n > 1 {\n\
    \        return n;\n    }\n    return max_factor;\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyii9syvh.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= factor;\n   |             ^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut result = n;\n    while result > 1 {\n        if result % factor ==\
    \ 0 {\n            result /= factor;\n        } else {\n            factor +=\
    \ 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n       \
    \     n /= factor;\n        } else {\n            factor += 1;\n        }\n  \
    \  }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut ret = 2;\n  \
    \  let mut divisor = 3;\n    let mut num = n;\n    while divisor * divisor <=\
    \ num {\n        if num % divisor == 0 {\n            ret = divisor;\n       \
    \     num /= divisor;\n        } else {\n            divisor += 2;\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpzf4jcvh7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut quotient = n;\n\
    \    let mut largest_prime_factor = 0;\n    let mut i = 2;\n    while i * i <=\
    \ quotient {\n        if quotient % i == 0 {\n            quotient /= i;\n   \
    \         largest_prime_factor = i;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    if quotient > largest_prime_factor {\n        largest_prime_factor\
    \ = quotient;\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let primes = primes_up_to(n\
    \ as f64).collect::<Vec<_>>();\n    for prime in primes.iter().rev() {\n     \
    \   if n % prime == 0 {\n            return *prime;\n        }\n    }\n    unreachable!()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primes_up_to` in this scope\n --> /tmp/tmpyimzqg6b.rs:7:18\n\
    \  |\n7 |     let primes = primes_up_to(n as f64).collect::<Vec<_>>();\n  |  \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    let mut largest_factor = 1;\n    while n > 1 {\n      \
    \  if n % factor == 0 {\n            largest_factor = factor;\n            n /=\
    \ factor;\n            while n % factor == 0 {\n                n /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    largest_factor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut i = 2;\n    while i <= n {\n        while n % i == 0 {\n        \
    \    factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.pop().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsf58trff.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut result = 1;\n    while i <= n {\n        if n % i == 0 {\n            result\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpspi77t8d.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    unimplemented!();\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnaz6ndc6.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 2;\n\
    \    let mut is_prime = |x| {\n        for i in 2..x {\n            if x % i ==\
    \ 0 {\n                return false;\n            }\n        }\n        true\n\
    \    };\n    while prime <= n {\n        while n % prime == 0 {\n            n\
    \ /= prime;\n        }\n        prime += 1;\n        while !is_prime(prime) {\n\
    \            prime += 1;\n        }\n    }\n    prime\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpyk0gn12k.rs:8:9\n\
    \  |\n8 |     let mut is_prime = |x| {\n  |         ----^^^^^^^^\n  |        \
    \ |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmpyk0gn12k.rs:18:13\n   |\n6  | fn largest_prime_factor(n: isize) -> isize\
    \ {\n   |                         - help: consider making this binding mutable:\
    \ `mut n`\n...\n18 |             n /= prime;\n   |             ^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 0;\n\
    \    let mut sqrt = (n as f64).sqrt().ceil() as isize;\n    while sqrt > 0 {\n\
    \        if is_prime(sqrt) && n % sqrt == 0 {\n            prime = sqrt;\n   \
    \         break;\n        }\n        sqrt -= 1;\n    }\n    prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpdgat_02r.rs:10:12\n\
    \   |\n10 |         if is_prime(sqrt) && n % sqrt == 0 {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n\
    \    let mut largest_factor = 1;\n    let mut tmp = n;\n    while tmp > 1 {\n\
    \        if tmp % factor == 0 {\n            largest_factor = factor;\n      \
    \      tmp /= factor;\n            while tmp % factor == 0 {\n               \
    \ tmp /= factor;\n            }\n        }\n        factor += 1;\n    }\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut j = n;\n    while i * i <= j {\n        if j % i == 0 {\n            j /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    return j;\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // First, find some smaller\
    \ prime factor of n.\n    let mut factor = 2;\n    while n % factor != 0 {\n \
    \       factor += 1;\n    }\n\n    // Then, see if that factor has any prime factors\
    \ itself.\n    let mut other_factor = largest_prime_factor(factor);\n    let mut\
    \ result = n / factor;\n    while result % other_factor == 0 {\n        result\
    \ /= other_factor;\n    }\n\n    // If it doesn't, then that factor is the largest\
    \ prime factor of n.\n    if result == 1 {\n        factor\n    } else {\n   \
    \     // Otherwise, the largest prime factor of n is whatever's left.\n      \
    \  largest_prime_factor(result)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut p = 2;\n    while n > 1 {\n        while n % p == 0 {\n            n /=\
    \ p;\n        }\n        p += 1;\n    }\n    p - 1\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    let mut n = n;\n    for i in 2..n {\n        while n % i == 0 {\n       \
    \     n /= i;\n            largest = i;\n        }\n    }\n    largest\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let n = n as usize;\n\
    \    let mut result = 2;\n    let mut i = 2;\n    while i <= n / i {\n       \
    \ if n % i == 0 {\n            result = i;\n            n /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    result as isize\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpct14eq_s.rs:13:13\n\
    \   |\n7  |     let n = n as usize;\n   |         -\n   |         |\n   |    \
    \     first assignment to `n`\n   |         help: consider making this binding\
    \ mutable: `mut n`\n...\n13 |             n /= i;\n   |             ^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut num = n;\n  \
    \  let mut largest_prime = 1;\n    for p in primes() {\n        if p > num {\n\
    \            break;\n        }\n\n        if num % p == 0 {\n            num /=\
    \ p;\n            largest_prime = p;\n        }\n    }\n    largest_prime\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primes` in this scope\n --> /tmp/tmp_dh5uymv.rs:9:14\n\
    \  |\n9 |     for p in primes() {\n  |              ^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        panic!(\"\
    Input number {} is less than 2\", n);\n    }\n\n    let mut largest_prime_factor\
    \ = 0;\n    let mut remainder = n;\n    let mut p = 2;\n\n    while remainder\
    \ > 1 {\n        if remainder % p == 0 {\n            largest_prime_factor = p;\n\
    \            remainder /= p;\n        } else {\n            p += 1;\n        }\n\
    \    }\n\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut largest_factor = 1;\n    let mut current_factor = 2;\n    while n > 1 {\n\
    \        if n % current_factor == 0 {\n            largest_factor = current_factor;\n\
    \            n /= current_factor;\n            while n % current_factor == 0 {\n\
    \                n /= current_factor;\n            }\n        }\n        current_factor\
    \ += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 2 {\n       \
    \ return 2;\n    }\n\n    let mut n = n;\n    let mut i = 2;\n    let mut largest_prime\
    \ = 0;\n\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n \
    \           largest_prime = i;\n        } else {\n            i += 1;\n      \
    \  }\n    }\n\n    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let factors = find_factors(n);\n\
    \    factors.iter().fold(0, |acc, &x| if is_prime(x) { x } else { acc })\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_factors` in this scope\n --> /tmp/tmph8li1smv.rs:7:19\n\
    \  |\n7 |     let factors = find_factors(n);\n  |                   ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n --> /tmp/tmph8li1smv.rs:8:41\n  |\n8 |     factors.iter().fold(0,\
    \ |acc, &x| if is_prime(x) { x } else { acc })\n  |                          \
    \               ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i < n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut d = 2;\n    let\
    \ mut f = n;\n    while d * d <= f {\n        if f % d == 0 {\n            f /=\
    \ d;\n        } else {\n            d += 1;\n        }\n    }\n    f\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut num = n;\n    let mut max_prime = 1;\n    while i * i <= num {\n       \
    \ if num % i == 0 {\n            max_prime = i;\n            num = num / i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    if num > 1 {\n \
    \       return num;\n    }\n    return max_prime;\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut primes = vec![];\n    let mut result = n;\n    while p * p <= result {\n\
    \        if result % p == 0 {\n            result /= p;\n            primes.push(p);\n\
    \        } else {\n            p += 1;\n        }\n    }\n    primes.push(result);\n\
    \    return *primes.last().unwrap();\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut d = n;\n    while d % f == 0 {\n        d /= f;\n    }\n    if d == 1 {\n\
    \        return f;\n    }\n    f = 3;\n    while d % f == 0 {\n        d /= f;\n\
    \    }\n    if d == 1 {\n        return f;\n    }\n    f = 5;\n    while d % f\
    \ == 0 {\n        d /= f;\n    }\n    if d == 1 {\n        return f;\n    }\n\
    \    while d % 2 == 0 {\n        d /= 2;\n    }\n    let mut f = 7;\n    while\
    \ d > 1 {\n        while d % f == 0 {\n            d /= f;\n        }\n      \
    \  f += 4;\n        while d % f == 0 {\n            d /= f;\n        }\n     \
    \   f += 2;\n        while d % f == 0 {\n            d /= f;\n        }\n    \
    \    f += 4;\n        while d % f == 0 {\n            d /= f;\n        }\n   \
    \     f += 2;\n        while d % f == 0 {\n            d /= f;\n        }\n  \
    \      f += 4;\n        while d % f == 0 {\n            d /= f;\n        }\n \
    \       f += 6;\n        while d % f == 0 {\n            d /= f;\n        }\n\
    \        f += 2;\n        while d % f == 0 {\n            d /= f;\n        }\n\
    \        f += 6;\n    }\n    f - 2\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `35`,\n right: `7`', /tmp/tmpw5yv9ofr.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n           \
    \ n /= i;\n        }\n        i += 1;\n    }\n    if n == 1 {\n        i -= 1;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpqybximir.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = Vec::new();\n    let mut n = n;\n    for i in 2..n+1 {\n        if n % i ==\
    \ 0 {\n            prime_factors.push(i);\n            n /= i;\n        }\n  \
    \  }\n    *prime_factors.last().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp7mvbvqo6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut pf = 1;\n    while f * f <= n {\n        if n % f == 0 {\n            pf\
    \ = f;\n            while n % f == 0 {\n                n /= f;\n            }\n\
    \        }\n        f += 1;\n    }\n    if n > 1 {\n        pf = n;\n    }\n \
    \   pf\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpjcis1hep.rs:13:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \               n /= f;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factor = 2;\n    let mut largest_factor = 1;\n    while n > 1 {\n      \
    \  if n % factor == 0 {\n            largest_factor = factor;\n            n /=\
    \ factor;\n            while n % factor == 0 {\n                n /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    largest_factor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n    let mut largest = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n            largest = i;\n        } else {\n     \
    \       i += 1;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let\
    \ mut ans = 1;\n    while f <= n {\n        if is_prime(f) && n % f == 0 {\n \
    \           ans = f;\n        }\n        f += 1;\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvdhfrwfg.rs:10:12\n\
    \   |\n10 |         if is_prime(f) && n % f == 0 {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_iter(n,\
    \ 2)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `largest_prime_factor_iter` in this\
    \ scope\n --> /tmp/tmpwm9umbwk.rs:7:5\n  |\n7 |     largest_prime_factor_iter(n,\
    \ 2)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max_prime = 1;\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      max_prime = i;\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    max_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpc3zrb4y_.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut m = n;\n    let mut i = 2;\n    loop {\n        if m % i == 0 {\n\
    \            factors.push(i);\n            m /= i;\n        } else {\n       \
    \     i += 1;\n        }\n        if m == 1 {\n            break;\n        }\n\
    \    }\n    factors.last().unwrap().clone()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // 1. 2 is the only even\
    \ prime, so divide out any multiples of 2 first.\n    // 2. We don't need to check\
    \ any numbers higher than the square root of n.\n    // 3. If a number is a factor\
    \ of n, it is either a prime or a composite, so if it\n    //    divides n, we\
    \ can stop because we have found the largest prime factor.\n    let mut n = n;\n\
    \    let mut largest_prime_factor = 1;\n    while n % 2 == 0 {\n        n /= 2;\n\
    \        largest_prime_factor = 2;\n    }\n    let mut factor = 3;\n    while\
    \ factor <= n.sqrt() {\n        if n % factor == 0 {\n            n /= factor;\n\
    \            largest_prime_factor = factor;\n        } else {\n            factor\
    \ += 2;\n        }\n    }\n    if n > largest_prime_factor {\n        largest_prime_factor\
    \ = n;\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmptqx5ngw_.rs:18:23\n   |\n18 |     while factor <= n.sqrt()\
    \ {\n   |                       ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n    let mut x = n;\n    for i in 2..n {\n        if x % i == 0 {\n   \
    \         largest_prime_factor = i;\n            x = x / i;\n        }\n    }\n\
    \    return largest_prime_factor;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp5prna3sm.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut factor = n;\n    while i * i <= factor {\n        if factor % i == 0 {\n\
    \            factor /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut n = n;\n    let mut i = 2;\n    while i <= limit {\n\
    \        if n % i == 0 {\n            n /= i;\n            limit = (n as f64).sqrt()\
    \ as isize;\n        } else {\n            i += 1;\n        }\n    }\n    n\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `limit`\n  -->\
    \ /tmp/tmphfziv2bl.rs:13:13\n   |\n7  |     let limit = (n as f64).sqrt() as isize;\n\
    \   |         -----\n   |         |\n   |         first assignment to `limit`\n\
    \   |         help: consider making this binding mutable: `mut limit`\n...\n13\
    \ |             limit = (n as f64).sqrt() as isize;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut quotient = n;\n\
    \    let mut largest_prime_factor = 0;\n    let mut factor = 2;\n    while quotient\
    \ != 1 {\n        if quotient % factor == 0 {\n            largest_prime_factor\
    \ = factor;\n            quotient /= factor;\n        } else {\n            factor\
    \ += 1;\n        }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut r = n;\n    for\
    \ i in 2..n {\n        if i * i > n {\n            break;\n        }\n       \
    \ while r % i == 0 {\n            r /= i;\n        }\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpv47219dn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let\
    \ mut num = n;\n    while num > 1 {\n        while num % p == 0 {\n          \
    \  num /= p;\n        }\n        p += 1;\n    }\n    p - 1\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut f = 2;\n    while n > 1 {\n        if n % f == 0 {\n            n /= f;\n\
    \        } else {\n            f += 1;\n        }\n    }\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     largest_prime_factor(n / 2)\n    } else {\n        for x in (3..n).step_by(2)\
    \ {\n            if n % x == 0 {\n                return largest_prime_factor(n\
    \ / x);\n            }\n        }\n        n\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let mut p = 1;\n    let mut a = n;\n    while a > 1 {\n        // a is not prime,\
    \ so a has a prime factor p\n        p += 1;\n        while a % p == 0 {\n   \
    \         a /= p;\n        }\n    }\n    p\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let mut factor = 2;\n    let mut num = n;\n    while num > 1 {\n        if num\
    \ % factor == 0 {\n            while num % factor == 0 {\n                num\
    \ /= factor;\n            }\n        }\n        factor += 1;\n    }\n    factor\
    \ - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO\n    0\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpi64w8ggm.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut copy_n = n;\n\
    \    let mut i = 2;\n    while i <= copy_n {\n        if copy_n % i == 0 {\n \
    \           copy_n /= i;\n        } else {\n            i += 1;\n        }\n \
    \   }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // TODO\n    0\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmp7ohpw7ff.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = 1;\n\
    \    let mut num = n;\n    // Try 2 first\n    while num % 2 == 0 {\n        max_prime\
    \ = 2;\n        num /= 2;\n    }\n    // Odd numbers\n    let mut i = 3;\n   \
    \ while i <= (num as f64).sqrt() as isize {\n        while num % i == 0 {\n  \
    \          max_prime = i;\n            num /= i;\n        }\n        i += 2;\n\
    \    }\n    if num > 2 {\n        max_prime = num;\n    }\n    max_prime\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n\n    for i in (2..).take_while(|x| x * x <= n) {\n      \
    \  if n % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n\
    \    }\n\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
