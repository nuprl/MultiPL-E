name: HumanEval_27_flip_case
language: rust
prompt: "/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case('Hello')\n/// 'hELLO'\nfn flip_case(string: String)\
  \ -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")),\
  \ String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent\
  \ delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\"));\n}\n"
completions: ["    let mut flipped = String::new();\n    for c in string.chars() {\n\
    \        if c.is_ascii_uppercase() {\n            flipped.push(c.to_ascii_lowercase());\n\
    \        } else {\n            flipped.push(c.to_ascii_uppercase());\n       \
    \ }\n    }\n    flipped", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else {\n        \
    \    c.to_lowercase().next().unwrap()\n        }\n    }).collect()", '    unimplemented!("Flip
    case for {}", string);', "    let mut result = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    result", "    let mut buffer = String::with_capacity(string.len());\n\
    \    for c in string.chars() {\n        if c.is_ascii_uppercase() {\n        \
    \    buffer.push(c.to_ascii_lowercase());\n        } else {\n            buffer.push(c.to_ascii_uppercase());\n\
    \        }\n    }\n    buffer", "    let mut flipped = String::new();\n    for\
    \ c in string.chars() {\n        if c.is_lowercase() {\n            flipped.push(c.to_uppercase().collect::<String>());\n\
    \        } else {\n            flipped.push(c.to_lowercase().collect::<String>());\n\
    \        }\n    }\n    flipped", '    string.chars().map(|c| c.swap_case()).collect()',
  "    let mut flipped_string = String::new();\n    for c in string.chars() {\n  \
    \      if c.is_ascii_lowercase() {\n            flipped_string.push(c.to_ascii_uppercase());\n\
    \        } else {\n            flipped_string.push(c.to_ascii_lowercase());\n\
    \        }\n    }\n    flipped_string", "    string.chars().map(|c| match c {\n\
    \        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n        c if\
    \ c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        x if x.is_lowercase() => x.to_uppercase().next().unwrap(),\n\
    \        x if x.is_uppercase() => x.to_lowercase().next().unwrap(),\n        _\
    \ => c,\n    }).collect()", '    unimplemented!()', "    let mut result = String::new();\n\
    \    for character in string.chars() {\n        if character.is_uppercase() {\n\
    \            result.push(character.to_lowercase().next().unwrap());\n        }\
    \ else {\n            result.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    result", '    unimplemented!("Return a copy of {} but with
    the case flipped", string)', "    string.chars().map(|x| match x {\n        'a'...'z'\
    \ => x.to_ascii_uppercase(),\n        'A'...'Z' => x.to_ascii_lowercase(),\n \
    \       _ => x,\n    }).collect()", "    unimplemented!(\"flip_case('{}')\", string);",
  "    string.chars().map(|c| {\n        match c {\n            'a'...'z' => (c as\
    \ u8 - 'a' as u8 + 'A' as u8) as char,\n            'A'...'Z' => (c as u8 - 'A'\
    \ as u8 + 'a' as u8) as char,\n            _ => c,\n        }\n    }).collect()",
  '    unimplemented!()', "    string.chars().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", "    let mut ret = String::new();\n    for\
    \ c in string.chars() {\n        if c.is_uppercase() {\n            ret.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            ret.push(c.to_uppercase().next().unwrap());\n \
    \       }\n    }\n    ret", '    unimplemented!()', '  unimplemented!()', "  \
    \  let mut new_string = String::new();\n    for c in string.chars() {\n      \
    \  if c.is_lowercase() {\n            new_string.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            new_string.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    new_string", "    string.chars().map(|c| match c {\n  \
    \      'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", '    string.chars().map(|c| c.is_ascii_uppercase()
    { c.to_ascii_lowercase() } else { c.to_ascii_uppercase() }).collect()', '    unimplemented!()',
  '    string.chars().map(|x| x.to_ascii_uppercase()).collect()', "    // \u5C06\u5B57\
    \u7B26\u4E32\u8F6C\u6362\u4E3A\u5B57\u7B26\u6570\u7EC4\n    let mut chars = string.chars();\n\
    \    // \u5C06\u5B57\u7B26\u6570\u7EC4\u8F6C\u6362\u4E3A\u5B57\u7B26\u8FED\u4EE3\
    \u5668\n    let mut iter = chars.map(|c| c.to_ascii_lowercase());\n    // \u5C06\
    \u5B57\u7B26\u8FED\u4EE3\u5668\u8F6C\u6362\u4E3A\u5B57\u7B26\u4E32\n    let new_string:\
    \ String = iter.collect();\n    new_string", "    string.chars().map(|c| if c.is_ascii_lowercase()\
    \ {\n        c.to_ascii_uppercase()\n    } else {\n        c.to_ascii_lowercase()\n\
    \    }).collect()", '    string.chars().map(|c| if c.is_uppercase() { c.to_lowercase().next().unwrap()
    } else { c.to_uppercase().next().unwrap() }).collect()', '    string.chars().map(|c|
    c.to_lowercase().next().unwrap()).collect()', "    let chars: Vec<char> = string.chars().collect();\n\
    \    let flipped: Vec<char> = chars.iter().map(|c| flip_char(*c)).collect();\n\
    \    flipped.iter().collect()", "    string.chars().map(|c| if c.is_lowercase()\
    \ {\n        c.to_uppercase().next().unwrap()\n    } else {\n        c.to_lowercase().next().unwrap()\n\
    \    }).collect()", "    string.chars().map(|c| match c {\n        c if c.is_lowercase()\
    \ => c.to_uppercase().nth(0).unwrap(),\n        c if c.is_uppercase() => c.to_lowercase().nth(0).unwrap(),\n\
    \        _ => c,\n    }).collect()", "    let mut result = String::new();\n  \
    \  for c in string.chars() {\n        if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    result", "    let mut flipped = String::new();\n    for\
    \ c in string.chars() {\n        if c.is_uppercase() {\n            flipped.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            flipped.push(c.to_uppercase().collect::<String>());\n\
    \        }\n    }\n    flipped", '    unimplemented!()', "    string.chars().map(|x|\
    \ match x {\n        x if x.is_ascii_lowercase() => x.to_ascii_uppercase(),\n\
    \        x if x.is_ascii_uppercase() => x.to_ascii_lowercase(),\n        _ =>\
    \ x,\n    }).collect()", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().collect::<String>()\n        } else {\n    \
    \        c.to_lowercase().collect::<String>()\n        }\n    }).collect::<String>()",
  '    unimplemented!()', "    let mut s = String::with_capacity(string.len());\n\
    \    for c in string.chars() {\n        s.push(c.to_ascii_uppercase().to_ascii_lowercase());\n\
    \    }\n    s", '    string.chars().map(|c| if c.is_uppercase() { c.to_lowercase().next().unwrap()
    } else { c.to_uppercase().next().unwrap() }).collect()', '  string.chars().map(|x|
    x.to_lowercase().next().unwrap()).collect()', "    let mut output: String = String::new();\n\
    \    for i in string.chars() {\n        if i.is_lowercase() {\n            output.push(i.to_uppercase().to_string());\n\
    \        } else {\n            output.push(i.to_lowercase().to_string());\n  \
    \      }\n    }\n    output", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().collect::<String>()\n        } else {\n    \
    \        c.to_lowercase().collect::<String>()\n        }\n    }).collect::<String>()",
  "    let mut flipped = String::new();\n    for c in string.chars() {\n        if\
    \ c.is_lowercase() {\n            flipped.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            flipped.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    flipped", '    unimplemented!()', "    // Flip character\
    \ case, as described in the function docstring.\n    string.chars().map(|c| {\n\
    \        match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n       \
    \     'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n \
    \   }).collect()", '    string.chars().map(|char| if char.is_uppercase() { char.to_lowercase().next().unwrap()
    } else { char.to_uppercase().next().unwrap() }).collect()', "    string.chars().map(|char|\
    \ {\n        if char.is_ascii_lowercase() {\n            char.to_ascii_uppercase()\n\
    \        } else {\n            char.to_ascii_lowercase()\n        }\n    }).collect()",
  "    string.chars().map(|c| match c {\n        c if c.is_lowercase() => c.to_uppercase().collect::<String>(),\n\
    \        c if c.is_uppercase() => c.to_lowercase().collect::<String>(),\n    \
    \    _ => c.to_string(),\n    }).collect::<String>()", "    let mut new_string\
    \ = String::new();\n    for c in string.chars() {\n        if c.is_lowercase()\
    \ {\n            new_string.push(c.to_uppercase().next().unwrap());\n        }\
    \ else {\n            new_string.push(c.to_lowercase().next().unwrap());\n   \
    \     }\n    }\n    new_string", "    string.chars().map(|c| if c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", "    let mut string = string;\n    let string_len = string.len();\n\
    \    for i in 0..string_len {\n        let mut character = string.remove(i);\n\
    \        if character.is_ascii_uppercase() {\n            character = character.to_ascii_lowercase();\n\
    \        } else {\n            character = character.to_ascii_uppercase();\n \
    \       }\n        string.insert(i, character);\n    }\n    string", '    unimplemented!()',
  '    unimplemented!()', '    string.chars().map(|c| if c.is_lowercase() { c.to_uppercase()
    } else { c.to_lowercase() }).collect()', "    let mut flipped = String::new();\n\
    \    for character in string.chars() {\n        if character.is_ascii_lowercase()\
    \ {\n            flipped.push(character.to_ascii_uppercase());\n        } else\
    \ if character.is_ascii_uppercase() {\n            flipped.push(character.to_ascii_lowercase());\n\
    \        } else {\n            flipped.push(character);\n        }\n    }\n  \
    \  flipped", "    let mut flipped = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            flipped.push(c.to_ascii_lowercase());\n\
    \        } else {\n            flipped.push(c.to_ascii_uppercase());\n       \
    \ }\n    }\n    flipped", "    string.chars().map(|c| match c {\n        c if\
    \ c.is_lowercase() => c.to_uppercase().next().unwrap(),\n        c if c.is_uppercase()\
    \ => c.to_lowercase().next().unwrap(),\n        _ => c,\n    }).collect()", '    string.chars().map(|c|
    c.swap_case()).collect()', "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else {\n        \
    \    c.to_lowercase().next().unwrap()\n        }\n    }).collect()", '    unimplemented!()',
  '    unimplemented!("flip_case({})", string)', "    string.chars().map(|c| {\n \
    \       match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n        \
    \    'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n  \
    \  }).collect()", "    let mut output = String::new();\n    for c in string.chars()\
    \ {\n        output.push(if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        });\n\
    \    }\n    output", '    string.chars().map(|c| c.to_ascii_uppercase()).collect()',
  "    let mut chars = string.chars();\n    match chars.next() {\n        None =>\
    \ string,\n        Some(c) => format!(\"{}{}\",\n                           c.to_lowercase().to_string(),\n\
    \                           flip_case(chars.collect()))\n    }", "  unimplemented!(\"\
    Flip the case of the string '{}'\", string);", "    string.chars().map(|c| match\
    \ c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    // TODO: Write your solution here\n\
    \    let mut flipped = String::new();\n    for c in string.chars() {\n       \
    \ if c.is_ascii_lowercase() {\n            flipped.push(c.to_ascii_uppercase());\n\
    \        } else {\n            flipped.push(c.to_ascii_lowercase());\n       \
    \ }\n    }\n    flipped", "    string.chars().map(|ch| if ch.is_lowercase() {\n\
    \        ch.to_uppercase().nth(0).unwrap()\n    } else {\n        ch.to_lowercase().nth(0).unwrap()\n\
    \    }).collect()", "    // Hint: The `.to_uppercase()` and `.to_lowercase()`\
    \ methods might be helpful\n    let mut result: String = \"\".to_string();\n \
    \   for character in string.chars() {\n        if character.is_ascii_uppercase()\
    \ {\n            result.push(character.to_ascii_lowercase());\n        } else\
    \ {\n            result.push(character.to_ascii_uppercase());\n        }\n   \
    \ }\n    result", "    string.chars().map(|c| {\n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }\n    }).collect()", "    // flip_case(&String) -> &String\n    let\
    \ mut new_string = String::new();\n    for character in string.chars() {\n   \
    \     if character.is_lowercase() {\n            new_string.push(character.to_uppercase().next().unwrap());\n\
    \        } else if character.is_uppercase() {\n            new_string.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            new_string.push(character);\n        }\n    }\n\
    \    new_string", "    // .chars() method produces an iterator over the characters\
    \ of a string\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n \
    \           c.to_uppercase().next().unwrap()\n        } else {\n            c.to_lowercase().next().unwrap()\n\
    \        }\n    }).collect()", '    unimplemented!()', "    let mut new_string\
    \ = String::new();\n    for c in string.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            new_string.push(c.to_ascii_uppercase());\n        } else {\n\
    \            new_string.push(c.to_ascii_lowercase());\n        }\n    }\n    new_string",
  "    string.chars().map(|c| match c {\n        'a' ... 'z' => (c as u8 - 'a' as\
    \ u8 + 'A' as u8) as char,\n        'A' ... 'Z' => (c as u8 - 'A' as u8 + 'a'\
    \ as u8) as char,\n        _ => c,\n    }).collect()", "    let mut flipped_case\
    \ = String::with_capacity(string.len());\n    for letter in string.chars() {\n\
    \        if letter.is_ascii_uppercase() {\n            flipped_case.push(letter.to_ascii_lowercase());\n\
    \        } else {\n            flipped_case.push(letter.to_ascii_uppercase());\n\
    \        }\n    }\n    flipped_case", "    string.chars().map(|c| {\n        match\
    \ c {\n            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z'\
    \ => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()",
  '    unimplemented!("Flip all the letters in string to their opposite case")', " \
    \   string.chars().map(|x| {\n        if x.is_uppercase() {\n            x.to_lowercase().collect::<String>()\n\
    \        } else {\n            x.to_uppercase().collect::<String>()\n        }\n\
    \    }).collect::<String>()", "    string.chars().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", '    string.chars().map(|c| c.is_ascii_lowercase()
    ? c.to_ascii_uppercase() : c.to_ascii_lowercase()).collect()', "    string.chars().map(|c|\
    \ match c {\n        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ =>\
    \ c,\n    }).collect()", "    let mut res = String::with_capacity(string.len());\n\
    \    for ch in string.chars() {\n        if ch.is_ascii_uppercase() {\n      \
    \      res.push(ch.to_ascii_lowercase());\n        } else {\n            res.push(ch.to_ascii_uppercase());\n\
    \        }\n    }\n    res", '    unimplemented!()', "    let mut result = String::new();\n\
    \    for c in string.chars() {\n        result.push(match c {\n            'a'..='z'\
    \ => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        });\n    }\n    result", '    unimplemented!()',
  '    unimplemented!()', "    string.chars().map(|c| match c {\n        'a'..='z'\
    \ => c.to_ascii_uppercase(),\n        'A'..='Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", "    string.chars().map(|c| c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", "    let mut chars = string.chars();\n    let mut final =\
    \ String::new();\n    while let Some(c) = chars.next() {\n        final.push(c.to_ascii_uppercase().to_ascii_lowercase());\n\
    \    }\n    final", '    unimplemented!()', '    unimplemented!("Flip the case
    of {}", string)', "    // TODO: Implement this function.\n\n    string.chars().map(|x|\
    \ match x {\n        'a' ... 'z' => char::from(x as u8 + 'A' as u8 - 'a' as u8),\n\
    \        'A' ... 'Z' => char::from(x as u8 + 'a' as u8 - 'A' as u8),\n       \
    \ _ => x\n    }).collect()", "    let mut res = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_uppercase() {\n            res.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(c.to_uppercase().next().unwrap());\n \
    \       }\n    }\n    res", "    let mut flipped_case_chars: Vec<char> = Vec::new();\n\
    \    for c in string.chars() {\n        match c.is_lowercase() {\n           \
    \ true => flipped_case_chars.push(c.to_uppercase().next().unwrap()),\n       \
    \     false => flipped_case_chars.push(c.to_lowercase().next().unwrap()),\n  \
    \      }\n    }\n    flipped_case_chars.into_iter().collect()", "    string.chars().map(|c|\
    \ {\n        match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n   \
    \         'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n\
    \    }).collect()", "    string.chars().map(|character| match character {\n  \
    \      character if character.is_ascii_uppercase() => character.to_ascii_lowercase(),\n\
    \        character if character.is_ascii_lowercase() => character.to_ascii_uppercase(),\n\
    \        _ => character,\n    }).collect()", '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!()', "    string.chars().map(|character| {\n        if character.is_lowercase()\
    \ {\n            character.to_uppercase().collect::<String>()\n        } else\
    \ {\n            character.to_lowercase().collect::<String>()\n        }\n   \
    \ }).collect::<String>()", "    string.chars().map(|c| {\n        match c {\n\
    \            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", '    string.chars().map(|c|
    c.swap_case()).collect()', "    string.chars().map(|c| match c {\n        // flip\
    \ lowercase to uppercase\n        c if c.is_lowercase() => c.to_uppercase().next().unwrap(),\n\
    \        // flip uppercase to lowercase\n        c if c.is_uppercase() => c.to_lowercase().next().unwrap(),\n\
    \        // leave other characters unchanged\n        c => c,\n    }).collect()",
  "    string.chars().map(|c| {\n        match c {\n            c if c.is_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n            c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    string.chars().map(|c|\
    \ c.is_ascii_uppercase() {\n                                 c.to_ascii_lowercase()\n\
    \                             } else {\n                                 c.to_ascii_uppercase()\n\
    \                             }).collect()", '    string.chars().map(|x| if x.is_uppercase()
    { x.to_lowercase().next().unwrap() } else { x.to_uppercase().next().unwrap() }).collect()',
  "    // return string.to_lowercase();\n    string.chars().map(|c| match c {\n  \
    \      'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    string.chars().map(|c| if c.is_lowercase()\
    \ {\n        c.to_uppercase().collect::<String>()\n    } else {\n        c.to_lowercase().collect::<String>()\n\
    \    }).collect::<String>()", '    string.chars().map(|c| if c.is_lowercase()
    { c.to_uppercase() } else { c.to_lowercase() }).collect()', '    string.chars().map(|c|
    if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase() }).collect()',
  '    string.chars().map(|c| if c.is_ascii_lowercase() { c.to_ascii_uppercase() }
    else { c.to_ascii_lowercase() }).collect()', '    unimplemented!()', "    // TODO:\
    \ implement this function\n    unimplemented!()", "    let mut string = string;\n\
    \    string.make_ascii_lowercase();\n    string.chars().map(|c| if c.is_lowercase()\
    \ {\n        c.to_ascii_uppercase()\n    } else {\n        c.to_ascii_lowercase()\n\
    \    }).collect()", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else {\n        \
    \    c.to_lowercase().next().unwrap()\n        }\n    }).collect()", "    string.chars().map(|character|\
    \ {\n        if character.is_lowercase() {\n            character.to_uppercase().next().unwrap()\n\
    \        } else {\n            character.to_lowercase().next().unwrap()\n    \
    \    }\n    }).collect()", '    string.chars().map(|c| c.to_lowercase().next().unwrap()).collect()',
  '    unimplemented!()', '    string.chars().map(|x| if x.is_ascii_lowercase() {
    x.to_ascii_uppercase() } else { x.to_ascii_lowercase() }).collect()', "    let\
    \ mut flipped = String::new();\n    for c in string.chars() {\n        let new_char\
    \ = match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z'\
    \ => c.to_ascii_lowercase(),\n            _ => c,\n        };\n        flipped.push(new_char);\n\
    \    }\n    flipped", '    unimplemented!()', '  string.chars().map(|c| if c.is_lowercase()
    { c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap() }).collect()',
  "    string.chars().map(|c| match c {\n        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ =>\
    \ c,\n    }).collect()", "    let mut flipped = String::with_capacity(string.len());\n\
    \    for c in string.chars() {\n        flipped.push(c.to_ascii_uppercase());\n\
    \    }\n    flipped", "    string.chars().map(|c| match c {\n        c if c.is_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    string.chars().map(|x| match x {\n \
    \       'a'..='z' => x.to_ascii_uppercase(),\n        'A'..='Z' => x.to_ascii_lowercase(),\n\
    \        _ => x,\n    }).collect()", '    string.chars().map(|c| c.to_ascii_uppercase()).collect()',
  "    let mut result = String::with_capacity(string.len());\n    for character in\
    \ string.chars() {\n        if character.is_ascii_lowercase() {\n            result.push(character.to_ascii_uppercase());\n\
    \        } else {\n            result.push(character.to_ascii_lowercase());\n\
    \        }\n    }\n    result", '    unimplemented!()', '    string.chars().map(|c|
    if c.is_uppercase() { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()
    }).collect()', "    let mut flipped = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_lowercase() {\n            flipped.push(c.to_uppercase().to_string());\n\
    \        } else {\n            flipped.push(c.to_lowercase().to_string());\n \
    \       }\n    }\n    flipped", '    unimplemented!()', "    string.chars().map(|c|\
    \ {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let flipped_string: String = string\n        .chars()\n\
    \        .map(|character| match character.is_lowercase() {\n            true =>\
    \ character.to_uppercase().next().unwrap(),\n            false => character.to_lowercase().next().unwrap(),\n\
    \        })\n        .collect();\n    flipped_string", "    let mut chars = string.chars();\n\
    \    let mut new_string = String::new();\n    while let Some(c) = chars.next()\
    \ {\n        let new_char = if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        };\n\
    \        new_string.push(new_char);\n    }\n    new_string", "    return string.chars().map(|x|\
    \ {\n        if x.is_lowercase() {\n            x.to_uppercase().next().unwrap()\n\
    \        } else {\n            x.to_lowercase().next().unwrap()\n        }\n \
    \   }).collect::<String>();", "    string.chars().map(|character| match character\
    \ {\n        character if character.is_ascii_uppercase() => character.to_ascii_lowercase(),\n\
    \        character if character.is_ascii_lowercase() => character.to_ascii_uppercase(),\n\
    \        _ => character,\n    }).collect()", "    string.chars().map(|x| match\
    \ x {\n        'a'..='z' => x.to_ascii_uppercase(),\n        'A'..='Z' => x.to_ascii_lowercase(),\n\
    \        _ => x,\n    }).collect()", '    string.chars().map(|c| c.swap_case()).collect()',
  "    string.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let mut flip: String = String::from(\"\");\n    for char\
    \ in string.chars() {\n        if char.is_lowercase() {\n            flip.push(char.to_uppercase().next().unwrap());\n\
    \        } else {\n            flip.push(char.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    flip", "    string.chars().map(|c| if c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", "    string.chars().map(|c| c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n\
    \    } else {\n        c.to_uppercase().next().unwrap()\n    }).collect()", " \
    \   let mut res = String::new();\n    for ch in string.chars() {\n        if ch.is_ascii_lowercase()\
    \ {\n            res.push(ch.to_ascii_uppercase());\n        } else {\n      \
    \      res.push(ch.to_ascii_lowercase());\n        }\n    }\n    res", '    unimplemented!()',
  "    let mut flipped_string = String::new();\n    for character in string.chars()\
    \ {\n        if character.is_lowercase() {\n            flipped_string.push(character.to_uppercase().next().unwrap());\n\
    \        } else {\n            flipped_string.push(character.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    flipped_string", "    // Your code here\n\n    return string;",
  "    // TODO: Implement me!\n    unimplemented!();", "    let mut ret_string = String::new();\n\
    \    for char in string.chars() {\n        match char.is_uppercase() {\n     \
    \       true => ret_string.push(char.to_lowercase().collect::<Vec<char>>()[0]),\n\
    \            false => ret_string.push(char.to_uppercase().collect::<Vec<char>>()[0]),\n\
    \        }\n    }\n    ret_string", '    string.chars().map(|c| c.to_ascii_uppercase()).collect()',
  "    string.chars().map(|ch| match ch {\n        'a'...'z' => ch.to_ascii_uppercase(),\n\
    \        'A'...'Z' => ch.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()",
  "  let mut letters = string.into_bytes();\n  for i in 0..letters.len() {\n    if\
    \ letters[i] > 64 && letters[i] < 91 {\n      letters[i] += 32;\n    } else if\
    \ letters[i] > 96 && letters[i] < 123 {\n      letters[i] -= 32;\n    }\n  }\n\
    \  String::from_utf8(letters).unwrap()", "    string.chars().map(|c| if c.is_uppercase()\
    \ {\n        c.to_lowercase().next().unwrap()\n    } else {\n        c.to_uppercase().next().unwrap()\n\
    \    }).collect()", "  string.chars().map(|c| match c {\n    'a'...'z' => (c as\
    \ u8 - 'a' as u8 + 'A' as u8) as char,\n    'A'...'Z' => (c as u8 - 'A' as u8\
    \ + 'a' as u8) as char,\n    _ => c,\n  }).collect()", '    string.chars().map(|c|
    c.swap_case()).collect()', '    string.chars().map(|c| if c.is_lowercase() { c.to_uppercase()
    } else { c.to_lowercase() }).collect()', "    let mut flipped = String::new();\n\
    \    for c in string.chars() {\n        if c.is_uppercase() {\n            flipped.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            flipped.push(c.to_uppercase().collect::<String>());\n\
    \        }\n    }\n    flipped", "    string.chars().map(|c| match c {\n     \
    \   c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n        c if c.is_ascii_uppercase()\
    \ => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    string.chars().map(|c|\
    \ {\n        if c.is_ascii_uppercase() {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c.to_ascii_uppercase()\n        }\n    }).collect()",
  '    string.chars().map(|c| c.to_ascii_uppercase()).collect()', "    let mut flipped\
    \ = String::new();\n    for c in string.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            flipped.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            flipped.push(c.to_ascii_lowercase());\n        } else {\n   \
    \         flipped.push(c);\n        }\n    }\n    flipped", "    // TODO: implement\
    \ me!\n    unimplemented!();", "    let mut flipped = String::new();\n    for\
    \ character in string.chars() {\n        if character.is_lowercase() {\n     \
    \       flipped.push(character.to_uppercase().next().unwrap());\n        } else\
    \ if character.is_uppercase() {\n            flipped.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            flipped.push(character);\n        }\n    }\n  \
    \  flipped", "    let mut new_string = String::new();\n    for char in string.chars()\
    \ {\n        new_string.push(if char.is_uppercase() {\n            char.to_lowercase().to_string()\n\
    \        } else {\n            char.to_uppercase().to_string()\n        });\n\
    \    }\n    new_string", "    string.chars().map(|x| {\n        if x.is_uppercase()\
    \ {\n            x.to_lowercase().next().unwrap()\n        } else {\n        \
    \    x.to_uppercase().next().unwrap()\n        }\n    }).collect()", "    // This\
    \ is one way to create a String from a vector.\n    let mut result = String::new();\n\
    \    for c in string.chars() {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    result", '    unimplemented!()', "    let flipped_string:\
    \ String = string\n        .chars()\n        .map(|c| {\n            if c.is_uppercase()\
    \ {\n                c.to_lowercase().next().unwrap()\n            } else {\n\
    \                c.to_uppercase().next().unwrap()\n            }\n        })\n\
    \        .collect();\n    flipped_string", '    string.chars().map(|x| if x.is_uppercase()
    { x.to_lowercase().nth(0).unwrap() } else { x.to_uppercase().nth(0).unwrap() }).collect()',
  "    let mut chars = string.chars();\n    let mut result = String::new();\n    while\
    \ let Some(ch) = chars.next() {\n        if ch.is_uppercase() {\n            result.push(ch.to_lowercase().to_string());\n\
    \        } else {\n            result.push(ch.to_uppercase().to_string());\n \
    \       }\n    }\n    result", "    string.chars().map(|ch| match ch {\n     \
    \   x if x.is_ascii_lowercase() => x.to_ascii_uppercase(),\n        x if x.is_ascii_uppercase()\
    \ => x.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()", '    unimplemented!("Flip
    case for {}", string);', '    unimplemented!("flip case of string {}", string);',
  "    // TODO (EXERCISE 2)\n    let mut new_string = String::new();\n    for c in\
    \ string.chars() {\n        match c {\n            'a'...'z' => new_string.push(c.to_ascii_uppercase()),\n\
    \            'A'...'Z' => new_string.push(c.to_ascii_lowercase()),\n         \
    \   _ => new_string.push(c),\n        }\n    }\n    new_string", '    unimplemented!("Flip
    the case of string: {}", string);', "    string.chars().map(|c| {\n        match\
    \ c {\n            x if x.is_lowercase() => x.to_uppercase().next().unwrap(),\n\
    \            x if x.is_uppercase() => x.to_lowercase().next().unwrap(),\n    \
    \        _ => c,\n        }\n    }).collect()", "    string.chars().map(|c| match\
    \ c {\n        c if c.is_lowercase() => c.to_uppercase().next().unwrap(),\n  \
    \      c if c.is_uppercase() => c.to_lowercase().next().unwrap(),\n        _ =>\
    \ c,\n    }).collect()", '    unimplemented!()', "    string.chars().map(|c| {\n\
    \        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    string.chars().map(|c| {\n        if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }\n    }).collect()", '    string.chars().map(|c| if c.is_lowercase()
    { c.to_uppercase() } else { c.to_lowercase() }).collect()', '    unimplemented!()',
  "    let mut out = String::new();\n    for c in string.chars() {\n        out.push(match\
    \ c {\n            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z'\
    \ => c.to_ascii_lowercase(),\n            _ => c,\n        });\n    }\n    out",
  "    string.chars().map(|c| match c {\n        c if c.is_lowercase() => c.to_uppercase().next().unwrap(),\n\
    \        c if c.is_uppercase() => c.to_lowercase().next().unwrap(),\n        _\
    \ => c,\n    }).collect()", '    string.chars().map(|c| if c.is_uppercase() {
    c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap() }).collect()',
  '    unimplemented!()', "    let mut flipped = String::new();\n    for c in string.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            flipped.push(c.to_ascii_lowercase());\n\
    \        } else {\n            flipped.push(c.to_ascii_uppercase());\n       \
    \ }\n    }\n    flipped", '    unimplemented!("Flip case on {}", string);', '    unimplemented!()',
  "    let mut out = String::new();\n    for c in string.chars() {\n        out.push(c.to_ascii_uppercase().to_ascii_lowercase());\n\
    \    }\n    out", "    string.chars().map(|c| match c {\n        c if c.is_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n        c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    let mut flipped = String::new();\n \
    \   for c in string.chars() {\n        let flipped_char = if c.is_ascii_lowercase()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        };\n        flipped.push(flipped_char);\n    }\n    flipped", '    unimplemented!()',
  "    // Turn the string into a char vec.\n    let mut chars: Vec<char> = string.chars().collect();\n\
    \n    // Loop through all chars, flipping them.\n    for i in 0..chars.len() {\n\
    \        if chars[i].is_uppercase() {\n            chars[i] = chars[i].to_lowercase().next().unwrap();\n\
    \        } else {\n            chars[i] = chars[i].to_uppercase().next().unwrap();\n\
    \        }\n    }\n\n    // Reassemble the string from the char vec.\n    let\
    \ mut new_string = String::new();\n    for c in chars {\n        new_string.push(c);\n\
    \    }\n\n    new_string", "    // flipped_string = \"\"\n    // loop\n    //\
    \      convert character at index i to uppercase or lowercase\n    //      add\
    \ to flipped_string\n    // return flipped_string\n    let mut flipped_string\
    \ = String::new();\n    for character in string.chars() {\n        flipped_string.push(match\
    \ character {\n            'a'...'z' => character.to_ascii_uppercase(),\n    \
    \        'A'...'Z' => character.to_ascii_lowercase(),\n            _ => character,\n\
    \        });\n    }\n    flipped_string"]
stop_tokens:
- "\n}"
