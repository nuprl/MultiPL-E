name: HumanEval_21_rescale_to_unit
language: rust
results:
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let range = numbers[numbers.len() - 1] - numbers[0];\n    numbers.iter().map(|&x|\
    \ (x - numbers[0]) / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmphiech_x7.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let nums = numbers.clone();\n    let max = nums.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = nums.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    nums.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    if min == max {\n        numbers\n    } else {\n        let scale = 1.0 /\
    \ (max - min);\n        numbers.iter().map(|x| (x - min) * scale).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpksry3u8i.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpksry3u8i.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Input vector must have at least\
    \ two elements\");\n    }\n    let max = numbers.iter().cloned().fold(numbers[0],\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnk0bwp1c.rs:6:30\n\
    \     |\n6    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnk0bwp1c.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(mi, ma),\
    \ &n| {\n        (cmp::min(mi, n), cmp::max(ma, n))\n    });\n    let diff = max\
    \ - min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpkuk0pe4b.rs:7:10\n  |\n7 |         (cmp::min(mi, n), cmp::max(ma,\
    \ n))\n  |          ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n --> /tmp/tmpkuk0pe4b.rs:7:27\n\
    \  |\n7 |         (cmp::min(mi, n), cmp::max(ma, n))\n  |                    \
    \       ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Can't rescale list with less than\
    \ 2 elements!\");\n    }\n    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let scale = max - min;\n    let translated = numbers.iter().map(|x| x - min).collect::<Vec<f64>>();\n\
    \    translated.iter().map(|x| x / scale).collect::<Vec<f64>>()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().min().unwrap();\n    let maximum = numbers.iter().max().unwrap();\n\
    \    let delta = maximum - minimum;\n    numbers.iter().map(|i| (i - minimum)\
    \ / delta).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxydeha4q.rs:6:34\n\
    \     |\n6    |     let minimum = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpxydeha4q.rs:7:34\n\
    \     |\n7    |     let maximum = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let factor\
    \ = 1.0 / (max - min);\n    let mut data = numbers.into_iter().map(|x| factor\
    \ * (x - min)).collect::<Vec<_>>();\n    data\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter().map(|n| (n - min) / range).collect()\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeucifoir.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeucifoir.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for number\
    \ in numbers.iter() {\n        if number < &min {\n            min = *number;\n\
    \        }\n        if number > &max {\n            max = *number;\n        }\n\
    \    }\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let largest_number = *numbers.iter().max().unwrap();\n    let smallest_number\
    \ = *numbers.iter().min().unwrap();\n    numbers.iter().map(|x| (x - smallest_number)\
    \ / (largest_number - smallest_number)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_34de3hv.rs:6:42\n\
    \     |\n6    |     let largest_number = *numbers.iter().max().unwrap();\n   \
    \  |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_34de3hv.rs:7:43\n\
    \     |\n7    |     let smallest_number = *numbers.iter().min().unwrap();\n  \
    \   |                                           ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find largest and smallest numbers\n    let max = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| f64::max(acc, *x));\n    let min = numbers.iter().fold(f64::INFINITY,\
    \ |acc, x| f64::min(acc, *x));\n\n    // Linear transform is y = (x - min) / (max\
    \ - min)\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    let min_val = numbers.iter().min().unwrap();\n\
    \    let max_val = numbers.iter().max().unwrap();\n    let scaling_factor = 1.0\
    \ / (max_val - min_val);\n    numbers = numbers.iter().map(|&n| n * scaling_factor).collect();\n\
    \    numbers = numbers.iter().map(|&n| n - min_val).collect();\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5zz_drhp.rs:7:34\n\
    \     |\n7    |     let min_val = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5zz_drhp.rs:8:34\n\
    \     |\n8    |     let max_val = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_num = *numbers.iter().max().unwrap();\n    let min_num = *numbers.iter().min().unwrap();\n\
    \    numbers.iter().map(|n| (n - min_num) / (max_num - min_num)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbnjbbfz0.rs:6:35\n\
    \     |\n6    |     let max_num = *numbers.iter().max().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbnjbbfz0.rs:7:35\n\
    \     |\n7    |     let min_num = *numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().fold(f64::INFINITY, |min, x| if x < &min { *x\
    \ } else { min });\n    let maximum = numbers.iter().fold(f64::NEG_INFINITY, |max,\
    \ x| if x > &max { *x } else { max });\n    numbers.iter().map(|x| (x - minimum)\
    \ / (maximum - minimum)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeftes88x.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpeftes88x.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum: f64 = numbers.iter().min().unwrap().clone();\n    let maximum:\
    \ f64 = numbers.iter().max().unwrap().clone();\n    let diff: f64 = maximum -\
    \ minimum;\n    numbers.iter().map(|x| (x - minimum) / diff).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpincqcmhx.rs:6:39\n\
    \     |\n6    |     let minimum: f64 = numbers.iter().min().unwrap().clone();\n\
    \     |                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpincqcmhx.rs:7:39\n\
    \     |\n7    |     let maximum: f64 = numbers.iter().max().unwrap().clone();\n\
    \     |                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::new();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let range = max - min;\n  \
    \  for n in numbers {\n        result.push((n - min) / range);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpad_es4k0.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpad_es4k0.rs:8:30\n\
    \     |\n8    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::new();\n    let (min, max) = (\n        numbers.iter().min_by(|a,\
    \ b| a.partial_cmp(b).unwrap()).unwrap(),\n        numbers.iter().max_by(|a, b|\
    \ a.partial_cmp(b).unwrap()).unwrap(),\n    );\n    for n in numbers {\n     \
    \   result.push((n - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `numbers` because it is borrowed\n  -->\
    \ /tmp/tmpz3w8_qjp.rs:11:14\n   |\n8  |         numbers.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap(),\n\
    \   |         -------------- borrow of `numbers` occurs here\n...\n11 |     for\
    \ n in numbers {\n   |              ^^^^^^^ move out of `numbers` occurs here\n\
    12 |         result.push((n - min) / (max - min));\n   |                     \
    \     --- borrow later used here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let delta\
    \ = max - min;\n    if delta == 0.0 {\n        return numbers;\n    }\n    numbers.iter().map(|n|\
    \ (*n - min) / delta).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Cannot rescale a list with less\
    \ than 2 elements!\");\n    }\n    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let sub = max - min;\n    numbers.iter().map(|x| (x - min) / sub).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbd0se2m2.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbd0se2m2.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let n = numbers.len();\n    let min = numbers.iter().min().unwrap();\n  \
    \  let max = numbers.iter().max().unwrap();\n    let delta = (max - min) / (n\
    \ as f64 - 1.0);\n    numbers.iter().map(|x| (x - min) / delta).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprostel4z.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprostel4z.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter_mut().for_each(|n| *n = (*n - min) / range);\n    numbers\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdiprdb6l.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdiprdb6l.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|v| (*v - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5r7u7xhr.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5r7u7xhr.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo26k1_bw.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo26k1_bw.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpe8gdg3cg.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpe8gdg3cg.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min, max),\
    \ &n| {\n        if n < min {\n            (n, max)\n        } else if n > max\
    \ {\n            (min, n)\n        } else {\n            (min, max)\n        }\n\
    \    });\n    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let diff = max - min;\n   \
    \ if diff == 0.0 {\n        // There is no way to rescale numbers in this case\n\
    \        return numbers;\n    }\n    numbers.iter().map(|n| (*n - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsk3v7s8f.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsk3v7s8f.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    let range = max_value - min_value;\n    numbers.iter().map(|x| (x - min_value)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp__33hflo.rs:6:36\n\
    \     |\n6    |     let min_value = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp__33hflo.rs:7:36\n\
    \     |\n7    |     let max_value = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Cannot do rescaling with less than\
    \ 2 elements\");\n    }\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let delta = max - min;\n    let mut\
    \ normalized = Vec::new();\n    for number in numbers {\n        normalized.push((number\
    \ - min) / delta);\n    }\n    normalized\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdoz639df.rs:9:30\n\
    \     |\n9    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdoz639df.rs:10:30\n\
    \     |\n10   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let delta = max - min;\n\
    \    if delta == 0.0 {\n        numbers\n    } else {\n        numbers.iter().map(|n|\
    \ (*n - min) / delta).collect()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if min == max {\n        return numbers;\n    }\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpopczz_fm.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpopczz_fm.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let delta\
    \ = max - min;\n    let scaled = numbers.iter().map(|number| (number - min) /\
    \ delta).collect();\n    assert!(scaled.iter().cloned().fold(std::f64::MIN, f64::max)\
    \ == 1.0);\n    assert!(scaled.iter().cloned().fold(std::f64::MAX, f64::min) ==\
    \ 0.0);\n    scaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2akojn5j.rs:10:13\n\
    \   |\n9  |     let scaled = numbers.iter().map(|number| (number - min) / delta).collect();\n\
    \   |         ------ consider giving `scaled` a type\n10 |     assert!(scaled.iter().cloned().fold(std::f64::MIN,\
    \ f64::max) == 1.0);\n   |             ^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_n = numbers.iter().max().unwrap();\n    let min_n = numbers.iter().min().unwrap();\n\
    \    let scale = 1.0 / (max_n - min_n);\n    numbers.iter().map(|x| (x - min_n)\
    \ * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwbqgkd4q.rs:6:32\n\
    \     |\n6    |     let max_n = numbers.iter().max().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwbqgkd4q.rs:7:32\n\
    \     |\n7    |     let min_n = numbers.iter().min().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let range = max - min;\n    let a = (1.0 - 0.0) / range;\n    let b = 0.0\
    \ - a * min;\n    numbers.iter().map(|x| a * x + b).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 0.9999999999999999]`,\n right: `[0.0, 1.0]`', /tmp/tmpronabqwa.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    numbers.iter().map(|&x| (x - min) / span).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr23hacfb.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr23hacfb.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_value) / (max_value - min_value)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppabindwb.rs:6:36\n\
    \     |\n6    |     let min_value = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppabindwb.rs:7:36\n\
    \     |\n7    |     let max_value = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpchbwr_h1.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpchbwr_h1.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0,\
    \ f64::min);\n    let range = max - min;\n    numbers.iter().map(|num| (num -\
    \ min) / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpelautwd1.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    numbers.iter().map(|&x| (x\
    \ - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1n3041mn.rs:10:30\n\
    \     |\n10   |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1n3041mn.rs:11:30\n\
    \     |\n11   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = get_min_max(numbers);\n    rescale_to_range(numbers, min,\
    \ max)\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_min_max` in this scope\n --> /tmp/tmpagif6czt.rs:6:22\n\
    \  |\n6 |     let (min, max) = get_min_max(numbers);\n  |                    \
    \  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rescale_to_range`\
    \ in this scope\n --> /tmp/tmpagif6czt.rs:7:5\n  |\n7 |     rescale_to_range(numbers,\
    \ min, max)\n  |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let len = numbers.len();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  if range == 0.0 {\n        let ones = vec![1.0; len];\n        return ones;\n\
    \    }\n    let mut scaled = vec![0.0; len];\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        scaled[i] = (num - min) / range;\n    }\n    scaled\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnbrn15qp.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpnbrn15qp.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let scale_factor = 1.0 / (numbers.iter().max().unwrap() - numbers.iter().min().unwrap());\n\
    \    let offset = -numbers.iter().min().unwrap();\n    let mut scaled = Vec::new();\n\
    \    for i in numbers {\n        scaled.push(scale_factor * (i + offset));\n \
    \   }\n    scaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp11wmac_9.rs:6:46\n\
    \     |\n6    |     let scale_factor = 1.0 / (numbers.iter().max().unwrap() -\
    \ numbers.iter().min().unwrap());\n     |                                    \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help:\
    \ the following other types implement trait `Ord`:\n               i128\n    \
    \           i16\n               i32\n               i64\n               i8\n \
    \              isize\n               u128\n               u16\n             and\
    \ 4 others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp11wmac_9.rs:6:78\n\
    \     |\n6    |     let scale_factor = 1.0 / (numbers.iter().max().unwrap() -\
    \ numbers.iter().min().unwrap());\n     |                                    \
    \                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp11wmac_9.rs:7:34\n\
    \     |\n7    |     let offset = -numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let (min, max) = (numbers.iter().min().unwrap(),\
    \ numbers.iter().max().unwrap());\n    let denom = max - min;\n    if denom ==\
    \ 0.0 {\n        // for the degenerate case of identical numbers\n        let\
    \ len = numbers.len();\n        let unit = 1.0 / (len as f64);\n        numbers.iter().map(|_|\
    \ unit).collect()\n    } else {\n        numbers.iter().map(|x| (x - min) / denom).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpc7ia2zv1.rs:7:38\n\
    \     |\n7    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                      ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpc7ia2zv1.rs:7:69\n\
    \     |\n7    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                                                     ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers[0];\n    let max_value = numbers[0];\n    let mut\
    \ res = Vec::new();\n\n    for value in numbers {\n        res.push(value);\n\
    \        if value < min_value {\n            min_value = value;\n        }\n \
    \       if value > max_value {\n            max_value = value;\n        }\n  \
    \  }\n\n    for value in res.iter_mut() {\n        *value = (*value - min_value)\
    \ / (max_value - min_value);\n    }\n\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min_value`\n \
    \ --> /tmp/tmp4advknax.rs:13:13\n   |\n6  |     let min_value = numbers[0];\n\
    \   |         ---------\n   |         |\n   |         first assignment to `min_value`\n\
    \   |         help: consider making this binding mutable: `mut min_value`\n...\n\
    13 |             min_value = value;\n   |             ^^^^^^^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `max_value`\n  --> /tmp/tmp4advknax.rs:16:13\n   |\n7  |     let max_value\
    \ = numbers[0];\n   |         ---------\n   |         |\n   |         first assignment\
    \ to `max_value`\n   |         help: consider making this binding mutable: `mut\
    \ max_value`\n...\n16 |             max_value = value;\n   |             ^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find the minimum and maximum values of the input\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // Apply the transformation\
    \ to each element of the input list\n    numbers.iter().map(|num| (num - min)\
    \ / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptvj2m8_q.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptvj2m8_q.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let scale = *max - *min;\n\
    \    if scale != 0.0 {\n        return numbers.iter().map(|n| (*n - *min) / scale).collect();\n\
    \    } else {\n        return numbers.iter().map(|n| 0.0).collect();\n    }\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyww262kp.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyww262kp.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    let (min, max) = (*min, *max);\n    if min == max {\n        numbers\n  \
    \  } else {\n        let range = max - min;\n        numbers.iter().map(|num|\
    \ (num - min) / range).collect()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkpkvl39s.rs:6:38\n\
    \     |\n6    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                      ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkpkvl39s.rs:6:69\n\
    \     |\n6    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                                                     ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // define some variables\n    let mut max = numbers[0];\n    let mut min\
    \ = numbers[0];\n    let mut result = Vec::new();\n\n    // find the min and max\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        if number < min {\n            min = number;\n        }\n\
    \    }\n\n    // calculate the rescaled list\n    for number in numbers {\n  \
    \      let scaled_value = (number - min) / (max - min);\n        result.push(scaled_value);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpicb2h8gd.rs:22:19\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n12  |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n22  |     for number in numbers {\n    |              \
    \     ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\nhelp: consider iterating over\
    \ a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n  \
    \  |\n12  |     for number in &numbers {\n    |                   +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // TODO: Fill in the body of this function.\n    let mut unit_vec = Vec::new();\n\
    \    let min_value = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    for item in numbers {\n        unit_vec.push((item - min_value) / (max_value\
    \ - min_value));\n    }\n    unit_vec\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu_hhnbug.rs:8:36\n\
    \     |\n8    |     let min_value = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu_hhnbug.rs:9:36\n\
    \     |\n9    |     let max_value = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().min().unwrap();\n    let maximum = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - minimum) / (maximum - minimum)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4z0uwme4.rs:6:34\n\
    \     |\n6    |     let minimum = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4z0uwme4.rs:7:34\n\
    \     |\n7    |     let maximum = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let lowest = numbers[0];\n    let highest = numbers[numbers.len() - 1];\n\
    \    numbers.iter().map(|x| (*x - lowest) / (highest - lowest)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpoq646l0n.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    let offset = -min;\n    numbers.iter().map(|&x|\
    \ (x + offset) / span).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqqliv6jb.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqqliv6jb.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let n = numbers.len();\n    let (min, max) = find_min_max(&numbers);\n  \
    \  let mut new_numbers = Vec::new();\n    for num in numbers {\n        new_numbers.push((num\
    \ - min) / (max - min));\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmpdxj03qqx.rs:7:22\n\
    \  |\n7 |     let (min, max) = find_min_max(&numbers);\n  |                  \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // let max_number = numbers.iter().max().unwrap();\n    // let min_number\
    \ = numbers.iter().min().unwrap();\n    // let max_number = numbers.into_iter().max().unwrap();\n\
    \    // let min_number = numbers.into_iter().min().unwrap();\n    let max_number\
    \ = numbers.into_iter().max().cloned().unwrap();\n    let min_number = numbers.into_iter().min().cloned().unwrap();\n\
    \    let scale = 1.0 / (max_number - min_number);\n    numbers.into_iter().map(|n|\
    \ scale * (n - min_number)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpon_qnd9d.rs:10:42\n\
    \     |\n10   |     let max_number = numbers.into_iter().max().cloned().unwrap();\n\
    \     |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0599]: `Option<f64>` is not an iterator\n   --> /tmp/tmpon_qnd9d.rs:10:48\n\
    \    |\n10  |       let max_number = numbers.into_iter().max().cloned().unwrap();\n\
    \    |                                                  ^^^^^^ `Option<f64>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<f64>: Iterator`\n            which is required by `&mut Option<f64>:\
    \ Iterator`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n   \
    \ --> /tmp/tmpon_qnd9d.rs:11:42\n     |\n11   |     let min_number = numbers.into_iter().min().cloned().unwrap();\n\
    \     |                                          ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0599]: `Option<f64>` is not an iterator\n   --> /tmp/tmpon_qnd9d.rs:11:48\n\
    \    |\n11  |       let min_number = numbers.into_iter().min().cloned().unwrap();\n\
    \    |                                                  ^^^^^^ `Option<f64>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<f64>: Iterator`\n            which is required by `&mut Option<f64>:\
    \ Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome errors have"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let max = numbers[numbers.len() - 1];\n    let min = numbers[0];\n    let\
    \ diff = max - min;\n    let rescaled: Vec<f64> = numbers.iter().map(|x| (*x -\
    \ min) / diff).collect();\n    rescaled\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpfl1tnvsh.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // compute the minimum and maximum of a list in a single pass\n    let (min,\
    \ max) = {\n        let mut it = numbers.iter();\n        let mut min = it.next().unwrap();\n\
    \        let mut max = min;\n        for num in it {\n            if *num < *min\
    \ {\n                min = num;\n            }\n            if *num > *max {\n\
    \                max = num;\n            }\n        }\n        (*min, *max)\n\
    \    };\n\n    let mut result = Vec::with_capacity(numbers.len());\n    for num\
    \ in numbers {\n        result.push((num - min) / (max - min));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = 1.0 / (max - min);\n    numbers.iter().map(|x| (x - min) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphuehbzpq.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmphuehbzpq.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Return the rescaled list, using range to get the max and min values\n\
    \    // (minus `&` to get the list elements as numbers, not references to them)\n\
    \    rescale(numbers, numbers.iter().min().unwrap() - &0.0, numbers.iter().max().unwrap()\
    \ - &0.0)\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rescale` in this scope\n --> /tmp/tmpkjl7vrhb.rs:8:5\n\
    \  |\n8 |     rescale(numbers, numbers.iter().min().unwrap() - &0.0, numbers.iter().max().unwrap()\
    \ - &0.0)\n  |     ^^^^^^^ not found in this scope\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkjl7vrhb.rs:8:37\n     |\n\
    8    |     rescale(numbers, numbers.iter().min().unwrap() - &0.0, numbers.iter().max().unwrap()\
    \ - &0.0)\n     |                                     ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n     |\n     = help: the following other types implement\
    \ trait `Ord`:\n               i128\n               i16\n               i32\n\
    \               i64\n               i8\n               isize\n               u128\n\
    \               u16\n             and 4 others\n     = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\nnote: required by a bound\
    \ in `std::iter::Iterator::min`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n    --> /tmp/tmpkjl7vrhb.rs:8:75\n     |\n8    |     rescale(numbers,\
    \ numbers.iter().min().unwrap() - &0.0, numbers.iter().max().unwrap() - &0.0)\n\
    \     |                                                                      \
    \     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the\
    \ following other types implement trait `Ord`:\n               i128\n        \
    \       i16\n               i32\n               i64\n               i8\n     \
    \          isize\n               u128\n               u16\n             and 4\
    \ others\n     = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Cannot rescale a list of less than\
    \ two numbers\")\n    }\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x - min) /\
    \ (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv80bk5sa.rs:9:30\n\
    \     |\n9    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv80bk5sa.rs:10:30\n\
    \     |\n10   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_max = min_max(&numbers);\n    let min = min_max.0;\n    let max =\
    \ min_max.1;\n    let len = numbers.len();\n    let mut rescaled = Vec::with_capacity(len);\n\
    \    for i in 0..len {\n        rescaled.push((numbers[i] - min) / (max - min));\n\
    \    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min_max` in this scope\n --> /tmp/tmpipk_ls0r.rs:6:19\n\
    \  |\n6 |     let min_max = min_max(&numbers);\n  |                   ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // find min and max\n    let min = numbers.iter().fold(f64::INFINITY, |a,\
    \ &b| a.min(b));\n    let max = numbers.iter().fold(f64::NEG_INFINITY, |a, &b|\
    \ a.max(b));\n\n    let range = max - min;\n\n    numbers.iter().map(|&x| (x -\
    \ min) / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let (min, max) = (numbers[0], numbers[numbers.len() - 1]);\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpfus5gx_2.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let numbers_min = numbers.iter().min().unwrap();\n    let numbers_max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| ((x - numbers_min) / (numbers_max - numbers_min))).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4c6rxhgm.rs:6:38\n\
    \     |\n6    |     let numbers_min = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp4c6rxhgm.rs:7:38\n\
    \     |\n7    |     let numbers_max = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let smallest = numbers.iter().fold(numbers[0], |a, &b| {\n        if a <\
    \ b {\n            a\n        } else {\n            b\n        }\n    });\n  \
    \  let largest = numbers.iter().fold(numbers[0], |a, &b| {\n        if a > b {\n\
    \            a\n        } else {\n            b\n        }\n    });\n    let delta\
    \ = largest - smallest;\n    numbers.iter().map(|&x| (x - smallest) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n    let max = *numbers.iter().max().unwrap();\n\
    \    let min = *numbers.iter().min().unwrap();\n    for n in numbers {\n     \
    \   result.push((n - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1hxqzjxm.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1hxqzjxm.rs:8:31\n\
    \     |\n8    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0,\
    \ f64::min);\n    let max_minus_min = max - min;\n    let result = numbers.iter().map(|x|\
    \ (x - min) / max_minus_min).collect();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmp16k21xaj.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_value = numbers.iter().cloned().fold(0.0, f64::max);\n    let min_value\
    \ = numbers.iter().cloned().fold(0.0, f64::min);\n    let scale = 1.0 / (max_value\
    \ - min_value);\n    numbers.iter().map(|v| (v - min_value) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 0.9999999999999999]`,\n right: `[0.0, 1.0]`', /tmp/tmpx827z1m7.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(0.0, f64::max);\n    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let range = max - min;\n    numbers.iter().map(|x| (x - min)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let scale = max - min;\n    let mut new_numbers = Vec::new();\n    for n\
    \ in numbers {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpl5ag7s0u.rs:6:30\n\
    \     |\n6    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpl5ag7s0u.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = min_max(numbers);\n    let delta = max - min;\n    return\
    \ numbers.iter().map(|n| ((n - min) / delta)).collect();\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min_max` in this scope\n --> /tmp/tmpvtavxvp9.rs:6:22\n\
    \  |\n6 |     let (min, max) = min_max(numbers);\n  |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled = numbers.clone();\n    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let scale = max - min;\n    for num in rescaled.iter_mut() {\n        *num\
    \ = (*num - min) / scale;\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // this will panic for empty lists, which is ok for now\n    let xmin = numbers.iter().min().unwrap();\n\
    \    let xmax = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x\
    \ - xmin) / (xmax - xmin)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2j99n6_q.rs:7:31\n\
    \     |\n7    |     let xmin = numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2j99n6_q.rs:8:31\n\
    \     |\n8    |     let xmax = numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = 1.0 / (max - min);\n    let offset = -min * scale;\n    numbers.iter().map(|x|\
    \ x * scale + offset).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpssse_oey.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpssse_oey.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo_32f5ah.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo_32f5ah.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let n = numbers.len();\n    let mut result = Vec::new();\n    for num in\
    \ numbers {\n        result.push((num - min) / (max - min));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp7hv_q4xu.rs:6:30\n\
    \     |\n6    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp7hv_q4xu.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpp2gmbkg5.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpp2gmbkg5.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    if (*min_number - *max_number).abs() < std::f64::EPSILON {\n        vec![0.0;\
    \ numbers.len()]\n    } else {\n        numbers\n            .iter()\n       \
    \     .map(|number| (*number - *min_number) / (*max_number - *min_number))\n \
    \           .collect()\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpealk_0jx.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpealk_0jx.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let sub = *min;\n    let div = *max - *min;\n    let scaled: Vec<f64> = numbers.iter().map(|&x|\
    \ (x - sub) / div).collect();\n    scaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpy_kpdawf.rs:6:30\n\
    \     |\n6    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpy_kpdawf.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let span = max_number - min_number;\n    numbers.iter().map(|n| (*n - min_number)\
    \ / span).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpidrzrm_6.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpidrzrm_6.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // find the minimum and maximum numbers\n    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n\n    // turn everything\
    \ into a 1-dimensional vector\n    let numbers_iter = numbers.iter();\n\n    //\
    \ create a new vector of all 0s\n    let mut rescaled = vec![0f64; numbers.len()];\n\
    \n    for (index, number) in numbers_iter.enumerate() {\n        // rescale every\
    \ number with:\n        // (value - min) / (max - min)\n        rescaled[index]\
    \ = (*number - min_number) / (max_number - min_number);\n    }\n\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpuq7506k5.rs:7:37\n\
    \     |\n7    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpuq7506k5.rs:8:37\n\
    \     |\n8    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = {\n        let mut min = numbers[0];\n        let mut max\
    \ = numbers[0];\n        for number in numbers.iter() {\n            if *number\
    \ < min {\n                min = *number;\n            }\n            if *number\
    \ > max {\n                max = *number;\n            }\n        }\n        (min,\
    \ max)\n    };\n    let range = max - min;\n    let mut rescaled_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers.iter() {\n        let rescaled_number = (*number -\
    \ min) / range;\n        rescaled_numbers.push(rescaled_number);\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers_unit = numbers.clone();\n    let mut minimum: f64 = numbers[0];\n\
    \    let mut maximum: f64 = numbers[0];\n    for number in numbers {\n       \
    \ if number < minimum {\n            minimum = number;\n        }\n        if\
    \ number > maximum {\n            maximum = number;\n        }\n    }\n    let\
    \ scale = 1.0 / (maximum - minimum);\n    for i in 0..numbers.len() {\n      \
    \  numbers_unit[i] = (numbers[i] - minimum) * scale;\n    }\n    numbers_unit\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmp2ctq23da.rs:18:17\n\
    \    |\n5   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n9   |     for number in numbers {\n\
    \    |                   ------- `numbers` moved due to this implicit call to\
    \ `.into_iter()`\n...\n18  |     for i in 0..numbers.len() {\n    |          \
    \       ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider\
    \ iterating over a slice of the `Vec<f64>`'s content to avoid moving into the\
    \ `for` loop\n    |\n9   |     for number in &numbers {\n    |               \
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = numbers.clone();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let delta = max - min;\n  \
    \  for num in &mut result {\n        *num = (num - min) / delta;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5x2saxmi.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5x2saxmi.rs:8:30\n\
    \     |\n8    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0369]: cannot subtract `&f64` from `&mut f64`\n  --> /tmp/tmp5x2saxmi.rs:11:21\n\
    \   |\n11 |         *num = (num - min) / delta;\n   |                 --- ^ ---\
    \ &f64\n   |                 |\n   |                 &mut f64\n   |\nhelp: `-`\
    \ can be used on `f64`, you can dereference `num`\n   |\n11 |         *num = (*num\
    \ - min) / delta;\n   |                 +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpmnkf7a9g.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpmnkf7a9g.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    numbers.iter().map(|i|\
    \ (i - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp66_6wpez.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let numbers = numbers.iter().map(|n| (n - min) / (max - min)).collect();\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpid_jgko7.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpid_jgko7.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut transformed_list = numbers.clone();\n    let max = transformed_list.iter().max().unwrap();\n\
    \    let min = transformed_list.iter().min().unwrap();\n    for i in 0..transformed_list.len()\
    \ {\n        transformed_list[i] = (transformed_list[i] - min) / (max - min);\n\
    \    }\n    transformed_list\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppcwpi_j4.rs:7:39\n\
    \     |\n7    |     let max = transformed_list.iter().max().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmppcwpi_j4.rs:8:39\n\
    \     |\n8    |     let min = transformed_list.iter().min().unwrap();\n     |\
    \                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvhlmnz9v.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpvhlmnz9v.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_val = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n  \
    \  let max_val = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let scale = max_val - min_val;\n    let offset = min_val;\n    numbers.iter().map(|&n|\
    \ (n - offset) / scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"too few numbers: {:?}\", numbers);\n\
    \    }\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  println!(\"min {} max {}\", min, max);\n    numbers.iter().map(|&value| value\
    \ / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: "min 2 max 49.9\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04175365344467641, 1.0417536534446765]`,\n right: `[0.0, 1.0]`', /tmp/tmp6ccz3dju.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (minimum, maximum) = find_extremes(&numbers);\n    let range = maximum\
    \ - minimum;\n    let scaled_numbers = numbers.iter().map(|value| (value - minimum)\
    \ / range).collect();\n    scaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_extremes` in this scope\n -->\
    \ /tmp/tmppgbhez_y.rs:6:30\n  |\n6 |     let (minimum, maximum) = find_extremes(&numbers);\n\
    \  |                              ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = *numbers.iter().min().unwrap();\n    let max_number = *numbers.iter().max().unwrap();\n\
    \    let distance = max_number - min_number;\n    numbers.iter().map(|number|\
    \ {\n        if distance == 0.0 {\n            0.0\n        } else {\n       \
    \     (number - min_number) / distance\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr901y6ff.rs:6:38\n\
    \     |\n6    |     let min_number = *numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpr901y6ff.rs:7:38\n\
    \     |\n7    |     let max_number = *numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let n = numbers.len();\n    if n < 2 {\n        panic!(\"At least two elements\
    \ are needed to rescale.\");\n    }\n    let mut result = vec![0.0; n];\n    //\
    \ find the minimum and maximum values in the given list of numbers\n    let min_number\
    \ = numbers[0];\n    let max_number = numbers[0];\n    for i in 1..n {\n     \
    \   if numbers[i] < min_number {\n            min_number = numbers[i];\n     \
    \   }\n        if numbers[i] > max_number {\n            max_number = numbers[i];\n\
    \        }\n    }\n    // the linear transform\n    let a = 1.0 / (max_number\
    \ - min_number);\n    let b = -min_number * a;\n    for i in 0..n {\n        result[i]\
    \ = a * numbers[i] + b;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `min_number`\n\
    \  --> /tmp/tmppeuxe9df.rs:16:13\n   |\n12 |     let min_number = numbers[0];\n\
    \   |         ----------\n   |         |\n   |         first assignment to `min_number`\n\
    \   |         help: consider making this binding mutable: `mut min_number`\n...\n\
    16 |             min_number = numbers[i];\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice\
    \ to immutable variable `max_number`\n  --> /tmp/tmppeuxe9df.rs:19:13\n   |\n\
    13 |     let max_number = numbers[0];\n   |         ----------\n   |         |\n\
    \   |         first assignment to `max_number`\n   |         help: consider making\
    \ this binding mutable: `mut max_number`\n...\n19 |             max_number = numbers[i];\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    //\
    \ println!(\"{:?}\", numbers);\n    numbers.iter().map(|x| {\n        let x =\
    \ x - min;\n        let x = x / (max - min);\n        // println!(\"{}\", x);\n\
    \        x\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmppxrake3h.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min_max_diff = max - min;\n    numbers.iter().map(|x| (x - min) / min_max_diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprljlqrnz.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmprljlqrnz.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for n in numbers.iter() {\n        if *n < min {\n      \
    \      min = *n;\n        }\n        if *n > max {\n            max = *n;\n  \
    \      }\n    }\n    for n in numbers.iter_mut() {\n        *n = (*n - min) /\
    \ (max - min);\n    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwo2h9g9_.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpwo2h9g9_.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_value) / (max_value - min_value)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdyc6catl.rs:6:36\n\
    \     |\n6    |     let min_value = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdyc6catl.rs:7:36\n\
    \     |\n7    |     let max_value = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // There was an attempt to implement this as an iterator but that\n    //\
    \ was too hard for me (see the commented out code below)\n\n    // let min = numbers.iter().min();\n\
    \    // let max = numbers.iter().max();\n    // numbers.iter().map(|&x| rescale(x,\
    \ min, max)).collect()\n\n    let mut out = Vec::with_capacity(numbers.len());\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    for n in numbers {\n        out.push(rescale(n, min, max));\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rescale` in this scope\n  --> /tmp/tmpf32w0fsz.rs:17:18\n\
    \   |\n17 |         out.push(rescale(n, min, max));\n   |                  ^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \    --> /tmp/tmpf32w0fsz.rs:14:30\n     |\n14   |     let min = numbers.iter().min().unwrap();\n\
    \     |                              ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpf32w0fsz.rs:15:30\n\
    \     |\n15   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    return numbers.iter().map(|x| (x - min) / (max - min)).collect();\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1oo1adji.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp1oo1adji.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (mut min, mut max) = (numbers[0], numbers[0]);\n    for number in numbers.iter()\
    \ {\n        if *number < min {\n            min = *number;\n        }\n     \
    \   if *number > max {\n            max = *number;\n        }\n    }\n    let\
    \ interval = max - min;\n    return numbers.iter().map(|number| (*number - min)\
    \ / interval).collect();\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let denominator = max - min;\n    numbers.iter().map(|x| (x - min) / denominator).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpptbl_qtn.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpptbl_qtn.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut result = Vec::new();\n    if numbers.len() < 2 {\n        return\
    \ result;\n    }\n    let x_min = numbers.iter().min().unwrap();\n    let x_max\
    \ = numbers.iter().max().unwrap();\n    let a = 1.0 / (x_max - x_min);\n    let\
    \ b = -a * x_min;\n    for x in numbers {\n        result.push(a * x + b);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_ori_ndn.rs:10:32\n\
    \     |\n10   |     let x_min = numbers.iter().min().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_ori_ndn.rs:11:32\n\
    \     |\n11   |     let x_max = numbers.iter().max().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let scale = 1.0 /\
    \ (max - min);\n    numbers.iter().map(|&x| (x - min) * scale).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let mut numbers = numbers;\n    numbers.iter_mut().for_each(|n| *n = (*n\
    \ - min) / (max - min));\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp37gb3je4.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp37gb3je4.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_value = numbers\n        .iter()\n        .min_by(|x, y| x.partial_cmp(y).unwrap())\n\
    \        .unwrap();\n    let max_value = numbers\n        .iter()\n        .max_by(|x,\
    \ y| x.partial_cmp(y).unwrap())\n        .unwrap();\n    numbers\n        .iter()\n\
    \        .map(|n| (n - min_value) / (max_value - min_value))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // TODO: It might be better to use an iterator here\n    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        let new_number = rescale_to_unit_single(number,\
    \ min, max);\n        new_numbers.push(new_number);\n    }\n    new_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rescale_to_unit_single` in this scope\n\
    \  --> /tmp/tmp__ui68z7.rs:11:26\n   |\n11 |         let new_number = rescale_to_unit_single(number,\
    \ min, max);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n  \
    \  --> /tmp/tmp__ui68z7.rs:7:31\n     |\n7    |     let min = *numbers.iter().min().unwrap();\n\
    \     |                               ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp__ui68z7.rs:8:31\n\
    \     |\n8    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let\
    \ diff = max - min;\n    if diff > 0.0 {\n        numbers.iter().map(|n| (n -\
    \ min) / diff).collect()\n    } else {\n        numbers\n    }\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp2vkvcy6l.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // Find the minimum and maximum of the vector so we know by how much to shift\n\
    \    let mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n    for number\
    \ in numbers.iter() {\n        if *number < min {\n            min = *number;\n\
    \        }\n        if *number > max {\n            max = *number;\n        }\n\
    \    }\n    // Rescale the values\n    let scaled_numbers: Vec<f64> = numbers\n\
    \        .iter()\n        .map(|number| (number - min) / (max - min))\n      \
    \  .collect();\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut result = Vec::new();\n    for num in numbers {\n        result.push((num\
    \ - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu3n2ei8b.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpu3n2ei8b.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|num| (num\
    \ - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo3efzprr.rs:7:30\n\
    \     |\n7    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo3efzprr.rs:8:30\n\
    \     |\n8    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut smallest = numbers[0];\n    let mut largest = numbers[0];\n    for\
    \ &n in numbers.iter() {\n        if n < smallest {\n            smallest = n;\n\
    \        }\n        if n > largest {\n            largest = n;\n        }\n  \
    \  }\n    let range = largest - smallest;\n    numbers.iter().map(|&x| (x - smallest)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_number = *numbers.iter().max().unwrap();\n    let min_number = *numbers.iter().min().unwrap();\n\
    \    let rescaled = numbers.iter().map(|number| {\n        if max_number != min_number\
    \ {\n            (number - min_number) / (max_number - min_number)\n        }\
    \ else {\n            number.clone()\n        }\n    }).collect();\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_4l2wmy1.rs:6:38\n\
    \     |\n6    |     let max_number = *numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_4l2wmy1.rs:7:38\n\
    \     |\n7    |     let min_number = *numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let range\
    \ = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    let min_max_diff = largest\
    \ - smallest;\n    let diff_one = 1.0 - 0.0;\n    numbers.iter().map(|number|\
    \ {\n        (number - smallest) * (diff_one / min_max_diff)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkf5_dm74.rs:7:35\n\
    \     |\n7    |     let smallest = numbers.iter().min().unwrap();\n     |    \
    \                               ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkf5_dm74.rs:8:34\n\
    \     |\n8    |     let largest = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_wqe26os.rs:6:38\n\
    \     |\n6    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                      ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp_wqe26os.rs:6:69\n\
    \     |\n6    |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \     |                                                                     ^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let sorted = numbers.iter().sorted_by(|a, b| a.partial_cmp(b).unwrap()).collect::<Vec<&f64>>();\n\
    \    let min = *sorted[0];\n    let max = *sorted[sorted.len() - 1];\n    let\
    \ scale = 1.0 / (max - min);\n    numbers.iter().map(|x| (x - min) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmpywrwhydc.rs:6:33\n  |\n6 |     let sorted\
    \ = numbers.iter().sorted_by(|a, b| a.partial_cmp(b).unwrap()).collect::<Vec<&f64>>();\n\
    \  |                                 ^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ f64>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().fold(numbers[0], |acc, x| acc.min(*x));\n  \
    \  let maximum = numbers.iter().fold(numbers[0], |acc, x| acc.max(*x));\n    let\
    \ range = maximum - minimum;\n    numbers.iter().map(|x| (x - minimum) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let diff\
    \ = max - min;\n    numbers.iter().map(|x| (x - min) / diff).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_val = numbers.iter().min().unwrap();\n    let max_val = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_val) / (max_val - min_val)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpshd6lvwd.rs:6:34\n\
    \     |\n6    |     let min_val = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpshd6lvwd.rs:7:34\n\
    \     |\n7    |     let max_val = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / range).collect()\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max_number = *numbers.iter().max().unwrap();\n    let min_number = *numbers.iter().min().unwrap();\n\
    \    let range = max_number - min_number;\n    let to_unit_scale = 1.0 / range;\n\
    \    numbers.iter().map(|x| (x - min_number) * to_unit_scale).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo_tzztaf.rs:6:38\n\
    \     |\n6    |     let max_number = *numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo_tzztaf.rs:7:38\n\
    \     |\n7    |     let min_number = *numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut out = numbers.clone();\n    let min_n = out.iter().min().unwrap();\n\
    \    let max_n = out.iter().max().unwrap();\n    for o in out.iter_mut() {\n \
    \       *o = (*o - min_n) / (max_n - min_n);\n    }\n    out\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0okx1b9_.rs:7:28\n\
    \     |\n7    |     let min_n = out.iter().min().unwrap();\n     |           \
    \                 ^^^ the trait `Ord` is not implemented for `f64`\n     |\n \
    \    = help: the following other types implement trait `Ord`:\n              \
    \ i128\n               i16\n               i32\n               i64\n         \
    \      i8\n               isize\n               u128\n               u16\n   \
    \          and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0okx1b9_.rs:8:28\n\
    \     |\n8    |     let max_n = out.iter().max().unwrap();\n     |           \
    \                 ^^^ the trait `Ord` is not implemented for `f64`\n     |\n \
    \    = help: the following other types implement trait `Ord`:\n              \
    \ i128\n               i16\n               i32\n               i64\n         \
    \      i8\n               isize\n               u128\n               u16\n   \
    \          and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let\
    \ range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpldy99rnd.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / range).collect()\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Empty list of numbers!\");\n   \
    \ }\n    let min_number = numbers.iter().min().unwrap();\n    let max_number =\
    \ numbers.iter().max().unwrap();\n    let range = max_number - min_number;\n \
    \   numbers.iter().map(|n| (n - min_number) / range).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv404d5y_.rs:9:37\n\
    \     |\n9    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpv404d5y_.rs:10:37\n\
    \     |\n10   |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut rescaled = Vec::new();\n    let\
    \ min = sorted_numbers[0];\n    let max = sorted_numbers[sorted_numbers.len()\
    \ - 1];\n    for number in numbers {\n        rescaled.push((number - min) / (max\
    \ - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"A list of numbers must have at least\
    \ two elements\");\n    }\n    let min_value = numbers.iter().min().unwrap();\n\
    \    let max_value = numbers.iter().max().unwrap();\n    let offset = min_value.clone();\n\
    \    let scaling_factor = (max_value - min_value).recip();\n    numbers.iter().map(|value|\
    \ (value - offset) * scaling_factor).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsbzanff1.rs:9:36\n\
    \     |\n9    |     let min_value = numbers.iter().min().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpsbzanff1.rs:10:36\n\
    \     |\n10   |     let max_value = numbers.iter().max().unwrap();\n     |   \
    \                                 ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_val = numbers.iter().min().unwrap();\n    let max_val = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min_val) / (max_val - min_val)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpi1des_j5.rs:6:34\n\
    \     |\n6    |     let min_val = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpi1des_j5.rs:7:34\n\
    \     |\n7    |     let max_val = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Cannot rescale list of length <\
    \ 2\")\n    }\n    let mut result = numbers.clone();\n    let min = result.iter().min().unwrap();\n\
    \    let max = result.iter().max().unwrap();\n    for x in result.iter_mut() {\n\
    \        *x = (*x - min) / (max - min);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzmcgwire.rs:10:29\n\
    \     |\n10   |     let min = result.iter().min().unwrap();\n     |          \
    \                   ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpzmcgwire.rs:11:29\n\
    \     |\n11   |     let max = result.iter().max().unwrap();\n     |          \
    \                   ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpe8tnfyy4.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpe8tnfyy4.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_element = numbers.iter().min().unwrap();\n    let max_element = numbers.iter().max().unwrap();\n\
    \    let difference = max_element - min_element;\n    numbers.iter().map(|&x|\
    \ (x - min_element) / difference).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2y_1b3cz.rs:6:38\n\
    \     |\n6    |     let min_element = numbers.iter().min().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2y_1b3cz.rs:7:38\n\
    \     |\n7    |     let max_element = numbers.iter().max().unwrap();\n     | \
    \                                     ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = find_min_max(&numbers);\n    if min == max {\n        vec![0.0;\
    \ numbers.len()]\n    } else {\n        numbers.iter().map(|number| (number -\
    \ min) / (max - min)).collect()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmp10n1a7jh.rs:6:22\n\
    \  |\n6 |     let (min, max) = find_min_max(&numbers);\n  |                  \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = find_min_max(&numbers);\n    let denominator = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / denominator).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmpgk3il9eh.rs:6:22\n\
    \  |\n6 |     let (min, max) = find_min_max(&numbers);\n  |                  \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // find the minimum and maximum in the vector\n    let mut numbers = numbers;\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\n    //\
    \ calculate the transformation constants\n    let delta = max - min;\n    let\
    \ offset = min;\n\n    // apply the transform\n    numbers.iter_mut().for_each(|n|\
    \ *n = (*n - offset) / delta);\n\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let diff\
    \ = max - min;\n    numbers.iter().map(|n| (*n - min) / diff).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph57qm2wl.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmph57qm2wl.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8_xwxvwv.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp8_xwxvwv.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().fold(1.0e100, |a, &b| a.min(b));\n    let maximum\
    \ = numbers.iter().fold(-1.0e100, |a, &b| a.max(b));\n    let range = maximum\
    \ - minimum;\n    numbers.iter().map(|n| (n - minimum) / range).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `min` on ambiguous numeric type `{float}`\n\
    \ --> /tmp/tmp9hp_umxj.rs:6:58\n  |\n6 |     let minimum = numbers.iter().fold(1.0e100,\
    \ |a, &b| a.min(b));\n  |                                                 -  \
    \      ^^^\n  |                                                 |\n  |       \
    \                                          you must specify a type for this binding,\
    \ like `f32`\n\nerror[E0689]: can't call method `max` on ambiguous numeric type\
    \ `{float}`\n --> /tmp/tmp9hp_umxj.rs:7:59\n  |\n7 |     let maximum = numbers.iter().fold(-1.0e100,\
    \ |a, &b| a.max(b));\n  |                                                  - \
    \       ^^^\n  |                                                  |\n  |     \
    \                                             you must specify a type for this\
    \ binding, like `f32`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let mut rescaled = Vec::new();\n    for number\
    \ in numbers {\n        let rescaled_value = (number - min) / range;\n       \
    \ rescaled.push(rescaled_value);\n    }\n    rescaled\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo3t8tsh3.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo3t8tsh3.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_n = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max_n\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    // In the formula below,\
    \ I'm guessing the inputs x and y should be normalized to 0..1 range\n    let\
    \ normalize = |x: f64| (x - min_n) / (max_n - min_n);\n    numbers.iter().map(normalize).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n   --> /tmp/tmpzx6lt_8p.rs:10:24\n\
    \    |\n9   |     let normalize = |x: f64| (x - min_n) / (max_n - min_n);\n  \
    \  |                     -------------------------------------- found signature\
    \ of `fn(f64) -> _`\n10  |     numbers.iter().map(normalize).collect()\n    |\
    \                    --- ^^^^^^^^^ expected signature of `fn(&f64) -> _`\n   \
    \ |                    |\n    |                    required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `map`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmpzx6lt_8p.rs:9:21:\
    \ 9:59]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpzx6lt_8p.rs:10:35\n\
    \   |\n9  |       let normalize = |x: f64| (x - min_n) / (max_n - min_n);\n  \
    \ |                       --------------------------------------\n   |       \
    \                |\n   |                       doesn't satisfy `<_ as FnOnce<(&f64,)>>::Output\
    \ = _`\n   |                       doesn't satisfy `_: FnMut<(&f64,)>`\n10 | \
    \      numbers.iter().map(normalize).collect()\n   |                         \
    \            ^^^^^^^ method cannot be called on `Map<std::slice::Iter<'_, f64>,\
    \ [closure@/tmp/tmpzx6lt_8p.rs:9:21: 9:59]>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<[closure@/tmp/tmpzx6lt_8p.rs:9:21:\
    \ 9:59] as FnOnce<(&f64,)>>::Output = _`\n           which is required by `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmpzx6lt_8p.rs:9:21: 9:59]>: Iterator`\n           `[closure@/tmp/tmpzx6lt_8p.rs:9:21:\
    \ 9:59]: FnMut<(&f64,)>`\n           which is required by `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmpzx6lt_8p.rs:9:21: 9:59]>: Iterator`\n           `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmpzx6lt_8p.rs:9:21: 9:59]>: Iterator`\n           which\
    \ is required by `&mut Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmpzx6lt_8p.rs:9:21:\
    \ 9:59]>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0631.\nFor more informa"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let minimum = numbers.iter().fold(std::f64::MAX, |acc, x| if x < &acc { *x\
    \ } else { acc });\n    let maximum = numbers.iter().fold(std::f64::MIN, |acc,\
    \ x| if x > &acc { *x } else { acc });\n    numbers.iter().map(|x| (x - minimum)\
    \ / (maximum - minimum)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp90f7uvcc.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp90f7uvcc.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    let is_delta_zero = delta == 0.0;\n    numbers.iter().map(|x|\
    \ if is_delta_zero {\n        0.0\n    } else {\n        (x - min) / delta\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n   \
    \ assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2fdf0qyj.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2fdf0qyj.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|number| number.clone() / (max - min)).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9a1m9y1j.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9a1m9y1j.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    numbers.iter().map(|num|\
    \ (num - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp6w0cr3i9.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if min == max {\n        vec![0.0; numbers.len()]\n    } else {\n       \
    \ numbers.iter().map(|x| (x - min) / (max - min)).collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpikh7oy57.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpikh7oy57.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let delta = numbers.iter().max().unwrap() - numbers.iter().min().unwrap();\n\
    \    numbers.iter().map(|num| (num - numbers.iter().min().unwrap()) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpb8uac9qm.rs:6:32\n\
    \     |\n6    |     let delta = numbers.iter().max().unwrap() - numbers.iter().min().unwrap();\n\
    \     |                                ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpb8uac9qm.rs:6:64\n\
    \     |\n6    |     let delta = numbers.iter().max().unwrap() - numbers.iter().min().unwrap();\n\
    \     |                                                                ^^^ the\
    \ trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\n     = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\nnote:\
    \ required by a bound in `std::iter::Iterator::min`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n    --> /tmp/tmpb8uac9qm.rs:7:52\n     |\n\
    7    |     numbers.iter().map(|num| (num - numbers.iter().min().unwrap()) / delta).collect()\n\
    \     |                                                    ^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\n     = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\nnote: required\
    \ by a bound in `std::iter::Iterator::min`\n\nerror: ab"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = (numbers.iter().cloned().min().unwrap(), numbers.iter().cloned().max().unwrap());\n\
    \    let denom = max - min;\n    if denom != 0.0 {\n        return numbers.iter().map(|x|\
    \ (x - min) / denom).collect();\n    }\n    numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqe1k6qto.rs:6:47\n\
    \     |\n6    |     let (min, max) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n     |                           \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqe1k6qto.rs:6:87\n\
    \     |\n6    |     let (min, max) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n     |                           \
    \                                                            ^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if max == min {\n        return numbers;\n    }\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2kalbh8t.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp2kalbh8t.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut ret: Vec<f64> = Vec::new();\n    let min_value = numbers.iter().fold(std::f64::MAX,\
    \ |m, i| m.min(*i));\n    let max_value = numbers.iter().fold(std::f64::MIN, |m,\
    \ i| m.max(*i));\n    for n in numbers {\n        ret.push((n - min_value) / (max_value\
    \ - min_value));\n    }\n    ret\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0xr3_0gy.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp0xr3_0gy.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(std::f64::NEG_INFINITY, f64::max);\n\
    \    let min = numbers.iter().cloned().fold(std::f64::INFINITY, f64::min);\n \
    \   let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgzdus_y3.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgzdus_y3.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|num| (num - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyllvxvnj.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyllvxvnj.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    //unimplemented!()\n    let (nmin, nmax) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n    let (nmin, nmax) = (nmin as f64,\
    \ nmax as f64);\n    numbers.iter().map(|&x| (x - nmin) / (nmax - nmin)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbzhrfbm0.rs:7:49\n\
    \     |\n7    |     let (nmin, nmax) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n     |                           \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n    \
    \ |\n     = help: the following other types implement trait `Ord`:\n         \
    \      i128\n               i16\n               i32\n               i64\n    \
    \           i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbzhrfbm0.rs:7:89\n\
    \     |\n7    |     let (nmin, nmax) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n     |                           \
    \                                                              ^^^ the trait `Ord`\
    \ is not implemented for `f64`\n     |\n     = help: the following other types\
    \ implement trait `Ord`:\n               i128\n               i16\n          \
    \     i32\n               i64\n               i8\n               isize\n     \
    \          u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `std::iter::Iterator::max`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let number_range = max_number - min_number;\n    numbers.iter().map(|x| (x\
    \ - min_number) / number_range).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp57xium5c.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp57xium5c.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut rescaled = numbers;\n    for i in 0..rescaled.len() {\n        rescaled[i]\
    \ = rescaled[i] - min;\n        rescaled[i] = rescaled[i] / (max - min);\n   \
    \ }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpt3ffgqro.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpt3ffgqro.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let max_ = *numbers.iter().max().unwrap();\n\
    \    let min_ = *numbers.iter().min().unwrap();\n    numbers.iter().map(|number|\
    \ (number - min_) / (max_ - min_)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9vshke82.rs:7:32\n\
    \     |\n7    |     let max_ = *numbers.iter().max().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp9vshke82.rs:8:32\n\
    \     |\n8    |     let min_ = *numbers.iter().min().unwrap();\n     |       \
    \                         ^^^ the trait `Ord` is not implemented for `f64`\n \
    \    |\n     = help: the following other types implement trait `Ord`:\n      \
    \         i128\n               i16\n               i32\n               i64\n \
    \              i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let diff\
    \ = max - min;\n    if diff > 0.0 {\n        numbers.iter().map(|x| (x - min)\
    \ / diff).collect()\n    } else {\n        numbers\n    }\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let (a, b) = (numbers[0], numbers[numbers.len() - 1]);\n    numbers.iter().map(|number|\
    \ (number - a) / (b - a)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp71xk5x9c.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() < 2 {\n        panic!(\"Cannot rescale to unit a list with\
    \ less than 2 elements\");\n    }\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let norm_diff = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / norm_diff).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdt86tkb0.rs:9:30\n\
    \     |\n9    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpdt86tkb0.rs:10:30\n\
    \     |\n10   |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpowkboq1s.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpowkboq1s.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (x - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp43_q__ut.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp43_q__ut.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    if delta == 0.0 {\n        vec![0.0; numbers.len()]\n\
    \    } else {\n        numbers.iter().map(|&x| (x - min) / delta).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp50l6yj9f.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp50l6yj9f.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled_numbers = numbers.clone();\n    if let Some(min) = rescaled_numbers.iter().min()\
    \ {\n        rescaled_numbers = rescaled_numbers.iter().map(|x| x - min).collect();\n\
    \    }\n    if let Some(max) = rescaled_numbers.iter().max() {\n        rescaled_numbers\
    \ = rescaled_numbers.iter().map(|x| x / max).collect();\n    }\n    rescaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpghdowi9k.rs:7:48\n\
    \     |\n7    |     if let Some(min) = rescaled_numbers.iter().min() {\n     |\
    \                                                ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpghdowi9k.rs:10:48\n\
    \     |\n10   |     if let Some(max) = rescaled_numbers.iter().max() {\n     |\
    \                                                ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let range\
    \ = max - min;\n    numbers.iter().map(|n| (n - min) / range).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|number| (number - min) /\
    \ range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpn3a76ujn.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpn3a76ujn.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0,\
    \ f64::min);\n    let diff = max - min;\n    numbers.iter().map(|n| (n - min)\
    \ / diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.04008016032064128, 1.0]`,\n right: `[0.0, 1.0]`', /tmp/tmpvjq942kq.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let rescaled = numbers.iter().map(|x| (x - min)\
    \ / range).collect();\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgl8pan5k.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpgl8pan5k.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_num = numbers.iter().cloned().fold(numbers[0], f64::min);\n    let\
    \ max_num = numbers.iter().cloned().fold(numbers[0], f64::max);\n    numbers.iter().map(|x|\
    \ {\n        let num = x - min_num;\n        let denom = max_num - min_num;\n\
    \        num / denom\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    assert!(numbers.len() >= 2);\n    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    assert!(min < max);\n    let scale = 1.0 / (max - min);\n    numbers.iter().map(|x|\
    \ (x - min) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled = numbers.clone();\n    let min = rescaled.iter().min().unwrap();\n\
    \    let max = rescaled.iter().max().unwrap();\n    rescaled.iter_mut().for_each(|n|\
    \ *n = (*n - min) / (max - min));\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyp7nwgvb.rs:7:31\n\
    \     |\n7    |     let min = rescaled.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpyp7nwgvb.rs:8:31\n\
    \     |\n8    |     let max = rescaled.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut scaled_numbers = Vec::with_capacity(numbers.len());\n    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    for number in numbers {\n        let scaled_number = (number - min_number)\
    \ / (max_number - min_number);\n        scaled_numbers.push(scaled_number);\n\
    \    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpb91trjp8.rs:7:37\n\
    \     |\n7    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpb91trjp8.rs:8:37\n\
    \     |\n8    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let maximum = numbers.iter().max().unwrap();\n    let minimum = numbers.iter().min().unwrap();\n\
    \    let range = maximum - minimum;\n    numbers.iter().map(|&x| (x - minimum)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpylcbz7fk.rs:6:34\n\
    \     |\n6    |     let maximum = numbers.iter().max().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpylcbz7fk.rs:7:34\n\
    \     |\n7    |     let minimum = numbers.iter().min().unwrap();\n     |     \
    \                             ^^^ the trait `Ord` is not implemented for `f64`\n\
    \     |\n     = help: the following other types implement trait `Ord`:\n     \
    \          i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    //calculate the minimum and maximum\n    let (max, min) = numbers.iter().fold((std::f64::NEG_INFINITY,\
    \ std::f64::INFINITY), |(max, min), x| (x.max(max), x.min(min)));\n    //get the\
    \ scale factor\n    let scale = 1.0 / (max - min);\n    //rescale the data\n \
    \   numbers.iter().map(|x| (x - min) * scale).collect()\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let mut rescaled = numbers.clone();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let range = *max - *min;\n\
    \    for i in 0..rescaled.len() {\n        rescaled[i] = (rescaled[i] - *min)\
    \ / range;\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5nf214yl.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5nf214yl.rs:8:30\n\
    \     |\n8    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        result.push((number - min) / range);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkhva56ay.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpkhva56ay.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let range\
    \ = max - min;\n    let convert = |v: f64| (v - min) / range;\n    numbers.iter().map(convert).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n   --> /tmp/tmp59xp19qx.rs:10:24\n\
    \    |\n9   |     let convert = |v: f64| (v - min) / range;\n    |           \
    \        -------------------------- found signature of `fn(f64) -> _`\n10  | \
    \    numbers.iter().map(convert).collect()\n    |                    --- ^^^^^^^\
    \ expected signature of `fn(&f64) -> _`\n    |                    |\n    |   \
    \                 required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `map`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmp59xp19qx.rs:9:19: 9:45]>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp59xp19qx.rs:10:33\n \
    \  |\n9  |       let convert = |v: f64| (v - min) / range;\n   |             \
    \        --------------------------\n   |                     |\n   |        \
    \             doesn't satisfy `<_ as FnOnce<(&f64,)>>::Output = _`\n   |     \
    \                doesn't satisfy `_: FnMut<(&f64,)>`\n10 |       numbers.iter().map(convert).collect()\n\
    \   |                                   ^^^^^^^ method cannot be called on `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmp59xp19qx.rs:9:19: 9:45]>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<[closure@/tmp/tmp59xp19qx.rs:9:19:\
    \ 9:45] as FnOnce<(&f64,)>>::Output = _`\n           which is required by `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmp59xp19qx.rs:9:19: 9:45]>: Iterator`\n           `[closure@/tmp/tmp59xp19qx.rs:9:19:\
    \ 9:45]: FnMut<(&f64,)>`\n           which is required by `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmp59xp19qx.rs:9:19: 9:45]>: Iterator`\n           `Map<std::slice::Iter<'_,\
    \ f64>, [closure@/tmp/tmp59xp19qx.rs:9:19: 9:45]>: Iterator`\n           which\
    \ is required by `&mut Map<std::slice::Iter<'_, f64>, [closure@/tmp/tmp59xp19qx.rs:9:19:\
    \ 9:45]>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0631.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let numbers = numbers.iter().map(|x| (x - min) / (max - min)).collect();\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpafme7ajy.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpafme7ajy.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    if numbers.len() == 0 {\n        return numbers;\n    }\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let diff = max - min;\n   \
    \ if diff == 0.0 {\n        return numbers;\n    }\n    numbers.iter().map(|x|\
    \ (x - min) / diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjw51k7gt.rs:9:30\n\
    \     |\n9    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjw51k7gt.rs:10:30\n\
    \     |\n10   |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let max = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    let range = max -\
    \ min;\n    let scale = 1.0 / range;\n    numbers.iter().map(|x| (x - min) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    numbers.iter().map(|x| (x - min) / span).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo___08kw.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpo___08kw.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|n| (n - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptyn0q8t1.rs:6:31\n\
    \     |\n6    |     let min = *numbers.iter().min().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmptyn0q8t1.rs:7:31\n\
    \     |\n7    |     let max = *numbers.iter().max().unwrap();\n     |        \
    \                       ^^^ the trait `Ord` is not implemented for `f64`\n   \
    \  |\n     = help: the following other types implement trait `Ord`:\n        \
    \       i128\n               i16\n               i32\n               i64\n   \
    \            i8\n               isize\n               u128\n               u16\n\
    \             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = (max - min) / 1.0;\n    let mut rescaled = vec![];\n    for &number\
    \ in numbers.iter() {\n        rescaled.push((number - min) / scale);\n    }\n\
    \    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqkxbmgsn.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpqkxbmgsn.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let (min, max) = numbers.iter().cloned().fold((numbers[0], numbers[0]), |(min,\
    \ max), x| {\n        (\n            if x < min { x } else { min },\n        \
    \    if x > max { x } else { max },\n        )\n    });\n    let (min, max) =\
    \ (min as f64, max as f64);\n    numbers\n        .iter()\n        .cloned()\n\
    \        .map(|n| (n - min) / (max - min))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp6zj8hhl2.rs:6:30\n\
    \     |\n6    |     let min = numbers.iter().min().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp6zj8hhl2.rs:7:30\n\
    \     |\n7    |     let max = numbers.iter().max().unwrap();\n     |         \
    \                     ^^^ the trait `Ord` is not implemented for `f64`\n     |\n\
    \     = help: the following other types implement trait `Ord`:\n             \
    \  i128\n               i16\n               i32\n               i64\n        \
    \       i8\n               isize\n               u128\n               u16\n  \
    \           and 4 others\n     = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let scale\
    \ = max - min;\n    numbers.iter().map(|x| (*x - min) / scale).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    // find max & min\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    for number in numbers.iter() {\n        if number > &max {\n            max\
    \ = *number;\n        }\n        if number < &min {\n            min = *number;\n\
    \        }\n    }\n    // rescale\n    let mut scaled_numbers = Vec::new();\n\
    \    for number in numbers.iter() {\n        scaled_numbers.push((number - min)\
    \ / (max - min));\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let range = max_number - min_number;\n    numbers.iter().map(|i| (i - min_number)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbk84wh_l.rs:6:37\n\
    \     |\n6    |     let min_number = numbers.iter().min().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::min`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpbk84wh_l.rs:7:37\n\
    \     |\n7    |     let max_number = numbers.iter().max().unwrap();\n     |  \
    \                                   ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n     |\n     = help: the following other types implement trait `Ord`:\n\
    \               i128\n               i16\n               i32\n               i64\n\
    \               i8\n               isize\n               u128\n              \
    \ u16\n             and 4 others\n     = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\nnote: required by a bound in `std::iter::Iterator::max`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let diff = max - min;\n\
    \    let unit_space = 1.0 / diff;\n    numbers.iter().map(|&n| unit_space * (n\
    \ - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let span\
    \ = max - min;\n    numbers.iter().map(|&x| (x - min) / span).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
