name: HumanEval_83_starts_one_ends
language: rust
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    if n == 1 {\n        return 2;\n    }\n\n    let start_nine = starts_one_ends(n\
    \ - 1);\n    start_nine + (start_nine * 9)", "    // Unwrap the last call to starts_one_ends\
    \ because we know n > 0\n    (2 * ends_one_ends(n - 1)) + starts_one_ends(n -\
    \ 1).unwrap()", '    starts_ends(n, 1)', "    if n == 1 {\n        return 10;\n\
    \    }\n    if n == 2 {\n        return 10;\n    }\n    // Counts to an index\
    \ of one,\n    // after adding the count for the last two positions.\n    let\
    \ mut count = 11;\n    for _ in 3..=n {\n        count = count * 9 + 10;\n   \
    \ }\n    count", "    if n <= 0 {\n        return 0;\n    }\n\n    let n = n as\
    \ usize;\n    let mut dp = vec![0; n + 1];\n    dp[1] = 9;\n\n    for i in 2..=n\
    \ {\n        dp[i] = dp[i - 1] * 10 - dp[i - 2];\n    }\n\n    dp[n]", "    if\
    \ n == 1 {\n        return 1;\n    }\n\n    if n == 2 {\n        return 11;\n\
    \    }\n\n    let mut count = 10;\n    for i in 2..n {\n        count *= 10;\n\
    \        count += 9;\n    }\n\n    count", "    if n == 1 {\n        return 10;\n\
    \    }\n    if n == 2 {\n        return 9;\n    }\n    let val = (10 - 2) * 9;\n\
    \    return starts_one_ends(n - 1) + val;", "    if n == 1 {\n        return 10;\n\
    \    }\n    let x = n - 1;\n    9 * starts_one_ends(x) + 9 * count_perms(x);",
  "    if n == 1 {\n        return 1;\n    }\n    let mut dp = vec![0; (n as usize)\
    \ + 1];\n    dp[1] = 10;\n    dp[2] = 100;\n    for i in 3..=n {\n        dp[i\
    \ as usize] = 9 * dp[(i - 1) as usize] + 9 * dp[(i - 2) as usize];\n    }\n  \
    \  dp[n as usize]", "    if n == 1 {\n        return 1;\n    }\n\n    // We need\
    \ to get the number of 10-digit numbers, 100-digit numbers, etc\n    // that start\
    \ or end with 1.\n\n    // 1 is a 10-digit number.\n    let mut ret = 1;\n\n \
    \   // If n > 1, we have one to eight digits left.\n    if n > 1 {\n        ret\
    \ += 8 * starts_one_ends(n - 1);\n    }\n\n    ret", "    let mut result = 0;\n\
    \    for i in 0..n {\n        result += 9 * std::cmp::max(n - i - 1, 0) * (10\
    \ as isize).pow(i as u32);\n    }\n    result", "    // The answer is (digit-1)\
    \ * 10^(digit-2) + 10^(digit-1)\n    10isize.pow(n as u32 - 1) * (n - 1) + 10isize.pow(n\
    \ as u32 - 1)", "    let first = (n as f64).powf(0.5).ceil() as isize;\n    let\
    \ last = first - 1;\n    let count = (n - 2) * (last + first) + last * last;\n\
    \    count", "    // For n-digit numbers n >= 1, the count of numbers that start\
    \ with 1 and\n    // end with 1 is the same as the count of numbers that do not\
    \ start with 1\n    // (this is because each number has a unique representation,\
    \ and the\n    // requirement that the number start with 1 removes 1 potential\
    \ digit from\n    // the beginning of the number, which is not the same as adding\
    \ 1 potential\n    // digit to the end of the number). The count of numbers that\
    \ do not start\n    // with 1 is equal to the sum of the digits minus 1 (because\
    \ the first digit\n    // is reserved for 1).\n    let sum_digits = count_digits(n);\n\
    \    sum_digits - 1", "    match n {\n        1 => 2,\n        2 => 9,\n     \
    \   _ => {\n            let pow = |x| 10_isize.pow(x as u32);\n            let\
    \ pow9 = |x| (pow(x) - 1) / 9;\n            2 * pow9(n - 1) + pow9(n - 2) - pow9(n\
    \ - 3)\n        }\n    }", "    if n == 1 {\n        return 1;\n    }\n    let\
    \ mut one_start = 1;\n    let mut one_end = 1;\n    let mut nine_start = 0;\n\
    \    let mut nine_end = 0;\n    for _ in 2..=n {\n        one_start = one_start\
    \ + one_end + nine_end;\n        one_end = one_start;\n        nine_start = one_start\
    \ + one_end + nine_end;\n        nine_end = nine_start;\n    }\n    one_start\
    \ + one_end + nine_start + nine_end", "    let mut count = 0;\n    for i in 1..n\
    \ {\n        count += 10_isize.pow(i) * 9;\n    }\n    count += 9;\n    count",
  "    let mut count = 0;\n    let mut digits = vec![0; n as usize];\n    let mut\
    \ i = 1;\n    while i < n {\n        let mut j = 0;\n        while j < n {\n \
    \           digits[i as usize] = 1;\n            digits[j as usize] = 1;\n   \
    \         if is_valid(&digits) {\n                count += 1;\n            }\n\
    \            digits[i as usize] = 0;\n            digits[j as usize] = 0;\n  \
    \          j += 1;\n        }\n        i += 1;\n    }\n    count", "    assert!(n\
    \ > 0);\n    let mut count = 0;\n    for n in n..=2 * n {\n        if n.to_string().starts_with('1')\
    \ || n.to_string().ends_with('1') {\n            count += 1;\n        }\n    }\n\
    \    count", "    if n == 1 {\n        return 10;\n    }\n\n    let mut total\
    \ = 9;\n    let mut base = 9;\n    let mut exp = 9;\n\n    for _ in 2..n {\n \
    \       base *= 10;\n        exp *= 10;\n        total += base;\n        total\
    \ += base * exp;\n    }\n\n    total", "    if n == 1 {\n        return 1;\n \
    \   }\n\n    let n = n as usize;\n    let mut cache = vec![0; n + 1];\n    cache[1]\
    \ = 1;\n    for i in 2..=n {\n        cache[i] = cache[i - 1] + 9 * pow(10, i\
    \ - 2) as isize;\n    }\n\n    cache[n]", "    if n == 1 {\n        return 10;\n\
    \    }\n    let mut sum = 0;\n    for i in 1..n / 2 + 1 {\n        sum += starts_one_ends(i)\
    \ * starts_one_ends(n - i);\n    }\n    sum + 10 * starts_one_ends(n - 1)", " \
    \   // Ways to make a number of n digits where the last digit is 1\n    let ending_ones\
    \ = make_n_digit_num(n - 1);\n    // Ways to make a number of n digits where the\
    \ first digit is 1\n    let starting_ones = ending_ones;\n    ending_ones + starting_ones",
  "    assert!(n > 0);\n    let mut starts = 1;\n    let mut ends = 1;\n    for _\
    \ in 1..n {\n        let mut tmp = starts;\n        starts = ends;\n        ends\
    \ = ends + tmp;\n    }\n    starts + ends", "    if n == 1 {\n        return 1;\n\
    \    }\n\n    let mut total = 0;\n    for i in 1..n {\n        total += starts_one_ends(i)\
    \ * starts_one_ends(n - i);\n    }\n\n    total", "    if n == 1 {\n        return\
    \ 2;\n    }\n\n    let mut ends_count = ends_one_ends(n - 1);\n    if n % 2 ==\
    \ 0 {\n        ends_count += 1;\n    }\n\n    starts_one_ends(n - 1) + ends_count",
  "    assert!(n > 0);\n    if n <= 2 {\n        return n;\n    }\n    return starts_one_ends(n\
    \ - 1) + 10 * starts_one_ends(n - 2);", "    // f(n) = 9f(n-1) + 9f(n-2)\n   \
    \ if n == 1 {\n        9\n    } else if n == 2 {\n        180\n    } else {\n\
    \        let mut prev_prev = 180;\n        let mut prev = 1827;\n        for _\
    \ in 3..n {\n            let tmp = prev;\n            prev = 9 * prev + 9 * prev_prev;\n\
    \            prev_prev = tmp;\n        }\n        prev\n    }", "    let mut dp\
    \ = vec![vec![0; 10]; n as usize + 1];\n    for i in 1..n+1 {\n        for j in\
    \ 1..10 {\n            if i == 1 {\n                dp[i as usize][j] = 1;\n \
    \           } else {\n                for k in 0..10 {\n                    dp[i\
    \ as usize][j] += dp[(i-1) as usize][k];\n                }\n            }\n \
    \       }\n    }\n    let mut res = 0;\n    for i in 1..10 {\n        res += dp[n\
    \ as usize][i];\n    }\n    res", "    let one = 1;\n    let ten = 10;\n    let\
    \ mut count = 0;\n    let mut k = 1;\n    while k <= n {\n        count += (2\
    \ * ten.pow(k - 1) - two_to_power(k - 1)) as isize;\n        k += 1;\n    }\n\
    \    count", "    if n == 1 {\n        return 1;\n    }\n    let mut dp = vec![vec![0;\
    \ 2]; n as usize];\n    dp[0][0] = 0;\n    dp[0][1] = 1;\n    for i in 1..n {\n\
    \        dp[i as usize][0] = dp[(i - 1) as usize][0] * 9 + dp[(i - 1) as usize][1];\n\
    \        dp[i as usize][1] = dp[(i - 1) as usize][0];\n    }\n    dp[(n - 1) as\
    \ usize][0] + dp[(n - 1) as usize][1]", "    assert!(n > 0);\n    if n == 1 {\n\
    \        return 2;\n    }\n    let mut f = vec![0; n as usize];\n    f[0] = 1;\n\
    \    f[1] = 2;\n    for i in 2..n {\n        f[i as usize] = f[(i - 1) as usize]\
    \ + f[(i - 2) as usize];\n    }\n    f[(n - 1) as usize]", "    let mut count\
    \ = 0;\n    for i in 0..n {\n        count += tenpow(i) * 9;\n    }\n    count\
    \ + tenpow(n - 1)", "    if n == 1 {\n        return 2;\n    }\n    let n = n\
    \ - 1;\n    let mut ans = 10;\n    let mut _n = 9;\n    while n > 1 {\n      \
    \  _n *= 10;\n        ans += _n;\n        n -= 1;\n    }\n    ans", "    if n\
    \ == 1 {\n        return 10;\n    }\n    let m = 10_isize.pow(n as u32 - 1);\n\
    \    m + 9 * starts_one_ends(n - 1)", "    let count = (1..n + 1).fold(0, |acc,\
    \ _| acc * 10);\n    let stop = (1..n).fold(0, |acc, _| acc * 10);\n    (1..count).filter(|x|\
    \ x % 10 == 1 || *x / stop == 1).count() as isize", "    if n <= 1 {\n       \
    \ return 1;\n    }\n    (1..=9).map(|x| 10usize.pow(n as u32 - 1) * 9 * x).sum()\
    \ as isize", "    if n == 1 {\n        return 2;\n    }\n    let dp = vec![vec![0;\
    \ n as usize + 1]; 2];\n    for i in 1..n {\n        for j in 0..=9 {\n      \
    \      if i == 1 && j == 0 {\n                continue;\n            }\n     \
    \       dp[0][i as usize] += dp[0][(i - 1) as usize];\n            dp[1][i as\
    \ usize] += dp[1][(i - 1) as usize];\n        }\n        dp[0][i as usize] +=\
    \ dp[1][(i - 1) as usize];\n        dp[1][i as usize] += dp[0][(i - 1) as usize];\n\
    \    }\n    for j in 1..=9 {\n        dp[0][n as usize] += dp[0][(n - 1) as usize];\n\
    \        dp[1][n as usize] += dp[1][(n - 1) as usize];\n    }\n    dp[0][n as\
    \ usize] + dp[1][n as usize]", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        2 => 10,\n        _ => starts_one_ends(n - 1) + starts_one_ends(n - 2),\n\
    \    }", "    if n == 1 {\n        return 1;\n    }\n\n    if n == 2 {\n     \
    \   return 10;\n    }\n\n    let mut sum = 0;\n    let mut x = 1;\n    let mut\
    \ y = 10;\n    for _ in 2..n {\n        x = x * 10;\n        y = y * 10;\n   \
    \     sum += x;\n    }\n\n    sum * 2 + y", "    if n == 1 {\n        return 1;\n\
    \    }\n\n    let mut dp = vec![vec![0; n as usize]; 2];\n    dp[0][0] = 1;\n\
    \    dp[1][0] = 1;\n\n    for i in 0..n - 1 {\n        dp[0][i as usize + 1] =\
    \ dp[0][i as usize] + dp[1][i as usize];\n        dp[1][i as usize + 1] = dp[0][i\
    \ as usize];\n    }\n\n    dp[0][(n - 1) as usize] + dp[1][(n - 1) as usize]",
  "    // Smallest number with n digits is 10^(n-1).\n    // Largest number with n\
    \ digits is 9*10^(n-1).\n    let start = 10_isize.pow(n as u32 - 1);\n    let\
    \ end = 9 * start;\n    return end - start + 1;", "    if n == 1 {\n        return\
    \ 10;\n    }\n    let mut s = 0;\n    let tens = 10isize.pow(n - 1);\n    for\
    \ i in 1..=9 {\n        s += starts_one_ends(n - 1);\n        s += (i as isize)\
    \ * tens;\n    }\n    s", "    assert!(n > 0);\n    let (lower, upper) = match\
    \ n {\n        1 => (1, 9),\n        _ => (10_isize.pow(n - 1), 10_isize.pow(n)\
    \ - 1),\n    };\n    upper - lower + 1", "    if n <= 0 {\n        return 0;\n\
    \    }\n    (9 * counts(n - 1) + 9 * counts(n - 2)) % MODULO", "    // Let's first\
    \ compute the number of start-one n-digit numbers,\n    // call this count a.\
    \ The first digit can be 1 and the other n-1 digits\n    // can be any one of\
    \ the 10 digits. So a = 9 * 10^(n-1).\n\n    // Now, let's compute the number\
    \ of end-one n-digit numbers, call this\n    // count b. The last digit can be\
    \ 1, and the other n-1 digits can be\n    // any one of the 10 digits. So b =\
    \ 9 * 10^(n-1).\n\n    // The total count is a + b = 18 * 10^(n-1)\n    10_isize.pow(n\
    \ as u32 - 1) * 18", "    if n <= 1 {\n        return 1;\n    }\n\n    let mut\
    \ acc = 10;\n    for _ in 1..n {\n        acc *= 10;\n    }\n\n    let mut count\
    \ = 0;\n    for x in 1..acc {\n        let s = x.to_string();\n        let c =\
    \ s.chars().nth(0).unwrap();\n        let d = s.chars().nth(s.len() - 1).unwrap();\n\
    \        if c == '1' || d == '1' {\n            count += 1;\n        }\n    }\n\
    \n    count", "    let digits = 10_isize.pow(n - 1);\n    let left = 9_isize.pow(n\
    \ - 1);\n    let right = 9_isize.pow(n);\n    digits + left + right", "    if\
    \ n == 1 {\n        return 10;\n    }\n\n    let mut sum = 10;\n\n    for i in\
    \ 2..=n {\n        sum += 9 * 10i64.pow((i - 1) as u32) as isize;\n    }\n\n \
    \   sum", "    if n <= 0 {\n        return 0;\n    }\n    assert!(n <= MAX_LEN);\n\
    \    let n = n as usize;\n    let nums = 1;\n    let len = n + 1;\n    let mut\
    \ memo = vec![vec![0; len]; nums];\n    for i in 0..nums {\n        memo[i][1]\
    \ = 1;\n    }\n    for i in 0..nums {\n        for j in 2..len {\n           \
    \ for k in 0..10 {\n                if k == 1 {\n                    memo[i][j]\
    \ += memo[i][j - 1];\n                } else {\n                    memo[i][j]\
    \ += memo[i][j - 1] - memo[i][j - 2];\n                }\n            }\n    \
    \    }\n    }\n    memo[0][n]", "    let count = 9 * 10isize.pow(n - 1);\n   \
    \ println!(\"starts_one_ends({}) -> {}\", n, count);\n    count", "    if n ==\
    \ 1 {\n        1\n    } else {\n        (n - 1) * 9 * (10.0 as f64).powi(n as\
    \ i32 - 2) as isize\n    }", "    let mut cache = vec![0; n as usize + 1];\n \
    \   let ans = helper(n, &mut cache);\n    ans", "    let mut count = 0;\n    for\
    \ i in 0..n {\n        count += power(10, i);\n    }\n    count * 2", "    if\
    \ n <= 1 {\n        return 0;\n    }\n\n    let fm = n - 1;\n    let sn = 10_isize.pow(fm\
    \ as u32);\n    let tn = 10_isize.pow(n as u32);\n\n    let c = |x| match x {\n\
    \        0 | 1 => 1,\n        _ => {\n            let s = 10_isize.pow((x - 1)\
    \ as u32);\n            (s * 9) + (s - 1)\n        }\n    };\n\n    let s = c(fm);\n\
    \    let t = c(n);\n\n    t - (tn - sn)", "    if n == 1 {\n        return 10;\n\
    \    }\n    let mut result = 0;\n    for i in 0..n {\n        if i % 2 == 0 {\n\
    \            result += starts_one_ends(i) * starts_one_ends(n - i - 1);\n    \
    \    } else {\n            result += starts_one_ends(i) * starts_one_ends(n -\
    \ i - 1) * 9;\n        }\n    }\n    result", '    10 * 9isize.pow(n - 1)', " \
    \   if n == 1 {\n        return 10;\n    }\n    let mut count = 10;\n    let mut\
    \ pow = 1;\n    for _ in 0..n-1 {\n        pow *= 10;\n        count += 9 * pow;\n\
    \    }\n    count", "    let mut i = 1;\n    let mut sum = 0;\n    while i <=\
    \ n {\n        if i == 1 {\n            sum += 9;\n        } else {\n        \
    \    sum += 10 * (2 * pow(10, i - 2) - 1);\n        }\n        i += 1;\n    }\n\
    \    sum", "    if n <= 1 {\n        return n;\n    }\n    if n == 2 {\n     \
    \   return 10;\n    }\n    let mut start_one = 9;\n    let mut ends_one = 9;\n\
    \    let mut ends_one_plus_starts_one = 9;\n    for _ in 2..n {\n        ends_one_plus_starts_one\
    \ = ends_one * 9 + start_one;\n        start_one = ends_one_plus_starts_one -\
    \ start_one;\n        ends_one = ends_one_plus_starts_one;\n    }\n    start_one\
    \ + ends_one_plus_starts_one", '    10isize.pow(n as u32 - 1) * 9isize * (1..=n).sum::<isize>()',
  '    10 * (10isize.pow(n - 1) - 1) / 9', "    if n <= 1 {\n        return 0;\n \
    \   }\n\n    // if n == 2, then you have 10 possible numbers\n    // if n == 3,\
    \ then you have 3 possible numbers\n    // if n == 4, then you have 4 possible\
    \ numbers\n    // if n == 5, then you have 4 possible numbers\n    // if n ==\
    \ 6, then you have 4 possible numbers\n    // if n == 7, then you have 5 possible\
    \ numbers\n    // if n == 8, then you have 5 possible numbers\n    // if n ==\
    \ 9, then you have 6 possible numbers\n    // if n == 10, then you have 6 possible\
    \ numbers\n    let mut possible_numbers = vec![0, 10, 3, 4, 4, 4, 5, 5, 6, 6];\n\
    \n    for i in 11..=n {\n        let sum = possible_numbers[(i - 1) as usize]\
    \ + possible_numbers[(i - 2) as usize];\n        possible_numbers.push(sum);\n\
    \    }\n\n    possible_numbers[n as usize]", "    let mut result = 0;\n    let\
    \ mut start = 10isize.pow(n - 1);\n    while start < 10isize.pow(n) {\n      \
    \  result += start;\n        start += 10;\n    }\n    result", "    if n == 1\
    \ {\n        return 1;\n    }\n    if n == 2 {\n        return 9 + starts_one_ends(1);\n\
    \    }\n    (1..n).fold(10, |acc, n| acc + 9 * power(10, n - 1)) + starts_one_ends(n\
    \ - 1)", "    if n <= 1 {\n        1\n    } else {\n        9 * starts_one_ends(n\
    \ - 1)\n    }", "    if n == 1 {\n        return 10;\n    }\n    let mut v = vec![0;\
    \ n as usize];\n    v[0] = 9;\n    v[1] = 9;\n    for i in 2..n {\n        v[i\
    \ as usize] = v[(i - 1) as usize] * 10 - v[(i - 2) as usize];\n    }\n    v[(n\
    \ - 1) as usize] * 2", "    if n == 1 {\n        return 2;\n    }\n    let mut\
    \ ends = 11;\n    let mut starts = 1;\n    for _ in 1..n - 1 {\n        ends +=\
    \ starts * 9;\n        starts *= 10;\n    }\n    ends + starts", "    let mut\
    \ cache = HashMap::new();\n    let mut p = 0;\n    for i in 0..n {\n        p\
    \ += starts_one_ends_helper(i, &mut cache);\n    }\n    p", "    // We will use\
    \ dynamic programming to solve this problem.\n    //\n    // Let's say that f(i)\
    \ is the number of i-digit positive integers that\n    // start or end with 1.\
    \ Then,\n    //\n    //   f(1) = 1\n    //   f(2) = 9\n    //   f(3) = 91 + 10\
    \ = 101\n    //   f(4) = 901 + 100 = 1001\n    //   f(5) = 9001 + 1000 = 10001\n\
    \    //   ...\n    //\n    // We can see that f(n) is the sum of f(n - 1) and\
    \ the number of\n    // single-digit numbers that start with 1.\n    //\n    //\
    \ Now, let's define a function g(i) to be the number of i-digit numbers\n    //\
    \ that start with 1. Then\n    //\n    //   g(1) = 1\n    //   g(2) = 9\n    //\
    \   g(3) = 81\n    //   g(4) = 729\n    //   g(5) = 6561\n    //   ...\n    //\n\
    \    // g(n) is the number of single-digit numbers that start with 1, multiplied\n\
    \    // by 9^(n - 1).\n    //\n    // Now, we can just use dynamic programming\
    \ to fill out our tables.\n    let mut f: Vec<isize> = vec![0; (n + 1) as usize];\n\
    \    let mut g: Vec<isize> = vec![0; (n + 1) as usize];\n    f[1] = 1;\n    g[1]\
    \ = 1;\n    for i in 2..=n {\n        f[i as usize] = f[(i - 1) as usize] + g[(i\
    \ - 1) as usize];\n        g[i as usize] = 9 * g[(i - 1) as usize];\n    }\n \
    \   f[n as usize]", "    let zeros = zeros(n);\n    (n * 9_isize.pow(zeros - 1)\
    \ - 2 * 9_isize.pow(zeros))\n        .saturating_add(starts_one_ends(n - 1))",
  "    if n == 1 {\n        return 1;\n    }\n\n    let mut ret = 0;\n    for i in\
    \ 0..n {\n        ret += starts_one_ends(i) * (n - i - 1);\n    }\n\n    ret",
  "    let mut dp = vec![vec![0; 2]; n as usize + 1];\n    dp[1][0] = 0;\n    dp[1][1]\
    \ = 1;\n    for i in 2..=n {\n        dp[i as usize][0] = dp[(i - 1) as usize][0]\
    \ + dp[(i - 1) as usize][1];\n        dp[i as usize][1] = dp[(i - 1) as usize][0];\n\
    \    }\n    dp[n as usize][0] + dp[n as usize][1]", "    let mut result = 0;\n\
    \    let mut next = vec![1; n as usize];\n    for _ in 0..n {\n        result\
    \ += next[0];\n        next[0] = next[0] * 2;\n        for i in 1..(n - 1) {\n\
    \            next[i] = next[i - 1] + next[i];\n        }\n        next[n as usize\
    \ - 1] = next[n as usize - 2] * 2;\n    }\n    result", "    let mut count = 0;\n\
    \    let mut ini = \"1\".to_string();\n    while ini.len() <= n as usize {\n \
    \       count += 1;\n        ini.push('1');\n    }\n    count", "    let count\
    \ = (n - 1) * 9 + 1;\n    if n == 1 {\n        return count;\n    }\n    starts_one_ends(n\
    \ - 1) + count", "    let pow10 = (0..n).fold(1, |r, _| r * 10);\n    let pow9\
    \ = pow10 / 10;\n    let pow8 = pow9 / 10;\n    if n == 1 {\n        return 10;\n\
    \    } else if n == 2 {\n        return pow9 * 2 + 9;\n    }\n    pow9 * 2 + 9\
    \ * pow8", "    let mut dp = Vec::new();\n    dp.push(1);\n    dp.push(9);\n \
    \   if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 10;\n\
    \    }\n    for i in 3..=n {\n        let new = dp[(i - 2) as usize] * 9;\n  \
    \      dp.push(new);\n    }\n    dp[(n - 1) as usize]", '    return 10isize.pow(n
    as u32 - 1) * 2;', "    let mut a: isize = 9;\n    let mut b: isize = 1;\n   \
    \ let mut ans: isize = 10;\n    for _ in 1..n {\n        a *= 10 - _;\n      \
    \  b *= 9;\n        ans += a + b;\n    }\n    ans", "    let mut s = 0;\n    let\
    \ first = pow(10, n - 1);\n    let last = pow(10, n);\n    for i in first..last\
    \ {\n        let (a, b) = (i / 10, i % 10);\n        if a % 10 == 1 || b == 1\
    \ {\n            s += 1;\n        }\n    }\n    s", "    if n == 1 {\n       \
    \ return 1;\n    }\n    let mut prev: isize = 1;\n    let mut current: isize =\
    \ 1;\n    for _ in 1..n {\n        let tmp = current;\n        current = (prev\
    \ + current) * 9;\n        prev = tmp;\n    }\n    current", "    let mut count\
    \ = 0;\n    for i in 1..(n / 2 + 1) {\n        let pow = (10 as isize).pow(i);\n\
    \        count += 9 * pow;\n    }\n    if n % 2 == 0 {\n        count *= 2;\n\
    \    } else {\n        count += 9 * (10 as isize).pow(n / 2);\n    }\n    count",
  "    if n == 1 {\n        10\n    } else {\n        9 * digit_count(n - 1)\n   \
    \ }", "    let mut ret = 0;\n    let mut m = 1;\n    while m < n {\n        m\
    \ += 1;\n        ret += 9 * 9usize.pow(m as u32 - 2) as isize;\n    }\n    ret",
  "    if n == 1 {\n        return 10;\n    }\n    let mut result = 0;\n    for i\
    \ in 1..n {\n        let mut start_with_one = 1;\n        for _ in 0..i {\n  \
    \          start_with_one *= 10;\n        }\n        result += start_with_one;\n\
    \    }\n    result *= 9;\n    result", "    if n <= 0 {\n        return 0;\n \
    \   }\n    let mut n = n as usize;\n    let mut start_end_one_total = 0;\n   \
    \ let mut nums_with_one_at_start = 1;\n    let mut nums_with_one_at_end = 1;\n\
    \    let mut nums_with_one_at_start_and_end = 0;\n    let mut total = 0;\n   \
    \ for _ in 0..n - 1 {\n        nums_with_one_at_start_and_end = nums_with_one_at_start;\n\
    \        nums_with_one_at_start = total;\n        nums_with_one_at_end += start_end_one_total;\n\
    \        total = 9 * total + 10;\n        start_end_one_total = nums_with_one_at_start_and_end\
    \ + nums_with_one_at_end;\n    }\n    total + start_end_one_total", "    if n\
    \ == 1 {\n        1\n    } else {\n        (n - 1) * 9 + starts_one_ends(n - 1)\n\
    \    }", "    if n == 1 {\n        return 10;\n    }\n    let mut dp = vec![vec![0;\
    \ 10]; 2];\n    dp[0][1] = 10;\n    dp[1][1] = 9;\n    for i in 2..=n {\n    \
    \    for j in 1..=9 {\n            dp[0][j] = (dp[0][j - 1] + dp[1][j - 1]) %\
    \ 1000000007;\n            dp[1][j] = (dp[0][j] + dp[1][j - 1]) % 1000000007;\n\
    \        }\n    }\n    dp[0].iter().sum::<isize>() % 1000000007", "    if n ==\
    \ 1 {\n        return 2;\n    }\n    // (1..n-1).fold(9, |acc, _| acc * 10 + 9)\
    \ * 2 + 9\n    (0..n-1).fold(9 * 2 + 9, |acc, _| acc * 10 + 9)", "    let mut\
    \ total = 0;\n    let mut n_ones = 0;\n    let mut digit = 1;\n    while digit\
    \ <= n {\n        total += 9 * starts_one_ends(n - digit) + 10i64.pow(digit as\
    \ u32 - 1) as isize;\n        n_ones += 10i64.pow(digit as u32 - 1) as isize;\n\
    \        digit += 1;\n    }\n    return total;", "    let mut next = 1;\n    let\
    \ mut sz = 1;\n    while sz < n {\n        next = (next * 10) + 1;\n        sz\
    \ += 1;\n    }\n    let max = next;\n    let mut sum = 1;\n    let mut one = 1;\n\
    \    while one < max {\n        sum += one;\n        one *= 10;\n        one +=\
    \ 1;\n    }\n    sum", "    let mut base = 10;\n    let mut ans = 10;\n    for\
    \ _ in 2..n {\n        base *= 10;\n        ans += base;\n    }\n    ans", " \
    \   let mut ones = vec![0isize; n as usize];\n    let mut twos = vec![0isize;\
    \ n as usize];\n    ones[0] = 1;\n    twos[0] = 1;\n    for i in 1..n as usize\
    \ {\n        ones[i] = twos[i - 1];\n        twos[i] = ones[i - 1] + twos[i -\
    \ 1];\n    }\n    ones[n as usize - 1] + twos[n as usize - 1]", "    // We need\
    \ to consider all numbers that are either n digits long and start\n    // with\
    \ a 1, or those that are n-1 digits long and end with a 1.\n    //\n    // Let\
    \ A(n) be the number of n-digit positive integers that start with a 1,\n    //\
    \ and B(n) be the number of n-digit positive integers that end with a 1.\n   \
    \ //\n    // Then we have that A(n) = 10^{n-1} and B(n) = 9A(n-1) = 9(10^{n-2}).\n\
    \    //\n    // The number of n-digit positive integers that start or end with\
    \ a 1 is\n    // therefore A(n) + B(n).\n    10_isize.pow(n - 1) + 9 * 10_isize.pow(n\
    \ - 2)", "    let mut ends = 1;\n    let mut starts = 1;\n    for _ in 1..n {\n\
    \        ends = ends * 10 + 1;\n        starts = starts * 9 + 1;\n    }\n    starts\
    \ + ends", "    let mut p = vec![1, 1];\n    let mut t = 1;\n    while t < n {\n\
    \        let mut r = p[0];\n        for i in 1..t {\n            r += p[i] * (i\
    \ + 1);\n        }\n        p.push(r);\n        t += 1;\n    }\n    p[n as usize]",
  "    let mut current = 10;\n    let mut count = 0;\n    for _ in 1..n {\n      \
    \  count += current;\n        current = current * 10;\n    }\n    count + current",
  "    let mut counts = vec![0; n as usize + 1];\n    counts[1] = 1;\n    for i in\
    \ 2..=n {\n        for j in 1..i {\n            counts[i as usize] += counts[j\
    \ as usize];\n        }\n    }\n    return counts[n as usize];", "    // By brute\
    \ force!\n    let mut count = 0;\n    let start = 1;\n    let end = 1;\n    for\
    \ i in 1..10 {\n        let mut digits = Vec::with_capacity(n as usize);\n   \
    \     digits.push(i);\n        start_one_ends_recursive(\n            n - 1,\n\
    \            start,\n            end,\n            &mut digits,\n            &mut\
    \ count,\n        );\n    }\n    count", "    // Count the number of n-digit numbers\
    \ that start with 1 (except 11)\n    // and the number of n-digit numbers that\
    \ end with 1.\n    // Subtract the number of n-digit numbers that start with 1\
    \ and end with 1\n    // to remove the double counting.\n    starts_one(n) + ends_one(n)\
    \ - starts_one_ends_one(n)", "    let mut dp = vec![vec![0; 2]; (n + 1) as usize];\n\
    \    dp[1][0] = 1;\n    dp[1][1] = 0;\n    for i in 2..=n {\n        dp[i as usize][0]\
    \ = dp[(i - 1) as usize][0] + dp[(i - 1) as usize][1];\n        dp[i as usize][1]\
    \ = dp[(i - 1) as usize][0];\n    }\n    dp[n as usize][0] + dp[n as usize][1]",
  "    let mut result = 0;\n    for i in 1..n + 1 {\n        result += one_ends(i);\n\
    \    }\n    result", "    if n == 1 {\n        return 10;\n    }\n\n    if n ==\
    \ 2 {\n        return 10 + 10 * 9;\n    }\n\n    starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2) * 9", "    // The numbers starting with 1 are easy.\n    let begins_one\
    \ = _num_length(n - 1);\n\n    // For the numbers ending with 1, the \"1\" has\
    \ to be after the first digit,\n    // so they can have lengths 1 .. n-1 digits.\n\
    \    let ends_one = (1..n).map(|i| _num_length(i)).sum();\n\n    begins_one +\
    \ ends_one", "    let mut count = 0;\n    let mut i = 1;\n    while i < n {\n\
    \        count += 9 * (10isize.pow(i - 1) as isize);\n        i += 1;\n    }\n\
    \    count += 10isize.pow(n - 1) as isize;\n    count", "    (1..(n + 1)).map(|m|\
    \ {\n        // We can't choose a 0 as the first digit.\n        (10 - 1).pow(m\
    \ - 1)\n    }).sum()", "    if n == 1 {\n        return 10;\n    }\n\n    let\
    \ mut total = 0;\n    for d in 1..10 {\n        let mut s = 0;\n        for i\
    \ in 0..n {\n            s += &one_ends(n - i - 1, false) * 10_isize.pow(i as\
    \ u32);\n        }\n        total += s;\n    }\n\n    total", "    let (mut ten,\
    \ mut one) = (1, 1);\n    for _ in 0..n {\n        ten = (ten + one) * 9;\n  \
    \      one = one * 10;\n    }\n    ten + one", "    if n <= 0 {\n        return\
    \ 0;\n    }\n    let mut result = 0;\n    if n >= 2 {\n        let max = 10_isize.pow(n\
    \ as u32 - 1);\n        let two_max = 10_isize.pow(n as u32);\n        result\
    \ += (two_max - max) * 9 / 10;\n    }\n    if n >= 1 {\n        result += 9;\n\
    \    }\n    result", "    if n == 1 {\n        return 10;\n    }\n    let mut\
    \ start = 1;\n    let mut end = 1;\n    for _ in 1..n {\n        start *= 9;\n\
    \        end *= 9;\n    }\n    start + end", "    if n == 1 {\n        return\
    \ 2;\n    }\n    let mut prev_1 = 1;\n    let mut prev_2 = 1;\n    for _ in 2..=n\
    \ {\n        let new_val = prev_1 + prev_2;\n        prev_1 = prev_2;\n      \
    \  prev_2 = new_val;\n    }\n    prev_2", "    let n = n as usize;\n    let mut\
    \ dp = vec![0; n + 1];\n    dp[1] = 10;\n    for j in 2..=n {\n        dp[j] =\
    \ 9 * dp[j - 1] + 10_isize.pow(j as u32 - 1);\n    }\n    dp[n]", "    if n ==\
    \ 1 {\n        return 1;\n    }\n\n    let mut count = 1;\n    for _ in 1..n {\n\
    \        count *= 5;\n    }\n\n    count", "    if n == 1 {\n        return 2;\n\
    \    }\n    let n = n as usize;\n    let mut count = 0;\n    let mut one_counts\
    \ = vec![0; n + 1];\n    let mut two_counts = vec![0; n + 1];\n    one_counts[1]\
    \ = 2;\n    two_counts[1] = 3;\n    for i in 2..=n {\n        one_counts[i] =\
    \ two_counts[i - 1];\n        two_counts[i] = one_counts[i - 1] + two_counts[i\
    \ - 1];\n    }\n    for i in 1..=n {\n        count += one_counts[i] + two_counts[i];\n\
    \    }\n    count", "    if n == 1 {\n        10\n    } else {\n        (1..n\
    \ + 1).fold(0, |acc, i| acc + starts_one_ends(i - 1)) * 9 + starts_one_ends(n\
    \ - 1)\n    }", "    if n <= 0 {\n        return 0;\n    }\n    let mut result\
    \ = 1;\n    for _ in 1..n {\n        result = result * 10 + 1;\n    }\n    result",
  "    if n == 1 {\n        return 10;\n    }\n\n    let mut sum = 0;\n    let mut\
    \ nine = 9;\n    let mut nine_pow = 1;\n    for _ in 0..n - 1 {\n        sum +=\
    \ nine * nine_pow;\n        nine *= 10;\n        nine_pow *= 9;\n    }\n    sum\
    \ * 2 + ten_to_the(n)", "    let mut cur = 1;\n    let mut prev = 0;\n    for\
    \ _ in 0..n - 1 {\n        let temp = cur;\n        cur = prev * 9 + cur;\n  \
    \      prev = temp;\n    }\n    cur + prev", "    if n <= 1 {\n        0\n   \
    \ } else {\n        let pow = (10 as f64).powi(n as i32 - 1);\n        let n_str\
    \ = n.to_string();\n        let nums = n_str.chars().fold(0, |sum, x| sum + x.to_digit(10).unwrap()\
    \ as isize);\n        let ans = pow * nums as f64;\n        (ans.floor() as isize\
    \ - 1) * nums\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n    \
    \    _ => 10 * starts_one_ends(n - 1) - 9 * power(10, n - 2),\n    }", "    if\
    \ n == 1 {\n        return 10;\n    }\n    10 * (starts_one_ends(n - 1) + 9 *\
    \ 9isize.pow((n - 2) as u32))", "    if n == 1 {\n        return 10;\n    }\n\
    \    let pow = 10f64.powi(n as i32 - 1) as isize;\n    let nine = 9 * pow;\n \
    \   if n == 2 {\n        return nine + 1;\n    }\n    nine + starts_one_ends(n\
    \ - 1)", "    if n <= 1 {\n        return 0;\n    }\n\n    let mut ones = 0;\n\
    \    let mut power = 1;\n    for _ in 0..n - 1 {\n        power *= 10;\n     \
    \   ones += 9 * power;\n    }\n\n    let final_count = 1 + 9 * ones;\n    let\
    \ count = if n >= 2 {\n        ones + starts_one_ends(n - 1)\n    } else {\n \
    \       ones\n    };\n\n    count + final_count", "    let mut prefix = 1isize;\n\
    \    let mut suffix = 1isize;\n    for _ in 0..n - 1 {\n        prefix *= 10;\n\
    \        suffix = suffix * 10 + 1;\n    }\n    let nines = std::iter::repeat(9).take(n\
    \ as usize - 1).fold(1, |acc, x| acc * x);\n    prefix + suffix + nines", "  \
    \  assert!(n > 0);\n    if n == 1 {\n        return 1;\n    }\n\n    let mut count\
    \ = 0;\n    for i in 0..=9 {\n        count += start_one_ends_with(n - 1, i);\n\
    \    }\n    count", "    let nums_end = ends_one(n);\n    if n == 1 {\n      \
    \  nums_end\n    } else {\n        nums_end + starts_one_ends(n - 1)\n    }",
  "    let mut dp = vec![0; (n as usize) + 1];\n    dp[1] = 1;\n    dp[2] = 2;\n \
    \   for i in 3..=n {\n        dp[i as usize] = dp[(i - 1) as usize] + dp[(i -\
    \ 2) as usize];\n    }\n    let sum = dp[n as usize];\n    return sum - 1;", " \
    \   if n == 1 {\n        return 1;\n    }\n\n    let mut dp = vec![0; n as usize];\n\
    \    let mut dp2 = vec![0; n as usize];\n\n    // n = 2\n    dp[0] = 1;\n    dp[1]\
    \ = 1;\n\n    // n >= 3\n    for i in 2..n {\n        dp[i as usize] = dp[(i -\
    \ 1) as usize] + dp[(i - 2) as usize];\n    }\n\n    // Counting the last digit\
    \ as 1.\n    dp2[0] = 1;\n    dp2[1] = 1;\n    for i in 2..n {\n        dp2[i\
    \ as usize] = dp2[(i - 1) as usize] + dp2[(i - 2) as usize];\n    }\n\n    dp[(n\
    \ - 1) as usize] + dp2[(n - 1) as usize]", "    if n == 1 {\n        return 10;\n\
    \    }\n    if n < 1 {\n        return 0;\n    }\n    let mut sum = 0;\n    for\
    \ i in 1..10 {\n        sum += starts_one_ends(n - 1);\n    }\n    sum", "   \
    \ let mut dp = [0; 100];\n    dp[0] = 0;\n    dp[1] = 10;\n    dp[2] = 10;\n \
    \   for i in 3..n {\n        dp[i as usize] = dp[(i - 1) as usize] + 9 * dp[(i\
    \ - 2) as usize];\n    }\n    dp[n as usize]", '    (1..n).fold(10, |acc, _| acc
    * 10)', "    let (mut ends, mut starts, mut counts) = (0, 0, 0);\n    let mut\
    \ v = Vec::new();\n    if n == 1 {\n        return 10;\n    }\n    for _ in 0..n\
    \ {\n        if v.len() == 0 {\n            for i in 1..10 {\n               \
    \ v.push(i);\n            }\n        } else {\n            for i in 0..v.len()\
    \ {\n                if v[i] == 1 {\n                    starts += 1;\n      \
    \          }\n                v[i] *= 10;\n            }\n            let prev\
    \ = v.len();\n            for i in 0..prev {\n                v.push(v[i] + 1);\n\
    \            }\n        }\n    }\n    println!(\"{:?}\", v);\n    println!(\"\
    {:?}\", v.len());\n    for x in v {\n        if x % 10 == 1 {\n            ends\
    \ += 1;\n        }\n    }\n    counts = ends + starts;\n    return counts;", '    unimplemented!();',
  "    if n == 1 {\n        return 1;\n    }\n    let mut dp = vec![0; n as usize];\n\
    \    dp[0] = 1;\n    dp[1] = 10;\n    for i in 2..n {\n        dp[i as usize]\
    \ = dp[(i - 1) as usize] + dp[(i - 2) as usize];\n    }\n    return dp[(n - 1)\
    \ as usize] * 2;", '    starts_one_ends_helper(n, 10)', "    if n == 1 {\n   \
    \     return 10;\n    }\n\n    let mut end = 10;\n    let mut start = 9;\n   \
    \ let mut sum = 19;\n\n    for _ in 2..n {\n        let new_start = start * 9;\n\
    \        let new_end = end * 9;\n        let new_sum = new_start + new_end;\n\n\
    \        end = new_end;\n        start = new_start;\n        sum += new_sum;\n\
    \    }\n\n    sum", "    if n <= 1 {\n        return 1;\n    }\n\n    let mut\
    \ num = 9;\n    let mut base = 9;\n    let mut answer = 10;\n\n    for _ in 2..n\
    \ {\n        num *= base;\n        answer += num;\n        base -= 1;\n    }\n\
    \n    answer", "    let mut res = vec![0; n as usize + 1];\n    res[1] = 10;\n\
    \    for i in 2..=n {\n        let digit = i - 1;\n        res[i as usize] = 9\
    \ * res[(i - 1) as usize] + 9isize.pow(digit as u32);\n    }\n    res[n as usize]",
  "    if n == 1 {\n        return 2;\n    }\n\n    let mut count = 0;\n    for i\
    \ in 1..n {\n        count += count_begin_one(i) * count_end_one(n - i);\n   \
    \ }\n\n    count + count_begin_one(n)", "    let mut result = 0;\n    let mut\
    \ a = 0;\n    let mut b = 0;\n    let mut c = 1;\n    for _ in 1..n + 1 {\n  \
    \      result += a + b + c;\n        a = b;\n        b = c;\n        c = result;\n\
    \    }\n    result", "    if n == 1 {\n        return 2;\n    }\n    let mut counts\
    \ = Vec::new();\n    counts.push(10);\n    for i in 2..n + 1 {\n        counts.push(counts[i\
    \ as usize - 2] * 9 + (i - 1) * 9 * (10 as isize).pow(i - 2));\n    }\n    return\
    \ counts[n as usize - 1];", "    let mut total = 0;\n    for i in 1..=n {\n  \
    \      total += starts_with_one(i);\n        total += ends_with_one(i);\n    }\n\
    \    total", "    let mut m = 1;\n    for _ in 1..n {\n        m *= 10;\n    }\n\
    \    let q = m * 10;\n    if n == 1 {\n        return 9;\n    }\n    9 * ((q -\
    \ m) / 9) + (1 - m)", "    // The number of n-digit positive integers that start\
    \ or end with 1\n    // is equal to the number of positive integers of length\
    \ n - 1, which\n    // must be less than 10:\n    //\n    //   1 <= x < 10\n \
    \   //\n    // The number of n-digit positive integers that end with 1 is equal\
    \ to\n    // the number of n-digit positive integers that start with 1.\n    if\
    \ n == 1 {\n        return 2;\n    }\n    starts_one_ends(n - 1)", "    if n <=\
    \ 0 {\n        return 0;\n    }\n    let mut tmp = 1;\n    for _ in 0..n - 1 {\n\
    \        tmp *= 10;\n    }\n    tmp + starts_one_ends(n - 1) * 9", "    let digits\
    \ = 9;\n    let mut prev = vec![1];\n    let mut curr = vec![1];\n    for _ in\
    \ 1..n {\n        let mut added = prev.iter().sum::<isize>();\n        for i in\
    \ 0..curr.len() {\n            added += digits;\n            curr[i] = added;\n\
    \        }\n        let mut tmp = prev;\n        prev = curr;\n        curr =\
    \ tmp;\n    }\n    curr.iter().sum::<isize>()", "    if n == 1 {\n        return\
    \ 1;\n    }\n\n    let mut sum = 2 * starts_one_ends(n - 1);\n    if n > 2 {\n\
    \        sum += starts_one_ends(n - 2);\n    }\n\n    sum", "    if n == 1 {\n\
    \        return 2;\n    }\n    let mut ans = 9;\n    for i in 1..n {\n       \
    \ ans *= 10 - i;\n    }\n    ans", "    // Zero digits are valid.\n    if n ==\
    \ 0 {\n        return 1;\n    }\n\n    // Otherwise, we'll just start with the\
    \ count for n-1 digits, and add on\n    // the ways of having n digits that end\
    \ in 1.\n    let n_minus_one = starts_one_ends(n - 1);\n    let x = 10_isize.pow(n\
    \ as u32 - 1);\n    n_minus_one + x", "    let mut dp = vec![vec![0; 2]; (n +\
    \ 1) as usize];\n    dp[1][0] = 1;\n    dp[1][1] = 1;\n    for i in 2..=n {\n\
    \        dp[i as usize][0] = dp[(i - 1) as usize][0] + dp[(i - 1) as usize][1];\n\
    \        dp[i as usize][1] = dp[(i - 1) as usize][0];\n    }\n    dp[n as usize][0]\
    \ + dp[n as usize][1]", "    // n digits means the numbers could range from 10^(n-1)\
    \ to 10^n. We can count\n    // the numbers in each range, then sum them up to\
    \ get the answer.\n    // To count the numbers in each range, we count the ones\
    \ that start or end\n    // with 1, then subtract the ones that start and end\
    \ with 1. This is because\n    // we have counted them twice.\n    (1..n)\n  \
    \      .map(|digits| 2 * 10isize.pow(digits - 1) - 10isize.pow(digits - 2))\n\
    \        .sum()", "    let mut counter = 0;\n    let low = 10_isize.pow(n - 1);\n\
    \    let high = 10_isize.pow(n);\n    for i in low..high {\n        if i % 10\
    \ == 1 || i / 10_isize.pow(n - 1) == 1 {\n            counter += 1;\n        }\n\
    \    }\n    counter", '    (1..n).map(|i| 10_isize.pow(i as u32)).sum::<isize>()',
  "    if n == 1 {\n        return 1;\n    }\n    count_by_digit(n - 1) + count_by_digit(n\
    \ - 2)", "    if n <= 1 {\n        0\n    } else {\n        9 * starts_one_ends(n\
    \ - 1) + 10isize.pow(n - 1)\n    }", "    let mut count = 0;\n    let mut inc\
    \ = 1;\n    let mut start = 0;\n    let mut end = 0;\n    for _ in 0..n {\n  \
    \      count += 9 * inc;\n        start += 9 * inc;\n        end += 9 * inc +\
    \ 1;\n        inc *= 10;\n    }\n    end - start + count", "    let mut a = 1;\n\
    \    let mut b = 9;\n    let mut c = 9;\n    for _ in 1..n {\n        a = a +\
    \ b + c;\n        b = b * 10 + 9;\n        c = c * 10;\n    }\n    a", "    let\
    \ mut count = 0;\n    for i in 0..n - 1 {\n        count += 9 * power(10, i);\n\
    \    }\n    count += power(10, n - 1);\n    count", "    if n == 1 {\n       \
    \ return 2;\n    }\n    let mut dp = vec![0; n as usize];\n    dp[0] = 1;\n  \
    \  dp[1] = 2;\n    for i in 2..n {\n        dp[i as usize] = dp[(i - 1) as usize]\
    \ + dp[(i - 2) as usize];\n    }\n    2 * dp[(n - 1) as usize]", "    assert!(n\
    \ > 0);\n    if n == 1 {\n        return 2;\n    }\n    starts_one_ends(n - 1)\
    \ + 3 * starts_one_ends(n - 2)", "    if n == 1 {\n        return 2;\n    }\n\n\
    \    let mut count = 0;\n    for i in 1..n {\n        count += count_with_prefix(n,\
    \ i) * starts_one_ends(i);\n    }\n\n    count", "    let pow10 = 10isize.pow(n\
    \ - 1);\n    pow10 + 9 * pow10 - pow10 / 10", "    let mut total = 0;\n    let\
    \ mut left = 1;\n    let mut right = 1;\n    for _ in 0..n {\n        total +=\
    \ left + right;\n        left *= 10;\n        right *= 10;\n    }\n    total",
  "    if n == 1 {\n        return 10;\n    }\n\n    let end_digits = start_one_ends(n\
    \ - 1);\n    let start_digits = 9 * start_one_ends(n - 1);\n\n    start_digits\
    \ + end_digits", "    assert!(n > 0);\n    let mut digits = vec![1; n as usize];\n\
    \    let mut sum = 1;\n    loop {\n        if digits[0] == 9 {\n            let\
    \ mut i = 0;\n            while i < n - 1 && digits[i] == 9 {\n              \
    \  digits[i] = 1;\n                i += 1;\n            }\n            if i <\
    \ n - 1 {\n                digits[i] += 1;\n            } else {\n           \
    \     break;\n            }\n        } else {\n            digits[0] += 1;\n \
    \       }\n        sum += 1;\n    }\n    sum", "    // Base cases.\n    if n ==\
    \ 1 {\n        return 2;\n    } else if n == 2 {\n        return 4;\n    }\n\n\
    \    // Recursive case.\n    let m = n - 1;\n    let mut result = starts_one_ends(m)\
    \ * 10 - starts_one_ends(m - 1);\n    if m > 2 {\n        result += starts_one_ends(m\
    \ - 2);\n    }\n    result", '    unimplemented!()', "    const DIGITS: isize\
    \ = 10;\n    let mut counts = vec![0isize; n as usize];\n    let mut prev = vec![0isize;\
    \ n as usize];\n    counts[0] = 1;\n    prev[0] = 1;\n    for i in 1..n {\n  \
    \      let mut f = 0;\n        let mut g = 0;\n        for j in 0..DIGITS {\n\
    \            if j == 1 {\n                f += prev[(i - 1) as usize];\n     \
    \       }\n            let k = DIGITS - j - 1;\n            if k == 1 {\n    \
    \            g += counts[(i - 1) as usize];\n            }\n        }\n      \
    \  prev[i as usize] = f;\n        counts[i as usize] = f + g;\n    }\n    // println!(\"\
    {:?}\", counts);\n    counts[(n - 1) as usize]", "    if n == 1 {\n        return\
    \ 2;\n    }\n    starts_one_ends(n - 1) + 9 * starts_one_ends(n - 2)", "    let\
    \ mut prev_count = 1;\n    let mut count = 1;\n    let mut prev_prev_count = 0;\n\
    \    let modulo = 1000000007;\n    if n == 1 {\n        return 1;\n    }\n   \
    \ for _ in 2..n {\n        let temp = count;\n        count = (count + prev_prev_count)\
    \ % modulo;\n        prev_prev_count = prev_count;\n        prev_count = temp;\n\
    \    }\n    (count + prev_count) % modulo", "    let mut result = 0;\n    let\
    \ mut n = n;\n    while n > 0 {\n        result += 9;\n        n -= 1;\n    }\n\
    \    result", "    let mut dp = vec![0; (n + 1) as usize];\n    dp[1] = 1;\n \
    \   for i in 2..=n {\n        dp[i as usize] = dp[(i - 1) as usize] * 9 + dp[(i\
    \ - 2) as usize];\n    }\n    return dp[n as usize];", "    let mut result = 0;\n\
    \    let one_digit = 10;\n    let n_digit = n - 1;\n    let digit_start = 1;\n\
    \    result += digit_start * (one_digit.pow(n_digit) - one_digit.pow(n_digit -\
    \ 1));\n    for i in 1..n {\n        result += one_digit.pow(i - 1) * digit_start\
    \ * one_digit.pow(n - i - 1);\n    }\n    result", "    // We handle the 0-1 case\
    \ separately.\n    if n == 1 {\n        return 1;\n    }\n\n    // Subtract a\
    \ case where the number is 1 followed by n-1 zeros.\n    //\n    //  * 1XX000...000\n\
    \    //\n    // Because we have subtracted this case, we need to handle the n-2\
    \ digit\n    // case separately, otherwise we will also subtract 1XX000...000,\
    \ which\n    // we don't want to do.\n    let mut count = starts_one_ends(n -\
    \ 1) - starts_one_ends(n - 2);\n\n    // In the n-1 digit case, every integer\
    \ that starts with a 1 and ends with\n    // a zero will be counted, except for\
    \ 1XX000...000 which we already\n    // subtracted. But we also want to count\
    \ numbers that start with a 1 and\n    // end with a 1. So, we add all the n-2\
    \ digit numbers (except for\n    // 1XX000...000 which we have already subtracted\
    \ once, but we need to\n    // subtract again).\n    if n > 2 {\n        count\
    \ += starts_one_ends(n - 2);\n    }\n\n    // In the n-1 digit case, every integer\
    \ that starts with a 1 and ends with\n    // a 1 will be counted, except for 1XX000...000\
    \ which we already\n    // subtracted. But we also want to count numbers that\
    \ start with a 1 and\n    // end with a 0. So, we add all the n-2 digit numbers\
    \ (except for\n    // 1XX000...000 which we have already subtracted once, but\
    \ we need to\n    // subtract again).\n    if n > 2 {\n        count += starts_one_ends(n\
    \ - 2);\n    }\n\n    count", "    let mut sum = 0;\n    for i in 1..n {\n   \
    \     sum += 9 * 9_isize.pow(i - 1);\n    }\n    sum + n * 9_isize.pow(n - 1)",
  "    if n == 1 {\n        return 10;\n    }\n\n    let mut cur = 0;\n    for i in\
    \ 2..n + 1 {\n        cur += 9 * 9isize.pow(i - 2);\n    }\n\n    2 * cur", " \
    \   if n <= 1 {\n        0\n    } else {\n        (1..n)\n            .map(|i|\
    \ {\n                find_numbers_with_digits(i) * find_numbers_with_digits(n\
    \ - i - 1)\n            })\n            .sum()\n    }", "    if n <= 1 {\n   \
    \     return 1;\n    }\n    let mut dp = vec![0isize; n as usize];\n    for i\
    \ in 0..n {\n        if i == 0 {\n            dp[i as usize] = 1;\n        } else\
    \ if i == 1 {\n            dp[i as usize] = 2;\n        } else {\n           \
    \ dp[i as usize] = dp[(i - 1) as usize] + dp[(i - 2) as usize];\n        }\n \
    \   }\n    dp[(n - 1) as usize]", "    if n == 1 {\n        return 10;\n    }\n\
    \n    let mut ones = 0;\n    for i in 0..n - 1 {\n        ones += 9 * 9isize.pow(i\
    \ as u32);\n    }\n\n    return 10 * ones;", "    if n == 1 {\n        return\
    \ 10;\n    }\n    let mut start_ends = 1;\n    let mut not_start_ends = 9;\n \
    \   for _ in 1..n {\n        start_ends = start_ends + not_start_ends;\n     \
    \   not_start_ends = (not_start_ends * 8) % 1_000_000_007;\n    }\n    (start_ends\
    \ + not_start_ends) % 1_000_000_007", '    starts_one_ends_0(n, false)', "   \
    \ if n == 1 {\n        return 2;\n    }\n\n    (1..n + 1).map(|i| {\n        let\
    \ digits = i as f64;\n        (1f64..digits + 1f64).map(|j| digit_count(j)).sum::<f64>()\n\
    \    }).sum() as isize", "    if n <= 0 {\n        return 0;\n    }\n\n    let\
    \ mut options = 1;\n    let mut count = 0;\n    for _ in 0..n {\n        count\
    \ += options;\n        options *= 9;\n    }\n\n    count", "    let ten = 10_isize.pow(n\
    \ - 1);\n    let div = (1_isize..n + 1).product();\n    9 * ten / div", "    if\
    \ n == 1 {\n        return 10;\n    }\n    let mut dp = vec![vec![0; 10]; n as\
    \ usize];\n    let m = n as usize;\n    for i in 0..10 {\n        dp[0][i] = 1;\n\
    \    }\n    for i in 1..m {\n        for j in 0..10 {\n            for k in 0..10\
    \ {\n                if j == 1 || k == 1 {\n                    dp[i][j] += dp[i\
    \ - 1][k];\n                }\n            }\n        }\n    }\n    let mut res\
    \ = 0;\n    for i in 0..10 {\n        res += dp[m - 1][i];\n    }\n    res", " \
    \   (2..n)\n        .map(|i| 1isize.pow(i as u32))\n        .sum::<isize>()\n\
    \        * 9\n        + 1isize.pow(n as u32)", "    if n <= 0 {\n        return\
    \ 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    let mut prev = 1;\n\
    \    let mut curr = 1;\n    for _ in 2..=n {\n        let temp = curr;\n     \
    \   curr = prev + curr;\n        prev = temp;\n    }\n    prev", "    assert!(n\
    \ > 0);\n    let p = 10_isize.pow(n as u32 - 1);\n    if n == 1 {\n        return\
    \ 1;\n    } else if n == 2 {\n        return 2;\n    } else {\n        return\
    \ (p - 1) * 2;\n    }", "    if n == 1 {\n        return 10;\n    }\n    let mut\
    \ count = 0;\n    let mut last = 10;\n    let mut curr = 10;\n    for _ in 1..n\
    \ {\n        count += last;\n        let new_curr = count * 2;\n        last =\
    \ curr;\n        curr = new_curr;\n    }\n    count += curr;\n    count", "  \
    \  let mut start = 0;\n    let mut end = 0;\n    let mut start_count = 1;\n  \
    \  let mut end_count = 1;\n    let mut num_count = 1;\n    let mut total = 1;\n\
    \    let mut prev_end_count = 1;\n    let mut prev_end = 1;\n    let mut prev_total\
    \ = 1;\n    for _ in 1..n {\n        start_count = start + end;\n        end_count\
    \ = end * 2;\n        start = start_count;\n        end = end_count;\n       \
    \ num_count = prev_end_count * 10;\n        total = prev_total + num_count + prev_end_count;\n\
    \        prev_end_count = end_count;\n        prev_end = end;\n        prev_total\
    \ = total;\n    }\n    total", "    if n <= 0 {\n        return 0;\n    }\n  \
    \  let mut counts = vec![0; n as usize + 1];\n    counts[1] = 1;\n    for i in\
    \ 2..=n {\n        let count = (counts[(i - 1) as usize] + 1) * 10 - 1;\n    \
    \    counts[i as usize] = count;\n    }\n    counts[n as usize]", "    if n ==\
    \ 1 {\n        return 10;\n    }\n    let dp = vec![0, 9];\n    let mut dp2 =\
    \ vec![1, 9];\n    for _ in 2..=n {\n        dp2.push(dp2[dp2.len() - 1] * 10\
    \ - dp[dp.len() - 1]);\n        dp.push(dp2[dp2.len() - 1] + dp[dp.len() - 1]);\n\
    \    }\n    dp[dp.len() - 1] + dp2[dp2.len() - 1]", "    let mut m: isize = 1;\n\
    \    for _ in 0..n {\n        m *= 10;\n    }\n    let a = m / 10;\n    let b\
    \ = m - a;\n    a + b", "    if n == 1 {\n        return 1;\n    }\n    if n ==\
    \ 2 {\n        return 11;\n    }\n    let mut prev = starts_one_ends(n - 1);\n\
    \    let mut curr = prev + 2 * starts_one_ends(n - 2);\n    for i in (3..n).rev()\
    \ {\n        let tmp = curr;\n        curr = prev + 2 * curr;\n        prev =\
    \ tmp;\n    }\n    curr", "    let mut res = 0;\n    let mut num = 1;\n    let\
    \ mut i = 1;\n    while i <= n {\n        let start = num * 10;\n        let end\
    \ = num + 1;\n        res += start + end;\n        num *= 10;\n        i += 1;\n\
    \    }\n    res", "    let n = n as usize;\n    let mut a = Vec::with_capacity(n);\n\
    \    a.push(3);\n    a.push(7);\n    a.push(17);\n    for i in 3..n {\n      \
    \  a.push(a[i - 1] * 2 + a[i - 2]);\n    }\n    a[n - 1]", "    // TODO\n    0",
  "    if n <= 1 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut\
    \ power = (1..n).fold(1, |product, _| product * 10);\n    count += 9 * power;\n\
    \    power /= 10;\n    count += 9 * power;\n    return count;", "    if n == 1\
    \ {\n        return 1;\n    }\n    fn calc(n: isize, begin: bool) -> isize {\n\
    \        if n == 0 {\n            return 1;\n        }\n        if n == 1 {\n\
    \            return 1;\n        }\n        let root = calc(n - 1, false);\n  \
    \      let k = if begin { 2 } else { 1 };\n        root * 10 - k * calc(n - 2,\
    \ false)\n    }\n    let count_root = calc(n - 1, false);\n    let count_begin\
    \ = calc(n - 1, true);\n    count_root - count_begin"]
stop_tokens:
- "\n}"
