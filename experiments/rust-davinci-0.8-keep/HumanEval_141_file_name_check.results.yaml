name: HumanEval_141_file_name_check
language: rust
results:
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if !file_name.chars().all(|c| {\n        let cat =\
    \ c.category();\n        cat == GeneralCategory::Letter || cat == GeneralCategory::DecimalNumber\n\
    \    }) {\n        return \"No\".to_string();\n    }\n    let mut counter = 0;\n\
    \    let mut is_valid = false;\n    for c in file_name.chars() {\n        if c.is_digit(10)\
    \ {\n            counter += 1;\n        }\n        if c == '.' {\n           \
    \ if counter > 3 {\n                return \"No\".to_string();\n            }\n\
    \            is_valid = true;\n        }\n    }\n    if !is_valid {\n        return\
    \ \"No\".to_string();\n    }\n    let file_name: Vec<&str> = file_name.split('.').collect();\n\
    \    if file_name.len() != 2 {\n        return \"No\".to_string();\n    }\n  \
    \  if file_name[0].len() == 0 {\n        return \"No\".to_string();\n    }\n \
    \   match file_name[1] {\n        \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n\
    \        _ => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `GeneralCategory`\n\
    \  --> /tmp/tmpcm6bneso.rs:16:16\n   |\n16 |         cat == GeneralCategory::Letter\
    \ || cat == GeneralCategory::DecimalNumber\n   |                ^^^^^^^^^^^^^^^\
    \ use of undeclared type `GeneralCategory`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `GeneralCategory`\n  --> /tmp/tmpcm6bneso.rs:16:50\n\
    \   |\n16 |         cat == GeneralCategory::Letter || cat == GeneralCategory::DecimalNumber\n\
    \   |                                                  ^^^^^^^^^^^^^^^ use of\
    \ undeclared type `GeneralCategory`\n\nerror[E0599]: no method named `category`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpcm6bneso.rs:15:21\n\
    \   |\n15 |         let cat = c.category();\n   |                     ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|&ch| ch.is_digit(10)).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    if file_name.find('.').unwrap_or(file_name.len())\
    \ == file_name.len() {\n        return \"No\".to_string();\n    }\n    let (p1,\
    \ p2) = file_name.split_at(file_name.find('.').unwrap());\n    if p1.is_empty()\
    \ || !p1.chars().nth(0).unwrap().is_alphabetic() {\n        return \"No\".to_string();\n\
    \    }\n    if p2 != \".txt\" && p2 != \".exe\" && p2 != \".dll\" {\n        return\
    \ \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut is_valid = true;\n    let mut number_of_digits\
    \ = 0;\n    let mut is_dot_present = false;\n    let mut has_non_empty_prefix\
    \ = false;\n    let mut has_valid_suffix = false;\n    for c in file_name.chars()\
    \ {\n        match c {\n            '0'..='9' => number_of_digits += 1,\n    \
    \        '.' => is_dot_present = true,\n            'a'..='z' | 'A'..='Z' => has_non_empty_prefix\
    \ = true,\n            _ => is_valid = false,\n        }\n        if number_of_digits\
    \ > 3 {\n            is_valid = false;\n        }\n    }\n    if is_dot_present\
    \ && has_non_empty_prefix {\n        let file_name_without_extension = &file_name[..file_name.len()\
    \ - 4];\n        if file_name_without_extension.contains('.') {\n            is_valid\
    \ = false;\n        }\n        let extension = &file_name[file_name.len() - 3..];\n\
    \        if extension == \"txt\" || extension == \"exe\" || extension == \"dll\"\
    \ {\n            has_valid_suffix = true;\n        }\n    }\n    if !is_dot_present\
    \ || !has_non_empty_prefix || !has_valid_suffix {\n        is_valid = false;\n\
    \    }\n    if is_valid {\n        \"Yes\".to_string()\n    } else {\n       \
    \ \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmphp97sblh.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet mut digit_counter = 0;\n\tlet mut dot_counter = 0;\n\
    \tlet mut latin_letter_counter = 0;\n\tlet mut has_number = false;\n\tlet mut\
    \ extension = String::new();\n\tlet mut substring_before_dot = String::new();\n\
    \tfor i in file_name.chars() {\n\t\tif i.is_numeric() {\n\t\t\thas_number = true;\n\
    \t\t\tdigit_counter += 1;\n\t\t}\n\t\tif i == '.' {\n\t\t\tdot_counter += 1;\n\
    \t\t}\n\t\tif i.is_alphabetic() {\n\t\t\tlatin_letter_counter += 1;\n\t\t}\n\t\
    }\n\tif latin_letter_counter == 0 {\n\t\treturn \"No\".to_string();\n\t}\n\tif\
    \ digit_counter > 3 {\n\t\treturn \"No\".to_string();\n\t}\n\tif dot_counter >\
    \ 1 {\n\t\treturn \"No\".to_string();\n\t}\n\tlet mut count = 0;\n\tfor i in file_name.chars()\
    \ {\n\t\tif i == '.' {\n\t\t\tbreak;\n\t\t}\n\t\tsubstring_before_dot.push(i);\n\
    \t\tcount += 1;\n\t}\n\tfor i in count..file_name.len() {\n\t\textension.push(file_name.chars().nth(i).unwrap());\n\
    \t}\n\tlet accepted_extensions = [\"txt\", \"exe\", \"dll\"];\n\tfor i in accepted_extensions.iter()\
    \ {\n\t\tif extension == *i {\n\t\t\treturn \"Yes\".to_string();\n\t\t}\n\t}\n\
    \t\"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp81jwfl03.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tif !file_name.contains('.') {\n\t\treturn \"No\".to_string();\n\
    \t}\n\tlet file_name: Vec<_> = file_name.split('.').collect();\n\tlet part_one\
    \ = file_name[0];\n\tlet part_two = file_name[1];\n\tlet mut digits_count = 0;\n\
    \tlet mut alphapet_count = 0;\n\tlet mut dot_count = 0;\n\tfor c in part_one.chars()\
    \ {\n\t\tif c.is_alphabetic() {\n\t\t\talphapet_count += 1;\n\t\t} else if c.is_digit(10)\
    \ {\n\t\t\tdigits_count += 1;\n\t\t} else if c == '.' {\n\t\t\tdot_count += 1;\n\
    \t\t}\n\t}\n\tif digits_count > 3 || alphapet_count == 0 || dot_count > 1 {\n\t\
    \treturn \"No\".to_string();\n\t}\n\tif part_two != \"txt\" && part_two != \"\
    exe\" && part_two != \"dll\" {\n\t\treturn \"No\".to_string();\n\t}\n\treturn\
    \ \"Yes\".to_string();\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp_xn93ncj.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let words: Vec<&str> = file_name.split('.').collect();\n\
    \    if words.len() != 2 {\n        return \"No\".to_string();\n    }\n    if\
    \ words[0].len() == 0 {\n        return \"No\".to_string();\n    }\n    let first_word\
    \ = words[0];\n    let count = first_word.chars().filter(|c| c.is_digit(10)).count();\n\
    \    if count > 3 {\n        return \"No\".to_string();\n    }\n    let first_char\
    \ = first_word.chars().next().unwrap();\n    if first_char.is_digit(10) {\n  \
    \      return \"No\".to_string();\n    }\n    if !first_char.is_ascii_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if words[1] != \"txt\" &&\
    \ words[1] != \"exe\" && words[1] != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() == 0 {\n        return \"No\".to_string();\n\
    \    }\n    let mut split_file_name = file_name.split(\".\");\n    let mut digits_count\
    \ = 0;\n    let mut position = 0;\n    let mut before_dot = String::new();\n \
    \   let mut after_dot = String::new();\n    for c in file_name.chars() {\n   \
    \     if c.is_ascii_digit() {\n            digits_count += 1;\n        }\n   \
    \     if c == '.' {\n            before_dot = file_name[0..position].to_string();\n\
    \            after_dot = file_name[position + 1..file_name.len()].to_string();\n\
    \        }\n        position += 1;\n    }\n    if digits_count > 3 {\n       \
    \ return \"No\".to_string();\n    }\n    if file_name.find('.') == None {\n  \
    \      return \"No\".to_string();\n    }\n    if before_dot.len() == 0 || !before_dot.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if after_dot != \"txt\" &&\
    \ after_dot != \"exe\" && after_dot != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    return \"Yes\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp_qvvuwoz.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"(?i)^[a-z]{1}[\\w]+\\.txt$|^[a-z]{1}[\\\
    w]+\\.exe$|^[a-z]{1}[\\w]+\\.dll$\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmptgdbtiyn.rs:14:14\n   |\n14 |     let re = Regex::new(r\"(?i)^[a-z]{1}[\\\
    w]+\\.txt$|^[a-z]{1}[\\w]+\\.exe$|^[a-z]{1}[\\w]+\\.dll$\").unwrap();\n   |  \
    \            ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet mut has_dot = false;\n\tlet mut digit_count = 0;\n\
    \tlet mut latin_letter_encountered = false;\n\tlet mut after_dot = false;\n\t\
    let mut is_valid = true;\n\tlet mut correct_extension = false;\n\tfor c in file_name.chars()\
    \ {\n\t\tif c == '.' {\n\t\t\thas_dot = true;\n\t\t\tafter_dot = true;\n\t\t}\
    \ else if c.is_ascii_digit() {\n\t\t\tdigit_count += 1;\n\t\t\tif digit_count\
    \ > 3 {\n\t\t\t\tis_valid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if !latin_letter_encountered\
    \ && c.is_ascii_alphabetic() {\n\t\t\tlatin_letter_encountered = true;\n\t\t}\
    \ else if after_dot {\n\t\t\tif file_name.len() - file_name.find('.').unwrap()\
    \ == 5 &&\n\t\t\t\t&file_name[(file_name.find('.').unwrap() + 1)..] == \"txt\"\
    \ ||\n\t\t\t\t&file_name[(file_name.find('.').unwrap() + 1)..] == \"exe\" ||\n\
    \t\t\t\t&file_name[(file_name.find('.').unwrap() + 1)..] == \"dll\" {\n\t\t\t\t\
    correct_extension = true;\n\t\t\t} else {\n\t\t\t\tis_valid = false;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t}\n\tif has_dot && latin_letter_encountered && correct_extension\
    \ {\n\t\treturn \"Yes\".to_string();\n\t}\n\t\"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp6v_u926y.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // your code goes here.\n    // use std::io::Write;\n\
    \    // let mut w = std::io::stdout();\n    // writeln!(w, \"{}\", file_name);\n\
    \    // w.flush();\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Yes\"`', /tmp/tmpw5ohssi7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tif file_name.matches(char::is_digit).count() > 3 {\n\t\
    \treturn \"No\".to_string();\n\t}\n\n\tlet dot_index = file_name.find('.').unwrap();\n\
    \tlet dot_suffix = &file_name[dot_index+1..];\n\tlet allowed_suffixes = [\"txt\"\
    , \"exe\", \"dll\"];\n\tif dot_suffix.len() < 3 || !allowed_suffixes.contains(&dot_suffix)\
    \ {\n\t\treturn \"No\".to_string();\n\t}\n\n\tlet prefix = &file_name[..dot_index];\n\
    \tif prefix.len() == 0 || !prefix.chars().next().unwrap().is_alphabetic() {\n\t\
    \treturn \"No\".to_string();\n\t}\n\n\t\"Yes\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n\
    \    --> /tmp/tmpdr2ag3kp.rs:14:23\n     |\n14   |     if file_name.matches(char::is_digit).count()\
    \ > 3 {\n     |                  ------- ^^^^^^^^^^^^^^ expected function that\
    \ takes 1 argument\n     |                  |\n     |                  required\
    \ by a bound introduced by this call\n     |\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `fn(char, u32) -> bool {char::methods::<impl\
    \ char>::is_digit}`\nnote: required by a bound in `core::str::<impl str>::matches`\n\
    \nerror[E0599]: the method `count` exists for struct `Matches<'_, fn(char, u32)\
    \ -> bool {char::methods::<impl char>::is_digit}>`, but its trait bounds were\
    \ not satisfied\n    --> /tmp/tmpdr2ag3kp.rs:14:39\n     |\n14   |       if file_name.matches(char::is_digit).count()\
    \ > 3 {\n     |                                            ^^^^^ method cannot\
    \ be called on `Matches<'_, fn(char, u32) -> bool {char::methods::<impl char>::is_digit}>`\
    \ due to unsatisfied trait bounds\n     |\n     = note: the following trait bounds\
    \ were not satisfied:\n             `fn(char, u32) -> bool {char::methods::<impl\
    \ char>::is_digit}: Pattern<'_>`\n             which is required by `Matches<'_,\
    \ fn(char, u32) -> bool {char::methods::<impl char>::is_digit}>: Iterator`\n \
    \            `Matches<'_, fn(char, u32) -> bool {char::methods::<impl char>::is_digit}>:\
    \ Iterator`\n             which is required by `&mut Matches<'_, fn(char, u32)\
    \ -> bool {char::methods::<impl char>::is_digit}>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0593, E0599.\n\
    For more information about an error, try `rustc --explain E0593`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut dot_counter = 0;\n\
    \    let mut dot_position = file_name.len();\n    let mut last_char_flag = false;\n\
    \    let mut last_char = file_name.chars().last().unwrap();\n    let mut result\
    \ = true;\n    let mut word_before_dot = \"\".to_string();\n    let mut word_after_dot\
    \ = \"\".to_string();\n    for (index, c) in file_name.chars().enumerate() {\n\
    \        if c == '.' {\n            dot_counter += 1;\n            dot_position\
    \ = index;\n        }\n        if c.is_digit(10) {\n            counter += 1;\n\
    \        }\n        if counter > 3 {\n            result = false;\n        }\n\
    \        if c == '.' && (index + 1) < file_name.len() {\n            last_char_flag\
    \ = true;\n        }\n    }\n    if counter > 3 {\n        result = false;\n \
    \   }\n    if dot_counter != 1 {\n        result = false;\n    }\n    if dot_position\
    \ == 0 {\n        result = false;\n    }\n    if last_char_flag {\n        last_char\
    \ = file_name.chars().nth(file_name.len() - 2).unwrap();\n    }\n    if !last_char.is_alphabetic()\
    \ {\n        result = false;\n    }\n    if result {\n        let mut i = 0;\n\
    \        while i < dot_position {\n            word_before_dot.push(file_name.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n        let mut i = dot_position + 1;\n     \
    \   while i < file_name.len() {\n            word_after_dot.push(file_name.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n        if word_after_dot != \"txt\" && word_after_dot\
    \ != \"exe\" && word_after_dot != \"dll\" {\n            result = false;\n   \
    \     }\n        if !word_before_dot.chars().nth\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpshhpvla1.rs:97:3\n\
    \   |\n13 | fn file_name_check(file_name: String) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n52 |     if\
    \ result {\n   |               - this delimiter might not be properly closed...\n\
    ...\n67 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    97 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpshhpvla1.rs:67:1\n\
    \   |\n66 |         if !word_before_dot.chars().nth\n   |         -- this `if`\
    \ expression has a condition, but no block\n67 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpshhpvla1.rs:13:42\n   |\n13 | fn file_name_check(file_name:\
    \ String) -> String {\n   |    ---------------                       ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n\
    \    let mut is_valid = true;\n    let valid_extensions = [\"txt\", \"exe\", \"\
    dll\"];\n    let mut extension = None;\n    let mut has_valid_extension = false;\n\
    \n    let mut chars = file_name.chars();\n    // handle name prefix\n    while\
    \ let Some(ch) = chars.next() {\n        if ch == '.' {\n            dot_count\
    \ += 1;\n            break;\n        }\n        if ch.is_numeric() {\n       \
    \     digit_count += 1;\n        }\n        if digit_count > 3 {\n           \
    \ is_valid = false;\n            break;\n        }\n        if ch.is_alphabetic()\
    \ {\n            if !ch.is_ascii_alphabetic() {\n                is_valid = false;\n\
    \                break;\n            }\n        } else {\n            is_valid\
    \ = false;\n            break;\n        }\n    }\n    // handle extension\n  \
    \  while let Some(ch) = chars.next() {\n        if ch == '.' {\n            dot_count\
    \ += 1;\n            continue;\n        }\n        if let Some(ext) = extension\
    \ {\n            extension = Some(format!(\"{}{}\", ext, ch));\n        } else\
    \ {\n            extension = Some(ch.to_string());\n        }\n    }\n    if extension.is_some()\
    \ {\n        if valid_extensions.contains(&extension.as_ref().unwrap().as_str())\
    \ {\n            has_valid_extension = true;\n        }\n    }\n    if dot_count\
    \ != 1 || !has_valid_extension || !is_valid {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpxwd1z77x.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let (before_dot, after_dot) = file_name.split_at(file_name.find('.').unwrap());\n\
    \    match (before_dot.len(), after_dot) {\n        (0, _) => String::from(\"\
    No\"),\n        (_, \"\") => String::from(\"No\"),\n        (_, \".txt\") | (_,\
    \ \".exe\") | (_, \".dll\") => String::from(\"Yes\"),\n        _ => String::from(\"\
    No\"),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpbbz6zhyk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp738n7qeb.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut num_digits = 0;\n    let mut num_dots = 0;\n\
    \    let mut has_alpha = false;\n    let mut has_ext = false;\n    let ext = [\"\
    txt\", \"exe\", \"dll\"];\n    for c in file_name.chars() {\n        match c {\n\
    \            '0'..='9' => num_digits += 1,\n            '.' => num_dots += 1,\n\
    \            'a'..='z' | 'A'..='Z' => has_alpha = true,\n            _ => (),\n\
    \        }\n    }\n    if num_digits > 3 || num_dots != 1 || !has_alpha {\n  \
    \      return \"No\".to_string();\n    }\n    for ext_str in ext.iter() {\n  \
    \      if file_name.ends_with(ext_str) {\n            has_ext = true;\n      \
    \      break;\n        }\n    }\n    if has_ext {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprxfte4sz.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.is_empty() {\n        return \"No\".to_string();\n\
    \    }\n    let mut valid = true;\n    let mut num_digits = 0;\n    let mut num_dots\
    \ = 0;\n    let mut starts_with_alpha = false;\n    let mut substring_after_dot\
    \ = \"\".to_string();\n    for ch in file_name.chars() {\n        if ch.is_alphabetic()\
    \ {\n            starts_with_alpha = true;\n        }\n        if ch.is_digit(10)\
    \ {\n            num_digits += 1;\n        }\n        if ch == '.' {\n       \
    \     num_dots += 1;\n        }\n        if num_dots == 1 {\n            substring_after_dot.push(ch);\n\
    \        }\n    }\n    valid = valid && starts_with_alpha && num_digits <= 3 &&\
    \ num_dots == 1;\n    let valid_substring_after_dot = substring_after_dot == \"\
    txt\" || substring_after_dot == \"exe\" || substring_after_dot == \"dll\";\n \
    \   valid = valid && valid_substring_after_dot;\n    if valid {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4hl0o9fs.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let dot_index = file_name.find('.').unwrap();\n   \
    \ let extension = &file_name[dot_index+1..];\n    let extension_arr = [\"txt\"\
    , \"exe\", \"dll\"];\n    let first_part = &file_name[..dot_index];\n    let non_digit_count\
    \ = first_part.chars().filter(|x| !x.is_digit(10)).count();\n    let digit_count\
    \ = first_part.chars().filter(|x| x.is_digit(10)).count();\n    if digit_count\
    \ > 3 || non_digit_count == 0 || !first_part.chars().nth(0).unwrap().is_alphabetic()\
    \ || !extension_arr.contains(&extension) {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpxm_dij1v.rs:14:41\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Unimplemented!();\n    let chars: Vec<char> = file_name.chars().collect();\n\
    \    let mut digits = 0;\n    let mut dot_count = 0;\n    let mut dot_position\
    \ = 0;\n    let mut result = \"\";\n    for i in 0..chars.len() {\n        if\
    \ chars[i].is_digit(10) {\n            digits += 1;\n        }\n        if chars[i]\
    \ == '.' {\n            dot_count += 1;\n            dot_position = i;\n     \
    \   }\n    }\n    if digits > 3 || dot_count != 1 || chars[0].is_digit(10) {\n\
    \        result = \"No\";\n    } else {\n        let prefix = file_name.get(0..dot_position).unwrap();\n\
    \        if prefix.len() == 0 {\n            result = \"No\";\n        } else\
    \ {\n            let suffix = file_name.get(dot_position + 1..file_name.len()).unwrap();\n\
    \            if suffix == \"txt\" || suffix == \"exe\" || suffix == \"dll\" {\n\
    \                result = \"Yes\";\n            } else {\n                result\
    \ = \"No\";\n            }\n        }\n    }\n    result.to_string()\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpwvfa_pgu.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: Implement me!\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpekce7sb0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgdsov6ns.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut ans = \"No\".to_string();\n    let mut digits\
    \ = 0;\n    let mut has_dot = false;\n    let mut first_part = String::new();\n\
    \    let mut last_part = String::new();\n    for c in file_name.chars() {\n  \
    \      if c == '.' {\n            has_dot = true;\n        } else if c >= '0'\
    \ && c <= '9' {\n            digits += 1;\n        } else if has_dot {\n     \
    \       last_part.push(c);\n        } else {\n            first_part.push(c);\n\
    \        }\n    }\n    if digits <= 3 && has_dot && !first_part.is_empty() &&\
    \ first_part.chars().next().unwrap().is_ascii_alphabetic() &&\n        last_part\
    \ == \"txt\" || last_part == \"exe\" || last_part == \"dll\" {\n        ans =\
    \ \"Yes\".to_string();\n    }\n    ans\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpyxfo7us7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpx__ctsrd.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6p2lafru.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut count = 0;\n    let mut first_is_digit = false;\n\
    \    let mut first_dot_pos = -1;\n    let mut found_dot = false;\n    let mut\
    \ dot_pos = -1;\n    let mut char_pos = 0;\n    for c in file_name.chars() {\n\
    \        if c.is_digit(10) {\n            count += 1;\n            if char_pos\
    \ == 0 {\n                first_is_digit = true;\n            }\n        }\n \
    \       if c == '.' {\n            if !found_dot {\n                found_dot\
    \ = true;\n                dot_pos = char_pos;\n            } else {\n       \
    \         return \"No\".to_string();\n            }\n        }\n        char_pos\
    \ += 1;\n    }\n    if count > 3 {\n        return \"No\".to_string();\n    }\n\
    \    if !found_dot {\n        return \"No\".to_string();\n    }\n    if dot_pos\
    \ == 0 {\n        return \"No\".to_string();\n    }\n    if first_is_digit {\n\
    \        return \"No\".to_string();\n    }\n    let extension = &file_name[dot_pos+1..];\n\
    \    if extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n\
    \        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpa1001gj_.rs:18:23\n\
    \   |\n18 |     let mut dot_pos = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let s: String = String::from(file_name);\n    let mut\
    \ count: i32 = 0;\n    for i in s.chars() {\n        if i.is_ascii_digit() {\n\
    \            count += 1;\n        }\n    }\n    if count > 3 {\n        String::from(\"\
    No\")\n    } else {\n        String::from(\"Yes\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp683_pnow.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwg4b_5gn.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphcca77mn.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|&c| c.is_digit(10)).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let parts: Vec<&str> =\
    \ file_name.split('.').collect();\n    if parts.len() != 2 {\n        return \"\
    No\".to_string();\n    }\n    if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if !vec![\"txt\", \"exe\"\
    , \"dll\"].contains(&parts[1]) {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let allowed_extension = [\"txt\", \"exe\", \"dll\"\
    ];\n    let parts: Vec<&str> = file_name.split(\".\").collect();\n    let digits:\
    \ Vec<char> = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let\
    \ allowed_chars: Vec<char> = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    if parts.len()\
    \ != 2 || parts[0].len() == 0 || parts[1].len() == 0 {\n        return \"No\"\
    .to_string();\n    }\n    if parts[0].chars().filter(|c| digits.contains(c)).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    if !allowed_chars.contains(&parts[0].chars().next().unwrap())\
    \ {\n        return \"No\".to_string();\n    }\n    if !allowed_extension.contains(&parts[1])\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpeojyy8fi.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpp5b4chw4.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits_count = 0;\n    let mut dot_count =\
    \ 0;\n    let mut alphabet_count = 0;\n    let mut latin_alphabet_count = 0;\n\
    \    let mut prefix = String::new();\n    let mut suffix = String::new();\n  \
    \  let chars = file_name.chars();\n    for c in chars {\n        if c == '.' {\n\
    \            dot_count += 1;\n        } else if c >= '0' && c <= '9' {\n     \
    \       digits_count += 1;\n        } else if c >= 'a' && c <= 'z' {\n       \
    \     alphabet_count += 1;\n            latin_alphabet_count += 1;\n        }\
    \ else if c >= 'A' && c <= 'Z' {\n            alphabet_count += 1;\n         \
    \   latin_alphabet_count += 1;\n        }\n    }\n    if digits_count > 3 || latin_alphabet_count\
    \ == 0 || dot_count != 1 {\n        return String::from(\"No\");\n    }\n    if\
    \ latin_alphabet_count > 1 {\n        let mut dot_find = 0;\n        for c in\
    \ chars {\n            if c == '.' {\n                dot_find += 1;\n       \
    \     } else if dot_find == 0 {\n                prefix.push(c);\n           \
    \ } else if dot_find == 1 {\n                suffix.push(c);\n            }\n\
    \        }\n    }\n    let suffix_list = [\"txt\", \"exe\", \"dll\"];\n    for\
    \ suffix_check in suffix_list.iter() {\n        if suffix == suffix_check.to_string()\
    \ {\n            return String::from(\"Yes\");\n        }\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "warning: variable `alphabet_count` is assigned to, but never used\n  -->\
    \ /tmp/tmpjqbq9sw7.rs:16:13\n   |\n16 |     let mut alphabet_count = 0;\n   |\
    \             ^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n   = note: consider using `_alphabet_count` instead\n\nerror[E0382]:\
    \ use of moved value: `chars`\n   --> /tmp/tmpjqbq9sw7.rs:39:18\n    |\n20  |\
    \     let chars = file_name.chars();\n    |         ----- move occurs because\
    \ `chars` has type `Chars<'_>`, which does not implement the `Copy` trait\n21\
    \  |     for c in chars {\n    |              ----- `chars` moved due to this\
    \ implicit call to `.into_iter()`\n...\n39  |         for c in chars {\n    |\
    \                  ^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `chars`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet mut letters_count = 0;\n\tlet mut digits_count =\
    \ 0;\n\tlet mut dots_count = 0;\n\tlet mut extension_index = -1;\n\tlet mut valid_extension\
    \ = false;\n\tlet mut index = 0;\n\tfor c in file_name.chars() {\n\t\tif c.is_alphabetic()\
    \ {\n\t\t\tletters_count += 1;\n\t\t}\n\t\tif c.is_digit(10) {\n\t\t\tdigits_count\
    \ += 1;\n\t\t}\n\t\tif c == '.' {\n\t\t\tdots_count += 1;\n\t\t\textension_index\
    \ = index;\n\t\t}\n\t\tindex += 1;\n\t}\n\tlet extension = &file_name[extension_index\
    \ + 1..];\n\tif extension == \"txt\" || extension == \"exe\" || extension == \"\
    dll\" {\n\t\tvalid_extension = true;\n\t}\n\tif digits_count <= 3 && dots_count\
    \ == 1 && letters_count > 0 && valid_extension {\n\t\t\"Yes\".to_string()\n\t\
    } else {\n\t\t\"No\".to_string()\n\t}\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpi7e8we61.rs:17:28\n\
    \   |\n17 |     let mut extension_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let chars = file_name.chars().collect::<Vec<char>>();\n\
    \    let mut dot_pos = 0;\n    let mut digit_count = 0;\n    let mut lower_case_letter_count\
    \ = 0;\n    let mut upper_case_letter_count = 0;\n    for (i, c) in chars.iter().enumerate()\
    \ {\n        match c {\n            '.' => dot_pos = i,\n            '0'..='9'\
    \ => digit_count += 1,\n            'a'..='z' => lower_case_letter_count += 1,\n\
    \            'A'..='Z' => upper_case_letter_count += 1,\n            _ => return\
    \ \"No\".to_string(),\n        }\n    }\n    if digit_count > 3 || dot_pos ==\
    \ 0 || lower_case_letter_count == 0 && upper_case_letter_count == 0 {\n      \
    \  return \"No\".to_string();\n    }\n    let extension = file_name.chars().skip(dot_pos\
    \ + 1).collect::<String>();\n    if extension == \"txt\" || extension == \"exe\"\
    \ || extension == \"dll\" {\n        return \"Yes\".to_string();\n    }\n    \"\
    No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n   \
    \ assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n\
    \    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpo74dzyd0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: implement this function\n    if file_name.starts_with(char::is_numeric)\
    \ {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmphbazyul_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp95jxjs_a.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() < 5 {\n        return \"No\".to_string();\n\
    \    }\n    let dot_pos = file_name.find('.').unwrap();\n    if dot_pos == 0 ||\
    \ dot_pos == file_name.len() - 1 {\n        return \"No\".to_string();\n    }\n\
    \    if !file_name[..dot_pos].chars().all(|c| c.is_alphabetic()) {\n        return\
    \ \"No\".to_string();\n    }\n    if file_name[..dot_pos].chars().filter(|c| c.is_numeric()).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    if file_name[dot_pos+1..]\
    \ != \"txt\" && file_name[dot_pos+1..] != \"exe\" && file_name[dot_pos+1..] !=\
    \ \"dll\" {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpsucflgc2.rs:27:31\n\
    \   |\n27 |     if file_name[dot_pos+1..] != \"txt\" && file_name[dot_pos+1..]\
    \ != \"exe\" && file_name[dot_pos+1..] != \"dll\" {\n   |                    \
    \           ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `str` with `&str`\n  -->\
    \ /tmp/tmpsucflgc2.rs:27:66\n   |\n27 |     if file_name[dot_pos+1..] != \"txt\"\
    \ && file_name[dot_pos+1..] != \"exe\" && file_name[dot_pos+1..] != \"dll\" {\n\
    \   |                                                                  ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmpsucflgc2.rs:27:101\n   |\n27 |     if file_name[dot_pos+1..]\
    \ != \"txt\" && file_name[dot_pos+1..] != \"exe\" && file_name[dot_pos+1..] !=\
    \ \"dll\" {\n   |                                                            \
    \                                         ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  ="
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptul1zdqq.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let regex_digit = regex::Regex::new(r\"\\d\").unwrap();\n\
    \    let regex_dot = regex::Regex::new(r\"\\.\").unwrap();\n    let regex_extensions\
    \ = regex::Regex::new(r\"txt|exe|dll\").unwrap();\n    let regex_letter = regex::Regex::new(r\"\
    [a-zA-Z]\").unwrap();\n    let mut has_dot = false;\n    let mut digit_count =\
    \ 0;\n    let mut letter_count = 0;\n    let mut extension_count = 0;\n    for\
    \ c in file_name.chars() {\n        match c {\n            '0'...'9' => digit_count\
    \ += 1,\n            '.' => has_dot = true,\n            'a'...'z' | 'A'...'Z'\
    \ => letter_count += 1,\n            _ => return \"No\".to_string(),\n       \
    \ }\n    }\n    if digit_count > 3 {\n        return \"No\".to_string();\n   \
    \ }\n    if !has_dot {\n        return \"No\".to_string();\n    }\n    let mut\
    \ names: Vec<&str> = file_name.split('.').collect();\n    if names.len() != 2\
    \ {\n        return \"No\".to_string();\n    }\n    if !regex_extensions.is_match(names[1])\
    \ {\n        return \"No\".to_string();\n    }\n    if !regex_letter.is_match(names[0])\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmpnop7lrul.rs:14:23\n   |\n14 |     let regex_digit = regex::Regex::new(r\"\
    \\d\").unwrap();\n   |                       ^^^^^ use of undeclared crate or\
    \ module `regex`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `regex`\n  --> /tmp/tmpnop7lrul.rs:15:21\n   |\n15 |     let regex_dot\
    \ = regex::Regex::new(r\"\\.\").unwrap();\n   |                     ^^^^^ use\
    \ of undeclared crate or module `regex`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `regex`\n  --> /tmp/tmpnop7lrul.rs:16:28\n   |\n\
    16 |     let regex_extensions = regex::Regex::new(r\"txt|exe|dll\").unwrap();\n\
    \   |                            ^^^^^ use of undeclared crate or module `regex`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmpnop7lrul.rs:17:24\n   |\n17 |     let regex_letter = regex::Regex::new(r\"\
    [a-zA-Z]\").unwrap();\n   |                        ^^^^^ use of undeclared crate\
    \ or module `regex`\n\nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpnop7lrul.rs:24:16\n\
    \   |\n24 |             '0'...'9' => digit_count += 1,\n   |                ^^^\
    \ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpnop7lrul.rs:26:16\n\
    \   |\n26 |             'a'...'z' | 'A'...'Z' => letter_count += 1,\n   |    \
    \            ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this\
    \ is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpnop7lrul.rs:26:28\n\
    \   |\n26 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpn462ab6o.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n    let\
    \ [name, extension] = &parts;\n    if !name.chars().any(|c| c.is_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    if name.chars().filter(|c|\
    \ c.is_numeric()).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   if !extension.is_empty() && [\"txt\", \"exe\", \"dll\"].contains(&extension)\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0529]: expected an array or slice, found `Vec<&str>`\n  --> /tmp/tmpz_xn4wm7.rs:18:9\n\
    \   |\n18 |     let [name, extension] = &parts;\n   |         ^^^^^^^^^^^^^^^^^\
    \   ------ help: consider slicing here: `&parts[..]`\n   |         |\n   |   \
    \      pattern cannot match with input type `Vec<&str>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0529`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits_cnt = 0;\n    let mut dot_pos = 0;\n\
    \    let mut letters_cnt = 0;\n    let mut after_dot = false;\n    let mut found_dot\
    \ = false;\n    for (i, ch) in file_name.chars().enumerate() {\n        if !after_dot\
    \ {\n            if ch == '.' {\n                found_dot = true;\n         \
    \       after_dot = true;\n                dot_pos = i;\n            } else if\
    \ ch.is_numeric() {\n                digits_cnt += 1;\n            } else if ch.is_alphabetic()\
    \ {\n                letters_cnt += 1;\n            }\n        } else {\n    \
    \        if found_dot && digits_cnt > 3 && letters_cnt == 0 {\n              \
    \  return \"No\".to_string();\n            } else if !found_dot && digits_cnt\
    \ > 3 {\n                return \"No\".to_string();\n            } else if i -\
    \ dot_pos != 4 {\n                return \"No\".to_string();\n            } else\
    \ if &file_name[dot_pos + 1..i + 1] != \"txt\" \n                && &file_name[dot_pos\
    \ + 1..i + 1] != \"exe\" \n                && &file_name[dot_pos + 1..i + 1] !=\
    \ \"dll\" {\n                return \"No\".to_string();\n            }\n     \
    \   }\n    }\n    if digits_cnt > 3 || letters_cnt == 0 {\n        return \"No\"\
    .to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmppunl4ljx.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if !(file_name.chars().all(|x| x.is_alphabetic() ||\
    \ x.is_digit() || x == '.')) {\n        return \"No\".to_string();\n    }\n  \
    \  let elems: Vec<_> = file_name.split('.').collect();\n    if elems.len() !=\
    \ 2 {\n        return \"No\".to_string();\n    }\n    if elems[0].chars().count()\
    \ == 0 {\n        return \"No\".to_string();\n    }\n    if elems[0].chars().next().unwrap().is_digit(10)\
    \ {\n        return \"No\".to_string();\n    }\n    if elems[0].chars().filter(|x|\
    \ x.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   if elems[1] != \"txt\" && elems[1] != \"exe\" && elems[1] != \"dll\" {\n \
    \       return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp9eobv_yv.rs:14:59\n    |\n14  |     if !(file_name.chars().all(|x|\
    \ x.is_alphabetic() || x.is_digit() || x == '.')) {\n    |                   \
    \                                        ^^^^^^^^- supplied 0 arguments\n    |\
    \                                                           |\n    |         \
    \                                                  expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n  let mut digits = 0;\n  let mut dot = false;\n  let mut\
    \ valid_extension = false;\n  let mut file_name_valid = false;\n  let mut extension_start_index\
    \ = 0;\n  let mut extension_end_index = 0;\n  let mut valid_file_name = false;\n\
    \  let mut name_start_index = 0;\n  let mut name_end_index = 0;\n  let mut valid_name\
    \ = false;\n  for (i, char) in file_name.chars().enumerate() {\n    if char.is_digit(10)\
    \ {\n      digits += 1;\n    }\n    if digits > 3 {\n      return \"No\".to_string();\n\
    \    }\n    if !valid_file_name && char.is_alphabetic() {\n      valid_file_name\
    \ = true;\n      name_start_index = i;\n    }\n    if char == '.' {\n      dot\
    \ = true;\n      if valid_file_name {\n        name_end_index = i;\n        valid_name\
    \ = true;\n      }\n      extension_start_index = i + 1;\n    }\n    if i == file_name.len()\
    \ - 1 {\n      extension_end_index = i + 1;\n    }\n  }\n  if !dot {\n    return\
    \ \"No\".to_string();\n  }\n  if !valid_name {\n    return \"No\".to_string();\n\
    \  }\n  let extension = &file_name[extension_start_index..extension_end_index];\n\
    \  if extension == \"txt\" || extension == \"exe\" || extension == \"dll\" {\n\
    \    valid_extension = true;\n  }\n  if valid_extension {\n    return \"Yes\"\
    .to_string();\n  }\n  \"No\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmptqiaqv07.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpviaxynh0.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let valid_extensions = [\".txt\", \".exe\", \".dll\"\
    ];\n    let digits_count = file_name.chars().filter(|&c| c.is_digit(10)).count();\n\
    \    if digits_count > 3 {\n        return \"No\".to_string();\n    }\n    let\
    \ parts: Vec<&str> = file_name.split('.').collect();\n    if parts.len() != 2\
    \ {\n        return \"No\".to_string();\n    }\n    if parts[0].is_empty() ||\
    \ !parts[0].chars().next().unwrap().is_alphabetic() {\n        return \"No\".to_string();\n\
    \    }\n    if !valid_extensions.contains(&parts[1]) {\n        return \"No\"\
    .to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpkyo6bxk8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphvcgi3v1.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let file_name = file_name.to_string();\n    let dot_index\
    \ = file_name.find('.').unwrap();\n    let sub_string_before_dot = &file_name[0..dot_index];\n\
    \    let sub_string_after_dot = &file_name[dot_index+1..];\n    let mut is_valid_name\
    \ = false;\n    let mut count_digit = 0;\n    if sub_string_before_dot.len() ==\
    \ 0 {\n        is_valid_name = false;\n    } else {\n        for c in sub_string_before_dot.chars()\
    \ {\n            if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n  \
    \              is_valid_name = false;\n                break;\n            } else\
    \ {\n                is_valid_name = true;\n            }\n        }\n    }\n\
    \    for c in sub_string_after_dot.chars() {\n        if c >= '0' && c <= '9'\
    \ {\n            count_digit += 1;\n        }\n    }\n    if count_digit > 3 {\n\
    \        is_valid_name = false;\n    }\n    if !(sub_string_after_dot == \"txt\"\
    \ || sub_string_after_dot == \"exe\" || sub_string_after_dot == \"dll\") {\n \
    \       is_valid_name = false;\n    }\n    if is_valid_name {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1_9yeuvi.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_qgezkyd.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut valid_name = false;\n    let mut valid_extension\
    \ = false;\n    let mut digits_count = 0;\n    let mut dot_count = 0;\n    for\
    \ (i, c) in file_name.chars().enumerate() {\n        if i == 0 {\n           \
    \ valid_name = c.is_alphabetic();\n        } else if c == '.' {\n            dot_count\
    \ += 1;\n        } else if c.is_numeric() {\n            digits_count += 1;\n\
    \        }\n    }\n    let mut split = file_name.split('.');\n    let name = split.next().unwrap();\n\
    \    let extension = split.next().unwrap();\n    valid_extension = match extension\
    \ {\n        \"txt\" | \"exe\" | \"dll\" => true,\n        _ => false,\n    };\n\
    \    if valid_name && digits_count <= 3 && dot_count == 1 && valid_extension {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpxrroh8ib.rs:29:34\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.contains(\".\") {\n        let parts:\
    \ Vec<&str> = file_name.split(\".\").collect();\n        if parts.len() == 2 &&\
    \ parts[0].len() > 0 {\n            let extensions = [\"txt\", \"exe\", \"dll\"\
    ];\n            if extensions.contains(&parts[1]) {\n                let mut digits\
    \ = 0;\n                for ch in parts[0].chars() {\n                    if ch.is_digit(10)\
    \ {\n                        digits += 1;\n                    }\n           \
    \     }\n                if digits > 3 {\n                    return \"No\".to_string();\n\
    \                }\n                if parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n                    return \"Yes\".to_string();\n                }\n    \
    \        }\n        }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^([a-zA-Z][\\w]*)(?:\\.(txt|exe|dll))$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp48y7i350.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^([a-zA-Z][\\\
    w]*)(?:\\.(txt|exe|dll))$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet mut counter: i32 = 0;\n\tlet chars: Vec<char> = file_name.chars().collect();\n\
    \tlet mut dot_place: i32 = -1;\n\tlet mut has_dot: bool = false;\n\tlet mut has_non_digit:\
    \ bool = false;\n\tfor (i, c) in chars.iter().enumerate() {\n\t\tif c.is_ascii_digit()\
    \ {\n\t\t\tcounter += 1;\n\t\t}\n\t\tif c == &'.' {\n\t\t\tdot_place = i as i32;\n\
    \t\t\thas_dot = true;\n\t\t}\n\t\tif !c.is_ascii_digit() {\n\t\t\thas_non_digit\
    \ = true;\n\t\t}\n\t}\n\tif counter > 3 || !has_dot || !has_non_digit || !chars[0].is_ascii_alphabetic()\
    \ {\n\t\treturn String::from(\"No\");\n\t}\n\tlet mut substring: String = String::new();\n\
    \tfor i in 0..dot_place {\n\t\tsubstring.push(chars[i]);\n\t}\n\tlet mut substring_after_dot:\
    \ String = String::new();\n\tfor i in dot_place+1..chars.len() {\n\t\tsubstring_after_dot.push(chars[i]);\n\
    \t}\n\tif substring == \"\" || substring_after_dot != \"txt\" && substring_after_dot\
    \ != \"exe\" && substring_after_dot != \"dll\" {\n\t\treturn String::from(\"No\"\
    );\n\t}\n\treturn String::from(\"Yes\");\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[char]` cannot be indexed by `i32`\n  --> /tmp/tmplelq161e.rs:36:18\n\
    \   |\n36 |         substring.push(chars[i]);\n   |                        ^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `i32`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<i32>` for `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplelq161e.rs:39:24\n   |\n39 |     for i in dot_place+1..chars.len()\
    \ {\n   |                           ^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \nerror[E0277]: the type `[char]` cannot be indexed by `i32`\n  --> /tmp/tmplelq161e.rs:40:28\n\
    \   |\n40 |         substring_after_dot.push(chars[i]);\n   |                \
    \                  ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[char]>` is not implemented for `i32`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<i32>` for `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let (first, _second) = file_name.split_at(file_name.find('.').unwrap());\n\
    \    if first.chars().filter(|&c| c.is_digit(10)).count() <= 3 &&\n        first.chars().filter(|&c|\
    \ c.is_alphabetic()).count() > 0 {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmphulrnahv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let (file_name, file_extension) = file_name.split_at(file_name.rfind('.').unwrap());\n\
    \    if !file_name.is_empty() && is_ascii_uppercase(file_name.chars().next().unwrap())\
    \ {\n        return \"No\".to_string();\n    }\n    if file_name.len() - file_name.matches(char::is_numeric).count()\
    \ < 4 {\n        if file_extension == \".txt\" || file_extension == \".exe\" ||\
    \ file_extension == \".dll\" {\n            return \"Yes\".to_string();\n    \
    \    }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_ascii_uppercase` in this scope\n\
    \  --> /tmp/tmpby71vuxi.rs:15:33\n   |\n15 |     if !file_name.is_empty() && is_ascii_uppercase(file_name.chars().next().unwrap())\
    \ {\n   |                                 ^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,2}\\\
    .[txt|exe|dll]$\").unwrap();\n    if re.is_match(&file_name) {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpnitkgxij.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,2}\\\
    .[txt|exe|dll]$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpslmoxkwk.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tunimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6gyit5ht.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n  // Could also use a regex here\n  let mut digits = 0;\n\
    \  let mut dot_found = false;\n  let mut extension = String::new();\n  let mut\
    \ letters = false;\n  for char in file_name.chars() {\n    if char.is_ascii_digit()\
    \ {\n      digits += 1;\n    } else if char == '.' {\n      dot_found = true;\n\
    \    } else if char.is_ascii_alphabetic() {\n      if !letters {\n        letters\
    \ = true;\n      }\n      if dot_found {\n        extension.push(char);\n    \
    \  }\n    }\n  }\n  let valid_extension = extension == \"txt\" || extension ==\
    \ \"exe\" || extension == \"dll\";\n  if digits <= 3 && dot_found && letters &&\
    \ valid_extension {\n    \"Yes\".to_string()\n  } else {\n    \"No\".to_string()\n\
    \  }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpqqwspu69.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: Your code here\n    // Use this structure\
    \ to save the number of digits you found in the name.\n    let mut num_of_digits\
    \ = 0;\n    // Use this variable to indicate whether the string contains a dot\
    \ or not.\n    let mut has_dot = false;\n    // Use this variable to indicate\
    \ whether the string starts with a latin alphabet letter or not.\n    let mut\
    \ starts_with_letter = false;\n    // Write your loop here.\n    for c in file_name.chars()\
    \ {\n        if c.is_numeric() {\n            num_of_digits += 1;\n        }\n\
    \        if c == '.' {\n            has_dot = true;\n        }\n        if c.is_alphabetic()\
    \ {\n            starts_with_letter = true;\n        }\n    }\n    // Decide whether\
    \ the file name is valid or not, and return your answer.\n    if num_of_digits\
    \ > 3 || !has_dot || !starts_with_letter {\n        return \"No\".to_string();\n\
    \    } else {\n        return \"Yes\".to_string();\n    }\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp14otizdk.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write code here\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5uvy3s1a.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if let Some(is_valid) = file_name_check_opt(file_name)\
    \ {\n        if is_valid {\n            \"Yes\".to_string()\n        } else {\n\
    \            \"No\".to_string()\n        }\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `file_name_check_opt` in this scope\n\
    \  --> /tmp/tmpu7ghg8ui.rs:14:29\n   |\n14 |     if let Some(is_valid) = file_name_check_opt(file_name)\
    \ {\n   |                             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.contains(\".\") {\n        let parts:\
    \ Vec<&str> = file_name.split(\".\").collect();\n        let first_part = parts[0];\n\
    \        let second_part = parts[1];\n        let first_part_chars: Vec<char>\
    \ = first_part.chars().collect();\n        let first_part_char = first_part_chars[0];\n\
    \        if first_part_char.is_alphabetic() {\n            if first_part.len()\
    \ - first_part.chars().filter(|c| c.is_numeric()).count() == 0 {\n           \
    \     if second_part == \"txt\" || second_part == \"exe\" || second_part == \"\
    dll\" {\n                    return \"Yes\".to_string();\n                }\n\
    \            }\n        }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7md3n4gg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^([a-zA-Z]+)(\\d{0,3})\\.(txt|exe|dll)$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpe7dwl8jf.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^([a-zA-Z]+)(\\\
    d{0,3})\\.(txt|exe|dll)$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() < 3 {\n        return \"No\".to_string();\n\
    \    }\n    if file_name.find('.').is_none() {\n        return \"No\".to_string();\n\
    \    }\n    let mut name_before_dot = file_name.clone();\n    let name_after_dot\
    \ = name_before_dot.split_off(file_name.find('.').unwrap());\n    let mut count_of_digits\
    \ = 0;\n    let mut is_digit = false;\n    for c in name_before_dot.chars() {\n\
    \        if c.is_numeric() {\n            count_of_digits += 1;\n            is_digit\
    \ = true;\n        }\n        if count_of_digits > 3 {\n            return \"\
    No\".to_string();\n        }\n    }\n    if !is_digit {\n        return \"No\"\
    .to_string();\n    }\n    if name_after_dot != \"txt\" && name_after_dot != \"\
    exe\" && name_after_dot != \"dll\" {\n        return \"No\".to_string();\n   \
    \ }\n    return \"Yes\".to_string();\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpwkesvpt1.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let cond1 = file_name.chars().filter(|&c| c.is_digit(10)).count()\
    \ <= 3;\n    let cond2 = file_name.chars().filter(|&c| c == '.').count() == 1;\n\
    \    let (cond3, cond4) = file_name.split_once('.').map(|(s, e)| (s, e.to_string())).unwrap();\n\
    \    let cond3 = cond3.chars().next().unwrap().is_alphabetic();\n    let cond4\
    \ = vec![\"txt\", \"exe\", \"dll\"].contains(&cond4.as_str());\n    if cond1 &&\
    \ cond2 && cond3 && cond4 {\n        \"Yes\".to_string()\n    } else {\n     \
    \   \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpb8qhh4b9.rs:16:85\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if !file_name.contains('.') || file_name.chars().count()\
    \ <= 4 {\n        return \"No\".to_string();\n    }\n    let file_parts: Vec<&str>\
    \ = file_name.split('.').collect();\n    if file_parts.len() != 2 {\n        return\
    \ \"No\".to_string();\n    }\n    if !(file_parts[0].chars().nth(0).unwrap().is_alphabetic())\
    \ ||\n       file_parts[0].chars().any(|c| c.is_digit(10)) ||\n       file_parts[0].chars().filter(|c|\
    \ c.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   if file_parts[1] != \"txt\" && file_parts[1] != \"exe\" && file_parts[1] !=\
    \ \"dll\" {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpfzv87zuc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write your code here!\n    unimplemented!();\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjfbozpqj.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO\n    \"Hello\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Hello\"`,\n right: `\"Yes\"`', /tmp/tmpf01i9mc4.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut valid = true;\n    let mut dot_count = 0;\n\
    \    let mut digit_count = 0;\n    let mut latin_letter_count = 0;\n    let mut\
    \ extension_not_valid = false;\n    for c in file_name.chars() {\n        if c\
    \ == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n\
    \            digit_count += 1;\n        } else if c.is_ascii_alphabetic() {\n\
    \            latin_letter_count += 1;\n        }\n    }\n    if dot_count != 1\
    \ {\n        valid = false;\n    }\n    if digit_count > 3 {\n        valid =\
    \ false;\n    }\n    if latin_letter_count == 0 {\n        valid = false;\n  \
    \  }\n    let extension = &file_name[file_name.find('.').unwrap() + 1..];\n  \
    \  if extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n\
    \        extension_not_valid = true;\n    }\n    if valid && !extension_not_valid\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpkoibdmad.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits = 0;\n    let mut dot = false;\n   \
    \ let mut after_dot = false;\n    let mut latin = false;\n    let mut check_extension\
    \ = false;\n    let mut extension = String::new();\n    for letter in file_name.chars()\
    \ {\n        if letter == '.' {\n            if dot {\n                return\
    \ \"No\".to_string();\n            }\n            dot = true;\n            after_dot\
    \ = true;\n            continue;\n        }\n        if digits > 3 {\n       \
    \     return \"No\".to_string();\n        }\n        if after_dot {\n        \
    \    extension.push(letter);\n            if extension.len() == 3 {\n        \
    \        check_extension = true;\n            }\n        } else {\n          \
    \  if latin {\n                if !letter.is_alphabetic() {\n                \
    \    return \"No\".to_string();\n                }\n            } else {\n   \
    \             if letter.is_alphabetic() {\n                    latin = true;\n\
    \                } else if letter.is_digit(10) {\n                    digits +=\
    \ 1;\n                } else {\n                    return \"No\".to_string();\n\
    \                }\n            }\n        }\n    }\n    if digits > 3 {\n   \
    \     return \"No\".to_string();\n    }\n    if check_extension {\n        if\
    \ extension == \"txt\" || extension == \"exe\" || extension == \"dll\" {\n   \
    \         return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpy5f9k0q_.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut point = 0;\n    let mut num = 0;\n    let mut\
    \ alphabet = 0;\n    let mut ext = 0;\n    for ch in file_name.chars() {\n   \
    \     if (ch == '.') {\n            point += 1;\n        }\n        if (ch.is_numeric())\
    \ {\n            num += 1;\n        }\n        if (ch.is_alphabetic()) {\n   \
    \         alphabet += 1;\n        }\n    }\n    if (point == 1 && alphabet >=\
    \ 1 && num <= 3) {\n        let mut split_str: Vec<&str> = file_name.split('.').collect();\n\
    \        if (split_str[1] == \"txt\" || split_str[1] == \"exe\" || split_str[1]\
    \ == \"dll\") {\n            ext += 1;\n        }\n    }\n    if (point == 1 &&\
    \ alphabet >= 1 && num <= 3 && ext == 1) {\n        String::from(\"Yes\")\n  \
    \  } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmps6002kbs.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut count = 0;\n    let mut has_dot = false;\n\
    \    let mut has_alpha = false;\n    let mut good_ext = false;\n    let mut good_before_dot\
    \ = false;\n    for c in file_name.chars() {\n        if c.is_alphabetic() {\n\
    \            has_alpha = true;\n        } else if c.is_numeric() {\n         \
    \   count += 1;\n        } else if c == '.' {\n            has_dot = true;\n \
    \       } else {\n            return \"No\".to_string();\n        }\n    }\n \
    \   if !has_dot {\n        return \"No\".to_string();\n    }\n    if count > 3\
    \ {\n        return \"No\".to_string();\n    }\n    if has_alpha {\n        let\
    \ parts: Vec<&str> = file_name.split('.').collect();\n        let mut before_dot\
    \ = parts[0].to_string();\n        let mut ext = parts[1].to_string();\n     \
    \   for c in before_dot.chars() {\n            if c.is_alphabetic() {\n      \
    \          good_before_dot = true;\n            } else {\n                good_before_dot\
    \ = false;\n                break;\n            }\n        }\n        if ext ==\
    \ \"txt\" || ext == \"exe\" || ext == \"dll\" {\n            good_ext = true;\n\
    \        }\n    }\n    if good_before_dot && good_ext {\n        return \"Yes\"\
    .to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpmseugil0.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut is_valid = true;\n    let mut dot_cnt = 0;\n\
    \    let mut digit_cnt = 0;\n    for ch in file_name.chars() {\n        if ch\
    \ == '.' {\n            dot_cnt += 1;\n        } else if ch.is_ascii_digit() {\n\
    \            digit_cnt += 1;\n        }\n    }\n    if digit_cnt > 3 || dot_cnt\
    \ != 1 {\n        is_valid = false;\n    } else {\n        let mut substrs = file_name.split('.');\n\
    \        let first_substr = substrs.next().unwrap();\n        let second_substr\
    \ = substrs.next().unwrap();\n        if !(first_substr.chars().next().unwrap().is_ascii_alphabetic())\
    \ || \n           !(second_substr == \"txt\" || second_substr == \"exe\" || second_substr\
    \ == \"dll\") {\n            is_valid = false;\n        }\n    }\n    if is_valid\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp_40l9zxr.rs:30:42\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // check if the file name contains more than 3 digits\n\
    \    let mut count = 0;\n    for c in file_name.chars() {\n        if c.is_numeric()\
    \ {\n            count += 1;\n        }\n    }\n    if count > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    // check if the file name contains exactly\
    \ one dot '.'\n    if file_name.matches('.').count() != 1 {\n        return \"\
    No\".to_string();\n    }\n\n    // check if the substring before the dot is not\
    \ empty, and it starts with a latin letter\n    let mut part = file_name.split('.').next().unwrap();\n\
    \    if part.is_empty() || !part.chars().next().unwrap().is_alphabetic() {\n \
    \       return \"No\".to_string();\n    }\n\n    // check if the substring after\
    \ the dot is in ['txt', 'exe', 'dll']\n    part = file_name.split('.').last().unwrap();\n\
    \    if part != \"txt\" && part != \"exe\" && part != \"dll\" {\n        return\
    \ \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z]+\\d{0,3}\\.\\w{3}$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmplzbowjhf.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z]+\\\
    d{0,3}\\.\\w{3}$\").unwrap();\n   |              ^^^^^ use of undeclared type\
    \ `Regex`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    lazy_static! {\n        static ref RE: Regex =\n  \
    \          Regex::new(r\"^[a-zA-Z]\\w{0,2}\\.(txt|exe|dll)$\").unwrap();\n   \
    \ }\n    if RE.is_match(&file_name) {\n        String::from(\"Yes\")\n    } else\
    \ {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpwhsfqga9.rs:14:5\n\
    \   |\n14 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpwhsfqga9.rs:18:8\n   |\n18 |     if\
    \ RE.is_match(&file_name) {\n   |        ^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let valid_file_name = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{1,8}[.](txt|exe|dll)$\"\
    ).unwrap();\n    if valid_file_name.is_match(&file_name) {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpnmm8ugbj.rs:14:27\n   |\n14 |     let valid_file_name = Regex::new(r\"\
    ^[a-zA-Z]{1}[a-zA-Z0-9]{1,8}[.](txt|exe|dll)$\").unwrap();\n   |             \
    \              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpluq1ak8w.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Your code goes here!\n    unimplemented!();\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpa_dx9lh1.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"(\\d+)?[a-zA-Z]+(\\.txt|\\.exe|\\\
    .dll)$\").unwrap();\n    if !re.is_match(&file_name) {\n        return \"No\"\
    .to_string();\n    }\n    let caps = re.captures(&file_name).unwrap();\n    if\
    \ caps.get(1).is_some() {\n        return \"No\".to_string();\n    }\n    \"Yes\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpewzbtbp2.rs:14:14\n   |\n14 |     let re = Regex::new(r\"(\\d+)?[a-zA-Z]+(\\\
    .txt|\\.exe|\\.dll)$\").unwrap();\n   |              ^^^^^ use of undeclared type\
    \ `Regex`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7mp153zp.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Unimplemented!()\n    let mut count = 0;\n    let\
    \ mut num_count = 0;\n    let mut alpha_count = 0;\n    let mut dot_count = 0;\n\
    \    let mut output = \"\";\n    let mut dot_index = -1;\n    let mut latin_check\
    \ = false;\n    let v: Vec<&str> = file_name.split('.').collect();\n    let mut\
    \ valid_ext = false;\n    let mut loop_count = 0;\n    for c in file_name.chars()\
    \ {\n        loop_count += 1;\n        // Check for valid extensions\n       \
    \ if c == '.' {\n            dot_count += 1;\n            dot_index = loop_count;\n\
    \        }\n        // Count number of digits\n        if c.is_numeric() {\n \
    \           num_count += 1;\n        }\n        // Count number of latin alphabet\
    \ characters\n        if c.is_alphabetic() {\n            alpha_count += 1;\n\
    \        }\n        if alpha_count > 0 && num_count == 0 {\n            latin_check\
    \ = true;\n        }\n        // Return 'No' if there are more than 3 digits\n\
    \        if num_count > 3 {\n            output = \"No\";\n            return\
    \ output.to_string();\n        }\n        // Check for '.' and valid extensions\n\
    \        if count == dot_index - 1 {\n            if v[1] == \"txt\" || v[1] ==\
    \ \"exe\" || v[1] == \"dll\" {\n                valid_ext = true;\n          \
    \  }\n        }\n        count += 1;\n    }\n    // Return 'No' if there are more\
    \ than 1 '.'\n    if dot_count > 1 {\n        output = \"No\";\n        return\
    \ output.to_string();\n    }\n    // Return 'No' if there are no '.'\n    if dot_count\
    \ == 0 {\n        output = \"No\";\n        return output.to_string();\n    }\n\
    \    // Return 'No' if the extension is not one of the valid extensions\n    if\
    \ valid_ext == false {\n        output = \"No\";\n        return output.to_string();\n\
    \    }\n    // Return\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmp7lrtp2il.rs:67:5\n\
    \   |\n13 |   fn file_name_check(file_name: String) -> String {\n   |        \
    \                                    ------ expected `String` because of this\
    \ return type\n...\n67 | /     if valid_ext == false {\n68 | |         output\
    \ = \"No\";\n69 | |         return output.to_string();\n70 | |     }\n   | |_____^\
    \ expected struct `String`, found `()`\n   |\n   = note: `if` expressions without\
    \ `else` evaluate to `()`\n   = help: consider adding an `else` block that evaluates\
    \ to the expected type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits = 0;\n    let mut dot = false;\n   \
    \ let mut dot_pos = 0;\n    let mut valid_pre_dot = false;\n    let mut valid_post_dot\
    \ = false;\n    for (i, ch) in file_name.chars().enumerate() {\n        if ch.is_ascii_digit()\
    \ {\n            digits += 1;\n        } else if ch == '.' {\n            dot\
    \ = true;\n            dot_pos = i;\n        } else if ch.is_ascii_alphabetic()\
    \ {\n            valid_pre_dot = true;\n        }\n    }\n    if digits > 3 ||\
    \ !dot || !valid_pre_dot {\n        return \"No\".to_string();\n    }\n    let\
    \ post_dot = &file_name[dot_pos + 1..];\n    if post_dot == \"txt\" || post_dot\
    \ == \"exe\" || post_dot == \"dll\" {\n        valid_post_dot = true;\n    }\n\
    \    if valid_post_dot {\n        \"Yes\".to_string()\n    } else {\n        \"\
    No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpvnf907ih.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write code here\n    let mut res = true;\n    let\
    \ mut dot = 0;\n    let mut count = 0;\n    let mut i = 0;\n    while i < file_name.len()\
    \ {\n        if dot > 1 {\n            res = false;\n            break;\n    \
    \    }\n        let c = file_name.chars().nth(i).unwrap();\n        if c == '.'\
    \ {\n            dot += 1;\n            count = 0;\n        } else if c.is_numeric()\
    \ {\n            count += 1;\n            if count > 3 {\n                res\
    \ = false;\n                break;\n            }\n        }\n        i += 1;\n\
    \    }\n    let file_type = &file_name[file_name.len() - 3..];\n    if file_type\
    \ != \"txt\" && file_type != \"exe\" && file_type != \"dll\" {\n        res =\
    \ false;\n    }\n    if res {\n        \"Yes\".to_string()\n    } else {\n   \
    \     \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprzhlgner.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits = 0;\n    let mut dot = false;\n   \
    \ let mut first_char = true;\n    let mut suffix = false;\n    let mut suffix_len\
    \ = 0;\n    for c in file_name.chars() {\n        if first_char {\n          \
    \  if !c.is_alphabetic() {\n                return \"No\".to_string();\n     \
    \       }\n            first_char = false;\n        }\n        if c.is_digit(10)\
    \ {\n            digits += 1;\n            if digits > 3 {\n                return\
    \ \"No\".to_string();\n            }\n        }\n        if !dot && c == '.' {\n\
    \            dot = true;\n        }\n        if dot {\n            suffix_len\
    \ += 1;\n            if suffix_len > 3 {\n                return \"No\".to_string();\n\
    \            }\n        }\n    }\n    if !dot {\n        return \"No\".to_string();\n\
    \    }\n    let (before, after) = file_name.split_at(file_name.len() - suffix_len);\n\
    \    if before.len() == 0 {\n        return \"No\".to_string();\n    }\n    match\
    \ after {\n        \"txt\" => return \"Yes\".to_string(),\n        \"exe\" =>\
    \ return \"Yes\".to_string(),\n        \"dll\" => return \"Yes\".to_string(),\n\
    \        _ => return \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1tjmvxr2.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let filename_split: Vec<&str> = file_name.split('.').collect();\n\
    \    if filename_split.len() != 2 {\n        return String::from(\"No\");\n  \
    \  }\n\n    let first = filename_split[0];\n    let second = filename_split[1];\n\
    \n    let first_chars: Vec<char> = first.chars().collect();\n    if first_chars.len()\
    \ < 1 {\n        return String::from(\"No\");\n    }\n\n    let mut number_digits\
    \ = 0;\n    for c in first_chars {\n        if c.is_digit(10) {\n            number_digits\
    \ += 1;\n        }\n    }\n\n    if number_digits > 3 {\n        return String::from(\"\
    No\");\n    }\n\n    if !first_chars[0].is_alphabetic() {\n        return String::from(\"\
    No\");\n    }\n\n    if second != \"txt\" && second != \"exe\" && second != \"\
    dll\" {\n        return String::from(\"No\");\n    }\n\n    return String::from(\"\
    Yes\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `first_chars`\n   --> /tmp/tmpm86csja2.rs:38:9\n\
    \    |\n22  |     let first_chars: Vec<char> = first.chars().collect();\n    |\
    \         ----------- move occurs because `first_chars` has type `Vec<char>`,\
    \ which does not implement the `Copy` trait\n...\n28  |     for c in first_chars\
    \ {\n    |              ----------- `first_chars` moved due to this implicit call\
    \ to `.into_iter()`\n...\n38  |     if !first_chars[0].is_alphabetic() {\n   \
    \ |         ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `first_chars`\nhelp: consider\
    \ iterating over a slice of the `Vec<char>`'s content to avoid moving into the\
    \ `for` loop\n    |\n28  |     for c in &first_chars {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    //TODO:\n    let mut dot_found: bool = false;\n   \
    \ let mut num_count: u8 = 0;\n    let mut letter_found: bool = false;\n    let\
    \ mut exe_found: bool = false;\n    let mut txt_found: bool = false;\n    let\
    \ mut dll_found: bool = false;\n    for letter in file_name.chars() {\n      \
    \  if letter == '.' {\n            dot_found = true;\n        }\n        if letter.is_alphabetic()\
    \ {\n            letter_found = true;\n        }\n        if letter.is_numeric()\
    \ {\n            num_count += 1;\n        }\n        if letter == 'e' {\n    \
    \        exe_found = true;\n        }\n        if letter == 't' {\n          \
    \  txt_found = true;\n        }\n        if letter == 'd' {\n            dll_found\
    \ = true;\n        }\n    }\n    if (num_count > 3) | (dot_found == false) | (letter_found\
    \ == false) | ((exe_found == false) & (txt_found == false) & (dll_found == false))\
    \ {\n        return \"No\".to_string();\n    }\n    else {\n        return \"\
    Yes\".to_string();\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpreta0gqo.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{1,}(\\\
    .[a-zA-Z0-9]{1,}){1}$\").unwrap();\n    if re.is_match(&file_name) {\n       \
    \ let re_dots = Regex::new(r\"\\.\").unwrap();\n        let dot_count = re_dots.find_iter(&file_name).count();\n\
    \        if dot_count == 1 {\n            let re_num = Regex::new(r\"[0-9]\").unwrap();\n\
    \            let digits_count = re_num.find_iter(&file_name).count();\n      \
    \      if digits_count <= 3 {\n                let parts: Vec<&str> = file_name.split(\"\
    .\").collect();\n                let file_type = parts[1];\n                if\
    \ file_type == \"txt\" || file_type == \"exe\" || file_type == \"dll\" {\n   \
    \                 return \"Yes\".to_string();\n                }\n           \
    \ }\n        }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpsfgzw3dz.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{1,}(\\\
    .[a-zA-Z0-9]{1,}){1}$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n\
    \  --> /tmp/tmpsfgzw3dz.rs:16:23\n   |\n16 |         let re_dots = Regex::new(r\"\
    \\.\").unwrap();\n   |                       ^^^^^ use of undeclared type `Regex`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmpsfgzw3dz.rs:19:26\n\
    \   |\n19 |             let re_num = Regex::new(r\"[0-9]\").unwrap();\n   |  \
    \                        ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n\
    \    let mut valid_start = false;\n    let mut valid_end = false;\n    let mut\
    \ in_first_part = true;\n    for ch in file_name.chars() {\n        if ch == '.'\
    \ {\n            dot_count += 1;\n            in_first_part = false;\n       \
    \ } else if ch.is_digit(10) {\n            digit_count += 1;\n        } else if\
    \ ch.is_alphabetic() {\n            if in_first_part {\n                valid_start\
    \ = true;\n            } else {\n                if ch == 'T' || ch == 'E' ||\
    \ ch == 'D' {\n                    valid_end = true;\n                }\n    \
    \        }\n        }\n    }\n    if dot_count == 1 && digit_count <= 3 && valid_start\
    \ && valid_end {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgse53uzp.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if !file_name.chars().all(|c| c.is_alphanumeric() ||\
    \ c == '.') {\n        return \"No\".to_string();\n    }\n    let mut chars =\
    \ file_name.chars();\n    let start = chars.next().unwrap();\n    if !start.is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    let mut digit_count = 0;\n\
    \    let mut dot_count = 0;\n    let mut extension = String::new();\n    let mut\
    \ curr = String::new();\n    while let Some(c) = chars.next() {\n        if c.is_digit(10)\
    \ {\n            digit_count += 1;\n        }\n        if c == '.' {\n       \
    \     dot_count += 1;\n            extension = chars.collect();\n        }\n \
    \       curr.push(c);\n    }\n    if digit_count > 3 || dot_count != 1 || !(extension\
    \ == \"txt\" || extension == \"exe\" || extension == \"dll\") {\n        return\
    \ \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `chars`\n    --> /tmp/tmpzrhgpime.rs:26:25\n\
    \     |\n17   |     let mut chars = file_name.chars();\n     |         ---------\
    \ move occurs because `chars` has type `Chars<'_>`, which does not implement the\
    \ `Copy` trait\n...\n26   |     while let Some(c) = chars.next() {\n     |   \
    \                      ^^^^^^^^^^^^ value borrowed here after move\n...\n32  \
    \ |             extension = chars.collect();\n     |                         \
    \      --------- `chars` moved due to this method call, in previous iteration\
    \ of loop\n     |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `chars`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjgx2xwpk.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Yes\"`', /tmp/tmp3s26o7_t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.find('.').is_none() {\n        return\
    \ \"No\".to_string();\n    }\n    let mut dots = 0;\n    let mut c_digit = 0;\n\
    \    let mut c_letter = 0;\n    let mut c_other = 0;\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            dots += 1;\n        } else if c >= '0'\
    \ && c <= '9' {\n            c_digit += 1;\n        } else if (c >= 'a' && c <=\
    \ 'z') || (c >= 'A' && c <= 'Z') {\n            c_letter += 1;\n        } else\
    \ {\n            c_other += 1;\n        }\n    }\n    if dots != 1 || c_other\
    \ > 0 || c_digit > 3 || c_letter == 0 {\n        return \"No\".to_string();\n\
    \    }\n    let prefix = &file_name[0..file_name.find('.').unwrap()];\n    let\
    \ suffix = &file_name[file_name.find('.').unwrap() + 1..];\n    if !(suffix ==\
    \ \"txt\" || suffix == \"exe\" || suffix == \"dll\") {\n        return \"No\"\
    .to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpyidatbpz.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut ext_count = 0;\n    let mut digits_count =\
    \ 0;\n    let mut after_dot = false;\n    let mut valid_ext = false;\n    let\
    \ mut start_with_letter = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if !after_dot {\n            if c == '.' {\n                after_dot\
    \ = true;\n                continue;\n            }\n            if c >= '0' &&\
    \ c <= '9' {\n                digits_count += 1;\n            }\n            if\
    \ digits_count > 3 {\n                return \"No\".to_string();\n           \
    \ }\n            if i == 0 && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') {\n\
    \                start_with_letter = true;\n            }\n        } else {\n\
    \            if c == '.' {\n                ext_count += 1;\n            }\n \
    \           if ext_count > 1 {\n                return \"No\".to_string();\n \
    \           }\n            if c == 't' {\n                valid_ext = file_name.ends_with(\"\
    txt\");\n            } else if c == 'e' {\n                valid_ext = file_name.ends_with(\"\
    exe\");\n            } else if c == 'd' {\n                valid_ext = file_name.ends_with(\"\
    dll\");\n            }\n        }\n    }\n    if after_dot && ext_count == 1 &&\
    \ valid_ext && start_with_letter {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpfexrcayi.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \tlet mut has_dot = false;\n\tlet mut dot_index = 0;\n\tlet mut numbers_count\
    \ = 0;\n\tlet mut not_valid_name = false;\n\tlet mut not_valid_extension = false;\n\
    \tlet mut extension_index = 0;\n\tlet mut not_valid_size = false;\n\tfor i in\
    \ 0..file_name.len() {\n\t\tif file_name.as_bytes()[i] >= 48 && file_name.as_bytes()[i]\
    \ <= 57 {\n\t\t\tnumbers_count += 1;\n\t\t}\n\t\tif file_name.as_bytes()[i] ==\
    \ 46 {\n\t\t\thas_dot = true;\n\t\t\tdot_index = i;\n\t\t}\n\t\tif !has_dot {\n\
    \t\t\tif !(file_name.as_bytes()[i] >= 65 && file_name.as_bytes()[i] <= 90) &&\
    \ !(file_name.as_bytes()[i] >= 97 && file_name.as_bytes()[i] <= 122) {\n\t\t\t\
    \tnot_valid_name = true;\n\t\t\t}\n\t\t}\n\t\tif numbers_count > 3 {\n\t\t\tnot_valid_size\
    \ = true;\n\t\t}\n\t}\n\tif !has_dot {\n\t\tnot_valid_extension = true;\n\t}\n\
    \telse {\n\t\tfor i in 0..valid_extensions.len() {\n\t\t\tlet mut flag = true;\n\
    \t\t\tfor j in 0..3 {\n\t\t\t\tif file_name.as_bytes()[dot_index + j + 1] != valid_extensions[i].as_bytes()[j]\
    \ {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif flag {\n\t\t\t\textension_index\
    \ = i;\n\t\t\t}\n\t\t}\n\t\tif extension_index == 0 {\n\t\t\tnot_valid_extension\
    \ = true;\n\t\t}\n\t}\n\tif not_\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpth0pyxl1.rs:59:1\n   |\n\
    58 |     if not_\n   |     -- this `if` expression has a condition, but no block\n\
    59 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Place your code here\n    panic!(\"Not implemented\
    \ yet\")\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'Not implemented yet', /tmp/tmpmbbuu8sg.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphs383ke5.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_2gp3_u8.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpapcfyl66.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let regex = regex::Regex::new(r\"^[a-zA-Z]{1}[\\w]{0,2}\\\
    .[txt|exe|dll]$\").unwrap();\n    let is_valid = regex.is_match(&file_name);\n\
    \    return if is_valid { \"Yes\".to_string() } else { \"No\".to_string() };\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmp1u6svto6.rs:14:17\n   |\n14 |     let regex = regex::Regex::new(r\"\
    ^[a-zA-Z]{1}[\\w]{0,2}\\.[txt|exe|dll]$\").unwrap();\n   |                 ^^^^^\
    \ use of undeclared crate or module `regex`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n  unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4mbe2xg5.rs:14:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfwouvrp_.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_count = 0;\n    let mut digits_count =\
    \ 0;\n    let mut letter_flag = false;\n    let mut first_letter_flag = false;\n\
    \    let mut last_3_letters = String::from(\"\");\n    let mut last_3_digits =\
    \ String::from(\"\");\n    for ch in file_name.chars() {\n        if ch == '.'\
    \ {\n            dot_count += 1;\n            letter_flag = false;\n        }\
    \ else if ch.is_digit(10) {\n            digits_count += 1;\n            if digits_count\
    \ == 4 {\n                return String::from(\"No\");\n            }\n      \
    \      last_3_digits.push(ch);\n        } else if ch.is_alphabetic() {\n     \
    \       if !first_letter_flag {\n                first_letter_flag = true;\n \
    \           }\n            if dot_count > 0 {\n                letter_flag = true;\n\
    \                last_3_letters.push(ch);\n            }\n        }\n    }\n \
    \   if dot_count != 1 || !first_letter_flag || !letter_flag || digits_count >\
    \ 3 {\n        return String::from(\"No\");\n    }\n    if last_3_letters == \"\
    txt\" || last_3_letters == \"exe\" || last_3_letters == \"dll\" {\n        return\
    \ String::from(\"Yes\");\n    }\n    return String::from(\"No\");\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp3gtbr9q0.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re_valid = Regex::new(r#\"^([A-Za-z])([A-Za-z0-9_]*)(\\\
    .(txt|exe|dll))$\"#).unwrap();\n    let re_digit = Regex::new(r#\"[0-9]\"#).unwrap();\n\
    \    if re_valid.is_match(&file_name) && re_digit.find_iter(&file_name).count()\
    \ <= 3 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpcsiga0q5.rs:14:20\n   |\n14 |     let re_valid = Regex::new(r#\"^([A-Za-z])([A-Za-z0-9_]*)(\\\
    .(txt|exe|dll))$\"#).unwrap();\n   |                    ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n\
    \  --> /tmp/tmpcsiga0q5.rs:15:20\n   |\n15 |     let re_digit = Regex::new(r#\"\
    [0-9]\"#).unwrap();\n   |                    ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_9fiz6xs.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // the length of the text before the dot\n    let before_dot_len\
    \ = file_name.find('.').unwrap();\n    // the length of the text after the dot\n\
    \    let after_dot_len = file_name.len() - file_name.find('.').unwrap() - 1;\n\
    \    // the number of digits in the file's name\n    let digits_count = file_name.chars().filter(|c|\
    \ c.is_digit(10)).count();\n    // the extension of the file\n    let extension\
    \ = &file_name[file_name.find('.').unwrap() + 1..];\n    // returns 'Yes' if the\
    \ file's name is valid, and returns 'No' otherwise\n    if file_name.matches('.').count()\
    \ == 1 &&\n        before_dot_len > 0 &&\n        file_name.chars().nth(0).unwrap().is_alphabetic()\
    \ &&\n        digits_count <= 3 &&\n        extension == \"txt\" || extension\
    \ == \"exe\" || extension == \"dll\" {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp89ln33nr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tlet file_name_vec: Vec<&str> = file_name.split('.').collect();\n\
    \tif file_name_vec.len() != 2 {\n\t\treturn \"No\".to_string();\n\t}\n\tlet name_vec:\
    \ Vec<char> = file_name_vec[0].chars().collect();\n\tif name_vec.len() == 0 {\n\
    \t\treturn \"No\".to_string();\n\t}\n\tlet mut digits = 0;\n\tfor ch in name_vec\
    \ {\n\t\tif ch >= '0' && ch <= '9' {\n\t\t\tdigits += 1;\n\t\t}\n\t}\n\tif digits\
    \ > 3 {\n\t\treturn \"No\".to_string();\n\t}\n\tlet allowed_endings = [\"txt\"\
    , \"exe\", \"dll\"];\n\tif allowed_endings.contains(&file_name_vec[1]) {\n\t\t\
    return \"Yes\".to_string();\n\t}\n\treturn \"No\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp9ucbhnlm.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpikw6zmgb.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    \"Not Yet Implemented\"\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3p7hhccg.rs:14:5\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n14\
    \ |     \"Not Yet Implemented\"\n   |     ^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write your code here\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpizsuxass.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let max_numbers = 3;\n    let valid_extensions = [\"\
    txt\", \"exe\", \"dll\"];\n    let file_name_vec: Vec<&str> = file_name.split('.').collect();\n\
    \    if file_name_vec.len() != 2 {\n        return \"No\".to_string();\n    }\n\
    \    let name_part = file_name_vec[0];\n    let extension_part = file_name_vec[1];\n\
    \    let num_digits = name_part.chars().filter(|c| c.is_digit(10)).count();\n\
    \    if num_digits > max_numbers {\n        return \"No\".to_string();\n    }\n\
    \    if !(name_part.chars().next().unwrap().is_alphabetic()) {\n        return\
    \ \"No\".to_string();\n    }\n    if !valid_extensions.contains(&extension_part)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpatf8oyfr.rs:26:35\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let is_alphapet = |ch| ('a' <= ch && ch <= 'z') ||\
    \ ('A' <= ch && ch <= 'Z');\n    let is_digit = |ch| '0' <= ch && ch <= '9';\n\
    \    let is_valid_ext = |ext| ext == \"txt\" || ext == \"exe\" || ext == \"dll\"\
    ;\n\n    let (mut ext, mut valid_ext) = (\"\".to_string(), false);\n    let (mut\
    \ has_dot, mut digits_num) = (false, 0);\n    let mut is_valid = true;\n    for\
    \ (i, ch) in file_name.chars().enumerate() {\n        if ch == '.' {\n       \
    \     ext = file_name[i + 1..].to_string();\n            has_dot = true;\n   \
    \     } else if is_digit(ch) {\n            digits_num += 1;\n        } else if\
    \ i == 0 && !is_alphapet(ch) {\n            is_valid = false;\n            break;\n\
    \        }\n    }\n    if digits_num > 3 {\n        is_valid = false;\n    }\n\
    \    if is_valid {\n        valid_ext = is_valid_ext(&ext);\n    }\n    if has_dot\
    \ && valid_ext {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpe87911ci.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO\n    return \"No\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpnezpo2g8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_nbr = 0;\n    let mut nbr_nbr = 0;\n  \
    \  let mut letter_nbr = 0;\n    let mut after_dot = String::new();\n    let mut\
    \ before_dot = String::new();\n    for ch in file_name.chars() {\n        if dot_nbr\
    \ == 0 {\n            if ch.is_digit(10) {\n                nbr_nbr += 1;\n  \
    \          } else if ch.is_alphabetic() {\n                letter_nbr += 1;\n\
    \            } else if ch == '.' {\n                dot_nbr += 1;\n          \
    \  }\n        } else {\n            after_dot.push(ch);\n        }\n    }\n  \
    \  if dot_nbr == 1 && nbr_nbr <= 3 && letter_nbr > 0 {\n        before_dot = file_name.chars().take_while(|&ch|\
    \ ch != '.').collect();\n        if after_dot == \"txt\" || after_dot == \"exe\"\
    \ || after_dot == \"dll\" {\n            return \"Yes\".to_string();\n       \
    \ }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpmn00b5qq.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|c| c.is_digit(10)).count()\
    \ > 3 {\n        \"No\".to_string()\n    } else if !file_name.contains('.') {\n\
    \        \"No\".to_string()\n    } else {\n        let parts: Vec<&str> = file_name.splitn(2,\
    \ '.').collect();\n        if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n            \"No\".to_string()\n        } else if parts[1] != \"txt\" &&\
    \ parts[1] != \"exe\" && parts[1] != \"dll\" {\n            \"No\".to_string()\n\
    \        } else {\n            \"Yes\".to_string()\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.split(\".\").count() != 2 {\n        return\
    \ \"No\".to_string();\n    }\n    let mut split_str = file_name.split(\".\");\n\
    \    let name = split_str.next().unwrap();\n    let ext = split_str.next().unwrap();\n\
    \    let mut digit_count = 0;\n    let mut alphabet_count = 0;\n    for ch in\
    \ name.chars() {\n        if ch.is_digit(10) {\n            digit_count += 1;\n\
    \        } else if ch.is_alphabetic() {\n            alphabet_count += 1;\n  \
    \      }\n    }\n    if digit_count > 3 || alphabet_count == 0 {\n        return\
    \ \"No\".to_string();\n    }\n    match ext {\n        \"txt\" | \"exe\" | \"\
    dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n    }\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpmcmoltuu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkdkwrkna.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let n_digits: usize = file_name.chars().filter(|c|\
    \ c.is_digit(10)).count();\n    if n_digits > 3 {\n        return \"No\".to_string();\n\
    \    }\n    let n_dots: usize = file_name.chars().filter(|c| *c == '.').count();\n\
    \    if n_dots != 1 {\n        return \"No\".to_string();\n    }\n    let parts:\
    \ Vec<_> = file_name.split('.').collect();\n    if parts.len() != 2 {\n      \
    \  return \"No\".to_string();\n    }\n    if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if parts[1] != \"txt\" &&\
    \ parts[1] != \"exe\" && parts[1] != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name = file_name.clone();\n    let mut\
    \ numbers = 0;\n    for i in file_name.chars() {\n        if i.is_numeric() {\n\
    \            numbers += 1;\n        }\n    }\n    if numbers > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    if file_name.contains(\".\") == false {\n\
    \        return \"No\".to_string();\n    }\n\n    file_name = file_name.split(\"\
    .\").collect::<Vec<&str>>()[0].to_string();\n    if file_name.len() == 0 {\n \
    \       return \"No\".to_string();\n    }\n\n    let first_letter = file_name.chars().nth(0).unwrap();\n\
    \    if first_letter.is_alphabetic() == false {\n        return \"No\".to_string();\n\
    \    }\n\n    if file_name.chars().nth(file_name.len() - 1).unwrap().is_alphabetic()\
    \ == false {\n        return \"No\".to_string();\n    }\n\n    let extension =\
    \ file_name.split(\".\").collect::<Vec<&str>>()[1].to_string();\n    if extension\
    \ != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n        return\
    \ \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n\nfn main() {\n  \
    \  let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpkj5a0tpb.rs:43:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0hueswse.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.matches(char::is_numeric).count() > 3\
    \ {\n        return \"No\".to_string();\n    }\n    if file_name.matches('.').count()\
    \ != 1 {\n        return \"No\".to_string();\n    }\n    let (prefix, suffix)\
    \ = file_name.split_at(file_name.find('.').unwrap());\n    if prefix.is_empty()\
    \ || !prefix.chars().all(char::is_alphabetic) {\n        return \"No\".to_string();\n\
    \    }\n    if suffix != \".txt\" && suffix != \".exe\" && suffix != \".dll\"\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0979itzx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: Implement the function here!\n    panic!(\"\
    Not implemented!\");\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'Not implemented!', /tmp/tmporbuwudy.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmmtr7c87.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let text = r\"([a-zA-Z]\\w{0,2})\\.(txt|exe|dll)\"\
    ;\n    match Regex::new(text) {\n        Ok(re) => {\n            if re.is_match(&file_name)\
    \ {\n                return \"Yes\".to_string();\n            }\n        }\n \
    \       Err(_) => {\n            panic!(\"Failed to compile regular expression\"\
    );\n        }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpeg556msv.rs:15:11\n   |\n15 |     match Regex::new(text) {\n   |   \
    \        ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut count = 0;\n    for (index, char) in file_name.chars().enumerate()\
    \ {\n        if char.is_digit(10) {\n            count += 1;\n        }\n    \
    \    if index == 0 && char.is_alphabetic() {\n            count += 1;\n      \
    \  }\n        if index == file_name.len() - 4 && char == '.' {\n            count\
    \ += 1;\n        }\n        if index == file_name.len() - 3 && (char == 't' ||\
    \ char == 'e' || char == 'd') {\n            count += 1;\n        }\n        if\
    \ index == file_name.len() - 2 && (char == 'x' || char == 'x' || char == 'l')\
    \ {\n            count += 1;\n        }\n        if index == file_name.len() -\
    \ 1 && (char == 't' || char == 'e' || char == 'l') {\n            count += 1;\n\
    \        }\n    }\n    if count == file_name.len() {\n        return \"Yes\".to_string();\n\
    \    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpsaebvau3.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    match file_name.chars().filter(|&c| c.is_digit(10)).count()\
    \ {\n        0...3 => String::from(\"Yes\"),\n        _ => String::from(\"No\"\
    ),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmplvp1afk3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut dot_count = 0;\n    let mut digits_count =\
    \ 0;\n    let mut latin_letter_exists = false;\n    let mut post_dot_text = \"\
    \";\n    for ch in file_name.chars() {\n        if ch.is_digit(10) {\n       \
    \     digits_count += 1;\n        } else if ch == '.' {\n            dot_count\
    \ += 1;\n        } else if ch.is_alphabetic() {\n            latin_letter_exists\
    \ = true;\n        }\n    }\n    if !latin_letter_exists || dot_count != 1 ||\
    \ digits_count > 3 {\n        return \"No\".to_string();\n    }\n    let dot_pos\
    \ = file_name.find('.').unwrap();\n    post_dot_text = &file_name[dot_pos + 1..];\n\
    \    match post_dot_text {\n        \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n\
    \        _ => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpcvxm3woh.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|&c| c.is_numeric()).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let idx = file_name.find('.').unwrap();\n\
    \    let (left, right) = file_name.split_at(idx);\n    if left.is_empty() {\n\
    \        return \"No\".to_string();\n    }\n    if !left.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if !(right == \".txt\" ||\
    \ right == \".exe\" || right == \".dll\") {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp8hcqrqkf.rs:17:35\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write the code here\n    let res = file_name.split('.').collect::<Vec<&str>>();\n\
    \    if res.len() != 2 || !res[0].chars().all(|x| x.is_alphabetic()) || \n   \
    \     !res[1].chars().all(|x| x.is_alphabetic()) || res[0].len() == 0 ||\n   \
    \     ![\"txt\", \"exe\", \"dll\"].contains(&res[1]) {\n        return \"No\"\
    .to_string();\n    }\n\n    for x in res[0].chars() {\n        if x.is_numeric()\
    \ {\n            return \"No\".to_string();\n        }\n    }\n\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp78uynobl.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if let Some(i) = file_name.find('.') {\n        let\
    \ (before, after) = file_name.split_at(i);\n        if let Some(c) = before.chars().next()\
    \ {\n            if c.is_ascii_alphabetic() && before.len() > 1 {\n          \
    \      if after.len() == 4 {\n                    if after == \".txt\" || after\
    \ == \".exe\" || after == \".dll\" {\n                        if file_name.chars().filter(|&c|\
    \ c.is_ascii_digit()).count() <= 3 {\n                            return \"Yes\"\
    .to_string();\n                        }\n                    }\n            \
    \    }\n            }\n        }\n    }\n    \"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpnxdc8uw5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: implement function\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp21ngc4bj.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits_count = 0;\n    let mut dot_count =\
    \ 0;\n    let mut letter_found = false;\n    let mut extension_found = false;\n\
    \    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    for c in file_name.chars()\
    \ {\n        if c.is_numeric() {\n            digits_count += 1;\n        }\n\
    \        if !letter_found && c.is_alphabetic() {\n            letter_found = true;\n\
    \        }\n        if c == '.' {\n            dot_count += 1;\n        }\n  \
    \      if c == '.' && !extension_found {\n            let dot_index = file_name.find('.').unwrap();\n\
    \            for valid_extension in valid_extensions.iter() {\n              \
    \  if file_name[dot_index + 1..].starts_with(valid_extension) {\n            \
    \        extension_found = true;\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    if digits_count > 3 || !letter_found\
    \ || dot_count != 1 || !extension_found {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprlc5r762.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() == 0 {\n        return \"No\".to_string();\n\
    \    }\n    if file_name.chars().filter(|x| x.is_digit(10)).count() > 3 {\n  \
    \      return \"No\".to_string();\n    }\n    if file_name.chars().filter(|x|\
    \ x == &'.').count() != 1 {\n        return \"No\".to_string();\n    }\n    let\
    \ file_name_parts: Vec<&str> = file_name.split('.').collect();\n    if file_name_parts.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    if file_name_parts[0].len()\
    \ == 0 || file_name_parts[0].chars().all(|x| !x.is_alphabetic()) {\n        return\
    \ \"No\".to_string();\n    }\n    if !file_name_parts[1].eq(\"txt\") && !file_name_parts[1].eq(\"\
    exe\") && !file_name_parts[1].eq(\"dll\") {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp3oqpp36p.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprbpt5dlv.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut valid = true;\n    let mut dot_count = 0;\n\
    \    let mut digit_count = 0;\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        valid = false;\n    }\n    for i in parts[0].chars()\
    \ {\n        if i.is_ascii_digit() {\n            digit_count += 1;\n        }\n\
    \        if !i.is_ascii_alphabetic() {\n            valid = false;\n        }\n\
    \    }\n    if parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\"\
    \ {\n        valid = false;\n    }\n    if digit_count > 3 {\n        valid =\
    \ false;\n    }\n    if valid {\n        return \"Yes\".to_string();\n    }\n\
    \    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpyz06twr3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\tif file_name.chars().filter(|c| c.is_digit(10)).count()\
    \ > 3 {\n\t\treturn \"No\".to_string();\n\t}\n\tif !file_name.contains('.') {\n\
    \t\treturn \"No\".to_string();\n\t}\n\tlet file_name_parts: Vec<&str> = file_name.split(\"\
    .\").collect();\n\tif file_name_parts.len() != 2 {\n\t\treturn \"No\".to_string();\n\
    \t}\n\tif file_name_parts[0].is_empty() || !file_name_parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n\t\treturn \"No\".to_string();\n\t}\n\tif file_name_parts[1] != \"txt\" &&\
    \ file_name_parts[1] != \"exe\" && file_name_parts[1] != \"dll\" {\n\t\treturn\
    \ \"No\".to_string();\n\t}\n\t\"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut ext = false;\n    let mut num_count = 0;\n\
    \    let mut alpha_count = 0;\n    let mut ext_count = 0;\n    let mut ext_type\
    \ = false;\n    let mut ext_check = false;\n    let mut ext_check2 = false;\n\
    \    let mut alpha_check = false;\n    let mut alpha_check2 = false;\n    let\
    \ mut check = false;\n    let mut check2 = false;\n    let file_chars: Vec<char>\
    \ = file_name.chars().collect();\n    for ch in file_chars {\n        if ch ==\
    \ '.' {\n            ext = true;\n            if ext_count != 0 {\n          \
    \      ext_check = true;\n            }\n        }\n        if ch.is_alphabetic()\
    \ {\n            alpha_count += 1;\n            if alpha_count > 1 {\n       \
    \         alpha_check = true;\n            }\n        }\n        if ch.is_digit(10)\
    \ {\n            num_count += 1;\n            if num_count > 3 {\n           \
    \     check = true;\n            }\n        }\n        if ext == true {\n    \
    \        ext_count += 1;\n            if alpha_count == 0 {\n                alpha_check2\
    \ = true;\n            }\n            if num_count != 0 {\n                check2\
    \ = true;\n            }\n            if ch.is_lowercase() {\n               \
    \ if ch == 't' {\n                    ext_type = true;\n                }\n  \
    \              if ch == 'x' && ext_type == true {\n                    ext_type\
    \ = true;\n                }\n                if ch == 'e' && ext_type == true\
    \ {\n                    ext_type = true;\n                }\n               \
    \ if ch == 'd' && ext_type == true {\n                    ext_type = true;\n \
    \               }\n                if ch == 'l' && ext_type == true {\n      \
    \              ext_type = true;\n                }\n                if ch == 'l'\
    \ && ext_type == false {\n                    ext_check2 = true;\n           \
    \     }\n            }\n        }\n    }\n    if check == true || check2 == true\
    \ || alpha_check == true || alpha_check2 == true || ext_\n}\n\nfn main() {\n \
    \   let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp6nyfn8u6.rs:76:1\n   |\n\
    75 |     if check == true || check2 == true || alpha_check == true || alpha_check2\
    \ == true || ext_\n   |     -- this `if` expression has a condition, but no block\n\
    76 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.matches(char::is_numeric).count() > 3\
    \ {\n        return \"No\".to_string();\n    }\n    let dots: Vec<_> = file_name.matches('.').collect();\n\
    \    if dots.len() != 1 {\n        return \"No\".to_string();\n    }\n    let\
    \ (before_dot, after_dot) = file_name.split_at(dots[0].len());\n    if before_dot.len()\
    \ < 2 {\n        return \"No\".to_string();\n    }\n    if !before_dot.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    match after_dot {\n      \
    \  \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpsied5yi1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.matches(char::is_numeric).count() > 3\
    \ ||\n       file_name.matches('.').count() != 1 {\n        \"No\".to_string()\n\
    \    } else {\n        let mut vec: Vec<&str> = file_name.split('.').collect();\n\
    \        let name = vec.remove(0);\n        let sub = vec.pop().unwrap();\n  \
    \      if name.chars().next().unwrap().is_alphabetic() && sub.len() == 3 &&\n\
    \           (sub == \"txt\" || sub == \"exe\" || sub == \"dll\") {\n         \
    \   \"Yes\".to_string()\n        } else {\n            \"No\".to_string()\n  \
    \      }\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpe_a16gf0.rs:21:32\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: Implement the function here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0rjrko_8.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1qtq8xjq.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let pat_file_name = Regex::new(r\"^[a-zA-Z]+[0-9]{0,3}\\\
    .[a-zA-Z]{3}$\").unwrap();\n    if pat_file_name.is_match(&file_name) {\n    \
    \    return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpidfvo7ga.rs:14:25\n   |\n14 |     let pat_file_name = Regex::new(r\"\
    ^[a-zA-Z]+[0-9]{0,3}\\.[a-zA-Z]{3}$\").unwrap();\n   |                       \
    \  ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqi7g8m54.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|c| c.is_numeric()).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    if file_name.chars().filter(|c|\
    \ *c == '.').count() != 1 {\n        return \"No\".to_string();\n    }\n    let\
    \ mut dot_index = 0;\n    for i in 0..file_name.len() {\n        if file_name.chars().nth(i).unwrap()\
    \ == '.' {\n            dot_index = i;\n            break;\n        }\n    }\n\
    \    let prefix = &file_name[0..dot_index];\n    let suffix = &file_name[dot_index+1..];\n\
    \    if prefix.len() == 0 || !prefix.chars().nth(0).unwrap().is_alphabetic() {\n\
    \        return \"No\".to_string();\n    }\n    if suffix != \"txt\" && suffix\
    \ != \"exe\" && suffix != \"dll\" {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut valid = true;\n    let mut file_type = None;\n\
    \    let mut file_name_s = None;\n    let mut digits = 0;\n    let mut dot_cnt\
    \ = 0;\n    for (i, c) in file_name.chars().enumerate() {\n        if !valid {\n\
    \            break;\n        }\n        match c {\n            '0'..='9' => {\n\
    \                digits += 1;\n                if digits > 3 {\n             \
    \       valid = false;\n                }\n            }\n            '.' => {\n\
    \                dot_cnt += 1;\n                if dot_cnt > 1 {\n           \
    \         valid = false;\n                }\n            }\n            'a'..='z'\
    \ | 'A'..='Z' => {\n                if dot_cnt == 0 {\n                    file_name_s\
    \ = Some(file_name[i..].to_string());\n                }\n            }\n    \
    \        _ => {\n                valid = false;\n            }\n        }\n  \
    \  }\n    if valid && dot_cnt == 1 && digits < 4 {\n        if let Some(s) = file_name_s\
    \ {\n            if let Some(d) = s.find('.') {\n                let file_name\
    \ = &s[..d];\n                let file_type = &s[d + 1..];\n                if\
    \ file_type == \"txt\" || file_type == \"exe\" || file_type == \"dll\" {\n   \
    \                 if file_name.len() > 0 {\n                        valid = true;\n\
    \                    }\n                }\n            }\n        }\n    } else\
    \ {\n        valid = false;\n    }\n    if valid {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpglkyfrhn.rs:15:25\n\
    \   |\n15 |     let mut file_type = None;\n   |         -------------   ^^^^ cannot\
    \ infer type for type parameter `T` declared on the enum `Option`\n   |      \
    \   |\n   |         consider giving `file_type` the explicit type `Option<T>`,\
    \ where the type parameter `T` is specified\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re1 = Regex::new(r\"(.*)[0-9]{4,}\").unwrap();\n\
    \    let re2 = Regex::new(r\"(.*)\\.(.*)\").unwrap();\n    let re3 = Regex::new(r\"\
    ([a-zA-Z]+)\\.(.*)\").unwrap();\n    let re4 = Regex::new(r\"(.*)\\.(txt|exe|dll)\"\
    ).unwrap();\n    if re1.is_match(&file_name) {\n        \"No\".to_string()\n \
    \   } else if !re2.is_match(&file_name) {\n        \"No\".to_string()\n    } else\
    \ if !re3.is_match(&file_name) {\n        \"No\".to_string()\n    } else if !re4.is_match(&file_name)\
    \ {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpib1sfkic.rs:14:15\n   |\n14 |     let re1 = Regex::new(r\"(.*)[0-9]{4,}\"\
    ).unwrap();\n   |               ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmpib1sfkic.rs:15:15\n\
    \   |\n15 |     let re2 = Regex::new(r\"(.*)\\.(.*)\").unwrap();\n   |       \
    \        ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Regex`\n  --> /tmp/tmpib1sfkic.rs:16:15\n   |\n16 |\
    \     let re3 = Regex::new(r\"([a-zA-Z]+)\\.(.*)\").unwrap();\n   |          \
    \     ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Regex`\n  --> /tmp/tmpib1sfkic.rs:17:15\n   |\n17 |\
    \     let re4 = Regex::new(r\"(.*)\\.(txt|exe|dll)\").unwrap();\n   |        \
    \       ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0_hctfpg.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6o2o11o2.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.chars().filter(|x| x.is_numeric()).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let mut name_ext: Vec<&str>\
    \ = file_name.split('.').collect();\n    if name_ext.len() != 2 {\n        return\
    \ \"No\".to_string();\n    }\n    if name_ext[0].is_empty() || !name_ext[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    match name_ext[1] {\n    \
    \    \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\"\
    .to_string(),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.contains(|c: char| c.is_numeric() && c\
    \ != '.') {\n        return \"No\".to_string();\n    }\n    if file_name.matches('.').count()\
    \ != 1 {\n        return \"No\".to_string();\n    }\n    let splitted: Vec<&str>\
    \ = file_name.split('.').collect();\n    if splitted[0].len() == 0 || !splitted[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    match splitted[1] {\n    \
    \    \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\"\
    .to_string(),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpehbm_d2o.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^([a-zA-Z]+)([0-9]{0,3})\\.(txt|exe|dll)$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        \"Yes\".to_string()\n \
    \   } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpsska2a7p.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^([a-zA-Z]+)([0-9]{0,3})\\\
    .(txt|exe|dll)$\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if let Some(dot_index) = file_name.find('.') {\n  \
    \      let prefix = &file_name[..dot_index];\n        let postfix = &file_name[dot_index\
    \ + 1..];\n        if prefix.chars().count() <= 0 {\n            return \"No\"\
    .to_string();\n        }\n        if prefix.chars().find(|c| !c.is_alphabetic()).is_some()\
    \ {\n            return \"No\".to_string();\n        }\n        if prefix.chars().filter(|c|\
    \ c.is_numeric()).count() > 3 {\n            return \"No\".to_string();\n    \
    \    }\n        if [\"txt\", \"exe\", \"dll\"].contains(&postfix.as_str()) {\n\
    \            return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpzyzf1btl.rs:26:52\n   |\n26 |         if [\"txt\"\
    , \"exe\", \"dll\"].contains(&postfix.as_str()) {\n   |                      \
    \                             -^^^^^^-- help: remove this method call\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO!\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Yes\"`', /tmp/tmp77p8hwv3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z]{1}[\\w]{0,254}\\.(txt|exe|dll)$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        \"Yes\".to_string()\n \
    \   } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpzg8fch4x.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z]{1}[\\\
    w]{0,254}\\.(txt|exe|dll)$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() < 5 {\n        return \"No\".to_string();\n\
    \    }\n    let mut cnt_dot = 0;\n    let mut cnt_digit = 0;\n    let mut contains_valid_char\
    \ = false;\n    for i in 0..file_name.len() {\n        let c = file_name.chars().nth(i).unwrap();\n\
    \        if c == '.' {\n            cnt_dot += 1;\n        } else if c.is_digit(10)\
    \ {\n            cnt_digit += 1;\n        } else if c.is_alphabetic() {\n    \
    \        contains_valid_char = true;\n        }\n    }\n    if cnt_dot != 1 ||\
    \ cnt_digit > 3 || !contains_valid_char {\n        return \"No\".to_string();\n\
    \    }\n    let mut left = 0;\n    let mut right = file_name.len() - 1;\n    while\
    \ file_name.chars().nth(left).unwrap() != '.' {\n        left += 1;\n    }\n \
    \   while file_name.chars().nth(right).unwrap() != '.' {\n        right -= 1;\n\
    \    }\n    if left == 0 || (right != file_name.len() - 4 && right != file_name.len()\
    \ - 3) {\n        return \"No\".to_string();\n    }\n    let ext = &file_name[right\
    \ + 1..];\n    match ext {\n        \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n\
    \        _ => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpifwxts2a.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // #TODO\n    \"Yes\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp3heav4kx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n  let mut digit_counter = 0;\n  let mut dot_counter = 0;\n\
    \  let mut non_empty_string = false;\n  let mut non_letter_character = false;\n\
    \  let mut dot_found = false;\n  let mut extention_found = false;\n  let extention_list\
    \ = [\"txt\", \"exe\", \"dll\"];\n  for ch in file_name.chars() {\n    if ch.is_numeric()\
    \ {\n      digit_counter += 1;\n    } else if !dot_found && ch == '.' {\n    \
    \  dot_counter += 1;\n      dot_found = true;\n    } else if !dot_found && ch.is_alphabetic()\
    \ {\n      non_empty_string = true;\n    } else if !dot_found && !ch.is_alphabetic()\
    \ {\n      non_letter_character = true;\n    } else if dot_found && !extention_found\
    \ {\n      for extention in extention_list.iter() {\n        if extention == &file_name[file_name.len()\
    \ - 3..] {\n          extention_found = true;\n        }\n      }\n    }\n  }\n\
    \  if digit_counter > 3 || dot_counter != 1 || !non_empty_string || non_letter_character\
    \ || !extention_found {\n    \"No\".to_string()\n  } else {\n    \"Yes\".to_string()\n\
    \  }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpx6wrrqd2.rs:33:22\n\
    \   |\n33 |         if extention == &file_name[file_name.len() - 3..] {\n   |\
    \                      ^^ no implementation for `&str == str`\n   |\n   = help:\
    \ the trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n    let\
    \ first_part = parts[0];\n    let second_part = parts[1];\n    if !first_part.is_ascii()\
    \ || !second_part.is_ascii() {\n        return \"No\".to_string();\n    }\n  \
    \  if !first_part.chars().next().unwrap().is_ascii_alphabetic() {\n        return\
    \ \"No\".to_string();\n    }\n    let second_part_valid = [\"txt\", \"exe\", \"\
    dll\"].contains(&second_part);\n    if !second_part_valid {\n        return \"\
    No\".to_string();\n    }\n    let is_digit = |c: char| -> bool { c.is_ascii_digit()\
    \ };\n    let count_digits = first_part.chars().filter(is_digit).count();\n  \
    \  if count_digits > 3 {\n        return \"No\".to_string();\n    }\n    \"Yes\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n   --> /tmp/tmp7_9wg5vs.rs:31:50\n\
    \    |\n30  |     let is_digit = |c: char| -> bool { c.is_ascii_digit() };\n \
    \   |                    ----------------- found signature of `fn(char) -> _`\n\
    31  |     let count_digits = first_part.chars().filter(is_digit).count();\n  \
    \  |                                           ------ ^^^^^^^^ expected signature\
    \ of `for<'r> fn(&'r char) -> _`\n    |                                      \
    \     |\n    |                                           required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `filter`\n\nerror[E0599]:\
    \ the method `count` exists for struct `Filter<Chars<'_>, [closure@/tmp/tmp7_9wg5vs.rs:30:20:\
    \ 30:60]>`, but its trait bounds were not satisfied\n  --> /tmp/tmp7_9wg5vs.rs:31:60\n\
    \   |\n30 |       let is_digit = |c: char| -> bool { c.is_ascii_digit() };\n \
    \  |                      -----------------\n   |                      |\n   |\
    \                      doesn't satisfy `<_ as FnOnce<(&char,)>>::Output = bool`\n\
    \   |                      doesn't satisfy `_: FnMut<(&char,)>`\n31 |       let\
    \ count_digits = first_part.chars().filter(is_digit).count();\n   |          \
    \                                                    ^^^^^ method cannot be called\
    \ on `Filter<Chars<'_>, [closure@/tmp/tmp7_9wg5vs.rs:30:20: 30:60]>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<[closure@/tmp/tmp7_9wg5vs.rs:30:20: 30:60] as FnOnce<(&char,)>>::Output\
    \ = bool`\n           which is required by `Filter<Chars<'_>, [closure@/tmp/tmp7_9wg5vs.rs:30:20:\
    \ 30:60]>: Iterator`\n           `[closure@/tmp/tmp7_9wg5vs.rs:30:20: 30:60]:\
    \ FnMut<(&char,)>`\n           which is required by `Filter<Chars<'_>, [closure@/tmp/tmp7_9wg5vs.rs:30:20:\
    \ 30:60]>: Iterator`\n           `Filter<Chars<'_>, [closure@/tmp/tmp7_9wg5vs.rs:30:20:\
    \ 30:60]>: Iterator`\n           which is required by `&mut Filter<Chars<'_>,\
    \ [closure@/tmp/tmp7_9wg5vs.rs:30:20: 30:60]>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Your solution here\n    String::from(\"No\")\n}\n\
    \nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpmkmdr22h.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z]+\\d{0,3}.[txt|exe|dll]$\"\
    ).unwrap();\n    match re.is_match(&file_name) {\n        true => \"Yes\".to_string(),\n\
    \        false => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpji52nfyd.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z]+\\\
    d{0,3}.[txt|exe|dll]$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO\n    \"No\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpl5099vht.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut num_digits = 0;\n    let mut has_dot = false;\n\
    \    let mut name_len = 0;\n    let mut ext_len = 0;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        match c {\n            '0'..='9' => num_digits += 1,\n          \
    \  '.' => {\n                if has_dot {\n                    return \"No\".to_string();\n\
    \                }\n                has_dot = true;\n                name_len\
    \ = i;\n            },\n            'a'..='z' | 'A'..='Z' => {\n             \
    \   if i == 0 {\n                    continue;\n                }\n          \
    \      let ext = &file_name[i..];\n                if ext == \"txt\" || ext ==\
    \ \"exe\" || ext == \"dll\" {\n                    ext_len = ext.len();\n    \
    \            }\n            },\n            _ => return \"No\".to_string(),\n\
    \        }\n    }\n    if num_digits > 3 || !has_dot || name_len == 0 || name_len\
    \ + ext_len != file_name.len() {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp02h8jkff.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Write your code here\n    return \"Yes\".to_string();\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmppp7r40zf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut counter = 0;\n    let mut dot_counter = 0;\n\
    \    let mut num_counter = 0;\n    let mut letter_counter = 0;\n    let mut dot_index\
    \ = 0;\n    let mut letter_index = 0;\n    let file_name_length = file_name.len();\n\
    \    for (i, c) in file_name.chars().enumerate() {\n        if c.is_alphabetic()\
    \ {\n            letter_counter += 1;\n            letter_index = i;\n       \
    \ }\n        if c.is_digit(10) {\n            num_counter += 1;\n        }\n \
    \       if c == '.' {\n            dot_counter += 1;\n            dot_index =\
    \ i;\n        }\n    }\n    if letter_counter == 0 || num_counter > 3 || dot_counter\
    \ != 1 {\n        return \"No\".to_string();\n    }\n    if letter_index == 0\
    \ {\n        return \"No\".to_string();\n    }\n    if dot_index + 4 != file_name_length\
    \ {\n        return \"No\".to_string();\n    }\n    let file_type = file_name.chars().skip(dot_index\
    \ + 1).take(3).collect::<String>();\n    if file_type != \"txt\" && file_type\
    \ != \"exe\" && file_type != \"dll\" {\n        return \"No\".to_string();\n \
    \   }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpfj93had4.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut three_numbers_count = 0;\n    let mut dot_count\
    \ = 0;\n    let mut found_latin_alphapet = false;\n    let mut substring_after_dot\
    \ = \"\";\n    for c in file_name.chars() {\n        if c.is_digit(10) {\n   \
    \         three_numbers_count += 1;\n        } else if c == '.' {\n          \
    \  dot_count += 1;\n        } else if c.is_alphabetic() {\n            found_latin_alphapet\
    \ = true;\n        } else {\n            return \"No\".to_string();\n        }\n\
    \        if three_numbers_count > 3 {\n            return \"No\".to_string();\n\
    \        }\n        if dot_count > 1 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    substring_after_dot = &file_name[file_name.find('.').unwrap()+1..];\n\
    \    if !found_latin_alphapet ||\n        !(substring_after_dot == \"txt\" ||\n\
    \        substring_after_dot == \"exe\" ||\n        substring_after_dot == \"\
    dll\") ||\n        file_name.find('.').unwrap() == 0 {\n        return \"No\"\
    .to_string();\n    }\n    return \"Yes\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpin0h1wt9.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits = 0;\n    let mut dot = false;\n   \
    \ let mut is_valid = true;\n    let mut p1 = true;\n    let mut p2 = false;\n\
    \    let mut p3 = false;\n    let mut p4 = false;\n    for c in file_name.chars()\
    \ {\n        if p1 {\n            if c.is_ascii_digit() {\n                digits\
    \ += 1;\n                if digits > 3 {\n                    is_valid = false;\n\
    \                    break;\n                }\n            } else if c == '.'\
    \ {\n                p1 = false;\n                p2 = true;\n               \
    \ dot = true;\n            } else if !c.is_ascii_alphabetic() {\n            \
    \    is_valid = false;\n                break;\n            }\n        } else\
    \ if p2 {\n            if c == 't' {\n                p2 = false;\n          \
    \      p3 = true;\n            } else {\n                is_valid = false;\n \
    \               break;\n            }\n        } else if p3 {\n            if\
    \ c == 'x' {\n                p3 = false;\n                p4 = true;\n      \
    \      } else {\n                is_valid = false;\n                break;\n \
    \           }\n        } else if p4 {\n            if c == 'e' {\n           \
    \     p4 = false;\n            } else {\n                is_valid = false;\n \
    \               break;\n            }\n        } else {\n            is_valid\
    \ = false;\n            break;\n        }\n    }\n    if !dot || p2 || p3 || p4\
    \ {\n        is_valid = false;\n    }\n    if is_valid {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmplqa4nkpw.rs:77:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let is_valid = file_name.chars().filter(|&x| x >= '0'\
    \ && x <= '9').count() <= 3\n                     && file_name.matches('.').count()\
    \ == 1\n                     && file_name.starts_with(|x: char| x >= 'a' && x\
    \ <= 'z' || x >= 'A' && x <= 'Z')\n                     && file_name.matches('.').next().unwrap().len()\
    \ > 1\n                     && file_name.matches('.').last().unwrap().len() >\
    \ 1\n                     && file_name.matches('.').last().unwrap().starts_with(|x:\
    \ char| x >= 'a' && x <= 'z' || x >= 'A' && x <= 'Z' )\n                     &&\
    \ (file_name.matches('.').last().unwrap() == \"txt\" || file_name.matches('.').last().unwrap()\
    \ == \"exe\" || file_name.matches('.').last().unwrap() == \"dll\");\n    if is_valid\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpqlstg6th.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // First, try to split the file name into two pieces,\
    \ according to the '.' char.\n    let mut split = file_name.split(\".\");\n  \
    \  // Regex to check that the substring before the dot contains no more than three\
    \ \n    // digits, and starts with a latin alphapet letter.\n    let valid_first_half\
    \ = Regex::new(r\"(?i)(^[a-z](?!.*[0-9]{4}).*[0-9]{0,3}$)\").unwrap();\n    //\
    \ Regex to check that the substring after the dot is one of the valid ones.\n\
    \    let valid_second_half = Regex::new(r\"(?i)(^(txt|exe|dll)$)\").unwrap();\n\
    \    // Check that the file name contains exactly one dot '.', and that it's in\
    \ the middle.\n    if split.clone().count() != 2 || file_name.chars().rev().next().unwrap()\
    \ != '.' {\n        return \"No\".to_string();\n    }\n    // Check that the first\
    \ half of the file name is valid.\n    if valid_first_half.is_match(split.next().unwrap())\
    \ {\n        // Check that the second half of the file name is valid.\n      \
    \  if valid_second_half.is_match(split.next().unwrap()) {\n            // If all\
    \ conditions above are met, the file name is valid.\n            return \"Yes\"\
    .to_string();\n        }\n    }\n    // Otherwise, the file name is invalid.\n\
    \    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp2l8ajwwq.rs:18:28\n   |\n18 |     let valid_first_half = Regex::new(r\"\
    (?i)(^[a-z](?!.*[0-9]{4}).*[0-9]{0,3}$)\").unwrap();\n   |                   \
    \         ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Regex`\n  --> /tmp/tmp2l8ajwwq.rs:20:29\n   |\n20 |\
    \     let valid_second_half = Regex::new(r\"(?i)(^(txt|exe|dll)$)\").unwrap();\n\
    \   |                             ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Delete invalid digits in `file_name`\n    // The\
    \ length difference of `file_name` must be one\n    if file_name.replace(|c: char|\
    \ c.is_ascii_digit(), \"\").len() - file_name.len() > 1 {\n        return \"No\"\
    .to_string();\n    }\n\n    // Find the dot `.` index in `file_name`\n    // If\
    \ the dot is not found, return \"No\"\n    // If the dot is found more than once,\
    \ return \"No\"\n    let dot_index = file_name.find('.');\n    if dot_index.is_none()\
    \ || file_name.find('.').unwrap() != file_name.rfind('.').unwrap() {\n       \
    \ return \"No\".to_string();\n    }\n\n    // Get the substrings before and after\
    \ the dot\n    let (before_dot, after_dot) = file_name.split_at(dot_index.unwrap());\n\
    \n    // Check if the substring before the dot is valid\n    // A substring before\
    \ the dot is valid if and only if it satisfies both of\n    // these conditions:\n\
    \    // - It is not empty\n    // - It starts with a latin alphapet\n    let before_dot_validity\
    \ = !before_dot.is_empty() && match before_dot.chars().next() {\n        Some(c)\
    \ => c.is_ascii_alphabetic(),\n        None => false,\n    };\n\n    // Check\
    \ if the substring after the dot is valid\n    // A substring after the dot is\
    \ valid if and only if it is one of these:\n    // ['txt', 'exe', 'dll']\n   \
    \ let after_dot_validity = [\"txt\", \"exe\", \"dll\"].contains(&after_dot);\n\
    \n    // If both substrings are valid, return \"Yes\"\n    // Otherwise, return\
    \ \"No\"\n    if before_dot_validity && after_dot_validity {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpduxemv8c.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n\t// TODO: Fix this and add tests\n\tif file_name.split('.').count()\
    \ == 2 {\n\t\tlet name = file_name.split('.').next().unwrap();\n\t\tif name.len()\
    \ > 0 && name.chars().next().unwrap().is_alphabetic() {\n\t\t\tif !name.chars().any(|x|\
    \ x.is_digit(10)) {\n\t\t\t\tif file_name.split('.').last().unwrap() == \"txt\"\
    \n\t\t\t\t|| file_name.split('.').last().unwrap() == \"exe\"\n\t\t\t\t|| file_name.split('.').last().unwrap()\
    \ == \"dll\" {\n\t\t\t\t\treturn \"Yes\".to_string();\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\t\"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp2u3fhlf8.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,3}\\\
    .txt$|^[a-zA-Z][a-zA-Z0-9]{0,3}\\.exe$|^[a-zA-Z][a-zA-Z0-9]{0,3}\\.dll$\").unwrap();\n\
    \    if re.is_match(&file_name) {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp4119sgs8.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,3}\\\
    .txt$|^[a-zA-Z][a-zA-Z0-9]{0,3}\\.exe$|^[a-zA-Z][a-zA-Z0-9]{0,3}\\.dll$\").unwrap();\n\
    \   |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmps_eqd0k9.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphnn87a_a.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let check_name = |name: &str| {\n        let dot_position\
    \ = name.rfind('.').unwrap();\n        let ext = &name[dot_position + 1..];\n\
    \        ext == \"txt\" || ext == \"exe\" || ext == \"dll\"\n    };\n    let mut\
    \ dot_found = false;\n    let mut digits_counter = 0;\n    for c in file_name.chars()\
    \ {\n        if c == '.' {\n            if dot_found {\n                return\
    \ \"No\".to_string();\n            }\n            dot_found = true;\n        }\
    \ else if c.is_digit(10) {\n            digits_counter += 1;\n            if digits_counter\
    \ > 3 {\n                return \"No\".to_string();\n            }\n        }\n\
    \    }\n    if dot_found && check_name(&file_name) {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpzzczwg6w.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let dot_index = file_name.find('.').unwrap();\n   \
    \ let (name, ext) = file_name.split_at(dot_index);\n    if name.contains(char::is_numeric)\
    \ {\n        return \"No\".to_string();\n    }\n    if ext != \".txt\" && ext\
    \ != \".exe\" && ext != \".dll\" {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprsbzculg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    use std::collections::HashSet;\n    let valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"].iter().map(|s| *s).collect::<HashSet<_>>();\n\
    \    let parts: Vec<&str> = file_name.split(\".\").collect();\n    if parts.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    let num_digits = parts[0].chars().filter(|c|\
    \ \"0123456789\".contains(*c)).count();\n    if num_digits > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    if !(parts[0].len() > 0 && parts[0].chars().next().unwrap().is_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    if !valid_extensions.contains(parts[1])\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52wxtcpk.rs:13:42\n   |\n\
    13 | fn file_name_check(file_name: String) -> String {\n   |    ---------------\
    \                       ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() == 0 {\n        return \"No\".to_string();\n\
    \    }\n    let file_name_arr: Vec<char> = file_name.chars().collect();\n    if\
    \ file_name_arr[0].is_digit(10) {\n        return \"No\".to_string();\n    }\n\
    \    let mut dot_num = 0;\n    let mut digit_num = 0;\n    for s in file_name_arr\
    \ {\n        if s == '.' {\n            dot_num += 1;\n        }\n        if s.is_digit(10)\
    \ {\n            digit_num += 1;\n        }\n    }\n    if dot_num != 1 || digit_num\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let mut extension_str\
    \ = String::new();\n    let mut before_dot_str = String::new();\n    let mut found_dot\
    \ = false;\n    for s in file_name_arr {\n        if s == '.' {\n            found_dot\
    \ = true;\n            continue;\n        }\n        if found_dot {\n        \
    \    extension_str.push(s);\n        } else {\n            before_dot_str.push(s);\n\
    \        }\n    }\n    if before_dot_str.len() == 0 {\n        return \"No\".to_string();\n\
    \    }\n    if extension_str != \"txt\" && extension_str != \"exe\" && extension_str\
    \ != \"dll\" {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `file_name_arr`\n   --> /tmp/tmpfdcikm7_.rs:37:14\n\
    \    |\n17  |     let file_name_arr: Vec<char> = file_name.chars().collect();\n\
    \    |         ------------- move occurs because `file_name_arr` has type `Vec<char>`,\
    \ which does not implement the `Copy` trait\n...\n23  |     for s in file_name_arr\
    \ {\n    |              ------------- `file_name_arr` moved due to this implicit\
    \ call to `.into_iter()`\n...\n37  |     for s in file_name_arr {\n    |     \
    \         ^^^^^^^^^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `file_name_arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<char>`'s content to avoid moving into the\
    \ `for` loop\n    |\n23  |     for s in &file_name_arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: Add some code here\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpxcv3yynp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut file_name_str = &file_name[..];\n    let mut\
    \ num_of_digits = 0;\n    let mut index_of_dot = 0;\n    let mut index = 0;\n\
    \    for c in file_name_str.chars() {\n        if !c.is_ascii_alphabetic() &&\
    \ !c.is_ascii_digit() {\n            if c == '.' {\n                if index_of_dot\
    \ != 0 {\n                    return \"No\".to_string();\n                }\n\
    \                index_of_dot = index;\n            } else {\n               \
    \ return \"No\".to_string();\n            }\n        } else if c.is_ascii_digit()\
    \ {\n            num_of_digits += 1;\n        }\n        index += 1;\n    }\n\
    \    if num_of_digits > 3 {\n        return \"No\".to_string();\n    }\n    if\
    \ index_of_dot == 0 {\n        return \"No\".to_string();\n    }\n    if index_of_dot\
    \ == 1 {\n        if !file_name_str.chars().nth(0).unwrap().is_ascii_alphabetic()\
    \ {\n            return \"No\".to_string();\n        }\n    }\n    let (_, file_type)\
    \ = file_name_str.split_at(index_of_dot);\n    if file_type != \".txt\" && file_type\
    \ != \".exe\" && file_type != \".dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpt54dgaun.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let words = file_name.split(\".\").collect::<Vec<&str>>();\n\
    \    let mut result = String::from(\"No\");\n    let mut count = 0;\n    let mut\
    \ start = false;\n    if words.len() == 2 {\n        for i in words[0].chars()\
    \ {\n            if i.is_digit(10) {\n                count += 1;\n          \
    \  }\n            if count > 3 {\n                break;\n            }\n    \
    \        if i.is_alphabetic() {\n                start = true;\n            }\n\
    \        }\n        if count <= 3 && start && words[1] == \"txt\" || words[1]\
    \ == \"exe\" || words[1] == \"dll\" {\n            result = String::from(\"Yes\"\
    );\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpk4mo6tih.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // if contains chars not a-z or A-Z or 0-9 or .\n \
    \   // iterate through file_name\n    // count digits in file_name\n    // count\
    \ number of .'s in file_name\n    // find index of . in file_name\n    // is the\
    \ substring from index to . == \"\"\n    // is the . in the index 0 or last position\n\
    \    // is the substring from . to end in [\"txt\", \"exe\", \"dll\"]\n    let\
    \ mut check = 0;\n    for ch in file_name.chars() {\n        if !ch.is_alphanumeric()\
    \ && ch != '.' {\n            check = 1;\n        }\n    }\n    if check == 1\
    \ {\n        return \"No\".to_string();\n    }\n\n    let mut count_digits = 0;\n\
    \    for ch in file_name.chars() {\n        if ch.is_numeric() {\n           \
    \ count_digits += 1;\n        }\n    }\n    if count_digits > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    let mut count_dots = 0;\n    for ch in file_name.chars()\
    \ {\n        if ch == '.' {\n            count_dots += 1;\n        }\n    }\n\
    \    if count_dots != 1 {\n        return \"No\".to_string();\n    }\n\n    let\
    \ index_of_dot = file_name.find('.').unwrap();\n    if index_of_dot == 0 || index_of_dot\
    \ == file_name.len() - 1 {\n        return \"No\".to_string();\n    }\n\n    let\
    \ substring_1 = &file_name[..index_of_dot];\n    if substring_1 == \"\" {\n  \
    \      return \"No\".to_string();\n    }\n\n    let substring_2 = &file_name[index_of_dot\
    \ + 1..];\n    if substring_2 != \"txt\" && substring_2 != \"exe\" && substring_2\
    \ != \"dll\" {\n        return \"No\".to_string();\n    }\n\n    return \"Yes\"\
    .to_string();\n}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpu95dxpdo.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9vuux5kj.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    // TODO: implement this method\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Yes\"`', /tmp/tmp3lt2b9nb.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpyi92bx0m.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut count_digits = 0;\n    let mut count_dots =\
    \ 0;\n    let len = file_name.len();\n    let mut dot_index = len;\n    for i\
    \ in 0..len {\n        let c = file_name.chars().nth(i).unwrap();\n        if\
    \ c.is_digit(10) {\n            count_digits += 1;\n        } else if c == '.'\
    \ {\n            count_dots += 1;\n            dot_index = i;\n        }\n   \
    \ }\n    if count_digits > 3 || count_dots != 1 || dot_index == 0 || dot_index\
    \ == len - 1 {\n        return \"No\".to_string();\n    }\n    let sub = &file_name[0..dot_index];\n\
    \    if !sub.chars().next().unwrap().is_alphabetic() {\n        return \"No\"\
    .to_string();\n    }\n    let sub = &file_name[dot_index + 1..len];\n    match\
    \ sub {\n        \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n       \
    \ _ => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if file_name.len() <= 4 {\n        return \"No\".to_string();\n\
    \    }\n    let mut count = 0;\n    let mut last_char_was_dot = false;\n    let\
    \ mut dot_found = false;\n    let mut is_valid = true;\n    for ch in file_name.chars()\
    \ {\n        if ch.is_ascii_digit() {\n            count += 1;\n            if\
    \ count > 3 {\n                is_valid = false;\n                break;\n   \
    \         }\n        } else if ch == '.' {\n            last_char_was_dot = true;\n\
    \            dot_found = true;\n        } else if !ch.is_ascii_alphabetic() {\n\
    \            is_valid = false;\n            break;\n        } else if last_char_was_dot\
    \ {\n            let s = &file_name[ch.len_utf8()..];\n            if s != \"\
    txt\" && s != \"exe\" && s != \"dll\" {\n                is_valid = false;\n \
    \               break;\n            }\n        }\n    }\n    if !dot_found {\n\
    \        is_valid = false;\n    }\n    if is_valid {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0__6uyaq.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmn6ztfd3.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n  \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp79zgkifg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut num_of_digits = 0;\n    let mut num_of_dots\
    \ = 0;\n    let mut start_with_alphapet = false;\n    let mut end_with_valid_chars\
    \ = false;\n    let mut is_valid = true;\n    for c in file_name.chars() {\n \
    \       match c {\n            '0'...'9' => num_of_digits += 1,\n            '.'\
    \ => num_of_dots += 1,\n            'a'...'z' | 'A'...'Z' => start_with_alphapet\
    \ = true,\n            _ => is_valid = false,\n        }\n    }\n    if !is_valid\
    \ || num_of_digits > 3 || num_of_dots != 1 || !start_with_alphapet {\n       \
    \ return \"No\".to_string();\n    }\n    let file_name_parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if file_name_parts.len() != 2 {\n        return \"No\".to_string();\n   \
    \ }\n    match file_name_parts[1] {\n        \"txt\" | \"exe\" | \"dll\" => end_with_valid_chars\
    \ = true,\n        _ => is_valid = false,\n    }\n    if !is_valid || !end_with_valid_chars\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpfzebnnld.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsdeblwfy.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    if !file_name.chars().any(|c| c == '.') {\n       \
    \ return \"No\".to_string();\n    }\n    let splitted: Vec<&str> = file_name.split('.').collect();\n\
    \    if splitted.len() != 2 {\n        return \"No\".to_string();\n    }\n   \
    \ if !splitted[0].chars().any(|c| c.is_alphabetic()) {\n        return \"No\"\
    .to_string();\n    }\n    if splitted[1] != \"txt\" && splitted[1] != \"exe\"\
    \ && splitted[1] != \"dll\" {\n        return \"No\".to_string();\n    }\n   \
    \ if splitted[0].chars().filter(|c| c.is_digit(10)).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpkmwzu5o9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let re = Regex::new(r\"^[a-zA-Z]{1}[\\w]{0,2}\\.[txt|exe|dll]$\"\
    ).unwrap();\n    if re.is_match(&file_name) {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpdi9ddyd9.rs:14:14\n   |\n14 |     let re = Regex::new(r\"^[a-zA-Z]{1}[\\\
    w]{0,2}\\.[txt|exe|dll]$\").unwrap();\n   |              ^^^^^ use of undeclared\
    \ type `Regex`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut digits_counter = 0;\n    let mut dot_counter\
    \ = 0;\n    let mut valid_alphapet = false;\n    let mut valid_extension = false;\n\
    \    let mut sub_str_check = String::new();\n    let mut sub_str_extension = String::new();\n\
    \    let mut char_counter = 0;\n    let mut is_valid = false;\n    for each_char\
    \ in file_name.chars() {\n        if char_counter == file_name.len() - 4 {\n \
    \           sub_str_check.push(each_char);\n        }\n        if char_counter\
    \ == file_name.len() - 3 {\n            sub_str_extension.push(each_char);\n \
    \       }\n        if each_char == '.' {\n            dot_counter += 1;\n    \
    \    }\n        if each_char.is_digit(10) {\n            digits_counter += 1;\n\
    \        }\n        if each_char.is_alphabetic() {\n            valid_alphapet\
    \ = true;\n        }\n        char_counter += 1;\n    }\n    if sub_str_extension\
    \ == \"txt\" || sub_str_extension == \"exe\" || sub_str_extension == \"dll\" {\n\
    \        valid_extension = true;\n    }\n    if valid_alphapet && valid_extension\
    \ && sub_str_check != \"\" && dot_counter == 1 && digits_counter <= 3 {\n    \
    \    is_valid = true;\n    }\n    if is_valid {\n        return \"Yes\".to_string();\n\
    \    } else {\n        return \"No\".to_string();\n    }\n}\n\nfn main() {\n \
    \   let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp2burmnkq.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")),\
    \ String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6y2p_rgp.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let mut cnt = 0;\n    let mut dot_pos = -1;\n    let\
    \ mut cnt_digits = 0;\n    for (i, ch) in file_name.chars().enumerate() {\n  \
    \      if ch == '.' {\n            cnt += 1;\n            dot_pos = i;\n     \
    \   }\n        if ch.is_digit(10) {\n            cnt_digits += 1;\n        }\n\
    \    }\n    if cnt != 1 || cnt_digits > 3 {\n        return \"No\".to_string();\n\
    \    }\n    let (before_dot, after_dot) = file_name.split_at(dot_pos);\n    if\
    \ !before_dot.is_empty() && before_dot.chars().next().unwrap().is_alphabetic()\
    \ && \n        [\"txt\", \"exe\", \"dll\"].contains(&after_dot.trim_start_matches('.'))\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\n\
    fn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpy7v44zfi.rs:15:23\n\
    \   |\n15 |     let mut dot_pos = -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    let n = file_name.chars().filter(|&c| c.is_digit(10)).count();\n\
    \    if n > 3 {\n        return \"No\".to_string();\n    }\n    let parts: Vec<&str>\
    \ = file_name.split('.').collect();\n    if parts.len() != 2 {\n        return\
    \ \"No\".to_string();\n    }\n    if parts[0].len() == 0 || !(parts[0].chars().next().unwrap().is_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    if parts[1] != \"txt\" &&\
    \ parts[1] != \"exe\" && parts[1] != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = file_name_check;\n\
    \    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"\
    ));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"\
    ));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"\
    No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function which takes a string representing a file's name,\
    \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
    /// A file's name is considered to be valid if and only if all the following conditions\
    \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
    \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// -\
    \ The substring before the dot should not be empty, and it starts with a letter\
    \ from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after\
    \ the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
    example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
    \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
    \ String) -> String {\n    use std::collections::HashSet;\n    use std::str::Chars;\n\
    \n    let ext_set: HashSet<&str> = [\"txt\", \"exe\", \"dll\"].iter().cloned().collect();\n\
    \    let mut digits = 0;\n    let mut num_dot = 0;\n    let mut empty_before_dot\
    \ = true;\n    let mut empty_after_dot = true;\n    let mut chars = file_name.chars();\n\
    \    loop {\n        match chars.next() {\n            Some(c) => {\n        \
    \        if c.is_digit(10) {\n                    digits += 1;\n             \
    \   } else if c == '.' {\n                    if digits > 3 {\n              \
    \          return \"No\".to_string();\n                    }\n               \
    \     num_dot += 1;\n                    empty_before_dot = false;\n         \
    \       } else if c.is_alphabetic() {\n                    empty_before_dot =\
    \ false;\n                }\n            }\n            None => {\n          \
    \      if num_dot != 1 {\n                    return \"No\".to_string();\n   \
    \             }\n                break;\n            }\n        }\n    }\n   \
    \ let ext: String = chars.collect();\n    if ext_set.contains(&ext.as_str()) {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
    example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
    1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
    K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
    )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
    )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")),\
    \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"\
    No\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpii74dp6l.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
