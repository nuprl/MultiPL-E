name: HumanEval_145_order_by_points
language: rust
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
  \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
  \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
  \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
  \ 23, 6, 6]);\n}\n"
completions: ["    if nums.is_empty() {\n        return vec![];\n    }\n    let mut\
    \ idx_vec: Vec<_> = nums.iter().enumerate().collect();\n    idx_vec.sort_by(|a,\
    \ b| {\n        let (a_num, a_idx) = a;\n        let (b_num, b_idx) = b;\n   \
    \     let sum_a = a_num.to_string().chars().fold(0, |sum, c| sum + c.to_digit(10).unwrap()\
    \ as isize);\n        let sum_b = b_num.to_string().chars().fold(0, |sum, c| sum\
    \ + c.to_digit(10).unwrap() as isize);\n        match sum_a.cmp(&sum_b) {\n  \
    \          Ordering::Less => Ordering::Less,\n            Ordering::Greater =>\
    \ Ordering::Greater,\n            Ordering::Equal => a_idx.cmp(b_idx),\n     \
    \   }\n    });\n    idx_vec.iter().map(|(n, _)| *n).collect()", "    // TODO\n\
    \    let mut nums = nums;\n    nums.sort_by(|a, b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n\
    \    nums", "    let mut nums_with_digits = nums.iter().map(|n| (*n, digits(*n))).collect::<Vec<_>>();\n\
    \    nums_with_digits.sort_by_key(|pair| pair.1);\n    nums_with_digits.iter().map(|pair|\
    \ pair.0).collect()", "    let mut nums = nums;\n    nums.sort_by_key(|n| n.abs()\
    \ % 10 + n.abs() / 10);\n    nums", "    let mut sorted = nums.clone();\n    sorted.sort_by(|a,\
    \ b| sum_digits(*a).cmp(&sum_digits(*b)));\n    sorted", "    let mut v = nums.clone();\n\
    \    v.sort_by(|a, b| {\n        let mut a_sum = 0;\n        let mut b_sum = 0;\n\
    \        for x in a.to_string().chars() {\n            a_sum += x.to_digit(10).unwrap()\
    \ as isize;\n        }\n        for x in b.to_string().chars() {\n           \
    \ b_sum += x.to_digit(10).unwrap() as isize;\n        }\n        a_sum.cmp(&b_sum)\n\
    \    });\n    v", "    let mut res = nums.clone();\n    res.sort_by(|a, b| a.abs().to_string().chars().sum::<u32>().cmp(&b.abs().to_string().chars().sum::<u32>()));\n\
    \    res", "    fn sum_digits(n: isize) -> isize {\n        n.abs()\n        \
    \    .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as isize)\n            .sum()\n    }\n\n    fn order_by_points_recursive(nums:\
    \ Vec<isize>) -> Vec<isize> {\n        if nums.len() <= 1 {\n            return\
    \ nums;\n        }\n\n        let pivot = nums[0];\n        let less = nums[1..]\n\
    \            .iter()\n            .cloned()\n            .filter(|&x| sum_digits(x)\
    \ < sum_digits(pivot))\n            .collect();\n        let equal = nums[1..]\n\
    \            .iter()\n            .cloned()\n            .filter(|&x| sum_digits(x)\
    \ == sum_digits(pivot))\n            .collect();\n        let greater = nums[1..]\n\
    \            .iter()\n            .cloned()\n            .filter(|&x| sum_digits(x)\
    \ > sum_digits(pivot))\n            .collect();\n\n        [&order_by_points_recursive(less),\
    \ &[pivot], &order_by_points_recursive(equal), &order_by_points_recursive(greater)].concat()\n\
    \    }\n\n    order_by_points_recursive(nums)", "    if nums.is_empty() {\n  \
    \      return vec![];\n    }\n    let mut result = nums.clone();\n    result.sort_by(|x,\
    \ y| {\n        let lhs = x.abs() / 10 + x.abs() % 10;\n        let rhs = y.abs()\
    \ / 10 + y.abs() % 10;\n        lhs.cmp(&rhs)\n    });\n    result", "    fn sum_of_digits(n:\
    \ isize) -> isize {\n        if n < 0 {\n            -sum_of_digits(-n)\n    \
    \    } else if n < 10 {\n            n\n        } else {\n            n % 10 +\
    \ sum_of_digits(n / 10)\n        }\n    }\n\n    nums.into_iter().enumerate().sorted_by_key(|(_,\
    \ n)| (sum_of_digits(*n), *n)).map(|(_, n)| n).collect()", '    nums.into_iter().enumerate().sorted_by_key(|&(i,
    n)| (sum_digits(n), i)).map(|(_, n)| n).collect()', "    let mut nums_digits =\
    \ Vec::new();\n    for num in nums {\n        let mut sum = 0;\n        let mut\
    \ n = num;\n        while n != 0 {\n            sum += n % 10;\n            n\
    \ /= 10;\n        }\n        nums_digits.push((num, sum));\n    }\n    nums_digits.sort_by(|x,\
    \ y| (x.1, x.0).cmp(&(y.1, y.0)));\n    nums_digits.iter().map(|x| x.0).collect()",
  "    let mut result = nums.clone();\n    result.sort_by(|a, b| {\n        let (c1,\
    \ c2) = (convert_to_digit_vector(*a), convert_to_digit_vector(*b));\n        let\
    \ (sum1, sum2) = (sum_all(c1), sum_all(c2));\n        if sum1 == sum2 {\n    \
    \        return a.cmp(b);\n        } else {\n            return sum1.cmp(&sum2);\n\
    \        }\n    });\n    result", "    nums.into_iter().enumerate().map(|(i, x)|\
    \ {\n        (x, i, digits(x).iter().sum::<isize>())\n    }).sorted_by(|a, b|\
    \ {\n        a.2.cmp(&b.2).then(a.1.cmp(&b.1))\n    }).map(|x| x.0).collect()",
  "    let mut new_vec = nums.clone();\n    new_vec.sort_by(|a, b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n\
    \    new_vec", "    nums.iter().enumerate().sorted_by(|a, b| {\n        (sum_of_digits(*a.1),\
    \ a.0)\n            .cmp(&(sum_of_digits(*b.1), b.0))\n    }).map(|(_, &x)| x).collect()",
  "    let mut map: HashMap<isize, Vec<usize>> = HashMap::new();\n    for (i, &num)\
    \ in nums.iter().enumerate() {\n        let mut m = num;\n        let mut sum\
    \ = 0;\n        while m != 0 {\n            sum += m % 10;\n            m /= 10;\n\
    \        }\n        let old = map.entry(sum).or_insert(Vec::new());\n        old.push(i);\n\
    \    }\n    let mut v: Vec<isize> = Vec::new();\n    let mut map2: HashMap<usize,\
    \ Vec<isize>> = HashMap::new();\n    for (_sum, indexes) in map.iter() {\n   \
    \     let mut list: Vec<isize> = Vec::new();\n        for &index in indexes.iter()\
    \ {\n            list.push(nums[index]);\n        }\n        list.sort();\n  \
    \      for i in 0..list.len() {\n            let old = map2.entry(indexes[i]).or_insert(Vec::new());\n\
    \            old.push(list[i]);\n        }\n    }\n    for (i, _v) in map2.iter()\
    \ {\n        v.push(nums[*i]);\n    }\n    v", '    unimplemented!()', "    nums.iter().enumerate().sorted_by(|x,\
    \ y| {\n        let (i, x) = x;\n        let (j, y) = y;\n        sum_of_digits(*x).cmp(&sum_of_digits(*y)).then(i.cmp(j))\n\
    \    }).map(|x| x.1).collect()", "    nums.iter().enumerate().map(|(idx, &num)|\
    \ (-(num as i64).abs() as usize, idx, num)).collect::<Vec<_>>().sort_by(|a, b|\
    \ {\n        let comp = a.0.cmp(&b.0);\n        if comp == Ordering::Equal {\n\
    \            a.1.cmp(&b.1)\n        } else {\n            comp\n        }\n  \
    \  }).iter().map(|&(_, _, num)| num).collect()", "    let mut result = nums.clone();\n\
    \    result.sort_by(|a, b| a.abs().to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>().cmp(&b.abs().to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>()));\n    result", '    nums.into_iter().enumerate().sorted_by_key(|&(i,
    x)| (x.abs() as usize + x.abs() as usize, i)).map(|(_, x)| x).collect()', "  \
    \  // Your code here!\n    let mut sum_map: HashMap<isize, isize> = HashMap::new();\n\
    \    let mut index_map: HashMap<isize, usize> = HashMap::new();\n    let mut order_index:\
    \ HashMap<usize, isize> = HashMap::new();\n    for (index, num) in nums.iter().enumerate()\
    \ {\n        let mut sum = 0;\n        let mut temp = *num;\n        while temp\
    \ != 0 {\n            sum += temp % 10;\n            temp /= 10;\n        }\n\
    \        sum_map.insert(*num, sum);\n        index_map.insert(*num, index);\n\
    \    }\n    let mut sorted_nums: Vec<isize> = nums.clone();\n    sorted_nums.sort_by(|a,\
    \ b| sum_map.get(a).unwrap().cmp(sum_map.get(b).unwrap()));\n    for (index, num)\
    \ in sorted_nums.iter().enumerate() {\n        order_index.insert(index_map.get(num).unwrap().clone(),\
    \ *num);\n    }\n    let mut result: Vec<isize> = Vec::new();\n    for i in 0..nums.len()\
    \ {\n        result.push(order_index.get(&i).unwrap().clone());\n    }\n    result",
  "    let mut vec: Vec<isize> = nums.clone();\n    vec.sort_by(|a, b| {\n       \
    \ let a_point = a.abs() as usize;\n        let b_point = b.abs() as usize;\n \
    \       let a_points = (a_point / 10) + (a_point % 10);\n        let b_points\
    \ = (b_point / 10) + (b_point % 10);\n        match a_points.cmp(&b_points) {\n\
    \            Ordering::Equal => nums.iter().position(|&x| x == *a).cmp(&nums.iter().position(|&x|\
    \ x == *b)),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    vec", "    let mut vec: Vec<(isize,\
    \ isize)> = nums.iter().map(|x| (get_sum_of_digits(*x), *x)).collect();\n    vec.sort_by(|a,\
    \ b| a.cmp(b));\n    vec.iter().map(|x| x.1).collect()", "    let mut sum = 0;\n\
    \    let mut vec = vec![];\n    let mut result = vec![];\n    for (i, num) in\
    \ nums.iter().enumerate() {\n        let mut num = *num;\n        while num !=\
    \ 0 {\n            sum += num % 10;\n            num /= 10;\n        }\n     \
    \   vec.push((sum, i));\n        sum = 0;\n    }\n    vec.sort();\n    for (sum,\
    \ i) in vec {\n        result.push(nums[i]);\n    }\n    result", "    let mut\
    \ nums = nums;\n    nums.sort_by_key(|x| x.abs() % 10 + x.abs() / 10);\n    nums",
  "    let mut nums_2 = nums.clone();\n    for i in 0..nums.len() {\n        for j\
    \ in 0..nums.len() - 1 {\n            if sum_digits(nums[j]) > sum_digits(nums[j\
    \ + 1]) {\n                nums_2[j] = nums[j + 1];\n                nums_2[j\
    \ + 1] = nums[j];\n            }\n        }\n    }\n    nums_2", "    let mut\
    \ b = nums.clone();\n    b.sort_by(|a, b| {\n        let a_sum = sum_digits(*a);\n\
    \        let b_sum = sum_digits(*b);\n        match a_sum.cmp(&b_sum) {\n    \
    \        Ordering::Equal => {\n                nums.iter().position(|&x| x ==\
    \ *a).cmp(&nums.iter().position(|&x| x == *b))\n            }\n            Ordering::Less\
    \ => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n  \
    \      }\n    });\n    b", "    let mut pair_vec: Vec<(isize, isize)> = Vec::new();\n\
    \    let mut answer: Vec<isize> = Vec::new();\n    for i in 0..nums.len() {\n\
    \        pair_vec.push((nums[i], i as isize));\n    }\n    pair_vec.sort_by(|&(ref\
    \ x, _), &(ref y, _)| {\n        let x_str = x.to_string();\n        let y_str\
    \ = y.to_string();\n        let x_sum: isize = x_str.chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum();\n        let y_sum: isize = y_str.chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum();\n        x_sum.cmp(&y_sum)\n    });\n    pair_vec.sort_by(|&(_,\
    \ ref x), &(_, ref y)| x.cmp(y));\n    for i in 0..pair_vec.len() {\n        answer.push(pair_vec[i].0);\n\
    \    }\n    answer", "    let mut items: Vec<(isize, usize)> = nums.iter().enumerate().map(|(i,\
    \ n)| (n.abs(), i)).collect();\n    items.sort_by(|a, b| a.0.cmp(&b.0));\n   \
    \ let mut result: Vec<isize> = Vec::new();\n    for (i, n) in items {\n      \
    \  result.push(nums[i]);\n    }\n    result", "    let mut r = nums;\n    r.sort_by(|a,\
    \ b| {\n        let sum_a = sum_digits(*a);\n        let sum_b = sum_digits(*b);\n\
    \        if sum_a == sum_b {\n            a.cmp(b)\n        } else {\n       \
    \     sum_a.cmp(&sum_b)\n        }\n    });\n    r", '    unimplemented!();',
  "    let mut n: Vec<_> = nums.iter().map(|n| (n, n.to_string())).collect();\n  \
    \  n.sort_by_key(|(n, num)| num.bytes().map(|b| (b - b'0') as isize).sum::<isize>());\n\
    \    n.into_iter().map(|(n, _)| *n).collect()", "    // TODO\n    unimplemented!();",
  '    unimplemented!()', "    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by(|a,\
    \ b| {\n        let sum_a = calc_sum_digits(*a);\n        let sum_b = calc_sum_digits(*b);\n\
    \        if sum_a == sum_b {\n            return a.cmp(b);\n        }\n      \
    \  sum_a.cmp(&sum_b)\n    });\n    sorted_nums", "    let mut tuples: Vec<_> =\
    \ nums.iter().map(|n| {\n        let m = n.abs();\n        let digits: Vec<_>\
    \ = m.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect();\n      \
    \  (n, digits.iter().sum::<u32>())\n    }).collect();\n    tuples.sort_by(|a,\
    \ b| (a.1, a.0).cmp(&(b.1, b.0)));\n    tuples.iter().map(|x| *x.0).collect()",
  "    let nums_with_sum: Vec<_> = nums.iter().map(|&n| (n, sum_of_digits(n))).collect();\n\
    \    let mut nums_with_sum = nums_with_sum.iter().enumerate().collect::<Vec<_>>();\n\
    \    nums_with_sum.sort_by(|&(_, (a, b)), &(_, (c, d))| {\n        if b == d {\n\
    \            Ordering::Less\n        } else {\n            b.cmp(&d)\n       \
    \ }\n    });\n    nums_with_sum.iter().map(|&(_, (n, _))| *n).collect()", "  \
    \  let mut result = nums.clone();\n    result.sort_by(|a, b| {\n        let a_digits\
    \ = a.abs() as u32;\n        let b_digits = b.abs() as u32;\n        a_digits.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>()\n            .cmp(&b_digits.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>())\n    });\n    result", "    use std::cmp::Ordering;\n\
    \    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let mut a_sum =\
    \ 0;\n        let mut b_sum = 0;\n        for ch in a.to_string().chars() {\n\
    \            a_sum += ch.to_digit(10).unwrap() as isize;\n        }\n        for\
    \ ch in b.to_string().chars() {\n            b_sum += ch.to_digit(10).unwrap()\
    \ as isize;\n        }\n        match a_sum.cmp(&b_sum) {\n            Ordering::Equal\
    \ => a.cmp(&b),\n            o => o,\n        }\n    });\n    nums", '    unimplemented!();',
  '    unimplemented!()', '    nums.into_iter().enumerate().sorted_by_key(|(_, x)|
    (x.abs(), x)).map(|(_, x)| x).collect()', "    nums.iter().enumerate().sorted_by(|(i1,\
    \ &n1), (i2, &n2)| {\n        let mut n1_abs = n1.abs();\n        let mut n2_abs\
    \ = n2.abs();\n        let mut n1_sum = 0;\n        let mut n2_sum = 0;\n    \
    \    while n1_abs > 0 {\n            n1_sum += n1_abs % 10;\n            n1_abs\
    \ /= 10;\n        }\n        while n2_abs > 0 {\n            n2_sum += n2_abs\
    \ % 10;\n            n2_abs /= 10;\n        }\n        n1_sum.cmp(&n2_sum).then(i1.cmp(i2))\n\
    \    }).map(|(_, &n)| n).collect()", '    nums.into_iter().enumerate().sorted_by_key(|t|
    sum_digits(t.1)).map(|t| t.1).collect()', '    unimplemented!()', "    let mut\
    \ pair_vec: Vec<(isize, isize)> = Vec::new();\n    for (index, num) in nums.iter().enumerate()\
    \ {\n        let index = index as isize;\n        let mut sum = 0;\n        let\
    \ mut temp = *num;\n        while temp != 0 {\n            sum += temp % 10;\n\
    \            temp /= 10;\n        }\n        pair_vec.push((index, sum));\n  \
    \  }\n    let mut ans: Vec<isize> = Vec::new();\n    pair_vec.sort_by(|a, b| {\n\
    \        let mut result = b.1.cmp(&a.1);\n        if result == Ordering::Equal\
    \ {\n            result = a.0.cmp(&b.0);\n        }\n        result\n    });\n\
    \    for (index, _) in pair_vec {\n        ans.push(nums[index as usize]);\n \
    \   }\n    ans", "    let mut nums = nums;\n    nums.sort_by_key(|&x| sum_digits(x));\n\
    \    nums", "    let mut sorted = nums.clone();\n    sorted.sort_by(|a, b| {\n\
    \        a.to_string()\n            .chars()\n            .fold(0, |acc, x| acc\
    \ + x.to_digit(10).unwrap())\n            .cmp(&b.to_string()\n              \
    \  .chars()\n                .fold(0, |acc, x| acc + x.to_digit(10).unwrap()))\n\
    \    });\n    sorted", "    let mut vec: Vec<_> = nums.iter().map(|&num| (num,\
    \ sum_digits(num))).collect();\n    vec.sort_by(|&(_, x), &(_, y)| {\n       \
    \ let cmp = x.cmp(&y);\n        if cmp == Ordering::Equal {\n            Ordering::Greater\n\
    \        } else {\n            cmp\n        }\n    });\n    vec.iter().map(|&(num,\
    \ _)| num).collect()", "    // fn sum_of_digits(mut x: isize) -> isize {\n   \
    \ //     let mut sum = 0;\n    //     while x != 0 {\n    //         sum += x\
    \ % 10;\n    //         x /= 10;\n    //     }\n    //     sum\n    // }\n   \
    \ // let mut tuples: Vec<_> = nums.iter().map(|x| (x, sum_of_digits(*x))).collect();\n\
    \    // tuples.sort_by(|a, b| match a.1.cmp(&b.1) {\n    //     Ordering::Equal\
    \ => a.0.cmp(&b.0),\n    //     other => other,\n    // });\n    // let mut ret\
    \ = Vec::new();\n    // for (x, _) in tuples {\n    //     ret.push(*x);\n   \
    \ // }\n    // ret\n    nums.iter()\n        .map(|x| (*x, x.abs() as usize))\n\
    \        .sorted_by(|a, b| a.1.cmp(&b.1))\n        .map(|x| x.0)\n        .collect()",
  "    let mut nums = nums;\n    nums.sort_by_key(|v| sum_digits(*v));\n    nums",
  '    unimplemented!();', "    if nums.is_empty() {\n        return vec![];\n   \
    \ }\n    let sum_f = |x: &isize| x.to_string().chars().map(|y| y.to_digit(10).unwrap()\
    \ as isize).sum::<isize>();\n    let mut f = nums.iter().map(|x| x).collect::<Vec<&isize>>();\n\
    \    let mut indices = (0..nums.len()).collect::<Vec<usize>>();\n    let mut sum_vec\
    \ = indices.iter().map(|&x| sum_f(&nums[x])).collect::<Vec<isize>>();\n    fn\
    \ merge_sort<T>(arr: &mut [T], indices: &mut [usize], left: usize, right: usize,\
    \ comp: &Fn(&T, &T) -> bool) {\n        if left == right {\n            return;\n\
    \        }\n        let mid = (left + right) / 2;\n        merge_sort(arr, indices,\
    \ left, mid, comp);\n        merge_sort(arr, indices, mid + 1, right, comp);\n\
    \        let mut tmp = Vec::with_capacity(right - left + 1);\n        let mut\
    \ left_idx = left;\n        let mut right_idx = mid + 1;\n        while left_idx\
    \ <= mid && right_idx <= right {\n            if comp(&arr[left_idx], &arr[right_idx])\
    \ {\n                tmp.push(arr[left_idx]);\n                left_idx += 1;\n\
    \            } else {\n                tmp.push(arr[right_idx]);\n           \
    \     right_idx += 1;\n            }\n        }\n        for i in left_idx..=mid\
    \ {\n            tmp.push(arr[i]);\n        }\n        for i in right_idx..=right\
    \ {\n            tmp.push(arr[i]);\n        }\n        for i in 0..(right - left\
    \ + 1) {\n            arr[left + i] = tmp[i];\n        }\n        let mut tmp_idx\
    \ = Vec::with_capacity(right - left + 1);", "    let mut sorted_nums = nums.clone();\n\
    \    sorted_nums.sort_by(|a, b| {\n        let a_sum = get_digits_sum(*a);\n \
    \       let b_sum = get_digits_sum(*b);\n        a_sum.cmp(&b_sum)\n    });\n\
    \    sorted_nums", "    nums.into_iter().enumerate().map(|(i, num)| (sum_of_digits(num),\
    \ i, num)).sorted_by(|a, b| {\n        let (a_sum, a_index, a_num) = a;\n    \
    \    let (b_sum, b_index, b_num) = b;\n        a_sum.cmp(&b_sum).then(a_index.cmp(&b_index)).then(a_num.cmp(&b_num))\n\
    \    }).map(|(_, _, num)| num).collect()", "    let mut nums = nums;\n    nums.sort_by(|a,\
    \ b| {\n        let a_sum = calc_sum_of_digits(*a);\n        let b_sum = calc_sum_of_digits(*b);\n\
    \        if a_sum == b_sum {\n            a.cmp(b)\n        } else {\n       \
    \     a_sum.cmp(&b_sum)\n        }\n    });\n    nums", '    unimplemented!()',
  "    let mut nums = nums;\n    nums.sort_by_key(|a| sum_digits(*a));\n    nums",
  "    let mut digits = nums.iter().map(|i| sum_digits(*i as u64)).collect::<Vec<u64>>();\n\
    \    let mut order = digits.iter().enumerate().map(|(i, _)| i).collect::<Vec<usize>>();\n\
    \    order.sort_by(|i, j| digits[*i].cmp(&digits[*j]).then(i.cmp(j)));\n    order.iter().map(|i|\
    \ nums[*i]).collect()", "    let mut nums = nums;\n    nums.sort_by_key(|&x|{\n\
    \        let mut result = 0;\n        let mut x = x;\n        while x != 0 {\n\
    \            result += x % 10;\n            x /= 10;\n        }\n        result\n\
    \    });\n    nums", "    let mut tmp: Vec<(isize, usize)> = nums.iter().enumerate().map(|(i,\
    \ x)| (*x, i)).collect();\n    tmp.sort_by_key(|(x, _)| x.abs() as usize % 10\
    \ + x.abs() as usize / 10);\n    tmp.iter().map(|(x, _)| *x).collect()", "   \
    \ nums.into_iter().enumerate().map(|(i, v)| {\n        (v, v.abs().to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize).sum(), i)\n    }).sorted_by(|a, b| a.1.cmp(&b.1).then(a.2.cmp(&b.2))).map(|a|\
    \ a.0).collect()", "    let mut nums = nums;\n    let mut result = Vec::new();\n\
    \    let mut sum_points = Vec::new();\n    if nums.len() == 0 {\n        return\
    \ nums;\n    }\n    for (index, num) in nums.iter().enumerate() {\n        let\
    \ mut sum = 0;\n        let mut num = *num;\n        if num < 0 {\n          \
    \  num = -num;\n        }\n        while num > 0 {\n            sum += num % 10;\n\
    \            num /= 10;\n        }\n        sum_points.push((index, sum));\n \
    \   }\n    sum_points.sort_by(|a, b| b.1.cmp(&a.1));\n    for index in sum_points\
    \ {\n        result.push(nums[index.0]);\n    }\n    result", "    let mut nums\
    \ = nums;\n    nums.sort_by_key(|n| n.abs() as usize);\n    nums", "    // TODO:\
    \ implement this function\n    vec![]", "    let mut nums = nums;\n    nums.sort_by_key(|v|\
    \ v.abs());\n    nums", "    fn sum_digits(n: isize) -> isize {\n        n.abs()\n\
    \            .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as isize)\n            .sum()\n    }\n\n    nums.into_iter()\n        .enumerate()\n\
    \        .sorted_by_key(|&(_, n)| (sum_digits(n), n))\n        .map(|(i, n)| (i,\
    \ n))\n        .sorted_by_key(|&(_, n)| n)\n        .map(|(_, n)| n)\n       \
    \ .collect()", "    nums.iter().enumerate().map(|(x, y)| (x, digits_sum(*y))).collect::<Vec<(usize,\
    \ usize)>>().sort_by(|a, b| {\n        if a.1 == b.1 {\n            a.0.cmp(&b.0)\n\
    \        } else {\n            a.1.cmp(&b.1)\n        }\n    }).iter().map(|x|\
    \ nums[x.0]).collect()", "    fn sum_digits(n: isize) -> usize {\n        n.abs()\n\
    \            .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as usize)\n            .sum()\n    }\n\n    nums.into_iter()\n        .enumerate()\n\
    \        .sorted_by_key(|&(_, n)| (sum_digits(n), n))\n        .map(|(i, n)| nums[i])\n\
    \        .collect()", "    nums.iter().enumerate().map(|(i, n)| ((n % 10) + (n\
    \ / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<_>>().sort();\n    nums.iter().enumerate().map(|(i,\
    \ n)| ((n % 10) + (n / 10 % 10), i, n)).collect::<Vec<", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let sum_a = a.1.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum();\n        let sum_b = b.1.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum();\n        sum_a.cmp(&sum_b).then(a.0.cmp(&b.0))\n    }).into_iter().map(|(_,\
    \ x)| x).collect()", "    fn get_digit_sum(num: isize) -> usize {\n        let\
    \ mut sum = 0;\n        let mut n = num;\n        while n != 0 {\n           \
    \ sum += (n % 10).abs() as usize;\n            n /= 10;\n        }\n        sum\n\
    \    }\n\n    fn is_equal(x: &isize, y: &isize) -> bool {\n        get_digit_sum(*x)\
    \ == get_digit_sum(*y)\n    }\n\n    fn is_less_than(x: &isize, y: &isize) ->\
    \ bool {\n        get_digit_sum(*x) < get_digit_sum(*y)\n    }\n\n    let mut\
    \ answer = nums.clone();\n    answer.sort_by(|x, y| {\n        if is_equal(x,\
    \ y) {\n            nums.iter().position(|n| n == x).cmp(&nums.iter().position(|n|\
    \ n == y))\n        } else {\n            is_less_than(x, y).cmp(&is_less_than(y,\
    \ x))\n        }\n    });\n    answer", "    let mut sorted_vec = nums.clone();\n\
    \    sorted_vec.sort_by(|a, b| {\n        let sum_a = get_sum_of_digits(*a);\n\
    \        let sum_b = get_sum_of_digits(*b);\n        sum_a.cmp(&sum_b)\n    });\n\
    \    sorted_vec", "    let mut list: Vec<_> = nums.into_iter().enumerate().collect();\n\
    \    list.sort_by_key(|&(i, n)| (sum_of_digits(n), i));\n    list.into_iter().map(|(_,\
    \ n)| n).collect()", '    nums.iter().enumerate().collect::<Vec<_>>().sort_by(|a,
    b| (a.1.abs() as usize).sum_digits().cmp(&(b.1.abs() as usize).sum_digits()).then(a.0.cmp(&b.0))).into_iter().map(|(_,
    num)| *num).collect()', "    let mut v = nums.clone();\n    if v.len() == 0 {\n\
    \        return v;\n    }\n    let mut order: Vec<isize> = vec![];\n    let mut\
    \ max_len = 0;\n    for n in &v {\n        let nn = *n;\n        let len = get_digit_sum(nn);\n\
    \        if len > max_len {\n            max_len = len;\n        }\n    }\n  \
    \  let mut i = 0;\n    while i < max_len {\n        let mut tmp: Vec<isize> =\
    \ vec![];\n        for j in 0..v.len() {\n            let mut n = v[j];\n    \
    \        if get_digit_sum(n) == i {\n                tmp.push(n);\n          \
    \  }\n        }\n        tmp.sort();\n        order.append(&mut tmp);\n      \
    \  i += 1;\n    }\n    return order;", "    let mut v = nums.clone();\n    v.sort_by(|a,\
    \ b| {\n        let sum_a = get_sum_of_digits(*a);\n        let sum_b = get_sum_of_digits(*b);\n\
    \        if sum_a != sum_b {\n            sum_a.cmp(&sum_b)\n        } else {\n\
    \            a.cmp(&b)\n        }\n    });\n    v", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let a_sum = sum_digits(a.1);\n        let b_sum = sum_digits(b.1);\n\
    \        let r = a_sum.cmp(&b_sum);\n        match r {\n            Ordering::Equal\
    \ => a.0.cmp(&b.0),\n            _ => r,\n        }\n    }).into_iter().map(|x|\
    \ x.1).collect()", "    let nums = nums\n        .into_iter()\n        .enumerate()\n\
    \        .map(|(index, num)| (index, num, sum_digits(num)))\n        .collect::<Vec<_>>();\n\
    \    let mut nums = nums.clone();\n    nums.sort_by(|(_, _, num1), (_, _, num2)|\
    \ num1.cmp(num2));\n    nums.iter().map(|(_, num, _)| *num).collect()", '    nums.into_iter().enumerate().map(|(i,
    n)| (n, i)).collect::<Vec<_>>().sort_by(|&(na, _), &(nb, _)| na.abs().to_string().chars().map(|c|
    c.to_digit(10).unwrap() as isize).sum::<isize>().cmp(&nb.abs().to_string().chars().map(|c|
    c.to_digit(10).unwrap() as isize).sum::<isize>()).then(na.cmp(&nb))).into_iter().map(|(n,
    _)| n).collect::<Vec<_>>()', '    nums.iter().enumerate().map(|(i, &x)| (x, i,
    x.abs() as u32)).collect::<Vec<_>>().iter().map(|&(x, i, sum)| (x, i, sum)).collect::<Vec<_>>().sort_by(|a,
    b| a.2.cmp(&b.2).then(a.1.cmp(&b.1))).iter().map(|&(x, _, _)| x).collect()', " \
    \   let mut output = nums.clone();\n    output.sort_by(|a, b| {\n        let x\
    \ = sum_digits(*a);\n        let y = sum_digits(*b);\n        x.cmp(&y)\n    });\n\
    \    output", "    nums.iter().enumerate().sorted_by(|(_, n1), (_, n2)| {\n  \
    \      let n1_sum = sum_of_digits(*n1);\n        let n2_sum = sum_of_digits(*n2);\n\
    \        let n1_sum_cmp = n1_sum.cmp(&n2_sum);\n        if n1_sum_cmp == std::cmp::Ordering::Equal\
    \ {\n            return n1.cmp(n2);\n        }\n        n1_sum_cmp\n    }).map(|(_,\
    \ n)| *n).collect()", "    use std::cmp::Ordering;\n    let mut res = nums.clone();\n\
    \    res.sort_by(|a, b| {\n        let mut a = a.abs();\n        let mut b = b.abs();\n\
    \        let mut suma = 0;\n        let mut sumb = 0;\n        while a > 0 {\n\
    \            suma += a % 10;\n            a /= 10;\n        }\n        while b\
    \ > 0 {\n            sumb += b % 10;\n            b /= 10;\n        }\n      \
    \  match suma.cmp(&sumb) {\n            Ordering::Equal => a.cmp(&b),\n      \
    \      Ordering::Less => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n\
    \        }\n    });\n    res", "    let mut sum = 0;\n    let mut temp = Vec::new();\n\
    \    let mut result = Vec::new();\n    let mut sum_vec = Vec::new();\n    let\
    \ mut sorted = Vec::new();\n    let mut vec = Vec::new();\n    let mut nums =\
    \ nums;\n    nums.sort();\n    for i in nums.iter() {\n        vec.push(format!(\"\
    {}\", i));\n    }\n    for i in vec.iter() {\n        sum = 0;\n        for j\
    \ in i.chars() {\n            sum += j.to_digit(10).unwrap() as isize;\n     \
    \   }\n        sum_vec.push(sum);\n    }\n    for j in sum_vec.iter() {\n    \
    \    for i in 0..sum_vec.len() {\n            if sum_vec[i] == *j {\n        \
    \        temp.push(nums[i]);\n            }\n        }\n    }\n    for _ in 0..temp.len()\
    \ {\n        for j in temp.iter() {\n            for i in 0..temp.len() {\n  \
    \              if temp[i] == *j {\n                    result.push(nums[i]);\n\
    \                }\n            }\n        }\n    }\n    result", '    nums.into_iter().enumerate().sorted_by_key(|(i,
    n)| (sum_digits(*n), *i)).map(|(_, n)| n).collect()', "    let mut nums_with_sum:\
    \ Vec<(isize, isize)> = nums.iter().map(|n| (*n, num_sum(*n))).collect();\n  \
    \  nums_with_sum.sort_by(|a, b| match a.1.cmp(&b.1) {\n        Ordering::Equal\
    \ => a.0.cmp(&b.0),\n        other => other,\n    });\n    nums_with_sum.iter().map(|n|\
    \ n.0).collect()", '    unimplemented!();', "    // Sum of digits in number x\
    \ is computed as\n    // x % 10 + x / 10 % 10 + ... + x / 10**n % 10,\n    //\
    \ where n is a number of digits.\n    // The sum_of_digits(x) function below computes\
    \ it.\n    fn sum_of_digits(x: isize) -> isize {\n        let mut sum = 0;\n \
    \       let mut x = x;\n        while x != 0 {\n            sum += x % 10;\n \
    \           x /= 10;\n        }\n        sum\n    }\n\n    let mut nums = nums;\n\
    \    nums.sort_by(|a, b| {\n        let sum_a = sum_of_digits(*a);\n        let\
    \ sum_b = sum_of_digits(*b);\n        if sum_a == sum_b {\n            // Since\
    \ we want to sort by index of original list\n            // we should use original\
    \ value of sum\n            a.cmp(&b)\n        } else {\n            sum_a.cmp(&sum_b)\n\
    \        }\n    });\n    nums", "    // use std::cmp::Ordering;\n    let mut nums_with_index\
    \ = nums.iter().enumerate().collect::<Vec<(usize, &isize)>>();\n    nums_with_index.sort_by(|&(_,\
    \ n), &(_, m)| sum_digits(*n).cmp(&sum_digits(*m)));\n    let result = nums_with_index.iter().map(|&(_,\
    \ n)| *n).collect::<Vec<isize>>();\n    result", "    let mut result = nums.clone();\n\
    \    result.sort_by(|x, y| {\n        let x_digits_sum = x.abs() / 10 + x.abs()\
    \ % 10;\n        let y_digits_sum = y.abs() / 10 + y.abs() % 10;\n        if x_digits_sum\
    \ == y_digits_sum {\n            nums.iter().position(|&val| val == *x).cmp(&nums.iter().position(|&val|\
    \ val == *y))\n        } else {\n            x_digits_sum.cmp(&y_digits_sum)\n\
    \        }\n    });\n    result", "    let sum = |n: &isize| -> isize {\n    \
    \    let mut val = *n;\n        let mut sum = 0;\n        while val != 0 {\n \
    \           sum += val % 10;\n            val /= 10;\n        }\n        sum\n\
    \    };\n    let mut temp: Vec<(isize, isize)> = nums.iter().map(|x| (sum(x),\
    \ *x)).collect();\n    temp.sort_by(|x, y| x.0.cmp(&y.0));\n    temp.iter().map(|x|\
    \ x.1).collect()", '    unimplemented!()', "    let mut res = nums.clone();\n\
    \    res.sort_by(|a, b| a.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>().cmp(&b.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>()));\n    res", "    // map a list of items\
    \ to its total sum of digits\n    let mut point_map: HashMap<isize, isize> = HashMap::new();\n\
    \    let mut list: Vec<isize> = Vec::new();\n    for num in nums {\n        let\
    \ total = num.abs()\n            .to_string()\n            .chars()\n        \
    \    .map(|c| c.to_digit(10).unwrap())\n            .sum::<u32>() as isize;\n\
    \        point_map.insert(num, total);\n        list.push(num);\n    }\n    list.sort_by(|a,\
    \ b| {\n        // get the point sum of a and b\n        let point_a = point_map.get(a).unwrap();\n\
    \        let point_b = point_map.get(b).unwrap();\n        if point_a == point_b\
    \ {\n            // sort by index if the points are equal\n            // a <\
    \ b\n            a.cmp(b)\n        } else {\n            // a < b\n          \
    \  point_a.cmp(point_b)\n        }\n    });\n    list", "    fn sum_digits(n:\
    \ isize) -> isize {\n        let mut sum = 0;\n        let mut n = n;\n      \
    \  while n != 0 {\n            sum += n % 10;\n            n /= 10;\n        }\n\
    \        sum\n    }\n\n    let mut nums = nums;\n    nums.sort_by_key(|&n| (sum_digits(n),\
    \ n));\n    nums", "    let mut digits_sum = HashMap::new();\n    let mut result\
    \ = Vec::new();\n\n    for num in nums {\n        let mut sum = 0;\n        for\
    \ ch in num.to_string().chars() {\n            sum += ch.to_digit(10).unwrap()\
    \ as isize;\n        }\n        digits_sum.insert(num, sum);\n    }\n\n    for\
    \ &num in nums.iter() {\n        let mut min = None;\n        for (&elem, &sum)\
    \ in digits_sum.iter() {\n            if sum < digits_sum[&num] && !result.contains(&elem)\
    \ {\n                if min.is_none() || sum < digits_sum[&min.unwrap()] {\n \
    \                   min = Some(elem);\n                }\n            }\n    \
    \    }\n        if min.is_some() {\n            result.push(min.unwrap());\n \
    \       }\n        result.push(num);\n    }\n\n    result", "    let mut nums\
    \ = nums;\n    nums.sort_by_key(|&x| digits_sum(x));\n    nums", "    let mut\
    \ result = nums.clone();\n    result.sort_by(|a, b| {\n        let a: String =\
    \ a.to_string();\n        let b: String = b.to_string();\n        a.chars().fold(0,\
    \ |acc, c| acc + c.to_digit(10).unwrap() as isize)\n            .cmp(&b.chars().fold(0,\
    \ |acc, c| acc + c.to_digit(10).unwrap() as isize))\n    });\n    result", " \
    \   let mut sums: Vec<(isize, usize)> = vec![];\n    for (idx, n) in nums.iter().enumerate()\
    \ {\n        let sum = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as\
    \ isize).sum();\n        sums.push((sum, idx));\n    }\n    sums.sort();\n   \
    \ let mut res: Vec<isize> = vec![];\n    for sum in sums {\n        res.push(nums[sum.1]);\n\
    \    }\n    res", "    let mut answer = nums.clone();\n    answer.sort_by(|a,\
    \ b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n    answer", "    fn sum_digits(n:\
    \ isize) -> isize {\n        n.abs()\n            .to_string()\n            .chars()\n\
    \            .map(|c| c.to_digit(10).unwrap() as isize)\n            .sum()\n\
    \    }\n\n    nums.into_iter()\n        .enumerate()\n        .sorted_by_key(|&(_,\
    \ n)| (sum_digits(n), n))\n        .map(|(i, n)| i as isize * n)\n        .sum::<isize>()\n\
    \        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap()\
    \ as isize)\n        .collect()", '    nums.into_iter().enumerate().map(|(x, y)|
    (x, y, y.abs() / 10 + y.abs() % 10)).sorted_by(|a, b| if a.2 == b.2 { a.0.cmp(&b.0)
    } else { a.2.cmp(&b.2) }).map(|x| x.1).collect()', "    let mut nums = nums;\n\
    \    nums.sort_by_key(|n| sum_digits(*n));\n    nums", "    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for i in\
    \ 0..nums.len() {\n        let mut sum = 0;\n        let mut number = nums[i];\n\
    \        while number != 0 {\n            sum += number % 10;\n            number\
    \ /= 10;\n        }\n        result.push((i, sum));\n    }\n    result.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    let mut result2 = vec![];\n    for i in 0..result.len()\
    \ {\n        result2.push(nums[result[i].0]);\n    }\n    result2", "    let mut\
    \ nums = nums;\n    nums.sort_by_key(|&num| {\n        let sum = num.abs()\n \
    \           .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap())\n\
    \            .sum::<u32>();\n        (sum, num)\n    });\n    nums", "    let\
    \ mut nums = nums;\n    nums.sort_by_key(|num| digits_sum(*num));\n    nums",
  "    let mut result = nums.clone();\n    result.sort_by(|a, b| {\n        let adigits\
    \ = get_digits(*a);\n        let bdigits = get_digits(*b);\n        adigits.iter().sum::<u32>().cmp(&bdigits.iter().sum::<u32>())\n\
    \    });\n    result", "    fn sum_of_digits(n: isize) -> usize {\n        n.abs()\n\
    \            .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap())\n\
    \            .sum()\n    }\n\n    nums.into_iter()\n        .enumerate()\n   \
    \     .map(|(i, n)| (i, n, sum_of_digits(n)))\n        .sorted_by(|(_, _, a),\
    \ (_, _, b)| a.cmp(b))\n        .map(|(_, n, _)| n)\n        .collect()", '    unimplemented!()',
  "    // TODO\n    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let mut\
    \ a_sum = 0;\n        let mut b_sum = 0;\n        let mut a_temp = *a;\n     \
    \   let mut b_temp = *b;\n        while a_temp != 0 {\n            a_sum += a_temp\
    \ % 10;\n            a_temp /= 10;\n        }\n        while b_temp != 0 {\n \
    \           b_sum += b_temp % 10;\n            b_temp /= 10;\n        }\n    \
    \    a_sum.cmp(&b_sum)\n    });\n    nums", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let (i, a) = a;\n        let (j, b) = b;\n        let mut a =\
    \ a;\n        let mut b = b;\n        let mut sum_a = 0;\n        let mut sum_b\
    \ = 0;\n        while a != 0 {\n            sum_a += a % 10;\n            a /=\
    \ 10;\n        }\n        while b != 0 {\n            sum_b += b % 10;\n     \
    \       b /= 10;\n        }\n        (sum_a, i).cmp(&(sum_b, j))\n    }).into_iter().map(|(_,\
    \ a)| a).collect()", "    let mut nums = nums;\n    nums.sort_by_key(|x| {\n \
    \       let mut x = *x;\n        let mut sum = 0;\n        while x != 0 {\n  \
    \          sum += x % 10;\n            x /= 10;\n        }\n        sum\n    });\n\
    \    nums", "    let mut nums = nums;\n    nums.sort_by_key(|k| k.abs());\n  \
    \  nums", '    unimplemented!()', "    let sums = nums.iter().map(|n| sum_digits(*n)).collect::<Vec<usize>>();\n\
    \    let mut indices = (0..nums.len()).collect::<Vec<usize>>();\n    indices.sort_by_key(|i|\
    \ (sums[*i], *i));\n    indices.iter().map(|i| nums[*i]).collect()", "    let\
    \ mut res = nums.clone();\n    res.sort_by(|a, b| a.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>().cmp(&b.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>()));\n\
    \    res", "    let sum_of_digits = |n: &isize| -> isize {\n        let mut m\
    \ = *n;\n        let mut sum = 0;\n        while m != 0 {\n            sum +=\
    \ m % 10;\n            m /= 10;\n        }\n        sum\n    };\n    let mut nums\
    \ = nums;\n    nums.sort_by_key(|n| (sum_of_digits(n), n));\n    nums", '    nums.iter().enumerate().map(|(i,
    x)| (i, x, sum_digits(*x))).collect::<Vec<_>>().iter().sort_by(|&(_, _, x), &(_,
    _, y)| x.cmp(&y)).map(|&(_, x, _)| *x).collect()', '    nums.into_iter().enumerate().map(|(i,
    x)| (x, sum_digits(x), i)).sorted_by(|a, b| a.1.cmp(&b.1).then(a.2.cmp(&b.2))).map(|a|
    a.0).collect()', "    let mut nums = nums;\n    nums.sort_by_key(|&num| num.abs());\n\
    \    nums", '    unimplemented!()', "    let mut vec = nums.clone();\n    vec.sort_by(|x,\
    \ y| {\n        let x = x.abs() as usize;\n        let mut x = {\n           \
    \ let mut x = x;\n            let mut v = Vec::new();\n            while x > 0\
    \ {\n                v.push(x % 10);\n                x /= 10;\n            }\n\
    \            v.into_iter().sum::<usize>()\n        };\n        let y = y.abs()\
    \ as usize;\n        let mut y = {\n            let mut y = y;\n            let\
    \ mut v = Vec::new();\n            while y > 0 {\n                v.push(y % 10);\n\
    \                y /= 10;\n            }\n            v.into_iter().sum::<usize>()\n\
    \        };\n        x.cmp(&y)\n    });\n    vec", "    let mut v: Vec<&isize>\
    \ = nums.iter().collect();\n    v.sort_by(|a, b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n\
    \    v.iter().map(|&x| *x).collect()", "    if nums.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut sum: Vec<isize> = vec![];\n    for i in nums.iter()\
    \ {\n        sum.push(*i as isize % 10 + *i as isize / 10);\n    }\n    sum.clone()\n\
    \        .iter()\n        .enumerate()\n        .collect::<Vec<(usize, &isize)>>()\n\
    \        .sort_by(|a, b| b.1.cmp(a.1));\n    let mut result: Vec<isize> = vec![];\n\
    \    for i in sum.iter() {\n        for (index, j) in nums.iter().enumerate()\
    \ {\n            if i == &(*j as isize % 10 + *j as isize / 10) {\n          \
    \      result.push(*j);\n                break;\n            }\n        }\n  \
    \  }\n    result", "    let mut nums = nums;\n    nums.sort_by_key(|num| num.abs()\
    \ - num.abs() % 10);\n    nums.sort_by_key(|num| (num.abs() / 10) % 10);\n   \
    \ nums.sort_by_key(|num| num.abs() / 100);\n    nums", "    let mut sort_vec:\
    \ Vec<(isize, usize)> = nums.iter().enumerate().map(|(i, x)| (x.abs(), i)).collect();\n\
    \    sort_vec.sort_by(|a, b| (a.0.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>()).cmp(&(b.0.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>())));\n    let mut vec_index: Vec<usize>\
    \ = sort_vec.iter().map(|&(_, i)| i).collect();\n    vec_index.sort();\n    let\
    \ mut vec_result: Vec<isize> = vec![];\n    for i in vec_index {\n        vec_result.push(nums[i]);\n\
    \    }\n    vec_result", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|(i1,\
    \ x1), (i2, x2)| {\n        let s1 = sum_digits(*x1);\n        let s2 = sum_digits(*x2);\n\
    \        if s1 != s2 {\n            s1.cmp(&s2)\n        } else {\n          \
    \  i1.cmp(&i2)\n        }\n    }).into_iter().map(|(_, x)| x).collect()", "  \
    \  let mut z = nums.iter().enumerate().collect::<Vec<(usize, &isize)>>();\n  \
    \  z.sort_by_key(|&(_, n)| {\n        let mut t = 0;\n        let mut nn = *n;\n\
    \        if nn < 0 {\n            nn = -nn;\n        }\n        while nn > 0 {\n\
    \            t += nn % 10;\n            nn /= 10;\n        }\n        t\n    });\n\
    \    z.iter().map(|&(_, n)| *n).collect()", "    let mut new_nums = nums.clone();\n\
    \    new_nums.sort_by(|a, b| {\n        let mut sum_a = 0;\n        let mut sum_b\
    \ = 0;\n        for i in a.to_string().chars() {\n            sum_a += i.to_digit(10).unwrap()\
    \ as isize;\n        }\n        for i in b.to_string().chars() {\n           \
    \ sum_b += i.to_digit(10).unwrap() as isize;\n        }\n        if sum_a == sum_b\
    \ {\n            a.cmp(b)\n        } else {\n            sum_a.cmp(&sum_b)\n \
    \       }\n    });\n    new_nums", '    unimplemented!();', "    let mut nums_sum\
    \ = nums.iter().map(|&x| x.abs() as usize).sum::<usize>();\n    let mut digits_vec\
    \ = Vec::new();\n    while nums_sum > 0 {\n        digits_vec.push(nums_sum %\
    \ 10);\n        nums_sum /= 10;\n    }\n    let mut result_vec = nums.clone();\n\
    \    result_vec.sort_by(|a, b| get_sum_of_digits(a).cmp(&get_sum_of_digits(b)));\n\
    \    result_vec", "    let mut result = nums.clone();\n    result.sort_by(|a,\
    \ b| {\n        let sum_a = a.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let sum_b = b.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>();\n\
    \        sum_a.cmp(&sum_b)\n    });\n    result", "    nums.into_iter().enumerate().sorted_by_key(|(_,\
    \ x)| {\n        x.abs() / 10 + x.abs() % 10\n    }).map(|(_, x)| x).collect()",
  "    if nums.is_empty() {\n        return nums;\n    }\n    let mut out = nums.clone();\n\
    \    out.sort_by(|a, b| {\n        let a_sum = sum_digits(*a);\n        let b_sum\
    \ = sum_digits(*b);\n        if a_sum == b_sum {\n            a.cmp(b)\n     \
    \   } else {\n            a_sum.cmp(&b_sum)\n        }\n    });\n    out", '    nums.iter().enumerate().map(|(idx,
    &num)| (idx, num, num.abs() / 10 + num.abs() % 10)).collect::<Vec<_>>().sort_by(|&(_,
    _, a), &(_, _, b)| a.cmp(&b)).iter().map(|&(_, num, _)| num).collect()', "   \
    \ let mut map = HashMap::new();\n    let mut v = Vec::new();\n    for (i, n) in\
    \ nums.iter().enumerate() {\n        let mut m = n.abs();\n        let mut sum\
    \ = 0;\n        while m > 0 {\n            sum += m % 10;\n            m /= 10;\n\
    \        }\n        v.push((i, sum, n));\n    }\n    v.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    let mut res = Vec::new();\n    for (_, _, n) in v {\n        res.push(*n);\n\
    \    }\n    res", "    let mut points = Vec::new();\n    for &num in &nums {\n\
    \        points.push((num, digit_sum(num)));\n    }\n    points.sort_by(|(a, b),\
    \ (c, d)| b.cmp(d).then(a.cmp(c)));\n    points.iter().map(|&(a, _)| a).collect()",
  "    let mut temp = nums.clone();\n    temp.sort_by(|a, b| {\n        let aa = a.abs()\
    \ as usize;\n        let bb = b.abs() as usize;\n        let mut sum = |n: usize|\
    \ {\n            let mut sum = 0;\n            let mut d = n;\n            while\
    \ d > 0 {\n                sum += d % 10;\n                d /= 10;\n        \
    \    }\n            sum\n        };\n        let (sum_a, sum_b) = (sum(aa), sum(bb));\n\
    \        if sum_a == sum_b {\n            let index_a = nums.iter().position(|&e|\
    \ e == *a).unwrap();\n            let index_b = nums.iter().position(|&e| e ==\
    \ *b).unwrap();\n            index_a.cmp(&index_b)\n        } else {\n       \
    \     sum_a.cmp(&sum_b)\n        }\n    });\n    temp", "    let mut result =\
    \ nums.clone();\n    result.sort_by(|x, y| sum_digits(*x).cmp(&sum_digits(*y)));\n\
    \    result", '    unimplemented!()', "    let mut res = nums.clone();\n    res.sort_by(|a,\
    \ b| {\n        let sum_a = sum_digits(*a);\n        let sum_b = sum_digits(*b);\n\
    \        sum_a.cmp(&sum_b)\n    });\n    res", "    fn sum_digits(num: isize)\
    \ -> isize {\n        let mut sum = 0;\n        let mut m = num;\n        while\
    \ m != 0 {\n            sum += m % 10;\n            m /= 10;\n        }\n    \
    \    sum\n    }\n\n    let mut v = nums.clone();\n    v.sort_by_key(|num| (sum_digits(*num),\
    \ nums.iter().position(|n| n == num).unwrap()));\n    v", '    unimplemented!();',
  "    let mut nums = nums;\n    nums.sort_by_key(|num| {\n        let mut sum = 0;\n\
    \        let mut n = *num;\n        while n != 0 {\n            sum += n % 10;\n\
    \            n /= 10;\n        }\n        sum\n    });\n    nums", "    let mut\
    \ sorted = nums.clone();\n    sorted.sort_by(|a, b| -> std::cmp::Ordering {\n\
    \        let a_sum = sum_of_digits(*a);\n        let b_sum = sum_of_digits(*b);\n\
    \        if a_sum < b_sum {\n            std::cmp::Ordering::Less\n        } else\
    \ if a_sum > b_sum {\n            std::cmp::Ordering::Greater\n        } else\
    \ {\n            nums.iter().position(|&x| x == *a).cmp(&nums.iter().position(|&x|\
    \ x == *b))\n        }\n    });\n    sorted", "    let mut sum_index = vec![];\n\
    \    for (index, value) in nums.iter().enumerate() {\n        let mut digits_sum\
    \ = 0;\n        let mut value = *value;\n        while value != 0 {\n        \
    \    digits_sum += value % 10;\n            value /= 10;\n        }\n        sum_index.push((digits_sum,\
    \ index));\n    }\n    sum_index.sort();\n    let mut result = vec![];\n    for\
    \ (sum, index) in sum_index {\n        result.push(nums[index]);\n    }\n    result",
  "    fn sum_digits(n: isize) -> isize {\n        let mut n = n;\n        let mut\
    \ result = 0;\n        while n != 0 {\n            result += n % 10;\n       \
    \     n /= 10;\n        }\n        result\n    }\n\n    let mut index_sum_pair:\
    \ Vec<(usize, isize)> = nums\n        .iter()\n        .enumerate()\n        .map(|(i,\
    \ n)| (i, sum_digits(*n)))\n        .collect();\n    index_sum_pair.sort_by(|a,\
    \ b| (a.1, a.0).cmp(&(b.1, b.0)));\n    index_sum_pair\n        .iter()\n    \
    \    .map(|(i, _)| nums[*i])\n        .collect::<Vec<isize>>()", '    nums.into_iter().enumerate().sorted_by_key(|(i,
    num)| (sum_digits(*num), *i)).map(|(_, num)| num).collect()', "    if nums.is_empty()\
    \ {\n        return nums;\n    }\n    // get vector of integers, each int is the\
    \ sum of digits of its index\n    let mut nums_digits_sum: Vec<usize> = nums.iter().map(|num|\
    \ num.abs() as usize).collect();\n    let nums_length = nums_digits_sum.len();\n\
    \    let mut sums: Vec<usize> = Vec::with_capacity(nums_length);\n    for i in\
    \ 0..nums_length {\n        let sum = digits_sum(nums_digits_sum[i]);\n      \
    \  sums.push(sum);\n    }\n    // for each digit sum, create a vector of indexes\
    \ with this sum\n    let mut indexes: Vec<Vec<usize>> = vec![Vec::new(); 50];\n\
    \    for i in 0..nums_length {\n        indexes[sums[i]].push(i);\n    }\n   \
    \ // sort indexes by the order of digits sum values\n    indexes.sort_by(|a, b|\
    \ a[0].cmp(&b[0]));\n    // create a new vector of sorted nums\n    let mut sorted_nums:\
    \ Vec<isize> = Vec::with_capacity(nums_length);\n    for indexes_vec in indexes\
    \ {\n        for index in indexes_vec {\n            sorted_nums.push(nums[index]);\n\
    \        }\n    }\n    sorted_nums", "    let mut list: Vec<(isize, isize)> =\
    \ nums.into_iter().map(|x| (x, x.abs() as usize % 10 + x.abs() as usize / 10)).collect();\n\
    \    list.sort_by(|a, b| a.1.cmp(&b.1));\n    list.into_iter().map(|x| x.0).collect()",
  "    let mut nums_with_count: Vec<_> = nums.iter().enumerate().map(|(i, n)| (i,\
    \ n)).collect();\n    nums_with_count.sort_by_key(|(_, n)| {\n        let n =\
    \ n.abs();\n        let mut n = n;\n        let mut sum = 0;\n        while n\
    \ > 0 {\n            sum += n % 10;\n            n /= 10;\n        }\n       \
    \ sum\n    });\n    nums_with_count.iter().map(|(_, n)| *n).collect()", "    fn\
    \ calc_points(n: isize) -> isize {\n        n.abs()\n            .to_string()\n\
    \            .chars()\n            .map(|c| c.to_digit(10).unwrap() as isize)\n\
    \            .sum()\n    }\n\n    fn do_sort(mut nums: Vec<isize>) -> Vec<isize>\
    \ {\n        nums.sort_by(|a, b| {\n            calc_points(*a)\n            \
    \    .cmp(&calc_points(*b))\n                .then(a.cmp(b))\n        });\n  \
    \      nums\n    }\n\n    do_sort(nums)", "    let mut nums_copy = nums.clone();\n\
    \    let mut sum_of_digits = Vec::new();\n    for i in 0..nums.len() {\n     \
    \   let mut num = nums[i];\n        let mut sum = 0;\n        while num != 0 {\n\
    \            sum += num % 10;\n            num /= 10;\n        }\n        sum_of_digits.push(sum);\n\
    \    }\n    println!(\"{:?}\", sum_of_digits);\n    let mut checker = true;\n\
    \    while checker {\n        checker = false;\n        for i in 0..sum_of_digits.len()\
    \ - 1 {\n            if sum_of_digits[i] > sum_of_digits[i + 1] {\n          \
    \      checker = true;\n                let temp = sum_of_digits[i];\n       \
    \         sum_of_digits[i] = sum_of_digits[i + 1];\n                sum_of_digits[i\
    \ + 1] = temp;\n                let temp_nums = nums_copy[i];\n              \
    \  nums_copy[i] = nums_copy[i + 1];\n                nums_copy[i + 1] = temp_nums;\n\
    \            }\n        }\n    }\n    nums_copy", '    unimplemented!()', "  \
    \  let mut nums = nums;\n    nums.sort_by_key(|x| -sum_digits(*x));\n    nums",
  '    nums.into_iter().enumerate().map(|(i, x)| (digits_sum(x), i, x)).sorted_by(|a,
    b| a.0.cmp(&b.0).then(a.1.cmp(&b.1))).map(|t| t.2).collect()', "    let mut sum_nums\
    \ = Vec::new();\n    for i in 0..nums.len() {\n        let mut sum = 0;\n    \
    \    let mut val = nums[i];\n        while val != 0 {\n            sum += val\
    \ % 10;\n            val /= 10;\n        }\n        sum_nums.push((i, sum, nums[i]));\n\
    \    }\n    sum_nums.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut ret = Vec::new();\n\
    \    for i in 0..sum_nums.len() {\n        ret.push(sum_nums[i].2);\n    }\n \
    \   ret", "    nums.into_iter().enumerate().sorted_by_key(|(_, x)| {\n       \
    \ x.abs()\n            .to_string()\n            .chars()\n            .map(|d|\
    \ d.to_digit(10).unwrap())\n            .sum::<u32>()\n    }).map(|(_, x)| x).collect()",
  '    nums.iter().enumerate().map(|(i, n)| (n, i, sum_digits(*n))).collect::<Vec<_>>().sort_by(|(a,
    b, c), (d, e, f)| c.cmp(&f).then(b.cmp(&e))).iter().map(|(n, _, _)| *n).collect()',
  "    let mut result = Vec::with_capacity(nums.len());\n    let mut map = BTreeMap::new();\n\
    \    for (i, n) in nums.iter().enumerate() {\n        let sum = sum_of_digits(*n);\n\
    \        let value = map.entry(sum).or_insert(Vec::new());\n        value.push(i);\n\
    \    }\n    for (sum, indices) in map {\n        let mut iter = indices.iter();\n\
    \        let first = iter.next().unwrap();\n        let first_value = nums[*first];\n\
    \        result.push(first_value);\n        for index in iter {\n            result.push(nums[*index]);\n\
    \        }\n    }\n    result", "    let mut result = nums.clone();\n    result.sort_by(|a,\
    \ b| get_points(*a).cmp(&get_points(*b)));\n    result", "    let mut sum = Vec::new();\n\
    \    for (i, n) in nums.iter().enumerate() {\n        sum.push((sum_digits(*n),\
    \ i, *n));\n    }\n    sum.sort();\n    let mut res = Vec::new();\n    for (_,\
    \ _, num) in sum {\n        res.push(num);\n    }\n    res", "    if nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sum = vec![];\n    for i in 0..nums.len()\
    \ {\n        let mut num = nums[i];\n        let mut sum_num = 0;\n        while\
    \ num != 0 {\n            sum_num += num % 10;\n            num /= 10;\n     \
    \   }\n        sum.push(sum_num);\n    }\n    let mut index = vec![];\n    for\
    \ i in 0..nums.len() {\n        index.push(i);\n    }\n    index.sort_by(|a, b|\
    \ sum[*a].cmp(&sum[*b]));\n    let mut result = vec![];\n    for i in 0..nums.len()\
    \ {\n        result.push(nums[index[i]]);\n    }\n    result", "    nums.iter().enumerate().map(|x|\
    \ (x.0, x.1, x.1.abs().to_string().chars().map(|x| x.to_digit(10).unwrap() as\
    \ isize).sum())).collect::<Vec<(usize, &isize, isize)>>().sort_by(|x, y| {\n \
    \       if x.2 == y.2 {\n            x.0.cmp(&y.0)\n        } else {\n       \
    \     x.2.cmp(&y.2)\n        }\n    }).iter().map(|x| *x.1).collect()", '    unimplemented!();',
  '    nums.into_iter().enumerate().sorted_by_key(|(_i, v)| sum_of_digits(*v)).map(|(_i,
    v)| v).collect()', "    if nums.is_empty() {\n        return vec![];\n    }\n\
    \    let mut nums_with_points: Vec<(isize, isize)> = nums\n        .iter()\n \
    \       .map(|&num| (num, get_points(num)))\n        .collect();\n    nums_with_points.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    let mut res: Vec<isize> = nums_with_points\n       \
    \ .iter()\n        .map(|(num, _)| *num)\n        .collect();\n    res", "   \
    \ let mut result = nums.clone();\n    result.sort_by(|a, b| sum_digits(*a).cmp(&sum_digits(*b)));\n\
    \    result", "    let mut nums = nums;\n    if nums.len() > 1 {\n        nums.sort_by(|a,\
    \ b| {\n            let sum_a = a.abs() / 10 + a.abs() % 10;\n            let\
    \ sum_b = b.abs() / 10 + b.abs() % 10;\n            match sum_a.cmp(&sum_b) {\n\
    \                Ordering::Less => Ordering::Less,\n                Ordering::Greater\
    \ => Ordering::Greater,\n                Ordering::Equal => a.cmp(&b),\n     \
    \       }\n        });\n    }\n    nums", "    let mut sorted_nums = nums.clone();\n\
    \    sorted_nums.sort_by(|a, b| {\n        let a_sum = sum_digits(*a);\n     \
    \   let b_sum = sum_digits(*b);\n        if a_sum == b_sum {\n            a.cmp(b)\n\
    \        } else {\n            a_sum.cmp(&b_sum)\n        }\n    });\n    sorted_nums",
  "    let mut nums = nums;\n    nums.sort_by_key(|n| {\n        n.abs()\n       \
    \     .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as isize)\n            .sum::<isize>()\n    });\n    nums", "    let mut nums_copy\
    \ = nums.clone();\n    let mut res = Vec::new();\n    loop {\n        match nums_copy.iter().enumerate().min_by_key(|i|\
    \ {\n            let sum = i.1.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \            (sum, i.0)\n        }) {\n            Some(n) => {\n            \
    \    res.push(n.1);\n                nums_copy.remove(n.0);\n            }\n \
    \           None => break,\n        }\n    }\n    res", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|x| (x.abs() as usize) % 10 + ((x.abs() / 10) as usize)\
    \ % 10);\n    nums", "    let mut nums = nums;\n    let sorted = nums.clone();\n\
    \    nums.sort_by(|a, b| a.abs().sum_digits().cmp(&b.abs().sum_digits()));\n \
    \   nums.reverse();\n    sorted.iter().map(|n| nums.iter().position(|e| e == n).unwrap()).collect()",
  "    let mut nums = nums;\n    let mut res = Vec::new();\n    while !nums.is_empty()\
    \ {\n        let mut min = (nums[0], 0);\n        for (i, num) in nums.iter().enumerate()\
    \ {\n            let digit_sum = num.abs()\n                .to_string()\n   \
    \             .chars()\n                .map(|c| c.to_digit(10).unwrap())\n  \
    \              .sum::<u32>();\n            if digit_sum < min.0 {\n          \
    \      min = (digit_sum, i);\n            }\n        }\n        res.push(nums.remove(min.1));\n\
    \    }\n    res", "    let mut vec: Vec<(isize, usize)> = nums.iter().enumerate().map(|(i,\
    \ &num)| (num, i)).collect();\n    vec.sort_by_key(|&(num, _)| sum_digits(num));\n\
    \    vec.iter().map(|&(num, _)| num).collect()", "    let mut sum_points = nums.iter().map(|x|\
    \ {\n        let mut sum = 0;\n        let mut x_copy = *x;\n        while x_copy\
    \ != 0 {\n            sum += x_copy % 10;\n            x_copy /= 10;\n       \
    \ }\n        (sum, x)\n    }).collect::<Vec<(isize, &isize)>>();\n    sum_points.sort_by(|a,\
    \ b| {\n        a.0.cmp(&b.0).then(a.1.cmp(&b.1))\n    });\n    sum_points.iter().map(|x|\
    \ *x.1).collect()", "    let mut result = nums.clone();\n    let mut sum_vec =\
    \ Vec::new();\n    for i in nums {\n        sum_vec.push(sum_of_num(i));\n   \
    \ }\n    result.sort_by(|a, b| sum_of_num(*a).cmp(&sum_of_num(*b)));\n    result",
  "    fn points(n: isize) -> usize {\n        fn to_digit(n: isize) -> usize {\n\
    \            (n as i8) as usize\n        }\n        match n {\n            n if\
    \ n < 0 => to_digit(-n) as usize,\n            _ => to_digit(n) as usize,\n  \
    \      }\n    }\n    nums.into_iter().enumerate().sorted_by(|&(i, a), &(j, b)|\
    \ {\n        match points(a).cmp(&points(b)) {\n            Ordering::Equal =>\
    \ i.cmp(&j),\n            r => r,\n        }\n    }).map(|(_, n)| n).collect()",
  "    fn sum_of_digits(x: isize) -> isize {\n        if x == 0 {\n            return\
    \ 0;\n        }\n        let rest = x / 10;\n        x - rest * 10 + sum_of_digits(rest)\n\
    \    }\n    nums.into_iter().enumerate().sorted_by_key(|x| (sum_of_digits(x.1),\
    \ x.0)).map(|x| x.1).collect()", "    let mut map: HashMap<isize, Vec<isize>>\
    \ = HashMap::new();\n    let mut res: Vec<isize> = Vec::new();\n    for num in\
    \ nums {\n        let mut sum = 0;\n        let mut tmp = num;\n        while\
    \ tmp != 0 {\n            sum += tmp % 10;\n            tmp /= 10;\n        }\n\
    \        map.entry(sum).or_insert(Vec::new()).push(num);\n    }\n    let mut keys:\
    \ Vec<isize> = map.keys().cloned().collect();\n    keys.sort();\n    for key in\
    \ keys {\n        let mut v = map.get(&key).unwrap().clone();\n        v.sort();\n\
    \        res.append(&mut v);\n    }\n    res", "    nums.into_iter().enumerate().map(|(i,\
    \ n)| (n, i)).collect::<Vec<_>>().sort_by(|a, b| {\n        let (na, _) = a;\n\
    \        let (nb, _) = b;\n        na.abs().to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum::<usize>().cmp(&nb.abs().to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum::<usize>()).then(b.1.cmp(&a.1))\n    }).into_iter().map(|(n, _)|\
    \ n).collect()", "    let mut result = nums.clone();\n    result.sort_by(|a, b|\
    \ {\n        let sum_a = sum_digits(*a);\n        let sum_b = sum_digits(*b);\n\
    \        sum_a.cmp(&sum_b)\n    });\n    result", '    nums.iter().map(|x| *x).collect::<Vec<isize>>()',
  "    let mut nums = nums;\n    nums.sort_by_key(|x| sum_of_digits(*x));\n    nums",
  '    unimplemented!()', "    if nums.is_empty() {\n        return nums;\n    }\n\
    \    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let point_a = a.abs()\n\
    \            .to_string()\n            .chars()\n            .map(|ch| ch.to_digit(10).unwrap()\
    \ as isize)\n            .sum::<isize>();\n        let point_b = b.abs()\n   \
    \         .to_string()\n            .chars()\n            .map(|ch| ch.to_digit(10).unwrap()\
    \ as isize)\n            .sum::<isize>();\n        match point_a.cmp(&point_b)\
    \ {\n            Ordering::Equal => a.cmp(&b),\n            Ordering::Less =>\
    \ Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n     \
    \   }\n    });\n    nums", '    unimplemented!();', "    let mut v = nums.clone();\n\
    \    v.sort_by(|a, b| digits_sum(*a).cmp(&digits_sum(*b)));\n    v", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let x = a.1.abs() as u64;\n        let y = b.1.abs() as u64;\n\
    \        let m = x.saturating_mul(10).saturating_add(x.saturating_rem(10));\n\
    \        let n = y.saturating_mul(10).saturating_add(y.saturating_rem(10));\n\
    \        m.cmp(&n).then(a.0.cmp(&b.0))\n    }).into_iter().map(|x| x.1).collect()",
  "    let mut score = nums.iter().map(|n| n.abs() as usize)\n        .map(|n| n.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as usize).sum())\n        .collect::<Vec<usize>>();\n\
    \    nums.iter().zip(score.iter()).sorted_by(|a, b| (b.1, a.0).cmp(&(a.1, b.0))).map(|x|\
    \ *x.0).collect()", "    fn sum_of_digits(n: isize) -> usize {\n        n.abs()\n\
    \            .to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as usize)\n            .sum()\n    }\n\n    nums.into_iter()\n        .enumerate()\n\
    \        .sorted_by_key(|(_, n)| (sum_of_digits(*n), *n))\n        .map(|(_, n)|\
    \ n)\n        .collect()", "    let mut nums = nums;\n    nums.sort_by_key(|&x|\
    \ sum_digits(x));\n    nums", "    let mut result = nums.clone();\n    result.sort_by(|x,\
    \ y| {\n        let mut x_digits = Vec::new();\n        let mut y_digits = Vec::new();\n\
    \        for i in x.to_string().chars() {\n            x_digits.push(i.to_digit(10).unwrap());\n\
    \        }\n        for i in y.to_string().chars() {\n            y_digits.push(i.to_digit(10).unwrap());\n\
    \        }\n        let x_sum: u32 = x_digits.iter().sum();\n        let y_sum:\
    \ u32 = y_digits.iter().sum();\n        if x_sum == y_sum {\n            nums.iter().position(|&r|\
    \ r == *x).cmp(&nums.iter().position(|&r| r == *y))\n        } else {\n      \
    \      x_sum.cmp(&y_sum)\n        }\n    });\n    result", '    unimplemented!()',
  "    // use isize::abs to get absolute value\n    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|x,\
    \ y| {\n        // get the sum of digits for each value\n        // and the index\
    \ in vector\n        let (x_sum, x_idx) = (x.1.abs().to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as usize).sum(), x.0);\n        let (y_sum, y_idx) =\
    \ (y.1.abs().to_string().chars().map(|c| c.to_digit(10).unwrap() as usize).sum(),\
    \ y.0);\n        // sort it\n        match x_sum.cmp(&y_sum) {\n            Ordering::Equal\
    \ => x_idx.cmp(&y_idx),\n            other => other,\n        }\n    }).into_iter().map(|v|\
    \ v.1).collect()", "    let mut nums = nums;\n    nums.sort_by_key(|&num| {\n\
    \        num.abs()\n            .to_string()\n            .chars()\n         \
    \   .fold(0, |acc, ch| acc + ch.to_digit(10).unwrap() as isize)\n    });\n   \
    \ nums"]
stop_tokens:
- "\n}"
