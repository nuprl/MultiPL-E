name: HumanEval_58_common
language: rust
results:
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.into_iter().filter(|&x| l2.contains(&x)).collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpbhlubis0.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut result = Vec::new();\n\
    \    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n     \
    \       result.push(l1[i]);\n            i += 1;\n            j += 1;\n      \
    \  } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n        \
    \    j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    if l1.len() == 0 || l2.len()\
    \ == 0 {\n        return res;\n    }\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut all = l1.iter().chain(l2.iter()).collect::<Vec<_>>();\n\
    \    all.sort();\n    all.dedup();\n    all\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpighhgte_.rs:10:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n10 |     all\n   |     ^^^ expected `isize`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common = Vec::new();\n    for x in l1 {\n        if\
    \ l2.contains(&x) {\n            common.push(x);\n        }\n    }\n    common.sort();\n\
    \    common.dedup();\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp0wym19pf.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // ...\n    // ... your code here\n    // ...\n    let mut\
    \ li1: Vec<isize> = l1.iter().cloned().collect();\n    let mut li2: Vec<isize>\
    \ = l2.iter().cloned().collect();\n    li1.sort();\n    li2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut res: Vec<isize> = Vec::new();\n    while\
    \ i < li1.len() && j < li2.len() {\n        if li1[i] == li2[j] {\n          \
    \  res.push(li1[i]);\n            i += 1;\n            j += 1;\n        } else\
    \ if li1[i] < li2[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    let (mut a, mut b) = (0, 0);\n\
    \    while a < l1.len() && b < l2.len() {\n        if l1[a] == l2[b] {\n     \
    \       if !res.contains(&l1[a]) {\n                res.push(l1[a]);\n       \
    \     }\n            a += 1;\n            b += 1;\n        } else if l1[a] < l2[b]\
    \ {\n            a += 1;\n        } else {\n            b += 1;\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for el in l1 {\n       \
    \ if l2.contains(&el) && !result.contains(&el) {\n            result.push(el);\n\
    \        }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut v3 = Vec::new();\n    let mut v4 =\
    \ Vec::new();\n    let mut v = Vec::new();\n    if v1.len() < v2.len() {\n   \
    \     for i in 0..v1.len() {\n            if v1[i] == v2[i] {\n              \
    \  v3.push(v1[i]);\n            }\n        }\n    } else {\n        for i in 0..v2.len()\
    \ {\n            if v1[i] == v2[i] {\n                v4.push(v2[i]);\n      \
    \      }\n        }\n    }\n    for i in 0..v3.len() {\n        if !v.contains(&v3[i])\
    \ {\n            v.push(v3[i]);\n        }\n    }\n    for i in 0..v4.len() {\n\
    \        if !v.contains(&v4[i]) {\n            v.push(v4[i]);\n        }\n   \
    \ }\n    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp74dyb33v.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = l1.into_iter().collect::<Vec<isize>>();\n  \
    \  res.extend(l2.into_iter());\n    res.sort();\n    res.dedup();\n    res\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 9, 34, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpernz8g3f.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n\
    \    let mut l1_val = *l1_iter.next().unwrap();\n    let mut l2_val = *l2_iter.next().unwrap();\n\
    \    let mut result = Vec::new();\n    loop {\n        if l1_val == l2_val {\n\
    \            result.push(l1_val);\n            l1_val = *l1_iter.next().unwrap_or(&isize::min_value());\n\
    \            l2_val = *l2_iter.next().unwrap_or(&isize::min_value());\n      \
    \  } else if l1_val < l2_val {\n            l1_val = *l1_iter.next().unwrap_or(&isize::min_value());\n\
    \        } else {\n            l2_val = *l2_iter.next().unwrap_or(&isize::min_value());\n\
    \        }\n        if l1_val == isize::min_value() && l2_val == isize::min_value()\
    \ {\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    for item in l1 {\n        if\
    \ l2.contains(&item) && !result.contains(&item) {\n            result.push(item);\n\
    \        }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n    l1\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  let mut result = vec![];\n  for item in l1 {\n    if l2.contains(&item)\
    \ && !result.contains(&item) {\n      result.push(item);\n    }\n  }\n  result.sort();\n\
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).copied().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp4kblo3mf.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  let mut inter: Vec<isize> = Vec::new();\n  let mut min_len:\
    \ usize = l1.len();\n  let l: &Vec<isize> = if l2.len() < min_len {\n    min_len\
    \ = l2.len();\n    &l2\n  } else {\n    &l1\n  };\n  for x in l {\n    if l1.contains(x)\
    \ && l2.contains(x) {\n      inter.push(*x);\n    }\n  }\n  inter.sort();\n  inter.dedup();\n\
    \  inter\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l: Vec<isize> = Vec::new();\n    let mut a = l1.iter().collect::<Vec<&isize>>();\n\
    \    let mut b = l2.iter().collect::<Vec<&isize>>();\n    a.sort();\n    b.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < a.len() && j < b.len()\
    \ {\n        if a[i] == b[j] {\n            l.push(*a[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if a[i] < b[j] {\n            i += 1;\n \
    \       } else {\n            j += 1;\n        }\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let l3: Vec<isize> = l1.iter().filter(|&x|\
    \ l2.contains(x)).cloned().collect();\n    l3.iter().unique().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpw47_5r1b.rs:12:15\n   |\n12 |     l3.iter().unique().cloned().collect()\n\
    \   |               ^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjccqmyet.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let set1: BTreeSet<isize> = l1.into_iter().collect();\n  \
    \  let set2: BTreeSet<isize> = l2.into_iter().collect();\n    let mut v: Vec<isize>\
    \ = set1.intersection(&set2).cloned().collect();\n    v.sort();\n    v\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmphnrf7pfb.rs:7:15\n\
    \  |\n7 |     let set1: BTreeSet<isize> = l1.into_iter().collect();\n  |     \
    \          ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `BTreeSet` in this scope\n --> /tmp/tmphnrf7pfb.rs:8:15\n  |\n8 |\
    \     let set2: BTreeSet<isize> = l2.into_iter().collect();\n  |             \
    \  ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: write code here\n    vec![]\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpo4utck7j.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l2 = l2;\n    l2.sort();\n\
    \    for i in l1 {\n        if !result.contains(&i) && l2.binary_search(&i).is_ok()\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort();\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s1 = l1.into_iter().collect::<HashSet<_>>();\n   \
    \ let mut s2 = l2.into_iter().collect::<HashSet<_>>();\n    s1.retain(|x| s2.contains(x));\n\
    \    s1.into_iter().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzuf6h9cp.rs:7:43\n\
    \  |\n7 |     let mut s1 = l1.into_iter().collect::<HashSet<_>>();\n  |      \
    \                                     ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzuf6h9cp.rs:8:43\n\
    \  |\n8 |     let mut s2 = l2.into_iter().collect::<HashSet<_>>();\n  |      \
    \                                     ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut result = Vec::new();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            result.push(l1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpb0yjkovi.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.iter().cloned().filter(|n| l2.contains(n)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut i = 0;\n    let mut j = 0;\n    let mut res = Vec::new();\n\
    \    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n      \
    \      i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n     \
    \   } else {\n            if i == 0 || l1[i] != l1[i - 1] {\n                res.push(l1[i]);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpb0flhs9x.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1_s = l1.clone();\n    let mut l2_s = l2.clone();\n\
    \    l1_s.sort();\n    l2_s.sort();\n    l1_s.into_iter().filter(|x| l2_s.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut result = Vec::new();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            result.push(l1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut out = Vec::new();\n    for i in l1 {\n        if l2.contains(&i)\
    \ && !out.contains(&i) {\n            out.push(i);\n        }\n    }\n    out.sort();\n\
    \    out\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu7szns8m.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect()\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.retain(|&x| l2.contains(&x));\n    l1\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpjf3_axvd.rs:7:19\n\
    \  |\n7 |     let mut res = Vec::new();\n  |         -------   ^^^^^^^^ cannot\
    \ infer type for type parameter `T`\n  |         |\n  |         consider giving\
    \ `res` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1 {\n        if\
    \ l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n   \
    \     }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut unique_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \    let mut unique_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    unique_l1.retain(|x|\
    \ unique_l2.contains(x));\n    let mut common = unique_l1.into_iter().collect::<Vec<isize>>();\n\
    \    common.sort();\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp9736zrcp.rs:7:50\n\
    \  |\n7 |     let mut unique_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                  ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp9736zrcp.rs:8:50\n\
    \  |\n8 |     let mut unique_l2 = l2.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                  ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let\
    \ set2: HashSet<_> = l2.into_iter().collect();\n    set1.intersection(&set2).map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpqt8w9zrx.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<_> = l1.into_iter().collect();\n  |          \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpqt8w9zrx.rs:8:15\n  |\n8 |     let set2:\
    \ HashSet<_> = l2.into_iter().collect();\n  |               ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s1 = l1.iter().cloned().collect::<BTreeSet<isize>>();\n\
    \    let mut s2 = l2.iter().cloned().collect::<BTreeSet<isize>>();\n    s1.intersection(&s2).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmp4k5l27ig.rs:7:47\n\
    \  |\n7 |     let mut s1 = l1.iter().cloned().collect::<BTreeSet<isize>>();\n\
    \  |                                               ^^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmp4k5l27ig.rs:8:47\n\
    \  |\n8 |     let mut s2 = l2.iter().cloned().collect::<BTreeSet<isize>>();\n\
    \  |                                               ^^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.into_iter().filter(|&x| l2.contains(&x)).collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp30yd0_dt.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n            if l1[i]\
    \ == l2[j] {\n                result.push(l1[i]);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: implement this function\n    unimplemented!()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphnytvj3f.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let res: Vec<isize> = l1.iter().filter(|&x| l2.contains(x)).copied().collect();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpg3kuxwu_.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|el| l2.contains(el)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpe17vqqjh.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpv24b80w2.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_2_ntm24.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: https://www.reddit.com/r/rust/comments/38m0ab/common_is_not_in_scope/\n\
    \    let mut res = vec![];\n    for x in l1 {\n        if l2.contains(&x) && !res.contains(&x)\
    \ {\n            res.push(x);\n        }\n    }\n    res.sort();\n    res\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut sorted1 = l1.clone();\n\
    \    let mut sorted2 = l2.clone();\n    sorted1.sort();\n    sorted2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < sorted1.len() && j < sorted2.len()\
    \ {\n        if sorted1[i] == sorted2[j] {\n            res.push(sorted1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if sorted1[i] < sorted2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut uniq_l1 = l1.clone();\n    uniq_l1.sort();\n    uniq_l1.dedup();\n\
    \    let mut uniq_l2 = l2.clone();\n    uniq_l2.sort();\n    uniq_l2.dedup();\n\
    \    uniq_l1.iter().filter(|&x| uniq_l2.contains(x)).cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplj94oym7.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let l1 = l1.dedup();\n    let l2 = l2.dedup();\n    let mut\
    \ res = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n       \
    \     res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: `()` is not an iterator\n  --> /tmp/tmp0qo93u79.rs:14:14\n\
    \   |\n14 |     for i in l1 {\n   |              ^^ `()` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `()`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `()`\n\
    \nerror[E0599]: no method named `contains` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp0qo93u79.rs:15:15\n   |\n15 |         if l2.contains(&i)\
    \ {\n   |               ^^^^^^^^ method not found in `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let l3: Vec<isize> = l1.into_iter().filter(|a|\
    \ l2.contains(a)).collect();\n    return l3;\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcypg_130.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    for (idx, val) in l1.iter().enumerate()\
    \ {\n        if l2.contains(val) {\n            res.push(*val);\n        }\n \
    \   }\n    let mut res = res.to_vec();\n    res.sort();\n    res.dedup();\n  \
    \  res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().cloned().filter(|&x| l2.contains(&x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp1qk9k16_.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut res = Vec::new();\n    let mut ix1 = 0;\n    let mut\
    \ ix2 = 0;\n    while ix1 < l1.len() && ix2 < l2.len() {\n        if l1[ix1] ==\
    \ l2[ix2] {\n            res.push(l1[ix1]);\n            ix1 += 1;\n         \
    \   ix2 += 1;\n        } else if l1[ix1] < l2[ix2] {\n            ix1 += 1;\n\
    \        } else {\n            ix2 += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v = l1.iter().map(|&x| x).collect::<Vec<isize>>();\n\
    \    v.extend(l2.iter().map(|&x| x));\n    v.sort();\n    v.dedup();\n    v\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 9, 34, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpb4v3kuzu.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    for i in l1 {\n        if l2.contains(&i)\
    \ && !result.contains(&i) {\n            result.push(i);\n        }\n    }\n \
    \   result.sort();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO write your code here\n    l1.iter().filter(|&x| l2.contains(x)).map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmptd4exekj.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    return Vec::new();\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpv0km11di.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut sorted1 = l1.clone();\n    sorted1.sort();\n    let\
    \ mut sorted2 = l2.clone();\n    sorted2.sort();\n    let mut common: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < sorted1.len()\
    \ && j < sorted2.len() {\n        if sorted1[i] == sorted2[j] {\n            common.push(sorted1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if sorted1[i] < sorted2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    let mut result: Vec<isize> = Vec::new();\n    for k in 0..common.len()\
    \ {\n        if k == 0 || common[k] != common[k - 1] {\n            result.push(common[k]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n    for item in l1 {\n\
    \        if l2.contains(&item) {\n            v.push(item);\n        }\n    }\n\
    \    v.sort();\n    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m1 = hashmap!{};\n    let mut m2 = hashmap!{};\n \
    \   let mut ret = vec![];\n    for i in l1 {\n        m1.insert(i, 1);\n    }\n\
    \    for i in l2 {\n        m2.insert(i, 1);\n    }\n    for (k, _) in m1 {\n\
    \        if m2.contains_key(&k) {\n            ret.push(k);\n        }\n    }\n\
    \    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `hashmap` in this scope\n --> /tmp/tmpgrym7hmm.rs:7:18\n\
    \  |\n7 |     let mut m1 = hashmap!{};\n  |                  ^^^^^^^\n\nerror:\
    \ cannot find macro `hashmap` in this scope\n --> /tmp/tmpgrym7hmm.rs:8:18\n \
    \ |\n8 |     let mut m2 = hashmap!{};\n  |                  ^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  vec![]\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpxdah7051.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut new_list = Vec::new();\n    for i in l1 {\n      \
    \  if l2.contains(&i) {\n            new_list.push(i);\n        }\n    }\n   \
    \ new_list.sort();\n    new_list.dedup();\n    new_list\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).map(|&x| x).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp0kkd6e2l.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v = Vec::new();\n    let mut count = 0;\n    for i\
    \ in l1 {\n        for j in l2 {\n            if i == j {\n                v.push(i);\n\
    \                count += 1;\n            }\n        }\n    }\n    v.sort();\n\
    \    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: variable `count` is assigned to, but never used\n --> /tmp/tmpq6l9ownw.rs:8:13\n\
    \  |\n8 |     let mut count = 0;\n  |             ^^^^^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_count` instead\n\nerror[E0382]: use\
    \ of moved value: `l2`\n   --> /tmp/tmpq6l9ownw.rs:10:18\n    |\n6   | fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |                         \
    \  -- move occurs because `l2` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n10  |         for j in l2 {\n    |                  ^^\
    \ `l2` moved due to this implicit call to `.into_iter()`, in previous iteration\
    \ of loop\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `l2`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n10  |         for j in &l2\
    \ {\n    |                  +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v: Vec<isize> = l1.into_iter().filter(|x| l2.contains(x)).collect();\n\
    \    v.sort();\n    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    let mut l1 = l1.into_iter();\n    let mut l2 = l2.into_iter();\n    while\
    \ let (Some(n1), Some(n2)) = (l1.next(), l2.next()) {\n        if n1 == n2 {\n\
    \            result.push(n1);\n        } else if n1 < n2 {\n            l2 = l2.skip_while(|n|\
    \ *n < n1);\n        } else {\n            l1 = l1.skip_while(|n| *n < n2);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0nlv52fe.rs:20:18\n   |\n\
    15 |     let mut l2 = l2.into_iter();\n   |                  -------------- expected\
    \ due to this value\n...\n20 |             l2 = l2.skip_while(|n| *n < n1);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::vec::IntoIter`,\
    \ found struct `SkipWhile`\n   |\n   = note: expected struct `std::vec::IntoIter<_>`\n\
    \              found struct `SkipWhile<std::vec::IntoIter<_>, [closure@/tmp/tmp0nlv52fe.rs:20:32:\
    \ 20:43]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0nlv52fe.rs:22:18\n\
    \   |\n14 |     let mut l1 = l1.into_iter();\n   |                  --------------\
    \ expected due to this value\n...\n22 |             l1 = l1.skip_while(|n| *n\
    \ < n2);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::vec::IntoIter`,\
    \ found struct `SkipWhile`\n   |\n   = note: expected struct `std::vec::IntoIter<_>`\n\
    \              found struct `SkipWhile<std::vec::IntoIter<_>, [closure@/tmp/tmp0nlv52fe.rs:22:32:\
    \ 22:43]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplg7ah4mm.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut elements: Vec<isize> = Vec::new();\n    let mut both_lists:\
    \ Vec<isize> = Vec::new();\n    both_lists.extend(l1);\n    both_lists.extend(l2);\n\
    \    both_lists.sort();\n    both_lists.dedup();\n    for el in both_lists {\n\
    \        if l1.contains(&el) && l2.contains(&el) {\n            elements.push(el);\n\
    \        }\n    }\n    elements\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l1`\n  --> /tmp/tmpw4e0nmav.rs:14:12\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \         -- move occurs because `l1` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n9  |     both_lists.extend(l1);\n   |               \
    \        -- value moved here\n...\n14 |         if l1.contains(&el) && l2.contains(&el)\
    \ {\n   |            ^^^^^^^^^^^^^^^^ value borrowed here after move\n   |\n \
    \  = note: borrow occurs due to deref coercion to `[isize]`\n\nerror[E0382]: borrow\
    \ of moved value: `l2`\n  --> /tmp/tmpw4e0nmav.rs:14:32\n   |\n6  | fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \ -- move occurs because `l2` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n10 |     both_lists.extend(l2);\n   |               \
    \        -- value moved here\n...\n14 |         if l1.contains(&el) && l2.contains(&el)\
    \ {\n   |                                ^^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n   |\n   = note: borrow occurs due to deref coercion to `[isize]`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut hm: HashMap<isize, isize> = HashMap::new();\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    for v in l1 {\n        *hm.entry(v).or_insert(0)\
    \ += 1;\n    }\n    for v in l2 {\n        if hm.contains_key(&v) {\n        \
    \    *hm.entry(v).or_insert(0) += 1;\n        }\n    }\n    for (k, v) in hm {\n\
    \        if v > 1 {\n            result.push(k);\n        }\n    }\n    result.sort();\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpbj9scsmp.rs:7:17\n\
    \  |\n7 |     let mut hm: HashMap<isize, isize> = HashMap::new();\n  |       \
    \          ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpbj9scsmp.rs:7:41\n\
    \  |\n7 |     let mut hm: HashMap<isize, isize> = HashMap::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut v3 = Vec::new();\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n        if\
    \ v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i] > v2[j] {\n  \
    \          j += 1;\n        } else {\n            v3.push(v1[i]);\n          \
    \  i += 1;\n            j += 1;\n        }\n    }\n    v3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|x| l2.contains(x));\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkbxp4b2y.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.intersect(&l2).cloned().collect()\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `intersect` found for struct `Vec<isize>`\
    \ in the current scope\n --> /tmp/tmprzb1rw4b.rs:7:8\n  |\n7 |     l1.intersect(&l2).cloned().collect()\n\
    \  |        ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `insert`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut set_2 = HashSet::new();\n\
    \    for n in l2 {\n        set_2.insert(n);\n    }\n    for n in l1 {\n     \
    \   if set_2.contains(&n) {\n            result.push(n);\n        }\n    }\n \
    \   result.sort();\n    result.dedup();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpwrfxfvl2.rs:8:21\n  |\n8 |     let mut set_2 = HashSet::new();\n  |\
    \                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp50d5cdsb.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut v3 = vec![];\n    let mut c = 0;\n\
    \    let mut c1 = 0;\n    let mut c2 = 0;\n    while c1 < v1.len() && c2 < v2.len()\
    \ {\n        if v1[c1] == v2[c2] {\n            if c == 0 {\n                v3.push(v1[c1]);\n\
    \                c += 1;\n            } else if v3[c - 1] != v1[c1] {\n      \
    \          v3.push(v1[c1]);\n                c += 1;\n            }\n        \
    \    c1 += 1;\n            c2 += 1;\n        } else if v1[c1] < v2[c2] {\n   \
    \         c1 += 1;\n        } else {\n            c2 += 1;\n        }\n    }\n\
    \    v3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  let mut res = Vec::new();\n  for e in l1 {\n    if l2.contains(&e)\
    \ && !res.contains(&e) {\n      res.push(e);\n    }\n  }\n  res.sort();\n  res\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|&x| l2.contains(&x));\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() < l2.len() {\n        common(l2, l1)\n    } else\
    \ {\n        l1.iter().cloned().filter(|x| l2.contains(x)).collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpn_y4b8as.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    return l1.iter().filter(|x| l2.contains(x)).map(|x| *x).collect();\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    fn _common(l1: &[isize], l2: &[isize], acc: &mut Vec<isize>)\
    \ {\n        if l1.is_empty() || l2.is_empty() {\n            return;\n      \
    \  }\n        if l1[0] < l2[0] {\n            _common(&l1[1..], l2, acc);\n  \
    \      } else if l1[0] > l2[0] {\n            _common(l1, &l2[1..], acc);\n  \
    \      } else {\n            acc.push(l1[0]);\n            _common(&l1[1..], &l2[1..],\
    \ acc);\n        }\n    }\n    let mut res = Vec::new();\n    _common(&l1, &l2,\
    \ &mut res);\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmp059a2b0o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n\
    \    list1.sort();\n    list2.sort();\n    let mut v: Vec<isize> = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < list1.len() && i2 <\
    \ list2.len() {\n        if list1[i1] < list2[i2] {\n            i1 += 1;\n  \
    \      } else if list1[i1] > list2[i2] {\n            i2 += 1;\n        } else\
    \ {\n            v.push(list1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    use std::collections::HashSet;\n    let hs: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let hs2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let mut l: Vec<isize> = Vec::new();\n    for x in hs2 {\n        if hs.contains(&x)\
    \ {\n            l.push(x);\n        }\n    }\n    l.sort();\n    l.dedup();\n\
    \    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set1: BTreeSet<isize> = BTreeSet::new();\n    let\
    \ mut set2: BTreeSet<isize> = BTreeSet::new();\n    for n in l1 {\n        set1.insert(n);\n\
    \    }\n    for n in l2 {\n        set2.insert(n);\n    }\n    set1.intersection(&set2).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpx7b7jpv6.rs:7:19\n\
    \  |\n7 |     let mut set1: BTreeSet<isize> = BTreeSet::new();\n  |          \
    \         ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BTreeSet`\n --> /tmp/tmpx7b7jpv6.rs:7:37\n\
    \  |\n7 |     let mut set1: BTreeSet<isize> = BTreeSet::new();\n  |          \
    \                           ^^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `BTreeSet` in this scope\n --> /tmp/tmpx7b7jpv6.rs:8:19\n \
    \ |\n8 |     let mut set2: BTreeSet<isize> = BTreeSet::new();\n  |           \
    \        ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BTreeSet`\n --> /tmp/tmpx7b7jpv6.rs:8:37\n\
    \  |\n8 |     let mut set2: BTreeSet<isize> = BTreeSet::new();\n  |          \
    \                           ^^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    l1.sort();\n    l2.sort();\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] == l2[j] {\n            if res.len() == 0 || res[res.len()\
    \ - 1] != l1[i] {\n                res.push(l1[i]);\n            }\n         \
    \   i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n        \
    \    i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpiwkwlra_.rs:10:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n10 |     l1.sort();\n   |     ^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `l2` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpiwkwlra_.rs:11:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                           -- help: consider changing this\
    \ to be mutable: `mut l2`\n...\n11 |     l2.sort();\n   |     ^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = vec![];\n    for x in l1 {\n        if l2.contains(&x)\
    \ && !res.contains(&x) {\n            res.push(x);\n        }\n    }\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: Implement\n    vec![]\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp6vfzk0pf.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n    let mut\
    \ set2: HashSet<isize> = HashSet::new();\n    let mut common: HashSet<isize> =\
    \ HashSet::new();\n\n    // Add numbers to sets\n    for x in l1 {\n        set1.insert(x);\n\
    \    }\n    for x in l2 {\n        set2.insert(x);\n    }\n\n    // Check for\
    \ any common numbers\n    for x in set1 {\n        if set2.contains(&x) {\n  \
    \          common.insert(x);\n        }\n    }\n\n    // Sort the common numbers\n\
    \    let mut common_vec: Vec<isize> = Vec::new();\n    for x in common {\n   \
    \     common_vec.push(x);\n    }\n    common_vec.sort();\n\n    common_vec\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp4s_viy3p.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp4s_viy3p.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp4s_viy3p.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmp4s_viy3p.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmp4s_viy3p.rs:9:21\n  |\n9 |     let mut\
    \ common: HashSet<isize> = HashSet::new();\n  |                     ^^^^^^^ not\
    \ found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use\
    \ std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n --> /tmp/tmp4s_viy3p.rs:9:38\n  |\n9 |     let mut common:\
    \ HashSet<isize> = HashSet::new();\n  |                                      ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut uniq_l1 = l1.clone();\n    uniq_l1.sort();\n    uniq_l1.dedup();\n\
    \    let mut uniq_l2 = l2.clone();\n    uniq_l2.sort();\n    uniq_l2.dedup();\n\
    \    let mut ret: Vec<isize> = vec![];\n    for i in uniq_l1 {\n        if uniq_l2.contains(&i)\
    \ {\n            ret.push(i);\n        }\n    }\n    ret\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut l1_clone = l1.clone();\n\
    \    let mut l2_clone = l2.clone();\n    l1_clone.sort();\n    l2_clone.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < l1_clone.len() && j < l2_clone.len()\
    \ {\n        if l1_clone[i] == l2_clone[j] {\n            res.push(l1_clone[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1_clone[i] < l2_clone[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut r1 = l1.clone();\n    let mut r2 = l2.clone();\n \
    \   r1.sort();\n    r2.sort();\n    r1.retain(|&x| r2.contains(&x));\n    r1.sort();\n\
    \    r1.dedup();\n    r1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = vec![];\n    let mut set1: HashSet<isize>\
    \ = HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    for\
    \ i in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n    for i in set1.intersection(&set2) {\n        ret.push(*i);\n    }\n\
    \    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzxa1r2f8.rs:8:19\n\
    \  |\n8 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpzxa1r2f8.rs:8:36\n  |\n8 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpzxa1r2f8.rs:9:19\n  |\n9 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpzxa1r2f8.rs:9:36\n  |\n9 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7m0h4k3j.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.retain(|&v| l2.contains(&v));\n    l1.dedup();\n    l1\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  let l1 = l1.into_iter().collect::<HashSet<_>>();\n  let l2 =\
    \ l2.into_iter().collect::<HashSet<_>>();\n  l1.intersection(&l2).cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpjk3b3bi9.rs:7:37\n\
    \  |\n7 |   let l1 = l1.into_iter().collect::<HashSet<_>>();\n  |            \
    \                         ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n --> /tmp/tmpjk3b3bi9.rs:8:37\n  |\n\
    8 |   let l2 = l2.into_iter().collect::<HashSet<_>>();\n  |                  \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut l1 = l1.iter();\n    let mut l2 = l2.iter();\n   \
    \ let mut l1i = l1.next();\n    let mut l2i = l2.next();\n    let mut result =\
    \ Vec::new();\n    while l1i.is_some() && l2i.is_some() {\n        if l1i.unwrap()\
    \ == l2i.unwrap() {\n            result.push(*l1i.unwrap());\n            l1i\
    \ = l1.next();\n            l2i = l2.next();\n        } else if l1i.unwrap() <\
    \ l2i.unwrap() {\n            l1i = l1.next();\n        } else {\n           \
    \ l2i = l2.next();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  //remove duplicates\n  let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \  let set2: HashSet<isize> = l2.into_iter().collect();\n  //find common values\n\
    \  let mut common: Vec<isize> = set1.intersection(&set2).cloned().collect();\n\
    \  //sort\n  common.sort();\n  common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp5xqopukp.rs:8:13\n\
    \  |\n8 |   let set1: HashSet<isize> = l1.into_iter().collect();\n  |        \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmp5xqopukp.rs:9:13\n  |\n9 |   let set2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for e in l1 {\n        if\
    \ l2.contains(&e) && !result.contains(&e) {\n            result.push(e);\n   \
    \     }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut res = vec![];\n    for (k, v) in l1.iter().enumerate() {\n\
    \        if k == 0 {\n            res.push(*v);\n        } else {\n          \
    \  let mut left = 0;\n            let mut right = res.len() - 1;\n           \
    \ while left <= right {\n                let mid = (left + right) / 2;\n     \
    \           if res[mid] == *v {\n                    break;\n                }\
    \ else if res[mid] < *v {\n                    left = mid + 1;\n             \
    \   } else {\n                    right = mid - 1;\n                }\n      \
    \      }\n            if left > right {\n                res.insert(left, *v);\n\
    \            }\n        }\n    }\n    let mut tmp = vec![];\n    for (k, v) in\
    \ l2.iter().enumerate() {\n        if k == 0 {\n            tmp.push(*v);\n  \
    \      } else {\n            let mut left = 0;\n            let mut right = tmp.len()\
    \ - 1;\n            while left <= right {\n                let mid = (left + right)\
    \ / 2;\n                if tmp[mid] == *v {\n                    break;\n    \
    \            } else if tmp[mid] < *v {\n                    left = mid + 1;\n\
    \                } else {\n                    right = mid - 1;\n            \
    \    }\n            }\n            if left > right {\n                tmp.insert(left,\
    \ *v);\n            }\n        }\n    }\n    let mut res2 = vec![];\n    let mut\
    \ index1 = 0;\n    let mut index2 = 0;\n    while index1 < res.len() && index2\
    \ < tmp.len() {\n        if res[index1] == tmp[index2] {\n            res2.push(res[index1]);\n\
    \            index1 += 1;\n            index2 += 1;\n        } else if res[index1]\
    \ < tmp[index2] {\n            index1 += 1;\n        } else {\n            index2\
    \ += 1;\n        }\n    }\n    res2\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpoyb1q9mc.rs:46:29\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpalruqvmu.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n  \
    \  let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n    s1.retain(|&x| s2.contains(&x));\n\
    \    s1.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpi_9xl_re.rs:7:43\n\
    \  |\n7 |     let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n  |     \
    \                                      ^^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpi_9xl_re.rs:8:43\n\
    \  |\n8 |     let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n  |     \
    \                                      ^^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    fn _common(l1: &[isize], l2: &[isize], acc: &mut Vec<isize>)\
    \ {\n        if l1.is_empty() || l2.is_empty() {\n            return;\n      \
    \  }\n\n        let (h1, t1) = l1.split_first().unwrap();\n        let (h2, t2)\
    \ = l2.split_first().unwrap();\n\n        match h1.cmp(h2) {\n            Ordering::Less\
    \ => _common(t1, l2, acc),\n            Ordering::Greater => _common(l1, t2, acc),\n\
    \            Ordering::Equal => {\n                acc.push(*h1);\n          \
    \      _common(t1, t2, acc);\n            }\n        }\n    }\n\n    let mut result\
    \ = Vec::new();\n    _common(&l1, &l2, &mut result);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpyt5txie0.rs:16:13\n   |\n16 |             Ordering::Less => _common(t1,\
    \ l2, acc),\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpyt5txie0.rs:17:13\n\
    \   |\n17 |             Ordering::Greater => _common(l1, t2, acc),\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpyt5txie0.rs:18:13\n\
    \   |\n18 |             Ordering::Equal => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret: Vec<isize> = vec![];\n    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut iter1 = l1.iter();\n\
    \    let mut iter2 = l2.iter();\n    let mut val1 = iter1.next();\n    let mut\
    \ val2 = iter2.next();\n    while val1.is_some() && val2.is_some() {\n       \
    \ let v1 = val1.unwrap();\n        let v2 = val2.unwrap();\n        if v1 < v2\
    \ {\n            val1 = iter1.next();\n        } else if v1 > v2 {\n         \
    \   val2 = iter2.next();\n        } else {\n            ret.push(*v1);\n     \
    \       val1 = iter1.next();\n            val2 = iter2.next();\n        }\n  \
    \  }\n    ret\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.intersect(&l2).cloned().collect()\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `intersect` found for struct `Vec<isize>`\
    \ in the current scope\n --> /tmp/tmpll70lstm.rs:7:8\n  |\n7 |     l1.intersect(&l2).cloned().collect()\n\
    \  |        ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `insert`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpa8s640bl.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut list1: Vec<isize> = Vec::new();\n    let mut list2: Vec<isize> =\
    \ Vec::new();\n    let mut result: Vec<isize> = Vec::new();\n    let mut prev:\
    \ isize = -1;\n    for e in l1.iter() {\n        list1.push(*e);\n    }\n    for\
    \ e in l2.iter() {\n        list2.push(*e);\n    }\n    while !list1.is_empty()\
    \ && !list2.is_empty() {\n        let (value1, value2) = (list1[0], list2[0]);\n\
    \        if value1 == value2 {\n            if value1 != prev {\n            \
    \    result.push(value1);\n                prev = value1;\n            }\n   \
    \         list1.remove(0);\n            list2.remove(0);\n        } else if value1\
    \ < value2 {\n            list1.remove(0);\n        } else {\n            list2.remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut res = Vec::new();\n\
    \    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n      \
    \      i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n     \
    \   } else {\n            res.push(l1[i]);\n            i += 1;\n            j\
    \ += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = l1.clone();\n    let mut l1 = l1;\n    l1.sort();\n\
    \    let mut l2 = l2;\n    l2.sort();\n    let mut n1 = 0;\n    let mut n2 = 0;\n\
    \    loop {\n        if n1 == l1.len() || n2 == l2.len() {\n            break;\n\
    \        }\n        if l1[n1] == l2[n2] {\n            res.push(l1[n1]);\n   \
    \         n1 += 1;\n            n2 += 1;\n        } else if l1[n1] < l2[n2] {\n\
    \            n1 += 1;\n        } else {\n            n2 += 1;\n        }\n   \
    \ }\n    res.sort();\n    res.dedup();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpqfjeh5tk.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp835_tqk8.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|x| l2.contains(x));\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_7tx9x79.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut l1_set = l1.clone().into_iter().collect::<HashSet<isize>>();\n\
    \    let mut l2_set = l2.clone().into_iter().collect::<HashSet<isize>>();\n  \
    \  for item in l1_set.intersection(&l2_set) {\n        res.push(*item);\n    }\n\
    \    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpeh11_17w.rs:8:55\n\
    \  |\n8 |     let mut l1_set = l1.clone().into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                       ^^^^^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpeh11_17w.rs:9:55\n\
    \  |\n9 |     let mut l2_set = l2.clone().into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                       ^^^^^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut m1 = HashMap::new();\n    let mut m2 = HashMap::new();\n\
    \    for i in l1 {\n        if m1.contains_key(&i) {\n            m1.insert(i,\
    \ *m1.get(&i).unwrap() + 1);\n        } else {\n            m1.insert(i, 1);\n\
    \        }\n    }\n    for i in l2 {\n        if m2.contains_key(&i) {\n     \
    \       m2.insert(i, *m2.get(&i).unwrap() + 1);\n        } else {\n          \
    \  m2.insert(i, 1);\n        }\n    }\n    let mut res = Vec::new();\n    for\
    \ (k, v) in m1 {\n        if m2.contains_key(&k) {\n            let v2 = *m2.get(&k).unwrap();\n\
    \            let v1 = v;\n            let c = std::cmp::min(v1, v2);\n       \
    \     for _ in 0..c {\n                res.push(k);\n            }\n        }\n\
    \    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp8t0vt8lo.rs:7:18\n  |\n7 |     let mut m1 = HashMap::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmp8t0vt8lo.rs:8:18\n\
    \  |\n8 |     let mut m2 = HashMap::new();\n  |                  ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let s1: HashSet<isize> = l1.into_iter().collect();\n    let\
    \ s2: HashSet<isize> = l2.into_iter().collect();\n    let output: Vec<isize> =\
    \ s1.intersection(&s2).cloned().collect();\n    output.sort();\n    output\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpb8eqzkdr.rs:7:13\n\
    \  |\n7 |     let s1: HashSet<isize> = l1.into_iter().collect();\n  |        \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpb8eqzkdr.rs:8:13\n  |\n8 |     let s2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut s1 = l1.clone();\n    let mut s2 = l2.clone();\n \
    \   s1.sort();\n    s2.sort();\n    return s1.into_iter().filter(|x| s2.contains(x)).collect();\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let len1 = l1.len();\n    let len2 = l2.len();\n    while i < len1\
    \ && j < len2 {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.into_iter().filter(|&x| l2.contains(&x)).collect()\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpvv89ion2.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let a: HashSet<_> = l1.into_iter().collect();\n    let b:\
    \ HashSet<_> = l2.into_iter().collect();\n    let c: HashSet<_> = a.intersection(&b).cloned().collect();\n\
    \    let mut v: Vec<isize> = c.into_iter().collect();\n    v.sort();\n    v\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpp9lmgkmk.rs:7:12\n\
    \  |\n7 |     let a: HashSet<_> = l1.into_iter().collect();\n  |            ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n --> /tmp/tmpp9lmgkmk.rs:8:12\n  |\n8 |     let b: HashSet<_>\
    \ = l2.into_iter().collect();\n  |            ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpp9lmgkmk.rs:9:12\n\
    \  |\n9 |     let c: HashSet<_> = a.intersection(&b).cloned().collect();\n  |\
    \            ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  if l1.len() == 0 || l2.len() == 0 {\n    return Vec::new();\n\
    \  }\n  l1.into_iter().filter(|x| l2.contains(x)).collect()\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp6k6oi8ye.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|x| l2.contains(x));\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n  let l1_set: HashSet<_> = l1.into_iter().collect();\n  let l2_set:\
    \ HashSet<_> = l2.into_iter().collect();\n  let common_elements: HashSet<_> =\
    \ l1_set.intersection(&l2_set).collect();\n  let mut common_vec: Vec<isize> =\
    \ common_elements.into_iter().collect();\n  common_vec.sort();\n  common_vec\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpwg_9_tdv.rs:7:15\n\
    \  |\n7 |   let l1_set: HashSet<_> = l1.into_iter().collect();\n  |          \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpwg_9_tdv.rs:8:15\n  |\n8 |   let l2_set:\
    \ HashSet<_> = l2.into_iter().collect();\n  |               ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpwg_9_tdv.rs:9:24\n\
    \  |\n9 |   let common_elements: HashSet<_> = l1_set.intersection(&l2_set).collect();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set: HashSet<isize> = HashSet::new();\n    for n in\
    \ l1 {\n        set.insert(n);\n    }\n    let mut v2: Vec<isize> = Vec::new();\n\
    \    for n in l2 {\n        if set.contains(&n) {\n            v2.push(n);\n \
    \       }\n    }\n    v2.sort();\n    v2.dedup();\n    v2\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp5hn60tp9.rs:7:18\n\
    \  |\n7 |     let mut set: HashSet<isize> = HashSet::new();\n  |             \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp5hn60tp9.rs:7:35\n  |\n7 |  \
    \   let mut set: HashSet<isize> = HashSet::new();\n  |                       \
    \            ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut i1 = 0;\n    let mut\
    \ i2 = 0;\n    let mut last_val: isize = 0;\n    let mut sorted_l1 = l1.clone();\n\
    \    let mut sorted_l2 = l2.clone();\n    sorted_l1.sort();\n    sorted_l2.sort();\n\
    \    while i1 < sorted_l1.len() && i2 < sorted_l2.len() {\n        if sorted_l1[i1]\
    \ == sorted_l2[i2] {\n            if sorted_l1[i1] != last_val {\n           \
    \     res.push(sorted_l1[i1]);\n                last_val = sorted_l1[i1];\n  \
    \          }\n            i1 += 1;\n            i2 += 1;\n        } else if sorted_l1[i1]\
    \ < sorted_l2[i2] {\n            i1 += 1;\n        } else {\n            i2 +=\
    \ 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let uniq1 = l1.into_iter().collect::<HashSet<_>>();\n    let\
    \ uniq2 = l2.into_iter().collect::<HashSet<_>>();\n    uniq1.intersection(&uniq2).cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmppea4kpdf.rs:7:42\n\
    \  |\n7 |     let uniq1 = l1.into_iter().collect::<HashSet<_>>();\n  |       \
    \                                   ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmppea4kpdf.rs:8:42\n\
    \  |\n8 |     let uniq2 = l2.into_iter().collect::<HashSet<_>>();\n  |       \
    \                                   ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    for x in l1 {\n        if l2.contains(&x)\
    \ && !result.contains(&x) {\n            result.push(x);\n        }\n    }\n \
    \   result.sort();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common_list: Vec<isize> = Vec::new();\n    for i in\
    \ 0..l1.len() {\n        if let Some(idx) = l2.iter().position(|&x| x == l1[i])\
    \ {\n            common_list.push(l1[i]);\n            common_list.push(l2[idx]);\n\
    \        }\n    }\n    let mut unique_list: Vec<isize> = Vec::new();\n    for\
    \ i in 0..common_list.len() {\n        if let Some(idx) = unique_list.iter().position(|&x|\
    \ x == common_list[i]) {\n            unique_list.remove(idx);\n        } else\
    \ {\n            unique_list.push(common_list[i]);\n        }\n    }\n    unique_list.sort();\n\
    \    unique_list\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp3k3diyma.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1 {\n        if\
    \ l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n   \
    \     }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    for i in 0..l1.len() {\n \
    \       for j in 0..l2.len() {\n            if l1[i] == l2[j] {\n            \
    \    result.push(l1[i]);\n                l2.remove(j);\n                break;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n    let mut\
    \ set2: HashSet<isize> = HashSet::new();\n    let mut result: Vec<isize> = Vec::new();\n\
    \n    for i in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n     \
    \   set2.insert(i);\n    }\n\n    for i in set1.intersection(&set2) {\n      \
    \  result.push(*i);\n    }\n\n    result.sort();\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp6hd33vy5.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp6hd33vy5.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp6hd33vy5.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmp6hd33vy5.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.iter().filter(|e| l2.contains(e)).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut v1_index = 0;\n    let mut v2_index\
    \ = 0;\n    let mut result = Vec::new();\n    while v1_index < v1.len() && v2_index\
    \ < v2.len() {\n        if v1[v1_index] < v2[v2_index] {\n            v1_index\
    \ += 1;\n        } else if v1[v1_index] > v2[v2_index] {\n            v2_index\
    \ += 1;\n        } else {\n            result.push(v1[v1_index]);\n          \
    \  v1_index += 1;\n            v2_index += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut sorted_common = Vec::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ < l2[j] {\n            i += 1;\n        } else if l1[i] > l2[j] {\n        \
    \    j += 1;\n        } else {\n            sorted_common.push(l1[i]);\n     \
    \       i += 1;\n            j += 1;\n        }\n    }\n    sorted_common\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let l1 = l1.into_iter().collect::<HashSet<_>>();\n    let\
    \ l2 = l2.into_iter().collect::<HashSet<_>>();\n    l1.intersection(&l2).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmphj7uyskj.rs:7:39\n\
    \  |\n7 |     let l1 = l1.into_iter().collect::<HashSet<_>>();\n  |          \
    \                             ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n --> /tmp/tmphj7uyskj.rs:8:39\n  |\n\
    8 |     let l2 = l2.into_iter().collect::<HashSet<_>>();\n  |                \
    \                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v = l1.iter().collect::<Vec<&isize>>();\n    v.sort();\n\
    \    v.dedup();\n    let mut v2 = l2.iter().collect::<Vec<&isize>>();\n    v2.sort();\n\
    \    v2.dedup();\n    let mut v3 = Vec::new();\n    for i in v {\n        if v2.contains(i)\
    \ {\n            v3.push(*i);\n        }\n    }\n    v3\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppilf25ll.rs:15:24\n   |\n\
    15 |         if v2.contains(i) {\n   |                        ^ expected `&isize`,\
    \ found `isize`\n   |\n   = note: expected reference `&&isize`\n             \
    \ found reference `&isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let set1: HashSet<isize> = l1.into_iter().collect();\n   \
    \ let set2: HashSet<isize> = l2.into_iter().collect();\n    let intersection:\
    \ HashSet<isize> = set1.intersection(&set2).map(|&x| x).collect();\n    let mut\
    \ result: Vec<isize> = intersection.into_iter().collect();\n    result.sort();\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp54x6fidg.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<isize> = l1.into_iter().collect();\n  |      \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp54x6fidg.rs:8:15\n  |\n8 | \
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n --> /tmp/tmp54x6fidg.rs:9:23\n  |\n9 |     let intersection:\
    \ HashSet<isize> = set1.intersection(&set2).map(|&x| x).collect();\n  |      \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let l1: HashSet<isize> = l1.into_iter().collect();\n    let\
    \ l2: HashSet<isize> = l2.into_iter().collect();\n    let l3: HashSet<isize> =\
    \ l1.intersection(&l2).map(|v| *v).collect();\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpza9q5vmh.rs:7:13\n\
    \  |\n7 |     let l1: HashSet<isize> = l1.into_iter().collect();\n  |        \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpza9q5vmh.rs:8:13\n  |\n8 |     let l2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpza9q5vmh.rs:9:13\n\
    \  |\n9 |     let l3: HashSet<isize> = l1.intersection(&l2).map(|v| *v).collect();\n\
    \  |             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|v| l2.contains(v));\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1_unique: Vec<isize> = l1.into_iter().unique().collect();\n\
    \    let mut l2_unique: Vec<isize> = l2.into_iter().unique().collect();\n    l1_unique.sort();\n\
    \    l2_unique.sort();\n    let mut res: Vec<isize> = Vec::new();\n    let mut\
    \ l1_iter = l1_unique.iter();\n    let mut l2_iter = l2_unique.iter();\n    let\
    \ mut l1_next: isize = match l1_iter.next() {\n        Some(x) => *x,\n      \
    \  None => return res,\n    };\n    let mut l2_next: isize = match l2_iter.next()\
    \ {\n        Some(x) => *x,\n        None => return res,\n    };\n    loop {\n\
    \        match l1_next.cmp(&l2_next) {\n            Ordering::Equal => {\n   \
    \             res.push(l1_next);\n                l1_next = match l1_iter.next()\
    \ {\n                    Some(x) => *x,\n                    None => break,\n\
    \                };\n                l2_next = match l2_iter.next() {\n      \
    \              Some(x) => *x,\n                    None => break,\n          \
    \      };\n            }\n            Ordering::Less => {\n                l1_next\
    \ = match l1_iter.next() {\n                    Some(x) => *x,\n             \
    \       None => break,\n                };\n            }\n            Ordering::Greater\
    \ => {\n                l2_next = match l2_iter.next() {\n                   \
    \ Some(x) => *x,\n                    None => break,\n                };\n   \
    \         }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp1vptkux1.rs:24:13\n   |\n24 |             Ordering::Equal => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp1vptkux1.rs:35:13\n\
    \   |\n35 |             Ordering::Less => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp1vptkux1.rs:41:13\n   |\n41 |             Ordering::Greater\
    \ => {\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `unique` found for struct `std::vec::IntoIter` in the current\
    \ scope\n --> /tmp/tmp1vptkux1.rs:7:52\n  |\n7 |     let mut l1_unique: Vec<isize>\
    \ = l1.into_iter().unique().collect();\n  |                                  \
    \                  ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\n\
    error[E0599]: no method named `unique` found for struct `std::vec::IntoIter` in\
    \ the current scope\n --> /tmp/tmp1vptkux1.rs:8:52\n  |\n8 |     let mut l2_unique:\
    \ Vec<isize> = l2.into_iter().unique().collect();\n  |                       \
    \                             ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut l1_iter = l1.iter();\n\
    \    let mut l2_iter = l2.iter();\n    let mut l1_next = l1_iter.next();\n   \
    \ let mut l2_next = l2_iter.next();\n    while l1_next.is_some() && l2_next.is_some()\
    \ {\n        let mut x = *l1_next.unwrap();\n        let mut y = *l2_next.unwrap();\n\
    \        match x.cmp(&y) {\n            Ordering::Equal => {\n               \
    \ res.push(x);\n                l1_next = l1_iter.next();\n                l2_next\
    \ = l2_iter.next();\n            }\n            Ordering::Less => {\n        \
    \        l1_next = l1_iter.next();\n            }\n            Ordering::Greater\
    \ => {\n                l2_next = l2_iter.next();\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp22o1yelo.rs:16:13\n   |\n16 |             Ordering::Equal => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp22o1yelo.rs:21:13\n\
    \   |\n21 |             Ordering::Less => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp22o1yelo.rs:24:13\n   |\n24 |             Ordering::Greater\
    \ => {\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    let mut d1 = l1.iter().map(|x|\
    \ (*x, 1)).collect::<HashMap<isize, isize>>();\n    let mut d2 = l2.iter().map(|x|\
    \ (*x, 1)).collect::<HashMap<isize, isize>>();\n    for k in d1.keys() {\n   \
    \     if d2.contains_key(k) {\n            result.push(*k);\n        }\n    }\n\
    \    result.sort();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmplndh09dm.rs:8:55\n\
    \  |\n8 |     let mut d1 = l1.iter().map(|x| (*x, 1)).collect::<HashMap<isize,\
    \ isize>>();\n  |                                                       ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashMap;\n  |\n\nerror[E0412]: cannot find type `HashMap`\
    \ in this scope\n --> /tmp/tmplndh09dm.rs:9:55\n  |\n9 |     let mut d2 = l2.iter().map(|x|\
    \ (*x, 1)).collect::<HashMap<isize, isize>>();\n  |                          \
    \                             ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let s1: HashSet<_> = l1.into_iter().collect();\n    let s2:\
    \ HashSet<_> = l2.into_iter().collect();\n    let intersect: HashSet<_> = s1.intersection(&s2).cloned().collect();\n\
    \    let mut v: Vec<isize> = intersect.into_iter().collect();\n    v.sort();\n\
    \    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmphlonuupi.rs:7:13\n\
    \  |\n7 |     let s1: HashSet<_> = l1.into_iter().collect();\n  |            \
    \ ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmphlonuupi.rs:8:13\n  |\n8 |     let s2:\
    \ HashSet<_> = l2.into_iter().collect();\n  |             ^^^^^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmphlonuupi.rs:9:20\n\
    \  |\n9 |     let intersect: HashSet<_> = s1.intersection(&s2).cloned().collect();\n\
    \  |                    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut tmp = [l1, l2];\n \
    \   tmp[0].sort();\n    tmp[1].sort();\n    for i in 0..tmp[0].len() {\n     \
    \   if tmp[0][i] == tmp[1][i] {\n            res.push(tmp[0][i]);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp0wmibrv9.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n\
    \        } else {\n            if res.len() == 0 || res[res.len() - 1] != l1[i]\
    \ {\n                res.push(l1[i]);\n            }\n            i += 1;\n  \
    \          j += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpw42snrkx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut res = Vec::new();\n    for v in l1 {\n        if l2.contains(&v)\
    \ && !res.contains(&v) {\n            res.push(v);\n        }\n    }\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n\
    \    l1.dedup();\n    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n    let mut\
    \ set2: HashSet<isize> = HashSet::new();\n    let mut common_vec: Vec<isize> =\
    \ Vec::new();\n\n    for item in l1 {\n        set1.insert(item);\n    }\n\n \
    \   for item in l2 {\n        set2.insert(item);\n    }\n\n    for item in set1.intersection(&set2)\
    \ {\n        common_vec.push(*item);\n    }\n\n    common_vec.sort();\n    common_vec\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp6x44yvkd.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp6x44yvkd.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp6x44yvkd.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmp6x44yvkd.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.extend(l2.clone());\n   \
    \ l3.sort();\n    l3.dedup();\n    l3.into_iter().filter(|x| l1.contains(x) &&\
    \ l2.contains(x)).collect()\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut l = Vec::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n        if v1[i]\
    \ == v2[j] {\n            l.push(v1[i]);\n            i += 1;\n            j +=\
    \ 1;\n        } else if v1[i] < v2[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let u1 = unique(l1);\n    let u2 = unique(l2);\n    let mut\
    \ result = Vec::new();\n    for u in u1 {\n        if u2.contains(&u) {\n    \
    \        result.push(u);\n        }\n    }\n    result.sort();\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `unique` in this scope\n --> /tmp/tmphyz4x98z.rs:7:14\n\
    \  |\n7 |     let u1 = unique(l1);\n  |              ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `unique` in this scope\n --> /tmp/tmphyz4x98z.rs:8:14\n\
    \  |\n8 |     let u2 = unique(l2);\n  |              ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp55ohtz4o.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let mut l1_i = 0;\n    let mut l2_i\
    \ = 0;\n    let mut res = Vec::new();\n    loop {\n        if l1_i >= l1.len()\
    \ || l2_i >= l2.len() {\n            break;\n        }\n        if l1[l1_i] <\
    \ l2[l2_i] {\n            l1_i += 1;\n        } else if l1[l1_i] > l2[l2_i] {\n\
    \            l2_i += 1;\n        } else {\n            res.push(l1[l1_i]);\n \
    \           l1_i += 1;\n            l2_i += 1;\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n\
    \    list1.sort();\n    list2.sort();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut output = Vec::new();\n    while i < list1.len() && j < list2.len()\
    \ {\n        if list1[i] == list2[j] {\n            output.push(list1[i]);\n \
    \           i += 1;\n            j += 1;\n        } else if list1[i] < list2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    output\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    // iterate over the first list\n\
    \    for i in l1 {\n        // check if list contains i\n        if l2.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut x: Vec<isize> = Vec::new();\n    let mut y: Vec<isize>\
    \ = Vec::new();\n    x.extend(l1);\n    y.extend(l2);\n    let mut v1: Vec<_>\
    \ = x.clone().into_iter().collect();\n    let mut v2: Vec<_> = y.clone().into_iter().collect();\n\
    \    v1.sort();\n    v2.sort();\n    let mut m1: Vec<isize> = Vec::new();\n  \
    \  let mut m2: Vec<isize> = Vec::new();\n    for i in v1.iter() {\n        if\
    \ m1.contains(i) {\n            continue;\n        }\n        m1.push(*i);\n \
    \   }\n    for i in v2.iter() {\n        if m2.contains(i) {\n            continue;\n\
    \        }\n        m2.push(*i);\n    }\n    let mut v3: Vec<isize> = Vec::new();\n\
    \    for i in m1.iter() {\n        if m2.contains(i) {\n            v3.push(*i);\n\
    \        }\n    }\n    v3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    if l1.len() == 0 || l2.len() == 0 {\n        return Vec::new();\n\
    \    }\n    let mut result = Vec::new();\n    for i in 0..l1.len() {\n       \
    \ for j in 0..l2.len() {\n            if l1[i] == l2[j] {\n                result.push(l1[i]);\n\
    \            }\n        }\n    }\n    result.sort();\n    result.dedup();\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut result = Vec::new();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j]\
    \ {\n            result.push(l1[i]);\n            i += 1;\n            j += 1;\n\
    \        } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n  \
    \          j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut set1 = HashSet::new();\n    for i in l1 {\n      \
    \  set1.insert(i);\n    }\n    let mut set2 = HashSet::new();\n    for i in l2\
    \ {\n        set2.insert(i);\n    }\n    let mut intersect: Vec<isize> = vec![];\n\
    \    for i in set1 {\n        if set2.contains(&i) {\n            intersect.push(i);\n\
    \        }\n    }\n    intersect\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp6u1off5m.rs:11:20\n   |\n11 |     let mut set1 = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp6u1off5m.rs:15:20\n\
    \   |\n15 |     let mut set2 = HashSet::new();\n   |                    ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common_elements: Vec<isize> = vec![];\n    for i in\
    \ 0..l1.len() {\n        for j in 0..l2.len() {\n            if l1[i] == l2[j]\
    \ {\n                common_elements.push(l1[i]);\n            }\n        }\n\
    \    }\n    common_elements.sort();\n    common_elements.dedup();\n    common_elements\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.into_iter().filter(|n| l2.contains(n)).collect()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp8mdehc2c.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let m1 = set(l1);\n    let m2 = set(l2);\n    let mut res\
    \ = Vec::new();\n    for key in m1.keys() {\n        if m2.contains_key(key) {\n\
    \            res.push(*key);\n        }\n    }\n    res.sort();\n    res\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `set` in this scope\n --> /tmp/tmpizz5ob9f.rs:7:14\n\
    \  |\n7 |     let m1 = set(l1);\n  |              ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `set` in this scope\n --> /tmp/tmpizz5ob9f.rs:8:14\n\
    \  |\n8 |     let m2 = set(l2);\n  |              ^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut uniques = Vec::new();\n    for i in l1 {\n       \
    \ for j in l2.iter() {\n            if i == *j {\n                uniques.push(i);\n\
    \            }\n        }\n    }\n    uniques.sort();\n    uniques.dedup();\n\
    \    uniques\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpwwkn0vzt.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let (mut l1, mut l2) = (l1.into_iter(), l2.into_iter());\n\
    \    let mut common = Vec::new();\n    let (mut a, mut b) = (l1.next(), l2.next());\n\
    \    while let (Some(a_num), Some(b_num)) = (a, b) {\n        if a_num == b_num\
    \ {\n            common.push(a_num);\n            a = l1.next();\n           \
    \ b = l2.next();\n        } else if a_num < b_num {\n            a = l1.next();\n\
    \        } else {\n            b = l2.next();\n        }\n    }\n    common\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    return intersection(l1, l2);\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `intersection` in this scope\n --> /tmp/tmph19cn5ix.rs:7:12\n\
    \  |\n7 |     return intersection(l1, l2);\n  |            ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut o: Vec<isize> = Vec::new();\n    for &x in l1.iter()\
    \ {\n        for &y in l2.iter() {\n            if x == y {\n                o.push(x);\n\
    \            }\n        }\n    }\n    o.sort();\n    o.dedup();\n    o\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuq0mate8.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    // let set2: HashSet<isize> = l2.into_iter().collect();\n    // let intersect\
    \ = set1.intersection(&set2);\n    // let mut ret = intersect.into_iter().collect::<Vec<&isize>>();\n\
    \    // ret.sort();\n    // ret\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpiay79uns.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let l1 = l1.into_iter().unique();\n    let l2 = l2.into_iter().unique();\n\
    \    let mut result = vec![];\n    for i in l1 {\n        if l2.contains(&i) {\n\
    \            result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpr83ka9tf.rs:11:29\n   |\n11 |     let l1\
    \ = l1.into_iter().unique();\n   |                             ^^^^^^ method not\
    \ found in `std::vec::IntoIter<isize>`\n\nerror[E0599]: no method named `unique`\
    \ found for struct `std::vec::IntoIter` in the current scope\n  --> /tmp/tmpr83ka9tf.rs:12:29\n\
    \   |\n12 |     let l2 = l2.into_iter().unique();\n   |                      \
    \       ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut common_elements: Vec<isize> = Vec::new();\n    let\
    \ mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut prev_elt\
    \ = None;\n    while let (Some(a), Some(b)) = (l1_iter.next(), l2_iter.next())\
    \ {\n        if a == b {\n            common_elements.push(*a);\n            prev_elt\
    \ = Some(*a);\n        } else if a > b {\n            l1_iter = l1.iter().skip_while(|&x|\
    \ x <= b || Some(x) == prev_elt);\n        } else {\n            l2_iter = l2.iter().skip_while(|&x|\
    \ x <= a || Some(x) == prev_elt);\n        }\n    }\n    common_elements\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmw00u7ev.rs:16:70\n   |\n\
    16 |             l1_iter = l1.iter().skip_while(|&x| x <= b || Some(x) == prev_elt);\n\
    \   |                                                                      ^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmw00u7ev.rs:16:23\n   |\n8  |     let mut l1_iter = l1.iter();\n\
    \   |                       --------- expected due to this value\n...\n16 |  \
    \           l1_iter = l1.iter().skip_while(|&x| x <= b || Some(x) == prev_elt);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::slice::Iter`, found struct `SkipWhile`\n   |\n   = note:\
    \ expected struct `std::slice::Iter<'_, _>`\n              found struct `SkipWhile<std::slice::Iter<'_,\
    \ _>, [closure@/tmp/tmpmw00u7ev.rs:16:44: 16:78]>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmw00u7ev.rs:18:70\n   |\n18 |             l2_iter = l2.iter().skip_while(|&x|\
    \ x <= a || Some(x) == prev_elt);\n   |                                      \
    \                                ^^^^^^^^ expected `&isize`, found `isize`\n \
    \  |\n   = note: expected enum `Option<&isize>`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmw00u7ev.rs:18:23\n   |\n9  |\
    \     let mut l2_iter = l2.iter();\n   |                       --------- expected\
    \ due to this value\n...\n18 |             l2_iter = l2.iter().skip_while(|&x|\
    \ x <= a || Some(x) == prev_elt);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::slice::Iter`, found struct `SkipWhile`\n   |\n   = note:\
    \ expected struct `std::slice::Iter<'_, _>`\n              found struct `SkipWhile<std::slice::Iter<'_,\
    \ _>, [closure@/tmp/tmpmw00u7ev.rs:18:44: 18:78]>`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let l1 = l1.into_iter().collect::<BTreeSet<_>>();\n    let\
    \ l2 = l2.into_iter().collect::<BTreeSet<_>>();\n    l1.intersection(&l2).map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpq0gcex52.rs:7:39\n\
    \  |\n7 |     let l1 = l1.into_iter().collect::<BTreeSet<_>>();\n  |         \
    \                              ^^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `BTreeSet` in this scope\n --> /tmp/tmpq0gcex52.rs:8:39\n \
    \ |\n8 |     let l2 = l2.into_iter().collect::<BTreeSet<_>>();\n  |          \
    \                             ^^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut seen = HashSet::new();\n    let mut res = Vec::new();\n\
    \    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    for n in l1.iter() {\n        if seen.contains(n) {\n            continue;\n\
    \        }\n        seen.insert(*n);\n        for m in l2.iter() {\n         \
    \   if n == m {\n                res.push(*n);\n                break;\n     \
    \       }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpe64s4mjt.rs:7:20\n  |\n7 |     let mut seen = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut out = vec![];\n    let mut l1_set = l1.iter().map(|x|\
    \ *x).collect::<HashSet<isize>>();\n    let mut l2_set = l2.iter().map(|x| *x).collect::<HashSet<isize>>();\n\
    \    for n in l1_set.iter() {\n        if l2_set.contains(n) {\n            out.push(*n);\n\
    \        }\n    }\n    return out;\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpidsjdzp1.rs:8:54\n\
    \  |\n8 |     let mut l1_set = l1.iter().map(|x| *x).collect::<HashSet<isize>>();\n\
    \  |                                                      ^^^^^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpidsjdzp1.rs:9:54\n\
    \  |\n9 |     let mut l2_set = l2.iter().map(|x| *x).collect::<HashSet<isize>>();\n\
    \  |                                                      ^^^^^^^ not found in\
    \ this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let s1: BTreeSet<isize> = l1.into_iter().collect();\n    let\
    \ s2: BTreeSet<isize> = l2.into_iter().collect();\n    s1.intersection(&s2).map(|i|\
    \ *i).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmp6q2cuulj.rs:7:13\n\
    \  |\n7 |     let s1: BTreeSet<isize> = l1.into_iter().collect();\n  |       \
    \      ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `BTreeSet` in this scope\n --> /tmp/tmp6q2cuulj.rs:8:13\n  |\n8 |     let s2:\
    \ BTreeSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: implement this function using map-reduce\n    let\
    \ m = l1.iter().map(|&x| x).collect::<HashSet<isize>>();\n    let n = l2.iter().map(|&x|\
    \ x).collect::<HashSet<isize>>();\n    let mut r = m.intersection(&n).map(|&x|\
    \ x).collect::<Vec<isize>>();\n    r.sort();\n    r\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp1putq6lz.rs:8:45\n\
    \  |\n8 |     let m = l1.iter().map(|&x| x).collect::<HashSet<isize>>();\n  |\
    \                                             ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp1putq6lz.rs:9:45\n\
    \  |\n9 |     let n = l2.iter().map(|&x| x).collect::<HashSet<isize>>();\n  |\
    \                                             ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // remove duplicates\n    let l1 = uniq(l1);\n    let l2 =\
    \ uniq(l2);\n\n    let mut a = l1.clone();\n    let mut b = l2.clone();\n\n  \
    \  // sort\n    a.sort();\n    b.sort();\n\n    // merge\n    let mut common =\
    \ Vec::new();\n    let mut j = 0;\n    for i in 0..a.len() {\n        loop {\n\
    \            if j >= b.len() {\n                break;\n            }\n      \
    \      if a[i] == b[j] {\n                common.push(a[i]);\n               \
    \ j += 1;\n                break;\n            } else if a[i] < b[j] {\n     \
    \           break;\n            } else {\n                j += 1;\n          \
    \  }\n        }\n    }\n\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `uniq` in this scope\n --> /tmp/tmp0fk5rmj6.rs:8:14\n\
    \  |\n8 |     let l1 = uniq(l1);\n  |              ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `uniq` in this scope\n --> /tmp/tmp0fk5rmj6.rs:9:14\n\
    \  |\n9 |     let l2 = uniq(l2);\n  |              ^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n \
    \   v1.sort();\n    v2.sort();\n    let mut v: Vec<isize> = Vec::new();\n    let\
    \ mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < v1.len() && i2 < v2.len() {\n\
    \        if v1[i1] == v2[i2] {\n            v.push(v1[i1]);\n            i1 +=\
    \ 1;\n            i2 += 1;\n        } else if v1[i1] < v2[i2] {\n            i1\
    \ += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpmsk6_1zh.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = l1\n        .into_iter()\n        .filter(|x|\
    \ l2.contains(x))\n        .collect::<Vec<isize>>();\n    result.sort();\n   \
    \ result.dedup();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO\n    let mut l3: Vec<isize> = Vec::new();\n    if\
    \ l1.len() >= l2.len() {\n        for i in 0..l1.len() {\n            for j in\
    \ 0..l2.len() {\n                if l1[i] == l2[j] {\n                    l3.push(l1[i]);\n\
    \                }\n            }\n        }\n    } else {\n        for i in 0..l2.len()\
    \ {\n            for j in 0..l1.len() {\n                if l2[i] == l1[j] {\n\
    \                    l3.push(l2[i]);\n                }\n            }\n     \
    \   }\n    }\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp940m4j9w.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut union = l1.clone();\n    union.extend(l2.clone());\n\
    \    union.sort();\n    let mut a = true;\n    let mut uniq = Vec::new();\n  \
    \  for n in union {\n        if a && n == uniq.last().unwrap_or(&0) {\n      \
    \      a = false;\n        } else {\n            uniq.push(n);\n            a\
    \ = true;\n        }\n    }\n    uniq\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp2vb62j_.rs:13:22\n   |\n\
    13 |         if a && n == uniq.last().unwrap_or(&0) {\n   |                  \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&{integer}`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n13 |         if a && n == *uniq.last().unwrap_or(&0)\
    \ {\n   |                      +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpslrcsdq6.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut li = Vec::new();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < l1.len() && j < l2.len() {\n        let v1 = l1[i];\n\
    \        let v2 = l2[j];\n        if v1 == v2 {\n            li.push(v1);\n  \
    \          i += 1;\n            j += 1;\n        } else if v1 < v2 {\n       \
    \     i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    li\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: implement\n    vec![]\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpt3uh4cyl.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n \
    \   l2.sort();\n    let mut out = Vec::new();\n    let mut l1i = 0;\n    let mut\
    \ l2i = 0;\n    loop {\n        if l1i == l1.len() || l2i == l2.len() {\n    \
    \        break;\n        }\n        if l1[l1i] < l2[l2i] {\n            l1i +=\
    \ 1;\n        } else if l1[l1i] > l2[l2i] {\n            l2i += 1;\n        }\
    \ else {\n            out.push(l1[l1i]);\n            l1i += 1;\n            l2i\
    \ += 1;\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxp8818lm.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpauyhb18f.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut r: Vec<isize> = Vec::new();\n    let mut m1: HashMap<isize,\
    \ bool> = HashMap::new();\n    let mut m2: HashMap<isize, bool> = HashMap::new();\n\
    \    for i in l1 {\n        m1.insert(i, true);\n    }\n    for i in l2 {\n  \
    \      m2.insert(i, true);\n    }\n    for i in l1 {\n        if m2.contains_key(&i)\
    \ {\n            r.push(i);\n        }\n    }\n    r.sort();\n    r.dedup();\n\
    \    r\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpx9ilkpty.rs:8:17\n\
    \  |\n8 |     let mut m1: HashMap<isize, bool> = HashMap::new();\n  |        \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpx9ilkpty.rs:8:40\n\
    \  |\n8 |     let mut m1: HashMap<isize, bool> = HashMap::new();\n  |        \
    \                                ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n --> /tmp/tmpx9ilkpty.rs:9:17\n  |\n\
    9 |     let mut m2: HashMap<isize, bool> = HashMap::new();\n  |              \
    \   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n --> /tmp/tmpx9ilkpty.rs:9:40\n  |\n9 |  \
    \   let mut m2: HashMap<isize, bool> = HashMap::new();\n  |                  \
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmps26j1gx3.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l: Vec<isize> = l1\n        .iter()\n        .filter(|&e|\
    \ l2.contains(e))\n        .map(|&e| e)\n        .collect();\n    l.sort();\n\
    \    l.dedup();\n    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = vec![];\n    for i in l1 {\n        if l2.contains(&i)\
    \ && !result.contains(&i) {\n            result.push(i);\n        }\n    }\n \
    \   result.sort();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut result = Vec::new();\n    for i in l1 {\n        if\
    \ l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n   \
    \     }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    fn uniq<T: Eq + Copy>(l: Vec<T>) -> Vec<T> {\n        let\
    \ mut out = Vec::new();\n        for i in l {\n            if !out.contains(&i)\
    \ {\n                out.push(i);\n            }\n        }\n        out\n   \
    \ }\n\n    fn sort<T: Ord + Copy>(l: Vec<T>) -> Vec<T> {\n        let mut out\
    \ = l.clone();\n        out.sort();\n        out\n    }\n\n    sort(uniq(l1.iter().filter(|&x|\
    \ l2.contains(x)).map(|&x| x).collect()))\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut ret = Vec::new();\n    for elem in l1 {\n        if\
    \ l2.contains(&elem) && !ret.contains(&elem) {\n            ret.push(elem);\n\
    \        }\n    }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    // TODO: Write code here\n    return Vec::new();\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpvxtyptma.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
    \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) ->\
    \ Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n\
    \    let mut ret = Vec::new();\n    loop {\n        if i1 == l1.len() || i2 ==\
    \ l2.len() {\n            break;\n        }\n        if l1[i1] < l2[i2] {\n  \
    \          i1 += 1;\n        } else if l1[i1] > l2[i2] {\n            i2 += 1;\n\
    \        } else {\n            ret.push(l1[i1]);\n            i1 += 1;\n     \
    \       i2 += 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
