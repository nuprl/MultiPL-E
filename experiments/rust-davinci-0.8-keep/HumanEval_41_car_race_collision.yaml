name: HumanEval_41_car_race_collision
language: rust
prompt: "/// Imagine a road that's a perfectly straight infinitely long line.\n///\
  \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
  /// are driving right to left.   The two sets of cars start out being very far from\n\
  /// each other.  All cars move in the same speed.  Two cars are said to collide\n\
  /// when a car that's moving left to right hits a car that's moving right to left.\n\
  /// However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n/// in their trajectory as if they did not collide.\n/// This function\
  \ outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
  \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n   \
  \ assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
completions: ["    let mut collisions = 0;\n    let mut nl = n;\n    let mut nr =\
    \ n;\n    let mut i = 0;\n    let mut j = 0;\n    let mut il = -1;\n    let mut\
    \ ir = -1;\n    let mut jl = -1;\n    let mut jr = -1;\n    let mut x: isize;\n\
    \    let mut y: isize;\n    let mut temp: isize;\n    let mut zero: isize = 0;\n\
    \    loop {\n        if nl == zero {\n            break;\n        }\n        temp\
    \ = il;\n        il = i;\n        i = temp;\n        temp = jl;\n        jl =\
    \ j;\n        j = temp;\n        j = j + 1;\n        y = i - j;\n        x = j\
    \ - il;\n        if x > y {\n            collisions = collisions + 1;\n      \
    \  }\n        nl = nl - 1;\n    }\n    loop {\n        if nr == zero {\n     \
    \       break;\n        }\n        temp = ir;\n        ir = i;\n        i = temp;\n\
    \        temp = jr;\n        jr = j;\n        j = temp;\n        j = j + 1;\n\
    \        y = i - j;\n        x = j - ir;\n        if x > y {\n            collisions\
    \ = collisions + 1;\n        }\n        nr = nr - 1;\n    }\n    collisions",
  "    if n == 0 {\n        return 0;\n    }\n    let mut total = 0;\n    for car_index\
    \ in 0..n {\n        // how many cars does this car collide with\n        let\
    \ cars_collided = n - car_index - 1;\n        total += cars_collided;\n    }\n\
    \    total", "    let mut i = 0;\n    let mut j = n - 1;\n    let mut result =\
    \ 0;\n    while i < j {\n        if i < j {\n            i += 1;\n           \
    \ result += 1;\n        }\n        if i < j {\n            j -= 1;\n         \
    \   result += 1;\n        }\n    }\n    result", '    (1..n).fold(0, |sum, i|
    sum + i * (n - i))', "    let mut x = n - 1;\n    for i in 0..n {\n        x +=\
    \ i;\n    }\n    x", "    // TODO\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut count = 0;\n    while i < n {\n        let mut k = 0;\n        while\
    \ k < n {\n            if k == j {\n                j = j + 1;\n             \
    \   count = count + 1;\n            }\n            k = k + 1;\n        }\n   \
    \     i = i + 1;\n    }\n    count", "    let mut num_collisions = 0;\n    let\
    \ mut left_to_right = Vec::with_capacity(n as usize);\n    let mut right_to_left\
    \ = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            num_collisions += 1;\n\
    \        } else {\n            right_to_left.remove(0);\n        }\n    }\n  \
    \  num_collisions", '    unimplemented!()', '    0', "    if n < 1 {\n       \
    \ return 0;\n    }\n    car_race_collision(n - 1) + n - 1", '    n * (n - 1) /
    2', "    let mut a = vec![0; n as usize];\n    let mut b = vec![0; n as usize];\n\
    \    let mut count = 0;\n    for i in 0..n {\n        a[i as usize] = 2 * i;\n\
    \        b[i as usize] = 2 * i - 1;\n    }\n    for &i in a.iter() {\n       \
    \ for &j in b.iter() {\n            if i == j {\n                count += 1;\n\
    \            }\n        }\n    }\n    count", "    // TODO: implement this function\n\
    \    let mut out = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if i > j {\n                out += 1;\n            }\n        }\n    }\n\
    \    out", "    let mut count = 0;\n    for i in 1..n {\n        for j in 1..n\
    \ {\n            if (i * j) % n == 0 {\n                count += 1;\n        \
    \    }\n        }\n    }\n    count", '    unimplemented!();', "    let mut ans\
    \ = 0;\n    let mut cars = vec![0; 2 * n as usize];\n    for i in 0..n {\n   \
    \     cars[i as usize] = i;\n    }\n    for i in n..2 * n {\n        cars[i as\
    \ usize] = 2 * n - i - 1;\n    }\n    cars.sort();\n    for i in 0..2 * n {\n\
    \        if cars[i as usize] == i {\n            ans += 1;\n        }\n    }\n\
    \    ans", '    car_race_collision_helper(n, n)', "    println!(\"n={}\", n);\n\
    \    if n <= 0 {\n        return 0;\n    }\n\n    let mut ans = 0;\n    for i\
    \ in 1..n {\n        let l: isize = (i - 1) * (n - i);\n        if l < 0 {\n \
    \           panic!(\"l < 0\");\n        }\n        ans += l;\n    }\n    ans *\
    \ 2", "    let mut count = 0;\n    let mut left_to_right = vec![false; n as usize];\n\
    \    let mut right_to_left = vec![false; n as usize];\n    // generate the left\
    \ to right array\n    for i in 0..n {\n        left_to_right[i as usize] = true;\n\
    \        count += rtl_collision(&left_to_right, &right_to_left);\n    }\n    //\
    \ generate the right to left array\n    for i in 0..n {\n        right_to_left[i\
    \ as usize] = true;\n        count += ltr_collision(&left_to_right, &right_to_left);\n\
    \    }\n    count", "    // 1. car_race_collision(n) = car_race_collision(n-1)\
    \ + n - 1\n    // 2. car_race_collision(1) = 0\n    if n == 1 {\n        return\
    \ 0;\n    }\n    car_race_collision(n - 1) + n - 1", '    car_race_collision_helper(n,
    0)', "    let mut cars = vec![0; 2 * n as usize];\n    let mut cars2 = vec![0;\
    \ 2 * n as usize];\n    for i in 0..n {\n        cars[i as usize] = i;\n     \
    \   cars2[i as usize] = -i;\n    }\n    mergesort_cars(&mut cars2, &mut cars);\n\
    \    return car_race_collision_helper(&mut cars, &mut cars2, 0, n) as isize;",
  '    0', "    let mut car_right_to_left = Vec::with_capacity(n as usize);\n    let\
    \ mut car_left_to_right = Vec::with_capacity(n as usize);\n    for _ in 0..n {\n\
    \        car_right_to_left.push(Position::new(5, -100));\n        car_left_to_right.push(Position::new(5,\
    \ 100));\n    }\n    for t in 0..100 {\n        let mut i = 0;\n        for car\
    \ in car_right_to_left.iter_mut() {\n            car.x += 1;\n            car.y\
    \ += 1;\n            let j = i;\n            let other_car = &mut car_left_to_right[j];\n\
    \            if car.y == other_car.y {\n                car.y += 1;\n        \
    \        other_car.y -= 1;\n            }\n            i += 1;\n        }\n  \
    \      let mut i = 0;\n        for car in car_left_to_right.iter_mut() {\n   \
    \         car.x += 1;\n            car.y -= 1;\n            let j = i;\n     \
    \       let other_car = &mut car_right_to_left[j];\n            if car.y == other_car.y\
    \ {\n                car.y -= 1;\n                other_car.y += 1;\n        \
    \    }\n            i += 1;\n        }\n    }\n    let mut collisions = 0;\n \
    \   for (car1, car2) in car_right_to_left.iter().zip(car_left_to_right.iter())\
    \ {\n        if car1.y == car2.y {\n            collisions += 1;\n        }\n\
    \    }\n    collisions", "    // TODO\n    0", "    // We can model a car's position\
    \ as an integer that moves left or right at unit\n    // speed.  A car driving\
    \ from left to right has a positive position, and a car\n    // driving from right\
    \ to left has a negative position.\n    // Thus, a car from left to right has\
    \ position x, and a car from right to left\n    // has position -x.\n    // A\
    \ collision happens when two cars have the same position.\n    // Since the two\
    \ sets of cars start out being very far from each other,\n    // every collision\
    \ occurs when a car from left to right drives across\n    // a car from right\
    \ to left.\n    // The question of counting the number of collisions is equivalent\
    \ to\n    // the question of counting the number of negative integers.\n    //\
    \ Thus, there are n collisions.\n    n", '    n * (n - 1) / 2', "    // No collision\
    \ is possible when there is only 1 car in each direction\n    if n <= 1 {\n  \
    \      return 0;\n    }\n\n    // Think of each of these cars as being a '1' in\
    \ a binary number.\n    // So for example, the first car in the left direction\
    \ is a '1',\n    // the second car is a '10', the third car is a '100', etc.\n\
    \    // Then sum up all these binary numbers together.  The lowest bit\n    //\
    \ will be the number of collisions involving the first car in the\n    // left\
    \ direction and the first car in the right direction.\n    // The second lowest\
    \ bit will be the number of collisions involving\n    // the first car in the\
    \ left direction and the second car in the\n    // right direction.  And so on.\n\
    \    // Specifically, return the lowest log2(n) bits of sum, where\n    // n is\
    \ the total number of cars.\n    let mut sum = 0;\n    for i in 0..n {\n     \
    \   sum += 1 << i;\n    }\n    sum & ((1 << (n as usize)) - 1)", "    let mut\
    \ count: isize = 0;\n    let mut i: isize = 1;\n    while i <= n {\n        count\
    \ += i;\n        i += 1;\n    }\n    count", "    // Write your code here\n  \
    \  0", "    if n < 2 {\n        return 0;\n    }\n    let mut sum = 1;\n    let\
    \ mut k = 1;\n    while k < n - 1 {\n        sum += k;\n        k += 1;\n    }\n\
    \    return sum;", "    if n == 0 {\n        0\n    } else {\n        let mut\
    \ i = 1;\n        let mut prev = 0;\n        let mut curr = 1;\n        while\
    \ i < n {\n            let temp = curr;\n            curr = prev + curr;\n   \
    \         prev = temp;\n            i += 1;\n        }\n        n * (n - 1) /\
    \ 2 - curr\n    }", "    let mut left_car_positions = HashSet::new();\n    let\
    \ mut right_car_positions = HashSet::new();\n    for i in 0..n {\n        let\
    \ pos = i * 2;\n        left_car_positions.insert(pos);\n        right_car_positions.insert(-pos);\n\
    \    }\n    let mut current_positions = HashSet::new();\n    let mut collisions\
    \ = 0;\n    for car_pos in left_car_positions.iter() {\n        current_positions.insert(*car_pos);\n\
    \        if current_positions.contains(&(*car_pos + 1)) {\n            collisions\
    \ += 1;\n        }\n    }\n    for car_pos in right_car_positions.iter() {\n \
    \       current_positions.insert(*car_pos);\n        if current_positions.contains(&(*car_pos\
    \ - 1)) {\n            collisions += 1;\n        }\n    }\n    collisions", " \
    \   if n < 1 {\n        return 0;\n    }\n    // cars n - 1 ... 0 are moving left\
    \ to right.\n    // cars n - 1 ... 0 are moving right to left.\n    // a car n\
    \ - 1 is at position n - 1.\n    // a car n - 2 is at position 2 * n - 2.\n  \
    \  // a car n - 3 is at position 3 * n - 3.\n    // ...\n    // car 0 is at position\
    \ n * n - n.\n    let mut cur = n;\n    let mut res = 0;\n    for i in (0..n).rev()\
    \ {\n        if cur > i {\n            res += cur - i;\n        }\n        cur\
    \ += i;\n    }\n    res", "    let mut count: isize = 0;\n    let mut right_to_left:\
    \ Vec<bool> = vec![false; n as usize];\n    let mut left_to_right: Vec<bool> =\
    \ vec![false; n as usize];\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if !left_to_right[i as usize] && !right_to_left[j as usize] {\n    \
    \            count += 1;\n                left_to_right[i as usize] = true;\n\
    \                right_to_left[j as usize] = true;\n            }\n        }\n\
    \    }\n    count", "    use std::cmp::{min, max};\n    if n <= 1 {\n        return\
    \ 0;\n    }\n    // Let's say we have n cars driving right to left, with velocity\n\
    \    // vec![v_0, v_1, ..., v_n-1].\n    // We want to count the number of collisions\
    \ with the cars that are\n    // driving left to right (which are of the form\
    \ [1, 2, ..., n]).\n    // Since these cars can only move in the positive direction,\
    \ if two cars\n    // collide, we must have (for some i and j) that v_i >= j and\
    \ v_j >= i.\n    // We can visualize this as a bunch of cells.\n    // We'll have\
    \ n rows and n columns, of form\n    // [ v_0  v_1  v_2  ...  v_n-1 ]\n    //\
    \ [ 1    2    3    ...  n     ]\n    // [ 2    3    4    ...  n+1   ]\n    //\
    \ [ ...                 ...   ]\n    // [ n    n+1  n+2  ...  2n-1  ]\n    //\
    \ We'll be interested in the number of cells with v_i >= j, so we want to know\n\
    \    // how many cells are above the lower-right to upper-left diagonal.\n   \
    \ // We can count this by doing the following.  For each row, we'll keep track\
    \ of\n    // how many elements are on or above the lower-right to upper-left diagonal,\
    \ and\n    // how many are below the diagonal.  Then, the number of elements above\
    \ the diagonal\n    // in each row is (n - num_below_diagonal).  So we can sum\
    \ up those numbers and multiply\n    // by 2 (since we want to count each collision\
    \ twice) to get the total number of collisions.\n    let mut num_above_diagonal\
    \ = 0;\n    let mut num_below_diagonal = 0;\n    for i in 0..n {\n        let\
    \ v_i = n - i;\n        for j in 0..n {\n            let v_j = n - j;\n      \
    \      if v_i >= v_j {\n                num_above_diagonal += 1;\n           \
    \ } else {\n", "    // TODO: actually implement this function.\n    0", '    car_race_collision_recursive(n,
    0)', '    (1..n).map(|i| i * (n - i)).sum()', "    // TODO implement this function\n\
    \n    n - n + 1", "    // As the cars move, this represents the segment of the\
    \ road that\n    // has no cars in it.  The cars are represented by this line\
    \ segment\n    // shrinking to zero size.  As the line segment shrinks to zero,\
    \ it is\n    // essentially representing the collision of two cars.\n    let mut\
    \ no_car_segment = n;\n\n    // This function essentially represents the left\
    \ side of the road that\n    // consists of moving cars.  It essentially represents\
    \ the left side of\n    // the line segment representing no cars in the road.\n\
    \    // It essentially represents the shrinking of the line segment representing\n\
    \    // no cars in the road.\n    fn helper(no_car_segment: isize) -> isize {\n\
    \        if no_car_segment == 0 {\n            return 0;\n        }\n\n      \
    \  // In this case, the line segment is too big to shrink.  So we\n        //\
    \ have to partition it into two smaller line segments and pass them\n        //\
    \ to two recursive calls.\n        if no_car_segment >= 2 {\n            let left_no_car_segment\
    \ = no_car_segment / 2;\n            let right_no_car_segment = no_car_segment\
    \ - left_no_car_segment;\n            return helper(left_no_car_segment) + helper(right_no_car_segment);\n\
    \        }\n\n        // In this case, the line segment cannot be partitioned\
    \ into two smaller\n        // line segments; so we must have a collision in the\
    \ road.\n        // The cars are infinitely strong and sturdy, so they do not\
    \ stop.\n        // They just continue going; so we have to account for the collision.\n\
    \        1\n    }\n\n    // Kick off the recursion.\n    helper(no_car_segment)",
  "    let mut position_right_to_left = HashSet::new();\n    let mut position_left_to_right\
    \ = HashSet::new();\n    let mut collides = 0;\n    for i in 0..n {\n        position_right_to_left.insert(i\
    \ as isize);\n        position_left_to_right.insert(n - i - 1);\n    }\n    let\
    \ mut index_right_to_left = 0;\n    let mut index_left_to_right = 0;\n    let\
    \ mut direction_right_to_left = 1;\n    let mut direction_left_to_right = -1;\n\
    \    loop {\n        // Cars moving right to left\n        if position_right_to_left.contains(&index_right_to_left)\
    \ {\n            // In case the car is moving right to left\n            if position_left_to_right.contains(&index_right_to_left)\
    \ {\n                collides += 1;\n            }\n            index_right_to_left\
    \ += direction_right_to_left;\n            if index_right_to_left >= n {\n   \
    \             direction_right_to_left = -1;\n                index_right_to_left\
    \ = n - 1;\n            } else if index_right_to_left < 0 {\n                direction_right_to_left\
    \ = 1;\n                index_right_to_left = 0;\n            }\n        } else\
    \ {\n            index_right_to_left += direction_right_to_left;\n           \
    \ if index_right_to_left >= n {\n                direction_right_to_left = -1;\n\
    \                index_right_to_left = n - 1;\n            } else if index_right_to_left\
    \ < 0 {\n                direction_right_to_left = 1;\n                index_right_to_left\
    \ = 0;\n            }\n        }\n        // Cars moving left to right\n     \
    \   if position_left_to_right.contains(&index_left_to_right) {\n            //\
    \ In case the car is moving left to right\n            if position_right_to_left.contains(&index_left_to_right)\
    \ {\n                collides += 1;\n            }\n", "    //\n    // Note that\
    \ the number of collisions is equal to the number of pairs\n    // in which the\
    \ first car comes before the second car, considering the order in which\n    //\
    \ the cars start the race.\n    //\n    // So, the number of such collisions is\
    \ equal to:\n    //\n    // n*(n-1)/2,\n    //\n    // but you can't compute it\
    \ by multiplying, because then you overflow.\n    //\n    // Instead, you can\
    \ compute it by adding:\n    //\n    // 0 + 1 + 2 + 3 + ... + (n-1)\n    //\n\
    \    // Using the following trick.\n    //\n    // In fact,\n    //\n    // 0\
    \ + 1 + 2 + 3 + ... + (n-1) =\n    // (n-1) + (n-2) + (n-3) + ... + 0\n    //\n\
    \    // (in other words, the sum of the numbers from 0 to n-1 is equal to the\n\
    \    // sum of the numbers from n-1 to 0)\n    //\n    // This is because the\
    \ sum from 0 to n-1 adds up everything\n    // and then adds n-1 to the result;\
    \ the sum from n-1 to 0 adds up everything\n    // and then adds 0 to the result.\n\
    \    //\n    // So, you can use this fact to implement the function without overflowing.\n\
    \    //\n    // The first and last numbers are the same.  The second and second\
    \ to last\n    // numbers are the same.  The third and third to last numbers are\
    \ the same.\n    // The fourth and fourth to last numbers are the same.\n    //\n\
    \    // The next number after the last number is the one right before the first\
    \ number.\n    //\n    // In other words,\n    //\n    //     1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10\n    // 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10\n    //     10 +\
    \ 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1\n    // -----------------------------------------\n\
    \    //     2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2\n    //     11 + 11 + 11", '    (1..n+1).map(|x|
    (n-x+1)*x).sum()', "    let mut left: Vec<isize> = Vec::new();\n    let mut right:\
    \ Vec<isize> = Vec::new();\n    for i in 0..n {\n        left.push(i);\n     \
    \   right.push(n - i - 1);\n    }\n    left.sort();\n    right.sort();\n    merge_sort_collision(&mut\
    \ left, &mut right)", "    let mut left = HashSet::new();\n    let mut right =\
    \ HashSet::new();\n    for i in 0..n {\n        left.insert(i);\n        right.insert(n\
    \ + i);\n    }\n    let mut collisions = 0;\n    while left.len() > 0 && right.len()\
    \ > 0 {\n        let mut s: HashSet<isize> = HashSet::new();\n        for i in\
    \ &left {\n            if right.contains(i) {\n                collisions += 1;\n\
    \            } else {\n                s.insert(*i);\n            }\n        }\n\
    \        left = s;\n        let mut s: HashSet<isize> = HashSet::new();\n    \
    \    for i in &right {\n            if left.contains(i) {\n                collisions\
    \ += 1;\n            } else {\n                s.insert(*i);\n            }\n\
    \        }\n        right = s;\n    }\n    collisions", "    let mut answer =\
    \ 0;\n    let mut right_to_left_cars = vec![];\n    for i in 0..n {\n        let\
    \ mut collisions = 0;\n        // if there's a collision, then there cannot be\
    \ a collision with a car\n        // that hasn't arrived yet.  We do not consider\
    \ such cars; they will be\n        // handled by the next iteration.\n       \
    \ while let Some(index) = right_to_left_cars.pop() {\n            if index > i\
    \ {\n                right_to_left_cars.push(index);\n                break;\n\
    \            }\n            collisions += 1;\n        }\n        answer += collisions;\n\
    \        right_to_left_cars.push(n - i - 1);\n    }\n    answer", "    // We can\
    \ do better than O(n^2), because the cars never change their speed.\n    // As\
    \ a result, the left to right car that enters from the left meets the\n    //\
    \ right to left car that enters from the right at a specific moment in time.\n\
    \    // This means that we don't need to track the cars' positions at every moment\n\
    \    // in time.  We only need to track the number of cars that entered at each\
    \ point in time.\n    // The cars never change their speed, so the number of cars\
    \ that entered at each moment in time\n    // stays constant.\n    // We will\
    \ track the number of cars that enter at each moment in time as a hash table.\n\
    \    // The key is the time a car enters, and the value is the number of cars\
    \ that entered at that time.\n    // Initially, the hash table will be empty.\n\
    \    let mut cars_entering_at_time = HashMap::new();\n    // Let's first initialize\
    \ the map for the cars entering from the left.\n    for x in 0..n {\n        //\
    \ Cars entering from the left will enter at time x, since it takes x time for\
    \ a car that\n        // started from the left to reach the intersection.\n  \
    \      let number_of_cars_entering_at_time = cars_entering_at_time.entry(x).or_insert(0);\n\
    \        *number_of_cars_entering_at_time += 1;\n    }\n    // Now we'll initialize\
    \ the map for the cars entering from the right.\n    for x in 0..n {\n       \
    \ // Cars entering from the right will enter at time -x, since it takes x time\
    \ for a car that\n        // started from the right to reach the intersection.\n\
    \        let number_of_cars_entering_at_time = cars_entering_at_time.entry(-x).or_insert(0);\n\
    \        *number_of_cars_entering_at_time += 1;\n    }\n    // So now we have\
    \ a hash table that maps each time a car enters to the number of cars that enter\n\
    \    // at that time.  Now we'll iterate over the hash table, and for each time,\
    \ we'll compute the\n    // number of cars that enter from the opposite direction\
    \ at that time, and", "    let mut left = vec![0; n as usize];\n    let mut right\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left[i as usize] = 2 *\
    \ i;\n        right[i as usize] = 2 * i + 1;\n    }\n    let mut res = 0;\n  \
    \  for pos in left {\n        for pos2 in right.iter() {\n            if pos2\
    \ <= &pos {\n                res += 1;\n            }\n        }\n    }\n    res",
  "    // No cars on the road so no collisions\n    if n == 0 {\n        return 0;\n\
    \    }\n\n    // There is one car on the road.  It must collide with itself.\n\
    \    if n == 1 {\n        return 1;\n    }\n\n    // There are two cars on the\
    \ road.  One is moving left, the other right.\n    // They each start out 10 miles\
    \ away from each other and move at 40 miles\n    // per hour.  Do they collide?\n\
    \    //\n    // We can find out how much time has elapsed since the cars started\
    \ moving\n    // by using the formula:\n    //\n    //      distance = speed *\
    \ time\n    //\n    // Solving for time, we get\n    //\n    //      time = distance\
    \ / speed\n    //\n    // In this case, we want to know how much time elapses\
    \ when two cars that\n    // start out 10 miles apart from each other and move\
    \ at 40 miles per hour\n    // travel in opposite directions.  It takes 0.25 hours,\
    \ or 15 minutes.\n    //\n    // It helps to look at this problem in terms of\
    \ a graph of the cars'\n    // movements.  Imagine a graph where the x-axis represents\
    \ miles and the\n    // y-axis represents time.  The cars start out at (10, 0)\
    \ and (0, 0).\n    // They travel in opposite directions at the same speed, so\
    \ we can plot\n    // the location of the cars every 15 minutes.\n    //\n   \
    \ //      After 15 minutes  (0, 15)     (10, 15)\n    //      After 30 minutes\
    \  (-10, 30)   (20, 30)\n    //      After 45 minutes  (-20, 45)   (30, 45)\n\
    \    //      After 60 minutes  (-30, 60)   (40, 60)\n    //\n    // We see that\
    \ the cars collide at the point (0, 30).  Since the x-axis\n    // represents\
    \ miles, the cars collide at mile 0.\n    //\n    // Let's try with three cars.\
    \  One car starts out at 10 miles, goes left,\n    // and travels at 40 miles\
    \ per hour.  The other two cars start out at 0 miles\n    // and travel at 30\
    \ miles per hour.  Do they collide?\n   ", '    (1..n + 1).sum()', "    // While\
    \ the list of moving left to right cars and the list of moving right to left cars\n\
    \    // are both non-empty, this program compares the leftmost moving left to\
    \ right car and\n    // the rightmost moving right to left car.  If their positions\
    \ intersect, we get a\n    // collision.\n    let mut left_to_right_cars = Vec::new();\n\
    \    for i in 0..n {\n        left_to_right_cars.push(i);\n    }\n    let mut\
    \ right_to_left_cars = Vec::new();\n    for i in 0..n {\n        right_to_left_cars.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right_cars.is_empty()\
    \ && !right_to_left_cars.is_empty() {\n        if left_to_right_cars[0] == right_to_left_cars[right_to_left_cars.len()\
    \ - 1] {\n            collisions += 1;\n        }\n        right_to_left_cars.pop();\n\
    \        left_to_right_cars.remove(0);\n    }\n    collisions", "    // The maximal\
    \ number of cars that can\n    // potentially collide is the first n cars on the\n\
    \    // left plus the first n cars on the right.\n    // There's no potential\
    \ collision between cars that\n    // are further than that, since they would\
    \ be too far away.\n    (1..=n).sum::<isize>()", "    let mut left_to_right: Vec<isize>\
    \ = (0..n).collect();\n    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] > right_to_left[0] {\n            collisions\
    \ += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else {\n            left_to_right.remove(0);\n        }\n    }\n  \
    \  collisions", "    let mut res = 0;\n    for i in 1..n + 1 {\n        for j\
    \ in 1..n + 1 {\n            if i < j {\n                res += 1;\n         \
    \   }\n        }\n    }\n    res", "    if n <= 0 {\n        return 0;\n    }\n\
    \    // Arrange the cars on a number line.\n    // Imagine two integers on the\
    \ number line, and imagine another line\n    // that is shifted one unit to the\
    \ right of the first line, and the integers\n    // on the second line are shifted\
    \ by one unit to the right of the first line.\n    // Start with the cars on the\
    \ right line.  For the next n iterations,\n    // move the integers on the right\
    \ line to the left line and vise versa.\n    // I'm using a single vector and\
    \ will use modular arithmetic.\n    let mut v = Vec::with_capacity(n as usize);\n\
    \    for i in 0..n {\n        v.push(i);\n    }\n    // We will flip the cars\
    \ at position i to position i+1.\n    let mut is_right_line = true;\n    let mut\
    \ num_collisions = 0;\n    for i in 0..n {\n        if is_right_line {\n     \
    \       if v[i as usize] == i + 1 {\n                num_collisions += 1;\n  \
    \          }\n            v[i as usize] = i + 1;\n        } else {\n         \
    \   if v[i as usize] == i {\n                num_collisions += 1;\n          \
    \  }\n            v[i as usize] = i;\n        }\n        is_right_line = !is_right_line;\n\
    \    }\n    num_collisions", "    // Note that all cars move in the same speed.\n\
    \    // For example, let's consider the following case:\n    //\n    //      \
    \   Left-to-right cars:   [4, 7, 9, 11, 20]\n    //         Right-to-left cars:\
    \   [6, 8, 15, 24, 25]\n    //\n    // Notice that we can immediately conclude\
    \ that:\n    //    - Any left-to-right car behind 20 will never collide.\n   \
    \ //    - Any right-to-left car behind 25 will never collide.\n    //    - Any\
    \ left-to-right car before 4 will never collide.\n    //    - Any right-to-left\
    \ car before 6 will never collide.\n    //\n    // Given this observation, we\
    \ can design the following algorithm:\n    //      - Let's say we have two pointers,\
    \ one for left-to-right cars,\n    //        and one for right-to-left cars.\n\
    \    //      - We can move the left-to-right car pointer from left to right, and\n\
    \    //        similarly move the right-to-left car pointer from right to left.\n\
    \    //      - As soon as we found a pair of cars whose positions are within each\
    \ other's\n    //        starting position, we know that they will collide.\n\
    \    //\n    // For example, in the above case, we would first check 4 and 25,\n\
    \    // and then 7 and 24, and so on.\n    //\n    // Therefore, the overall algorithmic\
    \ complexity is O(n).\n    // Note that this is a fairly simple problem, but it's\
    \ a good opportunity to introduce\n    // a few important concepts:\n    //\n\
    \    //      - Merge-sort-like algorithms.\n    //      - Finding \"largest-n\"\
    \ and \"smallest-n\" in a given array.\n    //      - Checking for collisions.\n\
    \    //\n    //     This problem also provides the following important lessons:\n\
    \    //\n    //      - In the above solution, the algorithm can be broken down\
    \ into a series of\n    //        smaller sub-problems.\n    //      - We can\
    \ use a pair of pointers to solve these sub-problems.\n    //      - The above\
    \ solution can be generalized to solve much more complex problems.\n    //\n \
    \   // If", "    // let mut left_cars = Vec::with_capacity(n as usize);\n    //\
    \ let mut right_cars = Vec::with_capacity(n as usize);\n    // for _ in 0..n {\n\
    \    //     left_cars.push(0);\n    //     right_cars.push(0);\n    // }\n   \
    \ // for i in 0..n {\n    //     left_cars[i as usize] = i;\n    //     right_cars[i\
    \ as usize] = n - i - 1;\n    // }\n    let mut cars: Vec<isize> = Vec::with_capacity(n\
    \ as usize);\n    for i in 0..n {\n        cars.push(i);\n    }\n    let mut left_cars\
    \ = cars.clone();\n    let mut right_cars = cars.clone();\n    left_cars.sort();\n\
    \    right_cars.sort();\n    let mut collisions = 0;\n    let mut left_index =\
    \ 0;\n    let mut right_index = n - 1;\n    while left_index < n && right_index\
    \ >= 0 {\n        if left_cars[left_index as usize] < right_cars[right_index as\
    \ usize] {\n            left_index += 1;\n        } else if left_cars[left_index\
    \ as usize] > right_cars[right_index as usize] {\n            right_index -= 1;\n\
    \        } else {\n            collisions += 1;\n            left_index += 1;\n\
    \            right_index -= 1;\n        }\n    }\n    collisions", "    //\n \
    \   // The first car from the left will collide with the nth car from the right.\n\
    \    // The second car from the left will collide with the (n-1)th car from the\
    \ right.\n    // And so on.\n    //\n    (n*(n-1))/2", "    // Each car (moving\
    \ left to right) enters the scene at a different time t.\n    // The cars (moving\
    \ right to left) all enter at the same time t=0.\n    // We are asked to count\
    \ the number of collisions.\n    // Since collisions happen one at a time, we\
    \ can find the time of the\n    // first collision (i.e. the smallest t), then\
    \ compute the number of\n    // collisions by counting the number of cars that\
    \ have not yet entered\n    // the scene.\n\n    // Find the time of the first\
    \ collision.\n    let mut first_collision_time = isize::max_value();\n    for\
    \ i in 0..n {\n        let t = 2 * i + 2;\n        first_collision_time = first_collision_time.min(t);\n\
    \    }\n\n    // Count the number of cars that have not yet entered the scene\n\
    \    // at the time of the first collision.\n    n - first_collision_time / 2",
  "    let mut count = 0;\n    let mut cars = vec![0; n as usize];\n    let mut cars_rev\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        cars[i as usize] = i +\
    \ 1;\n        cars_rev[i as usize] = n - i;\n    }\n    let mut index = 0;\n \
    \   while index < n {\n        let car = cars[index as usize];\n        let car_rev\
    \ = cars_rev[index as usize];\n        if car_rev > car {\n            count +=\
    \ car_rev - car;\n        }\n        index += 1;\n    }\n    count", "    let\
    \ mut res = 0;\n    if n > 1 {\n        res = n * (n - 1) / 2;\n    }\n    res",
  "    if n <= 1 {\n        return 0;\n    }\n\n    let mut left_to_right: Vec<bool>\
    \ = Vec::new();\n    for _ in 0..n {\n        left_to_right.push(true);\n    }\n\
    \n    let mut right_to_left: Vec<bool> = Vec::new();\n    for _ in 0..n {\n  \
    \      right_to_left.push(false);\n    }\n\n    let mut sum: isize = 0;\n    while\
    \ left_to_right.len() > 0 && right_to_left.len() > 0 {\n        let front_left_to_right:\
    \ usize = left_to_right.remove(0);\n        let front_right_to_left: usize = right_to_left.remove(0);\n\
    \n        if front_left_to_right == front_right_to_left {\n            sum +=\
    \ 1;\n        }\n    }\n\n    sum", "    let mut total = 0;\n    for i in 1..n\
    \ + 1 {\n        total += i;\n    }\n    total", "    let mut count = 0;\n   \
    \ let n = n as usize;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if i != j {\n                if (i < j && j - i < n) || (i > j && i - j >=\
    \ n) {\n                    count += 1;\n                }\n            }\n  \
    \      }\n    }\n    count", "    let mut num_collisions = 0;\n    for car_1 in\
    \ 0..n {\n        for car_2 in 0..n {\n            if car_1 > car_2 {\n      \
    \          num_collisions += 1;\n            }\n        }\n    }\n    num_collisions",
  "    if n < 2 {\n        return 0;\n    }\n    let (mut left_to_right, mut right_to_left)\
    \ = (vec![true; n as usize], vec![false; n as usize]);\n    let mut time = 0;\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() || !right_to_left.is_empty()\
    \ {\n        let mut pos_to_car_idx: HashMap<isize, usize> = HashMap::new();\n\
    \        let mut new_left_to_right = vec![];\n        let mut new_right_to_left\
    \ = vec![];\n        for (idx, &direction) in left_to_right.iter().enumerate()\
    \ {\n            let pos = (time - idx as isize) * 2;\n            if let Some(&other_idx)\
    \ = pos_to_car_idx.get(&pos) {\n                collisions += 1;\n           \
    \     if pos_to_car_idx.get(&(pos + 1)).is_none() {\n                    new_left_to_right.push(direction);\n\
    \                }\n                if pos_to_car_idx.get(&(pos - 1)).is_none()\
    \ {\n                    new_right_to_left.push(!direction);\n               \
    \ }\n            } else {\n                pos_to_car_idx.insert(pos, idx);\n\
    \                new_left_to_right.push(direction);\n            }\n        }\n\
    \        left_to_right = new_left_to_right;\n        for (idx, &direction) in\
    \ right_to_left.iter().enumerate() {\n            let pos = (time - idx as isize)\
    \ * 2;\n            if let Some(&other_idx) = pos_to_car_idx.get(&pos) {\n   \
    \             collisions += 1;\n                if pos_to_car_idx.get(&(pos +\
    \ 1)).is_none() {\n                    new_left_to_right.push(direction);\n  \
    \              }\n                if pos_to_car_idx.get(&(pos - 1)).is_none()\
    \ {\n", "    if n == 0 {\n        0\n    } else {\n        n - 1 + car_race_collision(n\
    \ - 1)\n    }", "    let mut result = 0;\n    for i in 1..n {\n        for j in\
    \ i + 1..n + 1 {\n            result += i * j;\n        }\n    }\n    result",
  "    // You can use this function to find the square root of a number.\n    (1..n).fold(0,\
    \ |acc, i| acc + (i * (n - i)))", "    // TODO: Write your code here.\n    isize::min(n,\
    \ 0)", "    let mut c = n;\n    let mut cnt = 0;\n    while c != 0 {\n       \
    \ c -= 1;\n        let mut z = n;\n        while z != 0 {\n            z -= 1;\n\
    \            cnt += 1;\n        }\n    }\n    cnt", "    let mut c = 0;\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if i < j {\n             \
    \   c += 1;\n            }\n        }\n    }\n    c", '    n * (n - 1) / 2', " \
    \   ///  A simulation of a car race on an infinite road.  All cars move at the\
    \ same speed.\n    ///  Both left and right cars are spawned immediately at the\
    \ start.\n    struct CarRace {\n        left_cars: Vec<isize>,\n        right_cars:\
    \ Vec<isize>,\n    }\n\n    impl CarRace {\n        fn new(n: isize) -> CarRace\
    \ {\n            let mut left_cars = Vec::new();\n            let mut right_cars\
    \ = Vec::new();\n            for i in 0..n {\n                left_cars.push(i);\n\
    \                right_cars.push(i);\n            }\n            CarRace {\n \
    \               left_cars,\n                right_cars,\n            }\n     \
    \   }\n\n        /// Simulate one time step of the race.\n        /// Assume that\
    \ a car can never leave the road.\n        /// We return the number of cars that\
    \ collided at this time step.\n        fn step(&mut self) -> isize {\n       \
    \     let mut nb_collisions = 0;\n            // The cars whose position already\
    \ has been checked; we have already\n            // detected that they did not\
    \ collide with any other car.\n            let mut checked_left_cars = BTreeSet::new();\n\
    \            let mut checked_right_cars = BTreeSet::new();\n            for i\
    \ in 0..self.left_cars.len() {\n                if !checked_left_cars.contains(&i)\
    \ {\n                    for j in 0..self.right_cars.len() {\n               \
    \         if !checked_right_cars.contains(&j) {\n                            if\
    \ self.left_cars[i] == self.right_cars[j] {\n                                nb_collisions\
    \ += 1;\n                                checked_left_cars.insert(i);\n      \
    \                          checked_right_cars.insert(j);\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n            }\n            // Advance the cars.\n            for i in 0..self.left_cars.len()\
    \ {\n                self.left_cars[i] += 1;\n            }\n            for i\
    \ in 0..self.right_cars.len() {\n                self.right_cars[i] -= 1;\n  \
    \          }\n            nb_", "    let mut counter = 0;\n    for i in 0..n {\n\
    \        for j in (i + 1)..n {\n            counter += 1;\n        }\n    }\n\
    \    counter", '    n - n / 2', "    let mut cars = vec![0; n as usize];\n   \
    \ let mut cars2 = vec![0; n as usize];\n    let mut pos = 0;\n    let mut pos2\
    \ = n - 1;\n    let mut collisions = 0;\n    while pos < n {\n        cars[pos\
    \ as usize] = 1;\n        cars2[pos2 as usize] = 1;\n        if cars[pos as usize]\
    \ == 1 && cars2[pos as usize] == 1 {\n            collisions += 1;\n        }\n\
    \        pos += 1;\n        pos2 -= 1;\n    }\n    collisions", "    let mut array_left:\
    \ Vec<bool> = vec![false; n as usize];\n    let mut array_right: Vec<bool> = vec![false;\
    \ n as usize];\n    let mut collisions = 0;\n    for i in 0..n {\n        if array_left[i\
    \ as usize] {\n            collisions += 1;\n        }\n        array_left[i as\
    \ usize] = true;\n        if array_right[(n - i - 1) as usize] {\n           \
    \ collisions += 1;\n        }\n        array_right[(n - i - 1) as usize] = true;\n\
    \    }\n    collisions", "    if n < 1 {\n        return 0;\n    }\n    n * (n\
    \ - 1) / 2", "    // TODO:  Complete the function\n    // Suggestion:  Use a priority\
    \ queue to solve this in O(n lg n) time\n    // Your code must pass compile! \
    \ Running it is optional\n    0", "    let mut cars: Vec<(isize, isize)> = Vec::new();\n\
    \    for k in 0..n {\n        cars.push((-k, -k));\n        cars.push((k, k));\n\
    \    }\n    let mut collide = 0;\n    for i in 0..2 * n {\n        for j in i\
    \ + 1..2 * n {\n            if (cars[i].0 > cars[j].0 && cars[i].1 < cars[j].1)\
    \ ||\n               (cars[i].0 < cars[j].0 && cars[i].1 > cars[j].1) {\n    \
    \            collide += 1;\n            }\n        }\n    }\n    collide", '    n
    * (n - 1) / 2', "    let (mut right_to_left, mut left_to_right) = (0, 0);\n  \
    \  for i in 0..n {\n        if i % 2 == 0 {\n            left_to_right += 1;\n\
    \        } else {\n            right_to_left += 1;\n        }\n    }\n    if left_to_right\
    \ > right_to_left {\n        left_to_right - right_to_left\n    } else {\n   \
    \     right_to_left - left_to_right\n    }", "    // Yikes, this is not the best\
    \ use case of isize\n    if n < 0 { return 0 }\n    // This should have been an\
    \ enum\n    let mut colliding = (1..n + 1).fold(0, |acc, x| acc + 2 * x - 1);\n\
    \    let mut pair = 2;\n    while pair < n {\n        let max_1 = pair * (pair\
    \ + 1) / 2;\n        let max_2 = pair * (pair - 1) / 2;\n        if colliding\
    \ >= max_1 {\n            colliding -= max_1\n        } else if colliding >= max_2\
    \ {\n            colliding -= max_2\n        } else {\n            colliding =\
    \ 0\n        }\n        pair += 1;\n    }\n    colliding", '    unimplemented!();',
  '    car_race_collision_helper(n, n, 0)', "    let mut fname = \"foo\".to_string();\n\
    \    let mut writer = BufWriter::new(File::create(&fname).unwrap());\n    let\
    \ mut cars_left: HashMap<u64, u64> = HashMap::new();\n    let mut cars_right:\
    \ HashMap<u64, u64> = HashMap::new();\n    let mut races: u64 = 0;\n    let mut\
    \ total_cars = n as u64;\n    while n > 0 {\n        let l: u64 = (total_cars\
    \ as f64 * rand::random::<f64>()) as u64;\n        let r: u64 = (total_cars as\
    \ f64 * rand::random::<f64>()) as u64;\n        if l == r {\n            continue;\n\
    \        }\n        if cars_left.contains_key(&l) || cars_right.contains_key(&r)\
    \ {\n            continue;\n        }\n        cars_left.insert(l, r);\n     \
    \   cars_right.insert(r, l);\n        races += 1;\n        n -= 1;\n    }\n  \
    \  for (left, right) in cars_left {\n        writeln!(writer, \"{} {}\", left,\
    \ right).unwrap();\n    }\n    fname = \"bar\".to_string();\n    let mut writer\
    \ = BufWriter::new(File::create(&fname).unwrap());\n    for (right, left) in cars_right\
    \ {\n        writeln!(writer, \"{} {}\", right, left).unwrap();\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    for (_, right)\
    \ in cars_left {\n        let mut a = cars_right.clone();\n        let mut j =\
    \ 0;\n        let mut b = a.values().enumerate().skip(i + 1);\n        for (_,\
    \ left) in b {\n            if left == &right {\n                collisions +=\
    \ 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    collisions", "    // Given an array of cars\n    // Initialize an empty array\
    \ of collisions\n    // For each car in the cars array\n    //   For each car\
    \ in the collisions array\n    //     If their velocities are opposite\n    //\
    \       Add the cars to the collisions array\n    // Return the collisions array\n\
    \    let mut cars = vec![vec![0; 2]; n as usize];\n    for i in 0..n {\n     \
    \   cars[i as usize][0] = i;\n        cars[i as usize][1] = 1;\n    }\n    for\
    \ i in 0..n {\n        cars[i as usize][0] = -i;\n        cars[i as usize][1]\
    \ = -1;\n    }\n    let mut collisions = vec![vec![0; 2]; n as usize];\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if cars[i as usize][1] * cars[j\
    \ as usize][1] == -1 {\n                collisions[i as usize][0] = i;\n     \
    \           collisions[i as usize][1] = j;\n            }\n        }\n    }\n\
    \    collisions.len() as isize", "    let mut right_to_left = vec![0; n as usize];\n\
    \    let mut left_to_right = vec![0; n as usize];\n    for i in 0..n {\n     \
    \   right_to_left[i as usize] = n + i;\n        left_to_right[i as usize] = i\
    \ - n;\n    }\n    car_race_collision_internal(n, &mut right_to_left, &mut left_to_right)",
  '    0', "    let mut count = 0;\n    for i in 1..n + 1 {\n        count += n -\
    \ i + 1;\n    }\n    count", "    let mut num_collisions = 0;\n    let mut left:\
    \ Vec<isize> = (0..n).map(|i| i).collect();\n    let mut right: Vec<isize> = (0..n).map(|i|\
    \ -i).collect();\n    let mut both = left.clone();\n    both.append(&mut right);\n\
    \    both.sort();\n    for i in 0..n {\n        let mut l = 0;\n        let mut\
    \ r = 0;\n        for j in i..2 * n {\n            if both[j] < 0 {\n        \
    \        r += 1;\n            } else {\n                l += 1;\n            }\n\
    \            if l == r {\n                num_collisions += 1;\n            }\n\
    \        }\n    }\n    num_collisions", "    // car_race_collision(1000) == 499500\n\
    \    // car_race_collision(10000) == 4999_9500\n    // car_race_collision(1_000_000)\
    \ == 499_995_000\n    // car_race_collision(10_000_000) == 4999_995_000\n    let\
    \ mut count = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ i < j {\n                count += 1;\n            }\n        }\n    }\n    count",
  "    let mut left_cars: Vec<isize> = (0..n).collect();\n    let mut right_cars:\
    \ Vec<isize> = (0..n).collect();\n    left_cars.sort();\n    right_cars.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut num_collisions = 0;\n   \
    \ while i < n && j < n {\n        if left_cars[i] <= right_cars[j] {\n       \
    \     num_collisions += j;\n            i += 1;\n        } else {\n          \
    \  j += 1;\n        }\n    }\n    num_collisions += j * (n - i);\n    num_collisions",
  '    0', "    if n < 1 {\n        return 0;\n    }\n    n - 1", "    if n == 0 {\n\
    \        0\n    } else {\n        car_race_collision(n - 1) + n - 1\n    }", " \
    \   // e.g.  5  2\n    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n\
    \        return 1;\n    }\n    let mut ret = 0;\n    for i in 1..=n {\n      \
    \  // 1\n        let left_to_right_cars = n - i;\n        // (6 - 1) / 2\n   \
    \     let right_to_left_cars = n - left_to_right_cars;\n        // (5 - 1) / 2\n\
    \        let right_to_left_passed_cars = i - 1;\n        // (5 + 2 - 1) / 2\n\
    \        ret += left_to_right_cars * right_to_left_cars - right_to_left_passed_cars;\n\
    \    }\n    ret", "    let mut car_left_to_right: Vec<isize> = Vec::new();\n \
    \   let mut car_right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n\
    \        car_left_to_right.push(i);\n        car_right_to_left.push(n-i-1);\n\
    \    }\n    println!(\"{:?}\", car_left_to_right);\n    println!(\"{:?}\", car_right_to_left);\n\
    \    let mut collision = 0;\n    while car_left_to_right.len() > 0 && car_right_to_left.len()\
    \ > 0 {\n        if car_left_to_right[0] > car_right_to_left[0] {\n          \
    \  car_right_to_left.remove(0);\n            collision += 1;\n        } else {\n\
    \            car_left_to_right.remove(0);\n        }\n    }\n    collision", " \
    \   assert!(n >= 0);\n    let mut result = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            result += (i - j).abs();\n        }\n    }\n    result",
  "    let mut cars_right_to_left = vec![0; n as usize];\n    let mut cars_left_to_right\
    \ = vec![0; n as usize];\n    let mut count: isize = 0;\n    for i in 0..n {\n\
    \        cars_right_to_left[i as usize] = n - i;\n        cars_left_to_right[i\
    \ as usize] = n - i;\n    }\n    let mut index_right_to_left = 0;\n    let mut\
    \ index_left_to_right = 0;\n    while index_right_to_left < n && index_left_to_right\
    \ < n {\n        if cars_right_to_left[index_right_to_left as usize] == cars_left_to_right[index_left_to_right\
    \ as usize] {\n            count += 1;\n            index_right_to_left += 1;\n\
    \            index_left_to_right += 1;\n        } else if cars_right_to_left[index_right_to_left\
    \ as usize] < cars_left_to_right[index_left_to_right as usize] {\n           \
    \ index_right_to_left += 1;\n        } else {\n            index_left_to_right\
    \ += 1;\n        }\n    }\n    count", "    // Ok, so I'm not sure what I'm supposed\
    \ to do here.  Is this asking me to simulate each car\n    // moving left to right\
    \ and right to left, and see how long each car takes to reach the\n    // other\
    \ end?  In that case I can do it but it seems a bit convoluted and not a particularly\n\
    \    // good use of time.  Are there better algorithms for this?\n    // This\
    \ one is a bit clearer: https://stackoverflow.com/questions/31106936/interview-question-scheduling-of-cars\n\
    \    let mut n_collisions = 0;\n    for c1 in 0..n {\n        for c2 in (c1 +\
    \ 1)..n {\n            if c1 < n - c2 {\n                n_collisions += 1;\n\
    \            }\n        }\n    }\n    n_collisions", "    let mut pairs: Vec<(isize,\
    \ isize)> = vec![];\n    for i in 0..n {\n        pairs.push((i, i));\n    }\n\
    \    pairs.iter().fold(0, |acc, pair| acc + car_pair_collision(pair.0, pair.1))",
  "    // using an algorithm that does not require sorting the\n    // array of starting\
    \ positions.\n    let mut cars_l_to_r: Vec<isize> = (0..n).collect();\n    let\
    \ mut cars_r_to_l: Vec<isize> = (0..n).rev().collect();\n    let mut x_count:\
    \ isize = 0;\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    while\
    \ i < n as usize && j < n as usize {\n        if cars_l_to_r[i] < cars_r_to_l[j]\
    \ {\n            x_count += j as isize;\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    x_count += j as isize * (n - i as\
    \ isize);\n    x_count", "    let mut i = 0;\n    let mut j = n - 1;\n    let\
    \ mut collision = 0;\n    while i < n && j >= 0 {\n        if i == j {\n     \
    \       collision += 1;\n        } else {\n            collision += 2;\n     \
    \   }\n        i += 1;\n        j -= 1;\n    }\n    collision", "    let mut left_cars\
    \ = (0..n).collect::<Vec<isize>>();\n    let mut right_cars = (0..n).rev().collect::<Vec<isize>>();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ n && j < n {\n        if left_cars[i] > right_cars[j] {\n            count +=\
    \ n - i - 1;\n            j += 1;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    count", "    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut total_collisions = 0;\n    while i < n && j <\
    \ n {\n        if left_to_right[i] == right_to_left[j] {\n            total_collisions\
    \ += 1;\n            i += 1;\n            j += 1;\n        } else if left_to_right[i]\
    \ < right_to_left[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    total_collisions", "    let left_moving_cars = (0..n).map(|x|\
    \ x as f64 + 0.5).collect::<Vec<f64>>();\n    let right_moving_cars = (0..n).map(|x|\
    \ -x as f64 - 0.5).collect::<Vec<f64>>();\n    let mut initial_state = HashMap::new();\n\
    \    for car in left_moving_cars {\n        initial_state.insert(car, 1.0);\n\
    \    }\n    for car in right_moving_cars {\n        initial_state.insert(car,\
    \ -1.0);\n    }\n    let collisions = simulate_traffic(0.1, &initial_state);\n\
    \    collisions.len() as isize", "    if n < 2 {\n        0\n    } else {\n  \
    \      // The intersection point between (i, 0) and (0, j) is ((j+i)/(i+j), (j+i)/(i+j))\n\
    \        let mut count = 0;\n        for i in 1..n {\n            for j in 1..n\
    \ {\n                if j + i > 0 && (j + i) % (i + j) == 0 {\n              \
    \      count += 1;\n                }\n            }\n        }\n        count\n\
    \    }", "    let mut left = 0;\n    let mut right = 0;\n    let mut num_collisions\
    \ = 0;\n    while left < n && right < n {\n        if left == right {\n      \
    \      num_collisions += 1;\n        }\n        left += 1;\n        right += 1;\n\
    \    }\n    num_collisions", "    let mut r = 0;\n    for i in 1..n + 1 {\n  \
    \      r += i * (n - i);\n    }\n    r", "    let mut collisions = 0;\n    //\
    \ TODO\n    collisions", "    let mut pos = [0; 2 * MAX_N as usize];\n    let\
    \ mut car = [0; 2 * MAX_N as usize];\n    let mut sorted_pos = [0; 2 * MAX_N as\
    \ usize];\n    let mut dp = [false; MAX_N as usize];\n    let mut dq = [false;\
    \ MAX_N as usize];\n    for i in 0..n {\n        let (mut p, mut d) = (0, 0);\n\
    \        read_two::<isize>(&mut p, &mut d);\n        if d == 1 {\n           \
    \ pos[i as usize] = p;\n            car[i as usize] = true;\n        } else {\n\
    \            pos[i as usize] = -p;\n            car[i as usize] = false;\n   \
    \     }\n        sorted_pos[i as usize] = pos[i as usize];\n    }\n    sorted_pos[n\
    \ as usize..].clone_from_slice(&pos[0..n as usize]);\n    sorted_pos.sort();\n\
    \    let mut ans = 0;\n    for i in 0..n {\n        if car[i as usize] {\n   \
    \         let p = pos[i as usize];\n            dp[i as usize] = true;\n     \
    \       let mut l = 0;\n            let mut r = n;\n            while r - l >\
    \ 1 {\n                let med = (l + r) / 2;\n                if sorted_pos[med\
    \ as usize] >= p {\n                    r = med;\n                } else {\n \
    \                   l = med;\n                }\n            }\n            ans\
    \ += n - r;\n        } else {\n            let p = pos[i as usize];\n        \
    \    dq[i as usize] = true;\n            let mut l = 0;\n            let mut r\
    \ = n;\n            while r - l > 1 {\n                let med = (l + r) / 2;\n\
    \                if sorted_pos[med as usize] > p {\n                    r = med;\n\
    \                } else {\n                    l = med;\n                }\n \
    \           }\n            ans += n - r;\n        }\n    }\n", '    0', "    let\
    \ mut cars_left = n.to_string();\n    let mut cars_right = n.to_string();\n  \
    \  let mut collision = 0;\n    while cars_left.len() > 0 && cars_right.len() >\
    \ 0 {\n        let left_pos = cars_left.pop().unwrap().to_digit(10).unwrap() as\
    \ isize;\n        let right_pos = cars_right.pop().unwrap().to_digit(10).unwrap()\
    \ as isize;\n        if left_pos == right_pos {\n            collision += 1;\n\
    \        }\n    }\n    collision", "    let mut num = 0;\n    for i in 0..n {\n\
    \        for j in 0..n {\n            num += 1;\n        }\n    }\n    num", " \
    \   if n < 2 {\n        return 0;\n    }\n    return car_race_collision(n - 1)\
    \ + n - 1;", "    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<_> = (0..n).map(|i| (i, false)).collect();\n    let mut right_to_left: Vec<_>\
    \ = (0..n).map(|i| (i, false)).collect();\n    let mut collisions = 0;\n    for\
    \ i in (0..n).rev() {\n        let l = left_to_right[i].0;\n        if !left_to_right[i].1\
    \ {\n            let r = right_to_left[l].0;\n            if !right_to_left[l].1\
    \ {\n                collisions += 1;\n                left_to_right[i].1 = true;\n\
    \                right_to_left[l].1 = true;\n                left_to_right[r].1\
    \ = true;\n                right_to_left[i].1 = true;\n            }\n       \
    \ }\n    }\n    collisions", "    // This solution is inspired by the answer from\
    \ the book.\n    // The book's solution is O(n) time complexity.\n    // This\
    \ solution has O(1) time complexity.\n\n    // Let n be the number of cars driving\
    \ from left to right.\n    // There are 2n cars in total.\n    // Assume the left\
    \ cars are labeled from 0 to n-1.\n    // Assume the right cars are labeled from\
    \ n to 2n-1.\n    // The car labeled x is moving left to right if x < n.\n   \
    \ // The car labeled x is moving right to left if x >= n.\n    // Because the\
    \ cars are infinitely strong, they continue moving in their\n    // trajectory\
    \ as if they did not collide.  As a result, no collision occurs.\n    // \n  \
    \  // Consider the following setup with n = 4.\n    // \n    //              \
    \         +----+\n    //                       |    |\n    //                \
    \       |    |\n    //                       |    |\n    //                  \
    \     |    |\n    //                       |    |\n    //                    \
    \   |    |\n    //                       |    |\n    //                      \
    \ |    |\n    //                       |    |\n    //                       |\
    \    |\n    //                       |    |\n    //                       |  \
    \  |\n    //                       |    |\n    // +----+  +----+  +----+ |   \
    \ |  +----+  +----+  +----+\n    // |    |  |    |  |    | |    |  |    |  | \
    \   |  |    |\n    // | 3  |  | 2  |  | 1  | | 0  |  | 7  |  | 6  |  | 5  |\n\
    \    // | <--|--| <--|--| <--|-| -->|--| <--|--| <--|--| <--|\n    // +----+ \
    \ +----+  +----+ |    |  +----+  +----+  +----+\n    //                      \
    \ |    |\n    //                       |    |\n    //                       |\
    \    |\n    //                       |    |\n    //                       |  \
    \  |\n    //                       |    |\n    //                       |    |\n\
    \    //                       |    |\n    //                       |    |", " \
    \   if n == 0 {\n        return 0;\n    }\n\n    let mut s = 0;\n    let mut l\
    \ = 0;\n    for i in 1..n + 1 {\n        s += i;\n        l += n - i + 1;\n  \
    \  }\n\n    s - l", "    let mut count: isize = 0;\n    let mut r = (1..=n)\n\
    \        .rev()\n        .zip(0..n)\n        .map(|(i, j)| {\n            if i\
    \ <= j {\n                count += 1;\n            }\n            count\n    \
    \    })\n        .collect::<Vec<isize>>();\n    println!(\"{:?}\", r);\n    count",
  "    if n < 1 {\n        return 0;\n    }\n    // TODO - you fill in here.\n   \
    \ 0", "    let mut collisions = 0;\n    let mut cars_left_to_right = Vec::with_capacity(n\
    \ as usize);\n    let mut cars_right_to_left = Vec::with_capacity(n as usize);\n\
    \    for i in 0..n {\n        cars_left_to_right.push(Car { x: i, y: n - i });\n\
    \        cars_right_to_left.push(Car { x: n - i, y: i });\n    }\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if cars_left_to_right[i as usize].y\
    \ <= cars_right_to_left[j as usize].y {\n                collisions += 1;\n  \
    \          }\n        }\n    }\n    collisions", "    let mut ctr: isize = 0;\n\
    \    if n > 0 {\n        // the \"cars\" are the numbers between 1 and n inclusive\n\
    \        let left_cars: Vec<isize> = (1..=n).collect();\n        let right_cars:\
    \ Vec<isize> = (1..=n).rev().collect();\n        // so we need a variable to store\
    \ the \"position\" of each car as it moves\n        let mut pos: Vec<isize> =\
    \ Vec::new();\n        for car in left_cars {\n            // each car starts\
    \ at 1 mile\n            pos.push(1);\n        }\n        for _ in 1..20 {\n \
    \           for (i, car) in left_cars.iter().enumerate() {\n                //\
    \ if car is at the middle of the road and is moving to the right,\n          \
    \      // it may collide with a car moving to the left\n                if pos[i]\
    \ == 0 && right_cars.contains(car) {\n                    ctr += 1;\n        \
    \        }\n                // the car advances one mile\n                pos[i]\
    \ += 1;\n            }\n            for (i, car) in right_cars.iter().enumerate()\
    \ {\n                // if car is at the middle of the road and is moving to the\
    \ left,\n                // it may collide with a car moving to the right\n  \
    \              if pos[i] == 0 && left_cars.contains(car) {\n                 \
    \   ctr += 1;\n                }\n                // the car advances one mile\n\
    \                pos[i] -= 1;\n            }\n        }\n    }\n    ctr", '    car_race_collision_recursive(n,
    0)', "    // We sort both groups of cars based on their starting location, and\
    \ then we iterate\n    // over both groups.  For every car that we meet coming\
    \ from the left, we add a number\n    // to our total based on how many cars we've\
    \ met coming from the right that are to the\n    // left of it.\n    //\n    //\
    \ For the first case, the right group of cars are sorted so that the closest car\n\
    \    // is at the end of the array.  We loop through the left group and always\
    \ add zero\n    // since there's no cars we've seen coming from the right.\n \
    \   //\n    // For the second case, the right group of cars are sorted in the\
    \ same way as the\n    // left group.  However, since every car is to the left\
    \ of the current car, we add\n    // n - i (the number of cars we've seen to the\
    \ left).\n    //\n    // To deal with negative numbers, we can just take their\
    \ absolute value and\n    // add that to the total.\n    //\n    // T(n) = O(n\
    \ log n)\n    let mut left_cars: Vec<isize> = vec![0; n as usize];\n    let mut\
    \ right_cars: Vec<isize> = vec![0; n as usize];\n    for i in 0..n {\n       \
    \ left_cars[i as usize] = i;\n        right_cars[(n - i - 1) as usize] = -i;\n\
    \    }\n    left_cars.sort();\n    right_cars.sort();\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        let mut j = 0;\n        while right_cars[j\
    \ as usize] < left_cars[i as usize] {\n            j += 1;\n        }\n      \
    \  collisions += n - i - j;\n    }\n    collisions", '    unimplemented!();',
  "    if n == 0 {\n        return 0;\n    }\n    let mut moving_right = (0..n).collect::<Vec<isize>>();\n\
    \    let mut moving_left = (0..n).rev().collect::<Vec<isize>>();\n    let mut\
    \ collision_count = 0;\n    for _ in 0..n {\n        for x in &mut moving_right\
    \ {\n            *x += 1;\n        }\n        for x in &mut moving_left {\n  \
    \          *x -= 1;\n        }\n        collision_count += moving_right.iter().filter(|&x|\
    \ moving_left.contains(x)).count() as isize;\n    }\n    collision_count", " \
    \   let mut count = 0;\n    let mut left_car = 1;\n    let mut right_car = n;\n\
    \    while left_car <= n {\n        if left_car == right_car {\n            count\
    \ += 1;\n        }\n        left_car += 1;\n        right_car -= 1;\n    }\n \
    \   count", "    let mut collisions = 0;\n    let mut left = 0;\n    let mut right\
    \ = n - 1;\n    while left < right {\n        collisions += left * (n - right);\n\
    \        left += 1;\n        right -= 1;\n    }\n    collisions", '    n * (n
    - 1) / 2', "    if n == 0 {\n        0\n    } else {\n        car_race_collision(n\
    \ - 1) + n - 1\n    }", "    let mut coll = 0;\n    let mut k = 0;\n    while\
    \ k < n {\n        k += 1;\n        coll += n - k;\n    }\n    coll", "    if\
    \ n <= 0 {\n        return 0;\n    }\n    n * (n - 1) / 2", "    let mut cars_l2r\
    \ = Vec::new();\n    let mut cars_r2l = Vec::new();\n    let mut col_count = 0;\n\
    \    for _ in 0..n {\n        cars_l2r.push(rand::random::<isize>());\n      \
    \  cars_r2l.push(rand::random::<isize>());\n    }\n    cars_l2r.sort();\n    cars_r2l.sort();\n\
    \    let mut car_r2l_idx = n - 1;\n    for i in 0..n {\n        while car_r2l_idx\
    \ >= 0 && cars_l2r[i as usize] >= cars_r2l[car_r2l_idx as usize] {\n         \
    \   car_r2l_idx -= 1;\n        }\n        col_count += n - car_r2l_idx - 1;\n\
    \    }\n    col_count", "    if n == 0 {\n        return 0;\n    }\n    let m\
    \ = (n as f64).log2() as isize;\n    let mut s = 0;\n    for i in 0..m + 1 {\n\
    \        let p = (1 << i) - 1;\n        s += (n / (1 << (i + 1))) * p;\n     \
    \   s += max(0, n % (1 << (i + 1)) - (1 << i));\n    }\n    s", "    let mut cars:\
    \ HashMap<f64, Vec<bool>> = HashMap::new();\n\n    let mut curr_position = -100000.0;\n\
    \    while curr_position < 100000.0 {\n        let left_to_right_cars = cars.entry(curr_position).or_insert(vec![]);\n\
    \        left_to_right_cars.push(true);\n        curr_position += 10.0;\n    }\n\
    \n    let mut curr_position = 100000.0;\n    while curr_position > -100000.0 {\n\
    \        let right_to_left_cars = cars.entry(curr_position).or_insert(vec![]);\n\
    \        right_to_left_cars.push(false);\n        curr_position -= 10.0;\n   \
    \ }\n\n    let mut curr_position = -100000.0;\n    let mut num_collisions = 0;\n\
    \    while curr_position < 100000.0 {\n        let car_set = cars.get(&curr_position).unwrap();\n\
    \        for car in car_set {\n            if !car {\n                num_collisions\
    \ += 1;\n            }\n        }\n        curr_position += 10.0;\n    }\n\n \
    \   num_collisions", '    n.pow(2)', "    let mut cars_from_left = Vec::with_capacity(n\
    \ as usize);\n    let mut cars_from_right = Vec::with_capacity(n as usize);\n\
    \    for i in 0..n {\n        cars_from_left.push(i);\n        cars_from_right.push(n\
    \ - i - 1);\n    }\n    let mut collision_count = 0;\n    let mut i = 0;\n   \
    \ let mut j = 0;\n    while i < n && j < n {\n        if cars_from_left[i as usize]\
    \ < cars_from_right[j as usize] {\n            collision_count += j;\n       \
    \     i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    collision_count",
  "    if n <= 0 {\n        return 0;\n    }\n    let mut first_to_last: Vec<isize>\
    \ = Vec::new();\n    let mut last_to_first: Vec<isize> = Vec::new();\n    for\
    \ i in 0..n {\n        first_to_last.push(i);\n        last_to_first.push(n -\
    \ i - 1);\n    }\n    car_race_collision_help(n, first_to_last, last_to_first)",
  '    ((n as f64).log2() as isize) + 1', "    if n == 0 {\n        return 0;\n  \
    \  }\n    let car_race_collision_n = |n: isize| -> isize {\n        // 2*i is\
    \ a car moving left to right\n        // 2*i + 1 is a car moving right to left\n\
    \        (0..n)\n            .map(|i| 2 * i)\n            .flat_map(|i| {\n  \
    \              (0..n)\n                    .map(|j| 2 * j + 1)\n             \
    \       .map(move |j| (i, j))\n                    .filter(move |&(i, j)| j >\
    \ i)\n            })\n            .count() as isize\n    };\n    let car_race_collision_n_plus_1\
    \ = |n: isize| -> isize {\n        // 2*i is a car moving left to right\n    \
    \    // 2*i + 1 is a car moving right to left\n        (0..n + 1)\n          \
    \  .map(|i| 2 * i)\n            .flat_map(|i| {\n                (0..n + 1)\n\
    \                    .map(|j| 2 * j + 1)\n                    .map(move |j| (i,\
    \ j))\n                    .filter(move |&(i, j)| j > i)\n            })\n   \
    \         .count() as isize\n    };\n    let a = car_race_collision_n(n);\n  \
    \  let b = car_race_collision_n_plus_1(n);\n    let c = car_race_collision_n_plus_1(n\
    \ - 1);\n    // The last car added will have n-1 collisions so we add that to\
    \ the number of collisions\n    // of the n-1 car case.\n    b - c + n - 1", " \
    \   if n == 0 {\n        return 0;\n    }\n    let mut count = n;\n    let mut\
    \ cars_left = n;\n    let mut cars_right = n;\n    while cars_left > 0 && cars_right\
    \ > 0 {\n        let mut left = (1..cars_left + 1).rev();\n        let mut right\
    \ = 1..cars_right + 1;\n        while let (Some(x), Some(y)) = (left.next(), right.next())\
    \ {\n            if x == y {\n                count -= 1;\n            }\n   \
    \     }\n        cars_left -= 1;\n        cars_right -= 1;\n    }\n    count",
  "    if n <= 1 {\n        return 0;\n    }\n\n    // Recurrence relation is:\n \
    \   //\n    //                /      0 if n = 1\n    //                |\n   \
    \ // car_race(n) = <       n(n-1)/2 if n = 2\n    //                |\n    //\
    \                \\      car_race(n-1) + (n-1) if n > 2\n    //\n    // Proof:\n\
    \    //\n    // - For n = 1, there are no collisions.\n    // - For n = 2, there\
    \ are n(n-1)/2 = 1 collision.\n    //\n    // Suppose the program is true for\
    \ n-1.  Then the cars that move left to right\n    // are numbered 1, 2, ...,\
    \ n-1.  Car n-1 is the rightmost car that moves left to right.\n    // It will\
    \ collide with every car that moves right to left (whose numbers are n, n+1, ...,\
    \ 2n-1).\n    // Therefore, the total number of collisions is car_race(n-1) +\
    \ (n-1).\n\n    let mut sum = 0;\n    for i in 1..n {\n        sum += i;\n   \
    \ }\n    sum", "    let mut collisions = 0;\n    let mut i = 0;\n    let mut current_car\
    \ = 0;\n    let mut arr = vec![0; n as usize];\n    for car in 1..n {\n      \
    \  current_car = car;\n        i = 0;\n        while i < n - car {\n         \
    \   if arr[i as usize] == 1 {\n                collisions += 1;\n            }\n\
    \            arr[i as usize] = current_car;\n            i += 1;\n        }\n\
    \    }\n    collisions", "    let n = n as usize;\n    // Length of the road\n\
    \    let l = n * n;\n    // Simultaneously give all n cars on the left a number\
    \ from 0 to n - 1.\n    // Simultaneously give all n cars on the right a number\
    \ from n to 2 * n - 1.\n    // The cars start out in their respective halves of\
    \ the road; the car on the left\n    // with the lowest number will start out\
    \ at the leftmost position; the car on the\n    // right with the highest number\
    \ will start out at the rightmost position.\n    // Now we can tell how many collisions\
    \ there will be.\n    // How far out does car k on the left start out?  That's\
    \ 2 * k.\n    // How far out does car k on the right start out?  That's l - 2\
    \ * k - 1.\n    // The two cars collide if these distances are equal.\n    //\
    \ The kth car on the left will collide with the l - k - 1 th car on the right.\n\
    \    // Therefore, there are n / 2 collisions.\n    n / 2", "    let mut count\
    \ = 0;\n    let mut left = 0;\n    let mut right = n - 1;\n    while left < right\
    \ {\n        let mut left_moved = false;\n        let mut right_moved = false;\n\
    \        if left_moved && right_moved {\n            count += 1;\n        }\n\
    \        if !left_moved {\n            left += 1;\n        }\n        if !right_moved\
    \ {\n            right -= 1;\n        }\n    }\n    count", "    let mut cars_left\
    \ = std::iter::repeat(1).take(n as usize).collect::<Vec<_>>();\n    let mut cars_right\
    \ = std::iter::repeat(1).take(n as usize).collect::<Vec<_>>();\n    let mut pos\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        pos[i as usize] = i;\n\
    \    }\n    let mut collisions = 0;\n    let mut last_idx = (n - 1) as usize;\n\
    \    while cars_left.len() > 0 {\n        if pos[0] >= 0 {\n            collisions\
    \ += cars_right.len();\n            let idx = pos[0] as usize;\n            cars_left.remove(idx);\n\
    \            pos.remove(idx);\n            for i in idx..pos.len() {\n       \
    \         pos[i] -= 1;\n            }\n        } else {\n            let idx =\
    \ (-pos[0] - 1) as usize;\n            cars_right.remove(idx);\n            pos.remove(0);\n\
    \            for i in 0..pos.len() {\n                pos[i] += 1;\n         \
    \   }\n        }\n    }\n    collisions", '    unimplemented!()', "    let mut\
    \ left_to_right: Vec<i32> = Vec::new();\n    let mut right_to_left: Vec<i32> =\
    \ Vec::new();\n    for x in 0..n {\n        left_to_right.push(x as i32);\n  \
    \      right_to_left.push(n - x - 1);\n    }\n    // Now merge the two arrays\
    \ and count the number of inversions.\n    let mut collisions = 0;\n    for i\
    \ in 0..left_to_right.len() {\n        for j in i..right_to_left.len() {\n   \
    \         if left_to_right[i] > right_to_left[j] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions", "    let mut left:\
    \ Vec<bool> = vec![false; n as usize];\n    let mut right: Vec<bool> = vec![false;\
    \ n as usize];\n    for i in 0..n {\n        if i % 2 == 0 {\n            left[i\
    \ as usize] = true;\n        } else {\n            right[i as usize] = true;\n\
    \        }\n    }\n    let mut result = 0;\n    while !left.is_empty() {\n   \
    \     if right.is_empty() {\n            break;\n        }\n        let mut left_pos\
    \ = 0;\n        let mut right_pos = 0;\n        for i in 0..n {\n            if\
    \ left[i as usize] {\n                left_pos = i;\n                break;\n\
    \            }\n        }\n        for i in 0..n {\n            if right[i as\
    \ usize] {\n                right_pos = i;\n                break;\n         \
    \   }\n        }\n        left_pos += 1;\n        right_pos += 1;\n        if\
    \ left_pos > right_pos {\n            result += 1;\n        }\n        left[left_pos\
    \ as usize] = true;\n        right[right_pos as usize] = true;\n        left[(left_pos\
    \ - 1) as usize] = false;\n        right[(right_pos - 1) as usize] = false;\n\
    \    }\n    result", "    let mut number_of_collisions = 0;\n    // You'll want\
    \ to keep track of each car as it moves left or right.\n    // You'll want to\
    \ increment number_of_collisions each time a collision occurs.\n    // We'll leave\
    \ the actual logic up to you.\n    unimplemented!();\n    number_of_collisions",
  "    let mut cars_left = n;\n    let mut cars_right = n;\n    let mut collisions\
    \ = 0;\n    while cars_left > 0 || cars_right > 0 {\n        collisions += cars_left\
    \ * cars_right;\n        cars_left -= 1;\n        cars_right -= 1;\n    }\n  \
    \  collisions", "    assert!(n >= 0);\n    if n <= 1 {\n        return 0;\n  \
    \  }\n    n * (n - 1) / 2", "    let mut cars = (1..=n).map(|x| (x, true)).collect::<Vec<(isize,\
    \ bool)>>();\n    let mut collisions = 0;\n    while cars.len() > 1 {\n      \
    \  cars.sort_by(|x, y| {\n            if x.0 == y.0 {\n                if x.1\
    \ && !y.1 {\n                    Ordering::Less\n                } else if !x.1\
    \ && y.1 {\n                    Ordering::Greater\n                } else {\n\
    \                    Ordering::Equal\n                }\n            } else {\n\
    \                if x.1 {\n                    x.0.cmp(&y.0)\n               \
    \ } else {\n                    y.0.cmp(&x.0)\n                }\n           \
    \ }\n        });\n        let mut i = 0;\n        while i < cars.len() - 1 {\n\
    \            if cars[i].1 == cars[i + 1].1 {\n                cars.remove(i);\n\
    \                collisions += 1;\n            } else {\n                i +=\
    \ 1;\n            }\n        }\n        cars.iter_mut().for_each(|x| x.0 += 1);\n\
    \    }\n    collisions", "    let mut collisions = 0;\n    let mut left_to_right_cars\
    \ = 0;\n    let mut right_to_left_cars = 0;\n    for i in 0..n {\n        if i\
    \ % 2 == 0 {\n            left_to_right_cars += 1;\n        } else {\n       \
    \     right_to_left_cars += 1;\n        }\n        if left_to_right_cars != 0\
    \ && right_to_left_cars != 0 {\n            collisions += left_to_right_cars *\
    \ right_to_left_cars;\n        }\n    }\n    collisions", "    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if i + j ==\
    \ n {\n                collisions += 1;\n            }\n        }\n    }\n   \
    \ collisions", "    let mut result = 0;\n    for i in 1..n {\n        result +=\
    \ (n - i) * i;\n    }\n    result * 2", '    car_race_collision_using_hashset(n)',
  "    // TODO: Fill me in\n    return 0;", "    if n < 2 {\n        return 0;\n \
    \   }\n    let left_t_start = vec![0.0; n as usize];\n    let left_t_end = vec![(n\
    \ - 1) as f64; n as usize];\n    let right_t_start = vec![(n - 1) as f64; n as\
    \ usize];\n    let right_t_end = vec![0.0; n as usize];\n    time_interval_collision(left_t_start,\
    \ left_t_end, right_t_start, right_t_end)", "    if n < 1 {\n        panic!(\"\
    n < 1\");\n    }\n\n    // The number of collisions between i'th car from the\
    \ left and\n    // j'th car from the right is min(i, j).  For example, if n =\
    \ 4,\n    // the collision counts are (in descending order):\n    // 1 1 1 1\n\
    \    // 0 2 2 2\n    // 0 0 3 3\n    // 0 0 0 4\n    //\n    // The total number\
    \ of collisions is then equal to the sum of diagonal\n    // elements in the above\
    \ matrix.\n    // In addition, sum of first n numbers is n * (n + 1) / 2.\n  \
    \  // So in our example, the collision count is 4 * (4 + 1) / 2 = 10.\n    (n\
    \ * (n + 1)) / 2", "    let mut left_right_cars: Vec<isize> = (0..n).collect();\n\
    \    let mut right_left_cars: Vec<isize> = (0..n).collect();\n    let mut num_collisions\
    \ = 0;\n    while !left_right_cars.is_empty() && !right_left_cars.is_empty() {\n\
    \        if left_right_cars[0] == right_left_cars[0] {\n            left_right_cars.remove(0);\n\
    \            right_left_cars.remove(0);\n            num_collisions += 1;\n  \
    \      } else if left_right_cars[0] < right_left_cars[0] {\n            left_right_cars.remove(0);\n\
    \        } else {\n            right_left_cars.remove(0);\n        }\n    }\n\
    \    num_collisions", "    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ - i - 1);\n    }\n    for i in 0..n {\n        for j in 0..n {\n           \
    \ if cars_left[i] == cars_right[j] {\n                return i as isize + j as\
    \ isize;\n            }\n        }\n    }\n    unreachable!()", "    let mut l_to_r\
    \ = vec![0; n as usize];\n    let mut r_to_l = vec![0; n as usize];\n    let left_to_right\
    \ = l_to_r.iter_mut();\n    let right_to_left = r_to_l.iter_mut();\n    let l_cars\
    \ = left_to_right.enumerate().filter(|&(idx, car)| {\n        let idx = idx as\
    \ isize;\n        car.is_none() && idx % 2 == 0\n    });\n    let r_cars = right_to_left.enumerate().filter(|&(idx,\
    \ car)| {\n        let idx = idx as isize;\n        car.is_none() && idx % 2 ==\
    \ 1\n    });\n    for (&mut (_, car), (_, car2)) in l_cars.zip(r_cars) {\n   \
    \     *car = Some(car2);\n        *car2 = Some(car);\n    }\n    let mut cnt =\
    \ 0;\n    let mut l_car_idx = 0;\n    let mut r_car_idx = n - 1;\n    while l_car_idx\
    \ < n && r_car_idx >= 0 {\n        if l_to_r[l_car_idx as usize].is_some() {\n\
    \            // There is a car in front of us.  To avoid collision, we must\n\
    \            // move to the next position.\n            l_car_idx += 1;\n    \
    \    } else if r_to_l[r_car_idx as usize].is_some() {\n            // There is\
    \ a car in front of us.  To avoid collision, we must\n            // move to the\
    \ next position.\n            r_car_idx -= 1;\n        } else {\n            //\
    \ We're safe for now, we can move to the next position.\n            l_car_idx\
    \ += 1;\n            r_car_idx -= 1;\n        }\n        if l_car_idx >= n ||\
    \ r_car_idx < 0 {\n            break;\n        }\n        if l_to_r", '    unimplemented!()',
  "    if n <= 0 {\n        return 0;\n    }\n    car_race_collision(n - 1) + n -\
    \ 1", "    let mut car_positions = vec![0; n as usize];\n    let mut car_directions\
    \ = vec![1; n as usize];\n    let mut collisions = 0;\n    for i in 0..n {\n \
    \       car_positions[i as usize] = i;\n    }\n    for car_idx in 0..n {\n   \
    \     let car_position = car_positions[car_idx as usize];\n        for other_car_idx\
    \ in (car_idx + 1)..n {\n            let other_car_position = car_positions[other_car_idx\
    \ as usize];\n            if car_directions[car_idx as usize] != car_directions[other_car_idx\
    \ as usize]\n                && car_position == other_car_position\n         \
    \   {\n                collisions += 1;\n            }\n        }\n        car_positions[car_idx\
    \ as usize] += car_directions[car_idx as usize];\n    }\n    collisions", "  \
    \  // Base cases:\n    // n = 0, collision = 0\n    // n = 1, collision = 0\n\
    \    // n = 2, collision = 1\n    // We now show that the number of collisions\
    \ for n = 3 is the same as\n    // 3 times the number of collisions for n = 1.\n\
    \    // This can be done by counting how many times the middle car collides\n\
    \    // with the other cars.\n    // The middle car will collide with the car\
    \ to its left and the car to its right.\n    // In total, this is 3 collisions.\n\
    \    // Now assume the theorem holds for some n > 2.\n    // We then prove that\
    \ the theorem holds for n + 1.\n    // The first n cars will have n collisions.\n\
    \    // Furthermore, the n+1 car will collide with the n car.\n    // This is\
    \ an additional collision.\n    // The total number of collisions is then n +\
    \ 1.\n    // By induction, the number of collisions is n.\n    n", "    let mut\
    \ count = 0;\n    for i in 1..=n {\n        count += i;\n    }\n    count", " \
    \   // TODO: Place the code that solves the problem here.\n    0", '    n*(n-1)/2',
  "    // TODO: write your solution to the problem here\n    panic!(\"To be implemented!\"\
    );", "    let mut l_to_r = Vec::new();\n    let mut r_to_l = Vec::new();\n   \
    \ for i in 0..n {\n        let x = n - i - 1;\n        l_to_r.push(x);\n     \
    \   r_to_l.push(x);\n    }\n    let mut collisions = 0;\n    while let Some(left_most)\
    \ = l_to_r.pop() {\n        let right_most = r_to_l.pop().unwrap();\n        if\
    \ left_most > right_most {\n            collisions += 1;\n        }\n    }\n \
    \   collisions", "    // number of cars moving left to right\n    // mutable because\
    \ we decrement this\n    let mut n_left = n;\n    // number of cars moving right\
    \ to left\n    let mut n_right = n;\n    // number of collisions\n    let mut\
    \ collisions = 0;\n    // modify n_left, n_right, and collisions in the loop\n\
    \    while n_left > 0 && n_right > 0 {\n        // the left car drives one minute\n\
    \        n_left -= 1;\n        // the right car drives one minute\n        n_right\
    \ -= 1;\n        // if the left car reached the right car, then there's a collision\n\
    \        if n_left == n_right {\n            collisions += 1;\n        }\n   \
    \ }\n    // return the number of collisions\n    collisions", "    if n <= 0 {\n\
    \        return 0;\n    }\n    let mut left_cars: Vec<isize> = Vec::new();\n \
    \   for i in 1..=n {\n        left_cars.push(i);\n    }\n    let mut right_cars:\
    \ Vec<isize> = Vec::new();\n    for i in 1..=n {\n        right_cars.push(i);\n\
    \    }\n    return _car_race_collision(0, n, &mut left_cars, &mut right_cars);",
  "    let mut direction = 1;\n    let mut head = n;\n    let mut tail = n;\n    let\
    \ mut count = 0;\n    while head != 0 || tail != 0 {\n        if direction ==\
    \ 1 {\n            head -= 1;\n            count += tail;\n        } else {\n\
    \            tail -= 1;\n            count += head;\n        }\n        direction\
    \ *= -1;\n    }\n    count", '    n', "    let mut collisions = 0;\n    for i\
    \ in 1..=n {\n        for j in 1..=n {\n            if (i - j).abs() == 1 {\n\
    \                collisions += 1;\n            }\n        }\n    }\n    collisions",
  "    let mut left_to_right: Vec<isize> = (0..n).collect();\n    let mut right_to_left:\
    \ Vec<isize> = (0..n).rev().collect();\n    let mut collisions = 0;\n    while\
    \ left_to_right.len() > 0 {\n        let first_ltor = left_to_right[0];\n    \
    \    let first_rtol = right_to_left[0];\n        let mut i = 0;\n        while\
    \ i < left_to_right.len() {\n            if left_to_right[i] <= first_rtol {\n\
    \                left_to_right.remove(i);\n                i -= 1;\n         \
    \   }\n            i += 1;\n        }\n        i = 0;\n        while i < right_to_left.len()\
    \ {\n            if right_to_left[i] >= first_ltor {\n                right_to_left.remove(i);\n\
    \                i -= 1;\n            }\n            i += 1;\n        }\n    \
    \    collisions += 1;\n    }\n    collisions", "    let mut counter = 0;\n   \
    \ let mut left_to_right = 0;\n    let mut right_to_left = n - 1;\n    while left_to_right\
    \ < right_to_left {\n        if left_to_right == right_to_left {\n           \
    \ counter += 1;\n        } else {\n            counter += 2;\n        }\n    \
    \    left_to_right += 1;\n        right_to_left -= 1;\n    }\n    counter", '    (1..n
    + 1).map(|x| (x - 1) * x).sum()', "    if n == 0 {\n        return 0;\n    }\n\
    \    return n + car_race_collision(n - 1);", "    let mut l = 0;\n    let mut\
    \ r = 0;\n    while l < n {\n        l += 1;\n        r += 1;\n    }\n    l +\
    \ r", "    let mut left_to_right: Vec<(isize, isize)> = vec![];\n    let mut right_to_left:\
    \ Vec<(isize, isize)> = vec![];\n    for i in 0..n {\n        left_to_right.push((i,\
    \ i + 1));\n        right_to_left.push((-i, -i - 1));\n    }\n    let mut total\
    \ = 0;\n    let mut done = false;\n    while !done {\n        done = true;\n \
    \       for (i, r) in right_to_left.iter_mut().enumerate() {\n            if r.1\
    \ > r.0 {\n                done = false;\n                r.0 += 1;\n        \
    \        r.1 += 1;\n                let (x1, x2) = r;\n                for j in\
    \ i + 1..right_to_left.len() {\n                    let (x3, x4) = right_to_left[j];\n\
    \                    if x1 < x3 && x2 > x4 {\n                        total +=\
    \ 1;\n                    }\n                }\n                for (x3, x4) in\
    \ left_to_right.iter() {\n                    if x1 < x3 && x2 > x4 {\n      \
    \                  total += 1;\n                    }\n                }\n   \
    \         }\n        }\n        for (i, l) in left_to_right.iter_mut().enumerate()\
    \ {\n            if l.1 > l.0 {\n                done = false;\n             \
    \   l.0 += 1;\n                l.1 += 1;\n                let (x1, x2) = l;\n\
    \                for j in i + 1..left_to_right.len() {\n                    let\
    \ (x3, x4) = left_to_right[j];\n                    if x1 < x3 && x2 > x4 {\n\
    \                        total += 1;\n                    }\n                }\n\
    \                for (x3, x4) in right_to_left.iter() {\n                    if\
    \ x1 < x3 && x2 > x4 {\n                        total += 1;\n                \
    \    }\n                }\n            }\n        }\n    }\n    total", "    //\
    \ let mut right_moving = (0..n).collect::<Vec<isize>>();\n    // let mut left_moving\
    \ = (0..n).rev().collect::<Vec<isize>>();\n    // let mut collisions = 0;\n  \
    \  //\n    // while right_moving.len() > 0 && left_moving.len() > 0 {\n    //\
    \     let right_moved = right_moving.pop().unwrap();\n    //     let left_moved\
    \ = left_moving.pop().unwrap();\n    //     collisions += n - std::cmp::max(right_moved,\
    \ left_moved);\n    // }\n    // collisions\n    n * (n - 1) / 2", "    let mut\
    \ collisions = 0;\n    let mut cars = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        cars[i as usize] = i;\n    }\n    for i in 0..n {\n        for j\
    \ in 0..n {\n            if cars[i as usize] > cars[j as usize] {\n          \
    \      collisions += 1;\n            }\n        }\n    }\n    collisions", " \
    \   if n == 0 {\n        0\n    } else {\n        car_race_collision(n - 1) +\
    \ n - 1\n    }", "    let mut coll = 0;\n    let mut dir: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        dir.push(1);\n    }\n    for i in n..(2 * n) {\n\
    \        dir.push(-1);\n    }\n    for i in 0..(2 * n) {\n        for j in (i\
    \ + 1)..(2 * n) {\n            if dir[i as usize] > 0 && dir[j as usize] < 0 {\n\
    \                coll += 1;\n            }\n        }\n    }\n    coll", "   \
    \ let mut i = 1;\n    let mut collisons = 0;\n    while i <= n {\n        collisons\
    \ += n - i;\n        i += 1;\n    }\n    collisons", "    let mut cars: Vec<Car>\
    \ = Vec::new();\n    for i in 0..n {\n        cars.push(Car { dir: Dir::LeftToRight,\
    \ pos: i as isize });\n        cars.push(Car { dir: Dir::RightToLeft, pos: n -\
    \ i as isize });\n    }\n    cars.sort_by(|a, b| a.cmp(b));\n    let mut collisions\
    \ = 0;\n    for i in 0..cars.len() - 1 {\n        if cars[i].dir == cars[i + 1].dir\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions", '    return
    0;', "    if n < 1 {\n        return 0;\n    }\n    // There are 2^(n-1) cars.\n\
    \    // For every car A, there are 2^(n-1) - A cars faster than A.\n    // All\
    \ of these cars have the same speed as A.\n    // So for every car A, A will collide\
    \ with 2^(n-1) - A cars.\n    // For every pair of cars A and B, if A is faster\
    \ than B, A will collide with B.\n    // If B is faster than A, B will collide\
    \ with A.\n    // So for every pair of cars A and B, there will be 1 collision.\n\
    \    // The result is the sum of (2^(n-1) - A) for all A, which is\n    // 2^(n-1)\
    \ * 2^(n-1) - (1 + 2 + ... + 2^(n-1))\n    // = 2^(n-1) * 2^(n-1) - (2^n - 1)\n\
    \    // = 2^(n-1) * 2^(n-1) - 2^n + 1\n    // = (2^(n-1) - 1) * (2^(n-1) + 1)\n\
    \    // = (2^(n-1) - 1) * (2^(n-1) - 1 + 2)\n    // = (2^(n-1) - 1) * (2^(n-1)\
    \ + 1)\n    // = (2^(n-1) - 1) * 2^(n-1) + (2^(n-1) - 1)\n    // = 2^(2n-2) -\
    \ 2^(n-1) + 2^(n-1) - 1\n    // = 2^(2n-2) - 1\n    (1 << (2 * n - 2)) - 1", " \
    \   let mut result = 0;\n    let mut left_to_right = vec![(0, false); n as usize];\n\
    \    let mut right_to_left = vec![(0, false); n as usize];\n    for i in 0..n\
    \ {\n        left_to_right[i as usize] = (i * 2, false);\n        right_to_left[i\
    \ as usize] = (i * 2 + 1, false);\n    }\n    for i in 0..n {\n        left_to_right[i\
    \ as usize].1 = false;\n        for j in 0..n {\n            if right_to_left[j\
    \ as usize].1 {\n                continue;\n            }\n            if left_to_right[i\
    \ as usize].0 > right_to_left[j as usize].0 {\n                result += 1;\n\
    \                right_to_left[j as usize].1 = true;\n            }\n        }\n\
    \    }\n    result", "    // This is a demo algorithm; it is not meant to be useful.\n\
    \    // In fact, it is a terrible algorithm.  The point of this demo\n    // is\
    \ to illustrate how to test code.\n    //\n    // (The point of this demo algorithm\
    \ is to be terrible.\n    // There are better algorithms that we didn't use.)\n\
    \    if n <= 0 {\n        return 0;\n    }\n\n    let mut out = 0;\n    for i\
    \ in 0..n {\n        out += i;\n    }\n    return out;", "    let (p, c) = (1,\
    \ 1);\n    let mut res = 1;\n    for _ in 1..n + 1 {\n        res = ncr(p + c,\
    \ c);\n    }\n    res", "    let mut count: isize = 0;\n    let mut i: isize =\
    \ 0;\n    while i < n {\n        let mut j: isize = 0;\n        while j < n {\n\
    \            if i > j {\n                count += 1;\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n    }\n    count", "    // We are given\
    \ n cars moving left to right, and n cars moving right to left,\n    // starting\
    \ at the same time, and from opposite ends of a straight infinitely long road.\n\
    \    // We have an algorithm to identify whether a car will collide with any other\
    \ car.\n    // Suppose we put the cars in a queue, left to right, and then we\
    \ pop cars from the\n    // right end of the queue, and we add new cars to the\
    \ left end of the queue.\n    // The cars can be compared to each other.  If a\
    \ car is popped from the queue,\n    // then we check whether it collides with\
    \ any other car that's still in the queue.\n    // If it collides with one or\
    \ more cars, then we increment our collision count by one.\n    // If we implement\
    \ the queue using a linked list, then popping the right-most car\n    // and adding\
    \ a new car to the left side of the queue takes constant time.\n    // The algorithm\
    \ to determine whether a car collides with any other car is O(n),\n    // so the\
    \ total run time is n * O(n) = O(n^2).\n    // Since this is a coding interview,\
    \ we could have been asked to do better.\n    // However, we do not want to spend\
    \ too much time on this problem.\n    // We don't need to spend any time at all.\
    \  We can just observe that the collision\n    // count is equal to the sum of\
    \ the first n integers.  2 + 3 + 4 + ... + n = n(n+1)/2.\n    n * (n + 1) / 2",
  "    if n <= 0 {\n        return 0;\n    }\n    let mut lr_ranges = HashMap::new();\n\
    \    let mut rl_ranges = HashMap::new();\n    // car #0 starts at position -1\
    \ and moves towards +1\n    lr_ranges.insert(0, Range { start: -1, end: 1 });\n\
    \    // car #1 starts at position 1 and moves towards -1\n    rl_ranges.insert(1,\
    \ Range { start: 1, end: -1 });\n    // Assume that there are at least two cars.\n\
    \    assert!(n >= 2);\n    for i in 2..n {\n        // car #i starts at position\
    \ -i and moves towards +i\n        lr_ranges.insert(i, Range { start: -i, end:\
    \ i });\n        // car #i starts at position i and moves towards -i\n       \
    \ rl_ranges.insert(i, Range { start: i, end: -i });\n    }\n    let mut coll_count\
    \ = 0;\n    let mut coll_set = HashSet::new();\n    // Go through the range of\
    \ left to right cars\n    for (x, r) in lr_ranges.iter() {\n        // Go through\
    \ the range of right to left cars\n        for (y, r1) in rl_ranges.iter() {\n\
    \            // if the two cars are colliding\n            if r.start >= r1.start\
    \ && r.start <= r1.end {\n                // make sure we don't count the same\
    \ collision twice\n                if coll_set.insert((*x, *y)) {\n          \
    \          coll_count += 1;\n                }\n            }\n        }\n   \
    \ }\n    coll_count"]
stop_tokens:
- "\n}"
